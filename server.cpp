//Growtopia By Time
#include "stdafx.h"
#include <iostream>
#include <sstream>
#include <fstream>
#include "enet/enet.h"
#include "Server_tile.h"
#include <cmath>
#include <string>
#include <vector>
#include <ctime>
#include <time.h>
#include "json.hpp"
#include <thread>
#include <experimental/filesystem>
#include <cstdlib>
#include <cstdio>
#include <cctype>
#include <regex>
#include <cstring>
#include <locale>
#include <stdexcept>
#include "World_events.h"
#ifdef _WIN32
#include <windows.h>
typedef __int8 __int8_t;
typedef __int16 __int16_t;
#elif __APPLE__ || __linux__
typedef unsigned int DWORD;
#endif
typedef unsigned char BYTE;
#define N_DECIMAL_POINTS_PRECISION (1000) // n = 3. Three decimal points.
#pragma warning(disable:4996)

int main()
{

	cout << ">>GrowtopiaCP<<" << endl;
	cout << "Server Time: " + currentDateTime() + "!" << endl;;
	//ConnectToDatabase();
	srand(time(nullptr));
	LoadEvents();

	//if (!Connected) return -1;
	int itemdathash;
	enet_initialize();
	{
		std::ifstream file("items.dat", std::ios::binary | std::ios::ate);
		itemsDatSize = file.tellg();
		itemsDat = new BYTE[60 + itemsDatSize];
		string asdf = "0400000010000000FFFFFFFF000000000800000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
		for (auto i = 0; i < asdf.length(); i += 2) {
			char x = ch2n(asdf[i]);
			x = x << 4;
			x += ch2n(asdf[i + 1]);
			memcpy(itemsDat + (i / 2), &x, 1);
			if (asdf.length() > 60 * 2) throw 0;
		}
		memcpy(itemsDat + 56, &itemsDatSize, 4);
		file.seekg(0, std::ios::beg);
		if (file.read(reinterpret_cast<char*>(itemsDat + 60), itemsDatSize)) {
			uint8_t* pData;
			auto size = 0;
			const char filename[] = "items.dat";
			size = filesize(filename);
			pData = getA(static_cast<string>(filename), &size, false, false);
			SendConsole("Updating items data success!", "INFO");
			itemdathash = HashString(static_cast<unsigned char*>(pData), size);
			file.close();
			//serializeItems();
		}
	}
	//SendConsole("Items.dat serialized!", "INFO");
	ENetAddress address;
	address.host = ENET_HOST_ANY;
	address.port = 17091;
	server = enet_host_create(&address, 1024, 2, 0, 0);
	if (server == nullptr) exit(EXIT_FAILURE);
	server->checksum = enet_crc32;
	enet_host_compress_with_range_coder(server);
	buildItemsDatabase();
	thread WorldEvents(WorldEvents);
	if (WorldEvents.joinable()) WorldEvents.detach();
	thread DayTimer(DayTimer);
	if (DayTimer.joinable()) DayTimer.detach();
	thread AutoSaveWorlds(autoSaveWorlds);
	if (AutoSaveWorlds.joinable()) AutoSaveWorlds.detach();

	worldDB.get("START");
	ENetEvent event;
	while (true) {
		while (enet_host_service(server, &event, 1000) > 0)
		{
			ENetPeer* peer = event.peer;
			switch (event.type)
			{
			case ENET_EVENT_TYPE_CONNECT:
			{
				event.peer->data = new PlayerInfo;
				char clientConnection[16];
				enet_address_get_host_ip(&peer->address, clientConnection, 16);
				static_cast<PlayerInfo*>(peer->data)->charIP = clientConnection;
				sendData(peer, 1, nullptr, 0);
				continue;
			}
			case ENET_EVENT_TYPE_RECEIVE:
			{
				if (serverIsFrozen) continue;
				string data = (char*)event.packet->data;
				if (data == "console_login" && !static_cast<PlayerInfo*>(peer->data)->Console)
				{
					static_cast<PlayerInfo*>(peer->data)->Console = true;
				}
				if (data == "console_toggle_global" && static_cast<PlayerInfo*>(peer->data)->Console)
				{
					if (!static_cast<PlayerInfo*>(peer->data)->GlobalChat)
					{
						Player::OnConsoleMessage(peer, "`#Global chat settings `2Toggled ON`#, `4(You can now see everyone messages)");
						static_cast<PlayerInfo*>(peer->data)->GlobalChat = true;
					}
					else
					{
						Player::OnConsoleMessage(peer, "`#Global chat settings `4Toggled OFF");
						static_cast<PlayerInfo*>(peer->data)->GlobalChat = false;
					}
				}
				/*if (data.find("scan_inv|") != string::npos && static_cast<PlayerInfo*>(peer->data)->Console)
				{
					string itemdata = data;
					size_t pos;
					while ((pos = itemdata.find("scan_inv|")) != std::string::npos) itemdata.replace(pos, 9, "");
					Player::OnConsoleMessage(peer, "`9Scan thread launched running on `4Multi-CPU `9With `499% `9Resource usage... (scanning all players)");
					thread InvScan(scan_inventory, peer, atoi(itemdata.c_str()));
					if (InvScan.joinable()) InvScan.detach();
				}
				if (data.find("scan_box|") != string::npos && static_cast<PlayerInfo*>(peer->data)->Console)
				{
					string itemdata = data;
					size_t pos;
					while ((pos = itemdata.find("scan_box|")) != std::string::npos) itemdata.replace(pos, 9, "");
					Player::OnConsoleMessage(peer, "`9Scan thread launched running on `4Multi-CPU `9With `499% `9Resource usage... (scanning all boxes)");
					thread BoxScan(scan_box, peer, atoi(itemdata.c_str()));
					if (BoxScan.joinable()) BoxScan.detach();
				}
				if (data.find("scan_safe|") != string::npos && static_cast<PlayerInfo*>(peer->data)->Console)
				{
					string itemdata = data;
					size_t pos;
					while ((pos = itemdata.find("scan_safe|")) != std::string::npos) itemdata.replace(pos, 10, "");
					Player::OnConsoleMessage(peer, "`9Scan thread launched running on `4Multi-CPU `9With `499% `9Resource usage... (scanning all boxes)");
					thread SafeScan(scan_safe, peer, atoi(itemdata.c_str()));
					if (SafeScan.joinable()) SafeScan.detach();
				}
				if (data.find("scan_dbox|") != string::npos && static_cast<PlayerInfo*>(peer->data)->Console)
				{
					string itemdata = data;
					size_t pos;
					while ((pos = itemdata.find("scan_dbox|")) != std::string::npos) itemdata.replace(pos, 10, "");
					Player::OnConsoleMessage(peer, "`9Scan thread launched running on `4Multi-CPU `9With `499% `9Resource usage... (scanning all boxes)");
					thread DboxScan(scan_dbox, peer, atoi(itemdata.c_str()));
					if (DboxScan.joinable()) DboxScan.detach();
				}
				if (data.find("scan_drop|") != string::npos && static_cast<PlayerInfo*>(peer->data)->Console)
				{
					string itemdata = data;
					size_t pos;
					while ((pos = itemdata.find("scan_drop|")) != std::string::npos) itemdata.replace(pos, 10, "");
					Player::OnConsoleMessage(peer, "`9Scan thread launched running on `4Multi-CPU `9With `499% `9Resource usage... (scanning all boxes)");
					thread DropScan(scan_drop, peer, atoi(itemdata.c_str()));
					if (DropScan.joinable()) DropScan.detach();
				}*/
				if (!peer) continue;
				if (static_cast<PlayerInfo*>(peer->data)->currentWorld != "EXIT")
				{
					const auto info = static_cast<PlayerInfo*>(peer->data);
					const auto netID = info->netID;
					const auto state = getState(info);
					for (ENetPeer* currentPeer = server->peers;
						currentPeer < &server->peers[server->peerCount];
						++currentPeer)
					{
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
						if (isHere(peer, currentPeer))
						{
							if (static_cast<PlayerInfo*>(currentPeer->data)->Console) continue;
							if (peer != currentPeer)
							{
								PlayerMoving data;
								data.packetType = 0x14;
								data.characterState = static_cast<PlayerInfo*>(peer->data)->characterState;
								data.x = 1000;
								data.y = 400;
								data.punchX = 0;
								data.punchY = 0;
								data.XSpeed = 300;
								data.YSpeed = 1000;
								data.netID = netID;
								data.plantingTree = state;
								const auto raw = packPlayerMoving(&data);
								auto var = static_cast<PlayerInfo*>(peer->data)->effect;
								memcpy(raw + 1, &var, 3);
								SendPacketRaw(4, raw, 56, nullptr, currentPeer, ENET_PACKET_FLAG_RELIABLE);
							}
						}
					}
				}
				int messageType = GetMessageTypeFromPacket(event.packet);
				WorldInfo* world = getPlyersWorld(peer);
				switch (messageType) {
				default:
				{
					string cch = GetTextPointerFromPacket(event.packet);
					if (static_cast<PlayerInfo*>(peer->data)->Console) cch = data;
					if (cch.size() <= 3) break;
					if (cch == "" || cch == " " || cch == "  " || cch == "   " || cch == "    " || cch == "     " || cch == "      " || cch == "       " || cch == "        " || cch == "        ") break;
					if (cch.size() > 2048) break;
					string str = cch.substr(cch.find("text|") + 5, cch.length() - cch.find("text|") - 1);
					if (cch.find("action|world_button\nname|_catselect_") == 0) {
						string worldOffers = "";
						worldOffers = "\nadd_button|Random|_0|0.8|3529161471|\nadd_button|Your Worlds|_16|0.8|3529161471|\nadd_button|Adventure|_1|0.8|3529161471|\nadd_button|Art|_2|0.8|3529161471|\nadd_button|Farm|_3|0.8|3529161471|\nadd_button|Game|_4|0.8|3529161471|\nadd_button|Guild|_13|0.8|3529161471|\nadd_button|Information|_5|0.8|3529161471|\nadd_button|Music|_15|0.8|3529161471|\nadd_button|Parkour|_6|0.8|3529161471|\nadd_button|Puzzle|_14|0.8|3529161471|\nadd_button|Roleplay|_7|0.8|3529161471|\nadd_button|Shop|_8|0.8|3529161471|\nadd_button|Social|_9|0.8|3529161471|\nadd_button|Storage|_10|0.8|3529161471|\nadd_button|Story|_11|0.8|3529161471|\nadd_button|Trade|_12|0.8|3529161471|";
						auto p3 = packetEnd(appendString(appendString(createPacket(), "OnRequestWorldSelectMenu"), worldOffers));
						const auto packet3 = enet_packet_create(p3.data, p3.len, ENET_PACKET_FLAG_RELIABLE);
						enet_peer_send(peer, 0, packet3);
						delete p3.data;
					}
					if (cch.find("action|world_button\nname|_0") == 0)
					{
						sendWorldOffers(peer);
					}
					if (cch.find("action|world_button\nname|_1") == 0)
					{
						//Player::OnTextOverlay(peer, "Soon!");
					}
					if (cch.find("action|world_button\nname|_2") == 0)
					{
						//Player::OnTextOverlay(peer, "Soon!");
					}
					if (cch.find("action|world_button\nname|_3") == 0)
					{
						//Player::OnTextOverlay(peer, "Soon!");
					}
					if (cch.find("action|world_button\nname|_4") == 0)
					{
						//Player::OnTextOverlay(peer, "Soon!");
					}
					if (cch.find("action|world_button\nname|_5") == 0)
					{
						//Player::OnTextOverlay(peer, "Soon!");
					}
					if (cch.find("action|world_button\nname|_6") == 0)
					{
						//Player::OnTextOverlay(peer, "Soon!");
					}
					if (cch.find("action|world_button\nname|_7") == 0)
					{
						//Player::OnTextOverlay(peer, "Soon!");
					}
					if (cch.find("action|world_button\nname|_8") == 0)
					{
						//Player::OnTextOverlay(peer, "Soon!");
					}
					if (cch.find("action|world_button\nname|_9") == 0)
					{
						//Player::OnTextOverlay(peer, "Soon!");
					}
					if (cch.find("action|world_button\nname|_10") == 0)
					{
						//Player::OnTextOverlay(peer, "Soon!");
					}
					if (cch.find("action|world_button\nname|_11") == 0)
					{
						//Player::OnTextOverlay(peer, "Soon!");
					}
					if (cch.find("action|world_button\nname|_12") == 0)
					{
						//Player::OnTextOverlay(peer, "Soon!");
					}
					if (cch.find("action|world_button\nname|_13") == 0)
					{
						//Player::OnTextOverlay(peer, "Soon!");
					}
					if (cch.find("action|world_button\nname|_14") == 0)
					{
						//Player::OnTextOverlay(peer, "Soon!");
					}
					if (cch.find("action|world_button\nname|_15") == 0)
					{
						//Player::OnTextOverlay(peer, "Soon!");
					}
					if (cch.find("action|world_button\nname|_16") == 0)
					{
						string worldOffers = "\nadd_button|Showing: `wYour Worlds``|_catselect_|0.6|3529161471|\n";
						std::sort(static_cast<PlayerInfo*>(peer->data)->worldsowned.begin(), static_cast<PlayerInfo*>(peer->data)->worldsowned.end());
						auto it = std::unique(static_cast<PlayerInfo*>(peer->data)->worldsowned.begin(), static_cast<PlayerInfo*>(peer->data)->worldsowned.end());
						static_cast<PlayerInfo*>(peer->data)->worldsowned.erase(it, static_cast<PlayerInfo*>(peer->data)->worldsowned.end());
						for (int i = 0; i < static_cast<PlayerInfo*>(peer->data)->worldsowned.size(); i++) {
							worldOffers += "add_floater|" + static_cast<PlayerInfo*>(peer->data)->worldsowned[i] + "|0|0.5|3417414143|\n";
						}
						auto p3 = packetEnd(appendString(appendString(createPacket(), "OnRequestWorldSelectMenu"), worldOffers));
						const auto packet3 = enet_packet_create(p3.data, p3.len, ENET_PACKET_FLAG_RELIABLE);
						enet_peer_send(peer, 0, packet3);
						delete p3.data;
					}
					if (cch.find("action|wrench") == 0)
					{
						if (serverIsFrozen) continue;
						std::stringstream ss(cch);
						std::string to;
						int id = -1;
						while (std::getline(ss, to, '\n'))
						{
							vector<string> infoDat = explode("|", to);
							if (infoDat[1].size() <= 4 || infoDat[1].size() >= 6)
							{
								//break;
							}
							else if (infoDat[1] != "netid")
							{
								//break;
							}
							else if (infoDat[1] == "netid")
							{
								try
								{
									id = atoi(infoDat[2].c_str());
								}
								catch (...)
								{
								}
							}
						}
						
						if (id < 0) continue;
						ENetPeer* currentPeer;
						for (currentPeer = server->peers;
							currentPeer < &server->peers[server->peerCount];
							++currentPeer)
						{
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
							if (isHere(peer, currentPeer))
							{
								if (static_cast<PlayerInfo*>(currentPeer->data)->netID == id)
								{
									static_cast<PlayerInfo*>(peer->data)->lastInfo = static_cast<PlayerInfo*>(currentPeer->data)->rawName;
									static_cast<PlayerInfo*>(peer->data)->lastInfoname = static_cast<PlayerInfo*>(currentPeer->data)->tankIDName;
									static_cast<PlayerInfo*>(peer->data)->lastDisplayname = static_cast<PlayerInfo*>(currentPeer->data)->displayName;
									string name = static_cast<PlayerInfo*>(currentPeer->data)->displayName;
									string rawnam = static_cast<PlayerInfo*>(peer->data)->rawName;
									string rawnamofwrench = static_cast<PlayerInfo*>(currentPeer->data)->rawName;
									string guildlabel = "";
									string guildpointslabel = "";
									string gemslabel = "";
									string levellabel = "";
									int guildpoints = 0;
									std::ifstream ifszsx("gemdb/" + static_cast<PlayerInfo*>(peer->data)->lastInfo + ".txt");
									std::string contentch2x((std::istreambuf_iterator<char>(ifszsx)), (std::istreambuf_iterator<char>()));
									if (static_cast<PlayerInfo*>(currentPeer->data)->guild == "" || isMod(currentPeer) && static_cast<PlayerInfo*>(currentPeer->data)->isNicked == false)
									{
										guildlabel = "";
										guildpointslabel = "";
									}
									else
									{
										ifstream guildstream123("guildrewards/guildpoints/" + static_cast<PlayerInfo*>(currentPeer->data)->guild + ".txt");
										guildstream123 >> guildpoints;
										guildstream123.close();
										guildlabel = "\nadd_dual_layer_icon_label|small|`9Guild: `2" + static_cast<PlayerInfo*>(currentPeer->data)->guild + "``|left|" + std::to_string(static_cast<PlayerInfo*>(currentPeer->data)->guildBg) + "|" + std::to_string(static_cast<PlayerInfo*>(currentPeer->data)->guildFg) + "|1.0|1|";
										guildpointslabel = "\nadd_label|small|`9Guild Points: `2" + std::to_string(guildpoints) + "|left|4|";
									}
									if (isMod(currentPeer) && static_cast<PlayerInfo*>(currentPeer->data)->isNicked == false)
									{
										gemslabel = "";
										levellabel = "`2?";
									}
									else
									{
										gemslabel = "\nadd_label|small|`9Gems:`^ " + contentch2x + "|left|4|";
										levellabel = to_string(static_cast<PlayerInfo*>(currentPeer->data)->level);
									}
									if (rawnamofwrench != rawnam)
									{
										if (rawnamofwrench != "")
										{
											if (world->owner == static_cast<PlayerInfo*>(peer->data)->rawName && static_cast<PlayerInfo*>(peer->data)->haveGrowId || isMod(peer))
											{
												if (isMod(peer))
												{
													Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`w" + name + " `w(`2" + levellabel + "`w)``|left|18|\nadd_spacer|small|" + guildlabel + "|" + guildpointslabel + "|" + gemslabel + "|\nadd_spacer|small|\nadd_button|punishview|`!Punish/View|0|0|\nadd_button|starttrade|`wTrade|\nadd_button|addfriendrnbutton|`9Add To Friends|0|0|\nadd_button|inviteguildbutton|`2Invite To Guild|0|0|\nadd_button|pull|`5Pull|0|0|\nadd_button|kick|`4Kick|0|0|\nadd_button|wban|`4World Ban|0|0|\nadd_button|btntradeworld|`9Sell World|0|0|\nadd_spacer|small|\nadd_button||Continue|0|0|\nadd_quick_exit");
												}
												else
												{
													Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`w" + name + " `w(`2" + levellabel + "`w)``|left|18|\nadd_spacer|small|" + guildlabel + "|" + guildpointslabel + "|" + gemslabel + "|\nadd_spacer|small|\nadd_button|starttrade|`wTrade|\nadd_button|addfriendrnbutton|`9Add To Friends|0|0|\nadd_button|inviteguildbutton|`2Invite To Guild|0|0|\nadd_button|pull|`5Pull|0|0|\nadd_button|kick|`4Kick|0|0|\nadd_button|wban|`4World Ban|0|0|\nadd_button|btntradeworld|`9Sell World|0|0|\nadd_spacer|small|\nadd_button||Continue|0|0|\nadd_quick_exit");
												}
											}
											else
											{
												Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`w" + name + " `w(`2" + levellabel + "`w)``|left|18|\nadd_spacer|small|" + guildlabel + "|" + guildpointslabel + "|" + gemslabel + "|\nadd_spacer|small|\nadd_spacer|small|\n\nadd_button|starttrade|`wTrade|\nadd_button|addfriendrnbutton|`wAdd To Friends|0|0|\nadd_button|inviteguildbutton|`2Invite To Guild|0|0|\nadd_spacer|small|\nadd_button||Continue|0|0|\nadd_quick_exit");
											}
										}
										else
										{
											Player::OnTextOverlay(peer, "something went wrong");
										}
									}
									else
									{
										string riftcape;
										if (static_cast<PlayerInfo*>(peer->data)->cloth_back == 10424)
										{
											riftcape = "\nadd_button|editriftcape|`$Rift Cape``|noflags|0|0|";
										}

										if (static_cast<PlayerInfo*>(peer->data)->haveGrowId == true)
										{
											
											string buffs;
											if (static_cast<PlayerInfo*>(peer->data)->SurgeryCooldown)
											{
												ifstream surgery("buffs/surgery/" + PlayerDB::getProperName(static_cast<PlayerInfo*>(peer->data)->rawName) + ".txt");
												long long cooldown = 0;
												surgery >> cooldown;
												surgery.close();
												auto cooldownleft = calcBanDuration(cooldown);
												buffs += "|\nadd_label_with_icon|small|`wMalpractice`` (`w" + OutputBanTime(calcBanDuration(cooldown)) + " left`o)|left|1260|";

											}
											if (static_cast<PlayerInfo*>(peer->data)->Subscriber)
											{
												buffs += "|\nadd_label_with_icon|small|`wPremium Benefits `o(`w" + to_string(static_cast<PlayerInfo*>(peer->data)->SubscribtionEndDay) + " days `oleft)``|left|6862|";
											}
											if (static_cast<PlayerInfo*>(peer->data)->cantsay)
											{
												buffs += "|\nadd_label_with_icon|small|`wDuct tape covered your mouth!``|left|408|";
											}
											if (static_cast<PlayerInfo*>(peer->data)->blueBerry)
											{
												buffs += "|\nadd_label_with_icon|small|`wBlueberry``|left|196|";
											}
											if (static_cast<PlayerInfo*>(peer->data)->LuckyClover || isRedAnces(peer) || FarmingEvent)
											{
												buffs += "|\nadd_label_with_icon|small|`wExtra Gem Drop``|left|528|";
											}
											if (isBlueAnces(peer) || FarmingEvent)
											{
												buffs += "|\nadd_label_with_icon|small|`wExtra Block Drop``|left|2|";
											}
											if (isYellowAnces(peer) || FarmingEvent)
											{
												buffs += "|\nadd_label_with_icon|small|`wExtra XP Buff``|left|1488|";
											}
											if (static_cast<PlayerInfo*>(peer->data)->PunchPotion)
											{
												buffs += "|\nadd_label_with_icon|small|`wOne HIT!``|left|6918|";
											}
											if (static_cast<PlayerInfo*>(peer->data)->PlacePotion)
											{
												buffs += "|\nadd_label_with_icon|small|`wTriple Place!``|left|6924|";
											}
											if (static_cast<PlayerInfo*>(peer->data)->cloth_hand == 6840)
											{
												buffs += "|\nadd_label_with_icon|small|`wHarvester!``|left|6840|";
											}
											if (static_cast<PlayerInfo*>(peer->data)->canDoubleJump)
											{
												buffs += "|\nadd_label_with_icon|small|`wDouble jump``|left|156|";
											}
											if (static_cast<PlayerInfo*>(peer->data)->canWalkInBlocks)
											{
												buffs += "|\nadd_label_with_icon|small|`wI can walk in blocks. (Ghost)``|left|3106|";
											}
											if (static_cast<PlayerInfo*>(peer->data)->isinv)
											{
												buffs += "|\nadd_label_with_icon|small|`wNinja, invisible to all!``|left|290|";
											}
											if (buffs == "")
											{
												buffs += "|\nadd_label_with_icon|small|`wYou don't have any active effects!``|left|18|";
											}
											int levels = static_cast<PlayerInfo*>(peer->data)->level;
											int xp = static_cast<PlayerInfo*>(peer->data)->xp;
											string currentworld = static_cast<PlayerInfo*>(peer->data)->currentWorld;
											int xxx = static_cast<PlayerInfo*>(peer->data)->x / 32;
											int yyy = static_cast<PlayerInfo*>(peer->data)->y / 32;
											string joinguilddialog = "";
											if (static_cast<PlayerInfo*>(peer->data)->isinvited == true)
											{
												joinguilddialog = "\nadd_button|joinguild|`2Join Guild " + static_cast<PlayerInfo*>(currentPeer->data)->guildlast + "!|";
											}
											Player::OnDialogRequest(peer, "set_default_color|`o\n\nadd_player_info|" + name + "|" + std::to_string(levels) + "|" + std::to_string(xp) + "|" + to_string(static_cast<PlayerInfo*>(peer->data)->level * 1500) + "|\nadd_spacer|small|" + joinguilddialog + "|\nadd_button|manage_title|`$Title``|small|" + riftcape + "\nadd_button|popup|`$Growmojis|\nadd_button|accountsecurity|`$Account Security|\nadd_button|achi|`$Achievements``|\nadd_button|notebook_edit|`$Notebook``||\nadd_button|worlds_view|`$My Worlds``|\nadd_spacer|small|\nadd_textbox|`wActive effects:``|left|" + buffs + "|\nadd_spacer|small|\nadd_textbox|`oYou have `w" + to_string(static_cast<PlayerInfo*>(peer->data)->currentInventorySize) + "`` `obackpack slots.``|left||\nadd_spacer|small|\nadd_textbox|`oCurrent world: `w" + currentworld + " `o(`w" + std::to_string(xxx) + "`o, `w" + std::to_string(yyy) + "`o)|left|\nadd_spacer|small|\nadd_button|chc0|`wContinue|noflags|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|");
										}
										else
										{
											SendRegisterDialog(peer);
											enet_host_flush(server);
										}
									}
								}
							}
						}
					}
					if (cch.find("action|setSkin") == 0)
					{
						if (!world) continue;
						std::stringstream ss(cch);
						std::string to;
						int id = -1;
						string color;
						while (std::getline(ss, to, '\n'))
						{
							vector<string> infoDat = explode("|", to);
							if (infoDat[0] == "color") color = infoDat[1];
							if (has_only_digits(color) == false) continue;
							id = atoi(color.c_str());
							if (color == "2190853119")
							{
								id = -2104114177;
							}
							else if (color == "2527912447")
							{
								id = -1767054849;
							}
							else if (color == "2864971775")
							{
								id = -1429995521;
							}
							else if (color == "3033464831")
							{
								id = -1261502465;
							}
							else if (color == "3370516479")
							{
								id = -924450817;
							}
						}
						static_cast<PlayerInfo*>(peer->data)->skinColor = id;
						sendClothes(peer);
					}
					if (cch.find("action|respawn") == 0)
					{
						playerRespawn(peer, false);
					}
					if (cch.find("action|respawn_spike") == 0)
					{
						playerRespawn(peer, false);
						if (game1status == true && static_cast<PlayerInfo*>(peer->data)->currentWorld == "GAME1")
						{
							sendPlayerToWorld(peer, static_cast<PlayerInfo*>(peer->data), "START");
						}
					}
					if (cch.find("action|friends") == 0)
					{
						if (static_cast<PlayerInfo*>(peer->data)->joinguild == true)
						{
							Player::OnDialogRequest(peer, "set_default_color|`w\n\nadd_label_with_icon|big|Social Portal``|left|1366|\n\nadd_spacer|small|\nadd_button|backonlinelist|Show Friends``|0|0|\nadd_button|showguild|Show Guild Members``|0|0|\nend_dialog||OK||\nadd_quick_exit|");
						}
						else
						{
							Player::OnDialogRequest(peer, "set_default_color|`w\n\nadd_label_with_icon|big|Social Portal``|left|1366|\n\nadd_spacer|small|\nadd_button|backonlinelist|Show Friends``|0|0|\nadd_button|createguildinfo|Create Guild``|0|0|\nend_dialog||OK||\nadd_quick_exit|");
						}
					}
					if (cch.find("action|world_button") == 0)
					{
						//"add_button|Random|_0|0.9|3529161471|add_button|Your Worlds|_16|0.9|3529161471|add_button|Adventure|_1|0.9|3529161471|add_button|Art|_2|0.9|3529161471|add_button|Farm|_3|0.9|3529161471|add_button | Game | _4 | 0.9 | 3529161471 |add_button | Guild | _13 | 0.9 | 3529161471 |add_button | Information | _5 | 0.9 | 3529161471 |add_button | Music | _15 | 0.9 | 3529161471 |add_button | Parkour | _6 | 0.9 | 3529161471 |add_button | Puzzle | _14 | 0.9 | 3529161471 |add_button | Roleplay | _7 | 0.9 | 3529161471 |add_button|Shop|_8|0.9|3529161471|add_button|Social|_9|0.9|3529161471|add_button|Storage|_10|0.9|3529161471|add_button|Story|_11|0.9|3529161471|add_button|Trade|_12|0.9|3529161471|"
					}
					if (cch.find("action|growid") == 0)
					{
						SendRegisterDialog(peer);
						enet_host_flush(server);
					}
					if (cch.find("action|eventmenu") == 0)
					{
						if (static_cast<PlayerInfo*>(peer->data)->haveGrowId == false)
						{
							SendRegisterDialog(peer);
						}
						else
						{
							if (static_cast<PlayerInfo*>(peer->data)->guild == "")
							{
								Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`9Guild Rewards And Challenges``|left|7340|\nadd_spacer|small|\nadd_textbox|`5Join or Create a `^Guild `5In order to access `cGuild Rewards`5!|\nadd_spacer|small|\nadd_button|cl0se|`wClose|\nadd_quick_exit|");
								continue;
							}
							int gpoints = 0;
							ifstream guildstream1("guildrewards/guildpoints/" + static_cast<PlayerInfo*>(peer->data)->guild + ".txt");
							guildstream1 >> gpoints;
							guildstream1.close();
							int personalpoints = 0;
							ifstream guildstream3("guildrewards/contribution/" + static_cast<PlayerInfo*>(peer->data)->guild + "/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
							guildstream3 >> personalpoints;
							guildstream3.close();
							Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`9Guild Rewards And Challenges``|left|7340|\nadd_label|small|`5Your guild currently have: `^" + std::to_string(gpoints) + " `5Points.|left|4||\nadd_label|small|`5Your personal contribution are: `^" + std::to_string(personalpoints) + " `5Points.|left|4||\nadd_spacer|small|\nadd_button|grewards|`wSpend Guild Points``|0|0|\nadd_button|gcontribution|`wMembers Contribution``|0|0|\nadd_spacer|small|\nadd_textbox|`2Guild `^Points `5Are `@Obtainable `5From those `9Activities`5: Usage of `9Magic Machine`5, Breaking `9Farmable Blocks`5, `6Harvesting `9Seeds`5.|\nadd_spacer|small|\nadd_button|cl0se|`wClose|\nadd_quick_exit|");
						}
					}
					if (cch.find("action|store\nlocation|gem") == 0)
					{
						if (((PlayerInfo*)(peer->data))->haveGrowId == true) {

							string text1 = "set_description_text|Welcome to the `2Growtopia Store``! Select the item you'd like more info on.`o `wWant to get `5Supporter`` status? Any Gem purchase (or `57,000`` Gems earned with free `5Tapjoy`` offers) will make you one. You'll get new skin colors, the `5Recycle`` tool to convert unwanted items into Gems, and more bonuses!";
							string text2 = "|enable_tabs|1";
							string text3 = "|\nadd_tab_button|main_menu|Home|interface/large/btn_shop2.rttex||1|0|0|0||||-1|-1||||";;
							string text4 = "|\nadd_tab_button|locks_menu|Locks And Stuff|interface/large/btn_shop2.rttex||0|1|0|0||||-1|-1|||";
							string text5 = "|\nadd_tab_button|itempack_menu|Item Packs|interface/large/btn_shop2.rttex||0|3|0|0||||-1|-1||||";
							string text6 = "|\nadd_tab_button|bigitems_menu|Awesome Items|interface/large/btn_shop2.rttex||0|4|0|0||||-1|-1||||";
							string text7 = "|\nadd_tab_button|weather_menu|Weather Machines|interface/large/btn_shop2.rttex|Tired of the same sunny sky?  We offer alternatives within...|0|5|0|0||||-1|-1||||";
							string text8 = "|\nadd_tab_button|token_menu|Growtoken Items|interface/large/btn_shop2.rttex||0|2|0|0||||-1|-1||||";
							string text9 = "|\nadd_banner|interface/large/gui_shop_featured_header.rttex|0|1|";
							string text10 = "|\nadd_button|itemomonth|`oItem Of The Month``|interface/large/store_buttons/store_buttons16.rttex|May 2020:`` `9Doomsday Warhammer``!<CR><CR>`2You Get:`` 1 `9Doomsday Warhammer``.<CR><CR>`5Description:`` Wield the Warhammer of Doom and rain fiery death down on all around you! This warhammer is so hot it even tears the ground up as you lug its heavy weight behind you.|0|3|200000|0||interface/large/gui_store_button_overlays1.rttex|0|0||-1|-1||1|||||||";
							string text11 = "|\nadd_button|ads_tv|`oGrowShow TV``|interface/large/store_buttons/store_buttons30.rttex|`2You Get:`` 1 GrowShow TV.<CR><CR>`5Description:`` Growtopia's most loved gameshow now brings you its very own TV to watch up to 3 ads per day for AMAZING prizes.|0|4|50|0|||-1|-1||-1|-1||1||||||";
							string text12 = "|\nadd_banner|interface/large/gui_shop_featured_header.rttex|0|2|";
							string text13 = "|\nadd_button|gems_glory|Road To Glory|interface/large/store_buttons/store_buttons30.rttex|rt_grope_loyalty_bundle01|0|0|0|0||interface/large/gui_store_button_overlays1.rttex|0|0|/interface/large/gui_shop_buybanner.rttex|1|0|`2You Get:`` Road To Glory and 100k Gems Instantly.<CR>`5Description:`` Earn Gem rewards when you level up. Every 10 levels you will get additional Gem rewards up to Level 50! Claim all rewards instantly if you are over level 50!! 1.6M Gems in total!! |1|||||||";
							string text14 = "|\nadd_button|gems_rain|It's Rainin' Gems|interface/large/store_buttons/store_buttons.rttex|rt_grope_gem_rain|1|5|0|0|||-1|-1||-1|-1|`2You Get:`` 200,000 Gems, 2 Growtoken, and 1 Megaphone.<CR><CR>`5Description:`` All the gems you could ever want and more plus 2 Growtokens and a Megaphone to tell the whole world about it.|1|||||||";
							string text15 = "|\nadd_button|gems_fountain|Gem Fountain|interface/large/store_buttons/store_buttons2.rttex|rt_grope_gem_fountain|0|2|0|0|||-1|-1||-1|-1|`2You Get:`` 90,000 Gems and 1 Growtoken.<CR><CR>`5Description:`` Get a pile of gems to shop to your hearts desire and 1 Growtoken.|1|||||||";
							string text16 = "|\nadd_button|gems_chest|Chest o' Gems|interface/large/store_buttons/store_buttons.rttex|rt_grope_gem_chest|0|5|0|0|||-1|-1||-1|-1|`2You Get:`` 30,000 Gems.<CR><CR>`5Description:`` Get a chest containing gems.|1|||||||";
							string text17 = "|\nadd_button|gems_bag|Bag o' Gems|interface/large/store_buttons/store_buttons.rttex|rt_grope_gem_bag|1|0|0|0|||-1|-1||-1|-1|`2You Get:`` 14,000 Gems.<CR><CR>`5Description:`` Get a small bag of gems.|1|||||||";
							string text18 = "|\nadd_button|tapjoy|Earn Free Gems|interface/large/store_buttons/store_buttons.rttex||1|2|0|0|||-1|-1||-1|-1||1|||||||";
							string text19 = "|\nadd_banner|interface/large/gui_shop_featured_header.rttex|0|3|";
							string text20 = "|\nadd_button|365d|`o1-Year Subscription Token``|interface/large/store_buttons/store_buttons22.rttex|rt_grope_subs_bundle02|0|5|0|0|||-1|-1||-1|-1|`2You Get:`` 1x 1-Year Subscription Token and 25 Growtokens.<CR><CR>`5Description:`` One full year of special treatment AND 25 Growtokens upfront! You'll get 70 season tokens (as long as there's a seasonal clash running), and 2500 gems every day and a chance of doubling any XP earned, growtime reduction on all seeds planted and Exclusive Skins!|1||||||";
							string text21 = "|\nadd_button|30d|`o30-Day Subscription Token``|interface/large/store_buttons/store_buttons22.rttex|rt_grope_subs_bundle01|0|4|0|0|||-1|-1||-1|-1|`2You Get:`` 1x 30-Day Free Subscription Token and 2 Growtokens.<CR><CR>`5Description:`` 30 full days of special treatment AND 2 Growtokens upfront! You'll get 70 season tokens (as long as there's a seasonal clash running), and 2500 gems every day and a chance of doubling any XP earned, growtime reduction on all seeds planted and Exclusive Skins!|1||||||";
							string text22 = "|\nadd_button|video_tapjoy|Watch Videos For Gems|interface/large/store_buttons/store_buttons29.rttex||0|1|0|0|1/5 VIDEOS WATCHED||-1|-1||-1|-1||1||||||";

							/*
							string text1 = "set_description_text|Welcome to the `2Growtopia Store``!  Tap the item you'd like more info on.`o  `wWant to get `5Supporter`` status? Any Gem purchase (or `57,000`` Gems earned with free `5Tapjoy`` offers) will make you one. You'll get new skin colors, the `5Recycle`` tool to convert unwanted items into Gems, and more bonuses!";
							string text2 = "|\nadd_button|iapp_menu|Buy Gems|interface/large/store_buttons5.rttex||0|2|0|0|";
							string text3 = "|\nadd_button|subs_menu|Subscriptions|interface/large/store_buttons22.rttex||0|1|0|0|";
							string text4 = "|\nadd_button|itemomonth|`oItem Of The Month``|interface/large/store_buttons16.rttex|`2September 2018:`` `9Sorcerer's Tunic of Mystery!`` Capable of reflecting the true colors of the world around it, this rare tunic is made of captured starlight and aether. If you think knitting with thread is hard, just try doing it with moonbeams and magic! The result is worth it though, as these clothes won't just make you look amazing - you'll be able to channel their inherent power into blasts of cosmic energy!``|0|3|200000|0|";
							string text5 = "|\nadd_button|locks_menu|Locks And Stuff|interface/large/store_buttons3.rttex||0|4|0|0|";
							string text6 = "|\nadd_button|itempack_menu|Item Packs|interface/large/store_buttons3.rttex||0|3|0|0|";
							string text7 = "|\nadd_button|bigitems_menu|Awesome Items|interface/large/store_buttons4.rttex||0|6|0|0|";
							string text8 = "|\nadd_button|weather_menu|Weather Machines|interface/large/store_buttons5.rttex|Tired of the same sunny sky?  We offer alternatives within...|0|4|0|0||";
							string text9 = "|\nadd_button|token_menu|Growtoken Items|interface/large/store_buttons9.rttex||0|0|0|0|";
							*/
							storerequest(peer, text1 + text2 + text3 + text4 + text5 + text6 + text7 + text8 + text9 + text10 + text11 + text12 + text13 + text14 + text15 + text16 + text17 + text18 + text19 + text20 + text21 + text22);

						}
						else {
#ifdef REGISTRATION
							//GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`w" + itemDefs.at(id).name + "``|left|" + std::to_string(id) + "|\n\nadd_spacer|small|\nadd_textbox|" + itemDefs.at(id).description + "|left|\nadd_spacer|small|\nadd_quick_exit|\nadd_button|chc0|Close|noflags|0|0|\nnend_dialog|gazette||OK|"));
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`wGet a GrowID``|left|206|\n\nadd_spacer|small|\nadd_textbox|A `wGrowID `wmeans `oyou can use a name and password to logon from any device.|\nadd_spacer|small|\nadd_textbox|This `wname `owill be reserved for you and `wshown to other players`o, so choose carefully!|\nadd_text_input|username|GrowID||30|\nadd_text_input_password|password|Password||100|\nadd_text_input_password|passwordverify|Password Verify||100|\nadd_textbox|Your `wemail address `owill only be used for account verification purposes and won't be spammed or shared. If you use a fake email, you'll never be able to recover or change your password.|\nadd_text_input|email|Email||100|\nend_dialog|register|Cancel|Get My GrowID!|\n"));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
#endif

							GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5 `1You must create `4GrowID `1first before you can access the `2Store`1!"));
							ENetPacket* packet2 = enet_packet_create(p2.data,
								p2.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet2);
							delete p2.data;
						}
					}
					if (cch.find("action|buy\nitem|store") == 0)
					{

						string text1 = "set_description_text|Welcome to the `2Growtopia Store``! Select the item you'd like more info on.`o `wWant to get `5Supporter`` status? Any Gem purchase (or `57,000`` Gems earned with free `5Tapjoy`` offers) will make you one. You'll get new skin colors, the `5Recycle`` tool to convert unwanted items into Gems, and more bonuses!";
						string text2 = "|enable_tabs|1";
						string text3 = "|\nadd_tab_button|main_menu|Home|interface/large/btn_shop2.rttex||1|0|0|0||||-1|-1||||";;
						string text4 = "|\nadd_tab_button|locks_menu|Locks And Stuff|interface/large/btn_shop2.rttex||0|1|0|0||||-1|-1|||";
						string text5 = "|\nadd_tab_button|itempack_menu|Item Packs|interface/large/btn_shop2.rttex||0|3|0|0||||-1|-1||||";
						string text6 = "|\nadd_tab_button|bigitems_menu|Awesome Items|interface/large/btn_shop2.rttex||0|4|0|0||||-1|-1||||";
						string text7 = "|\nadd_tab_button|weather_menu|Weather Machines|interface/large/btn_shop2.rttex|Tired of the same sunny sky?  We offer alternatives within...|0|5|0|0||||-1|-1||||";
						string text8 = "|\nadd_tab_button|token_menu|Growtoken Items|interface/large/btn_shop2.rttex||0|2|0|0||||-1|-1||||";
						string text9 = "|\nadd_banner|interface/large/gui_shop_featured_header.rttex|0|1|";
						string text10 = "|\nadd_button|itemomonth|`oItem Of The Month``|interface/large/store_buttons/store_buttons16.rttex|May 2020:`` `9Doomsday Warhammer``!<CR><CR>`2You Get:`` 1 `9Doomsday Warhammer``.<CR><CR>`5Description:`` Wield the Warhammer of Doom and rain fiery death down on all around you! This warhammer is so hot it even tears the ground up as you lug its heavy weight behind you.|0|3|200000|0||interface/large/gui_store_button_overlays1.rttex|0|0||-1|-1||1|||||||";
						string text11 = "|\nadd_button|ads_tv|`oGrowShow TV``|interface/large/store_buttons/store_buttons30.rttex|`2You Get:`` 1 GrowShow TV.<CR><CR>`5Description:`` Growtopia's most loved gameshow now brings you its very own TV to watch up to 3 ads per day for AMAZING prizes.|0|4|50|0|||-1|-1||-1|-1||1||||||";
						//string text12 = "|\nadd_banner|interface/large/gui_shop_featured_header.rttex|0|2|";
						//string text13 = "|\nadd_button|gems_glory|Road To Glory|interface/large/store_buttons/store_buttons30.rttex|rt_grope_loyalty_bundle01|0|0|0|0||interface/large/gui_store_button_overlays1.rttex|0|0|/interface/large/gui_shop_buybanner.rttex|1|0|`2You Get:`` Road To Glory and 100k Gems Instantly.<CR>`5Description:`` Earn Gem rewards when you level up. Every 10 levels you will get additional Gem rewards up to Level 50! Claim all rewards instantly if you are over level 50!! 1.6M Gems in total!! |1|||||||";
						//string text14 = "|\nadd_button|gems_rain|It's Rainin' Gems|interface/large/store_buttons/store_buttons.rttex|rt_grope_gem_rain|1|5|0|0|||-1|-1||-1|-1|`2You Get:`` 200,000 Gems, 2 Growtoken, and 1 Megaphone.<CR><CR>`5Description:`` All the gems you could ever want and more plus 2 Growtokens and a Megaphone to tell the whole world about it.|1|||||||";
						//string text15 = "|\nadd_button|gems_fountain|Gem Fountain|interface/large/store_buttons/store_buttons2.rttex|rt_grope_gem_fountain|0|2|0|0|||-1|-1||-1|-1|`2You Get:`` 90,000 Gems and 1 Growtoken.<CR><CR>`5Description:`` Get a pile of gems to shop to your hearts desire and 1 Growtoken.|1|||||||";
						//string text16 = "|\nadd_button|gems_chest|Chest o' Gems|interface/large/store_buttons/store_buttons.rttex|rt_grope_gem_chest|0|5|0|0|||-1|-1||-1|-1|`2You Get:`` 30,000 Gems.<CR><CR>`5Description:`` Get a chest containing gems.|1|||||||";
						//string text17 = "|\nadd_button|gems_bag|Bag o' Gems|interface/large/store_buttons/store_buttons.rttex|rt_grope_gem_bag|1|0|0|0|||-1|-1||-1|-1|`2You Get:`` 14,000 Gems.<CR><CR>`5Description:`` Get a small bag of gems.|1|||||||";
						//string text18 = "|\nadd_button|tapjoy|Earn Free Gems|interface/large/store_buttons/store_buttons.rttex||1|2|0|0|||-1|-1||-1|-1||1|||||||";
						//string text19 = "|\nadd_banner|interface/large/gui_shop_featured_header.rttex|0|3|";
						//string text20 = "|\nadd_button|365d|`o1-Year Subscription Token``|interface/large/store_buttons/store_buttons22.rttex|rt_grope_subs_bundle02|0|5|0|0|||-1|-1||-1|-1|`2You Get:`` 1x 1-Year Subscription Token and 25 Growtokens.<CR><CR>`5Description:`` One full year of special treatment AND 25 Growtokens upfront! You'll get 70 season tokens (as long as there's a seasonal clash running), and 2500 gems every day and a chance of doubling any XP earned, growtime reduction on all seeds planted and Exclusive Skins!|1||||||";
						//string text21 = "|\nadd_button|30d|`o30-Day Subscription Token``|interface/large/store_buttons/store_buttons22.rttex|rt_grope_subs_bundle01|0|4|0|0|||-1|-1||-1|-1|`2You Get:`` 1x 30-Day Free Subscription Token and 2 Growtokens.<CR><CR>`5Description:`` 30 full days of special treatment AND 2 Growtokens upfront! You'll get 70 season tokens (as long as there's a seasonal clash running), and 2500 gems every day and a chance of doubling any XP earned, growtime reduction on all seeds planted and Exclusive Skins!|1||||||";
						//string text22 = "|\nadd_button|video_tapjoy|Watch Videos For Gems|interface/large/store_buttons/store_buttons29.rttex||0|1|0|0|1/5 VIDEOS WATCHED||-1|-1||-1|-1||1||||||";

						/*
						string text1 = "set_description_text|Welcome to the `2Growtopia Store``!  Tap the item you'd like more info on.`o  `wWant to get `5Supporter`` status? Any Gem purchase (or `57,000`` Gems earned with free `5Tapjoy`` offers) will make you one. You'll get new skin colors, the `5Recycle`` tool to convert unwanted items into Gems, and more bonuses!";
						string text2 = "|\nadd_button|iapp_menu|Buy Gems|interface/large/store_buttons5.rttex||0|2|0|0|";
						string text3 = "|\nadd_button|subs_menu|Subscriptions|interface/large/store_buttons22.rttex||0|1|0|0|";
						string text4 = "|\nadd_button|itemomonth|`oItem Of The Month``|interface/large/store_buttons16.rttex|`2September 2018:`` `9Sorcerer's Tunic of Mystery!`` Capable of reflecting the true colors of the world around it, this rare tunic is made of captured starlight and aether. If you think knitting with thread is hard, just try doing it with moonbeams and magic! The result is worth it though, as these clothes won't just make you look amazing - you'll be able to channel their inherent power into blasts of cosmic energy!``|0|3|200000|0|";
						string text5 = "|\nadd_button|locks_menu|Locks And Stuff|interface/large/store_buttons3.rttex||0|4|0|0|";
						string text6 = "|\nadd_button|itempack_menu|Item Packs|interface/large/store_buttons3.rttex||0|3|0|0|";
						string text7 = "|\nadd_button|bigitems_menu|Awesome Items|interface/large/store_buttons4.rttex||0|6|0|0|";
						string text8 = "|\nadd_button|weather_menu|Weather Machines|interface/large/store_buttons5.rttex|Tired of the same sunny sky?  We offer alternatives within...|0|4|0|0||";
						string text9 = "|\nadd_button|token_menu|Growtoken Items|interface/large/store_buttons9.rttex||0|0|0|0|";
						*/
						storerequest(peer, text1 + text2 + text3 + text4 + text5 + text6 + text7 + text8 + text9 + text10 + text11); // + text12 + text13 + text14 + text15 + text16 + text17 + text18 + text19 + text20 + text21 + text22);

					}
					if (cch.find("action|buy\nitem|locks") == 0) {
						string text1 = "set_description_text|`2Locks And Stuff!``  Select the item you'd like more info on, or BACK to go back.";
						string text2 = "|enable_tabs|1";
						string text3 = "|\nadd_tab_button|store_menu|Home|interface/large/btn_shop2.rttex||0|0|0|0||||-1|-1||||";
						string text4 = "|\nadd_tab_button|locks_menu|Locks And Stuff|interface/large/btn_shop2.rttex||1|1|0|0||||-1|-1||||";
						string text5 = "|\nadd_tab_button|itempack_menu|Item Packs|interface/large/btn_shop2.rttex||0|3|0|0||||-1|-1||||";
						string text6 = "|\nadd_tab_button|bigitems_menu|Awesome Items|interface/large/btn_shop2.rttex||0|4|0|0||||-1|-1||||";
						string text7 = "|\nadd_tab_button|weather_menu|Weather Machines|interface/large/btn_shop2.rttex|Tired of the same sunny sky?  We offer alternatives within...|0|5|0|0||||-1|-1||||";
						string text8 = "|\nadd_tab_button|token_menu|Growtoken Items|interface/large/btn_shop2.rttex||0|2|0|0||||-1|-1||||";
						string text9 = "|\nadd_button|upgradebp|`0Upgrade Backpack`` (`w10 Slots``)|interface/large/store_buttons/store_buttons.rttex|`2You Get:`` 10 Additional Backpack Slots.<CR><CR>`5Description:`` Sewing an extra pocket onto your backpack will allow you to store `$10`` additional item types.  How else are you going to fit all those toilets and doors?|0|1|1000|0|||-1|-1||-1|-1||1|||||||";
						string text10 = "|\nadd_button|rename|`oBirth Certificate``|interface/large/store_buttons/store_buttons7.rttex|`2You Get:`` 1 Birth Certificate.<CR><CR>`5Description:`` Tired of being who you are? By forging a new birth certificate, you can change your GrowID! The Birth Certificate will be consumed when used. This item only works if you have a GrowID, and you can only use one every 60 days, so you're not confusing everybody.|0|6|20000|0|||-1|-1||-1|-1||1|||||||";
						string text11 = "|\nadd_button|cpack|`oClothes Pack``|interface/large/store_buttons/store_buttons2.rttex|`2You Get:`` 3 Randomly Wearble Items.<CR><CR>`5Description:`` Why not look the part? Some may even have special powers...|0|0|50|0|||-1|-1||-1|-1||1|||||||";
						string text12 = "|\nadd_button|rare_clothes|`oRare Clothes Pack``|interface/large/store_buttons/store_buttons2.rttex|`2You Get:`` 3 Randomly Chosen Wearbale Items.<CR><CR>`5Description:`` Enjoy the garb of kings! Some may even have special powers...|0|1|500|0|||-1|-1||-1|-1||1|||||||";
						string text13 = "|\nadd_button|transmutation_device|`oTransmutabooth``|interface/large/store_buttons/store_buttons27.rttex|`2You Get:`` 1 Transmutabooth.<CR><CR>`5Description:`` Behold! A wondrous technological achievement from the innovative minds at GrowTech, the Transmutabooth allows you to merge clothing items, transferring the visual appearance of one onto another in the same slot! If you've ever wanted your Cyclopean Visor to look like Shades (while keeping its mod), now you can!|0|7|25000|0|||-1|-1||-1|-1||1|||||||";
						string text14 = "|\nadd_button|contact_lenses|`oContact Lens Pack``|interface/large/store_buttons/store_buttons22.rttex|`2You Get:`` 10 Random Contact Lens Colors.<CR><CR>`5Description:`` Need a colorful new look? This pack includes 10 random Contact Lens colors (and may include Contact Lens Cleaning Solution, to return to your natural eye color)!|0|7|15000|0|||-1|-1||-1|-1||1|||||||";
						string text15 = "|\nadd_button|eye_drops|`oEye Drop Pack``|interface/large/store_buttons/store_buttons17.rttex|`2You Get:`` 1 `#Rare Bathroom Mirror`` and 10 random Eye Drop Colors.<CR><CR>`5Description:`` Need a fresh new look?  This pack includes a 10 random Eye Drop Colors (may include Eye Cleaning Solution, to leave your eyes sparkly clean)!|0|6|30000|0|||-1|-1||-1|-1||1|||||||";
						string text16 = "|\nadd_button|nyan_hat|`oTurtle Hat``|interface/large/store_buttons/store_buttons3.rttex|`2You Get:`` 1 Turtle Hat.<CR><CR>`5Description:`` It's the greatest hat ever. It bloops out bubbles as you run! `4Not available any other way!``|0|2|25000|0|||-1|-1||-1|-1||1|||||||";
						string text17 = "|\nadd_button|tiny_horsie|`oTiny Horsie``|interface/large/store_buttons/store_buttons3.rttex|`2You Get:`` 1 Tiny Horsie.<CR><CR>`5Description:`` Tired of wearing shoes? Wear a Tiny Horsie instead! Or possibly a large dachshund, we're not sure. Regardless, it lets you run around faster than normal, plus you're on a horse! `4Not available any other way!``|0|5|25000|0|||-1|-1||-1|-1||1|||||||";
						string text18 = "|\nadd_button|star_ship|`oPleiadian Star Ship``|interface/large/store_buttons/store_buttons4.rttex|`2You Get:`` 1 Pleiadian Star Ship.<CR><CR>`5Description:`` Float on, my brother. It's all groovy. This star ship can't fly, but you can still zoom around in it, leaving a trail of energy rings and moving at enhanced speed. Sponsored by Pleiadian. `4Not available any other way!``|0|3|25000|0|||-1|-1||-1|-1||1|||||||";
						string text19 = "|\nadd_button|dragon_hand|`oDragon Hand``|interface/large/store_buttons/store_buttons5.rttex|`2You Get:`` 1 Dragon Hand.<CR><CR>`5Description:`` Call forth the dragons of legend!  With the Dragon Hand, you will command your own pet dragon. Instead of punching blocks or players, you can order your dragon to incinerate them! In addition to just being awesome, this also does increased damage, and pushes other players farther. `4Not available any other way!``|0|1|50000|0|||-1|-1||-1|-1||1|||||||";
						string text20 = "|\nadd_button|corvette|`oLittle Red Corvette``|interface/large/store_buttons/store_buttons6.rttex|`2You Get:`` 1 Little Red Corvette.<CR><CR>`5Description:`` Cruise around the neighborhood in style with this sweet convertible. It moves at enhanced speed and leaves other Growtopians in your dust. `4Not available any other way!``|0|1|25000|0|||-1|-1||-1|-1||1|||||||";
						string text21 = "|\nadd_button|stick_horse|`oStick Horse``|interface/large/store_buttons/store_buttons6.rttex|`2You Get:`` 1 Stick Horse.<CR><CR>`5Description:`` Nobody looks cooler than a person bouncing along on a stick with a fake horse head attached. NOBODY. `4Not available any other way!``|0|3|25000|0|||-1|-1||-1|-1||1|||||||";
						string text22 = "|\nadd_button|ambulance|`oAmbulance``|interface/large/store_buttons/store_buttons7.rttex|`2You Get:`` 1 Ambulance.<CR><CR>`5Description:`` Rush to the scene of an accident while lawyers chase you in this speedy rescue vehicle. `4Not available any other way!``|0|3|25000|0|||-1|-1||-1|-1||1|||||||";
						string text23 = "|\nadd_button|raptor|`oRiding Raptor``|interface/large/store_buttons/store_buttons7.rttex|`2You Get:`` 1 Riding Raptor.<CR><CR>`5Description:`` Long thought to be extinct, it turns out that these dinosaurs are actually alive and easily tamed. And riding one lets you run around faster than normal! `4Not available any other way!``|0|7|25000|0|||-1|-1||-1|-1||1|||||||";
						string text24 = "|\nadd_button|owl|`oMid-Pacific Owl``|interface/large/store_buttons/store_buttons10.rttex|`2You Get:`` 1 Mid-Pacific Owl.<CR><CR>`5Description:`` This owl is a bit lazy - if you stop moving around, he'll land on your head and fall asleep. Dedicated to the students of the Mid-Pacific Institute. `4Not available any other way!``|0|1|30000|0|||-1|-1||-1|-1||1|||||||";
						string text25 = "|\nadd_button|unicorn|`oUnicorn Garland``|interface/large/store_buttons/store_buttons10.rttex|`2You Get:`` 1 Unicorn Garland.<CR><CR>`5Description:`` Prance about in the fields with your very own pet unicorn! It shoots `1R`2A`3I`4N`5B`6O`7W`8S``. `4Not available any other way!``|0|4|50000|0|||-1|-1||-1|-1||1|||||||";
						string text26 = "|\nadd_button|starboard|`oStarBoard``|interface/large/store_buttons/store_buttons11.rttex|`2You Get:`` 1 StarBoard.<CR><CR>`5Description:`` Hoverboards are here at last! Zoom around Growtopia on this brand new model, which is powered by fusion energy (that means stars spit out of the bottom). Moves faster than walking. Sponsored by Miwsky, Chudy, and Dawid. `4Not available any other way!``|0|1|30000|0|||-1|-1||-1|-1||1|||||||";
						string text27 = "|\nadd_button|motorcycle|`oGrowley Motorcycle``|interface/large/store_buttons/store_buttons11.rttex|`2You Get:`` 1 Growley Motorcycle.<CR><CR>`5Description:`` The coolest motorcycles available are Growley Dennisons. Get a sporty blue one today! It even moves faster than walking, which is pretty good for a motorcycle. `4Not available any other way!``|0|6|50000|0|||-1|-1||-1|-1||1|||||||";
						string text28 = "|\nadd_button|monkey_on_back|`oMonkey On Your Back``|interface/large/store_buttons/store_buttons13.rttex|`2You Get:`` 1 Monkey On Your Back.<CR><CR>`5Description:`` Most people work really hard to get rid of these, but hey, if you want one, it's available! `4But not available any other way!`` Sponsored by SweGamerHD's subscribers, Kizashi, and Inforced. `#Note: This is a neck item, not a back item. He's grabbing your neck!``|0|2|50000|0|||-1|-1||-1|-1||1|||||||";
						string text29 = "|\nadd_button|carrot_sword|`oCarrot Sword``|interface/large/store_buttons/store_buttons13.rttex|`2You Get:`` 1 Carrot Sword.<CR><CR>`5Description:`` Razor sharp, yet oddly tasty. This can carve bunny symbols into your foes! `4Not available any other way!`` Sponsored by MrMehMeh.|0|3|15000|0|||-1|-1||-1|-1||1|||||||";
						string text30 = "|\nadd_button|red_bicycle|`oRed Bicycle``|interface/large/store_buttons/store_buttons13.rttex|`2You Get:`` 1 Red Bicycle.<CR><CR>`5Description:`` It's the environmentally friendly way to get around! Ride this bicycle at high speed hither and zither throughout Growtopia. `4Not available any other way!``|0|5|30000|0|||-1|-1||-1|-1||1|||||||";
						string text31 = "|\nadd_button|fire_truck|`oFire Truck``|interface/large/store_buttons/store_buttons14.rttex|`2You Get:`` 1 Fire Truck.<CR><CR>`5Description:`` Race to the scene of the fire in this speedy vehicle! `4Not available any other way!``|0|2|50000|0|||-1|-1||-1|-1||1|||||||";
						string text32 = "|\nadd_button|pet_slime|`oPet Slime``|interface/large/store_buttons/store_buttons14.rttex|`2You Get:`` 1 Pet Slime.<CR><CR>`5Description:`` What could be better than a blob of greasy slime that follows you around? How about a blob of greasy slime that follows you around and spits corrosive acid, melting blocks more quickly than a normal punch? `4Not available any other way!``|0|4|100000|0|||-1|-1||-1|-1||1|||||||";
						string text33 = "|\nadd_button|dabstep_shoes|`oDabstep Low Top Sneakers``|interface/large/store_buttons/store_buttons21.rttex|`2You Get:`` 1 Dabstep Low Top Sneakers.<CR><CR>`5Description:`` Light up every footfall and move to a better beat with these dabulous shoes! When you're wearing these, the world is your dance floor! `4Not available any other way!``|0|2|30000|0|||-1|-1||-1|-1||1|||||||";


						storerequest(peer, text1 + text2 + text3 + text4 + text5 + text6 + text7 + text8 + text9 + text10 + text11 + text12 + text13 + text14 + text15 + text16 + text17 + text18 + text19 + text20 + text21 + text22 + text23 + text24 + text25 + text26 + text27 + text28 + text29 + text30 + text31 + text32 + text33);

					}
					if (cch.find("action|buy\nitem|itempack") == 0) {
						string text1 = "set_description_text|`2Item Packs!``  Select the item you'd like more info on, or BACK to go back.";
						string text2 = "|enable_tabs|1";
						string text3 = "|\nadd_tab_button|main_menu|Home|interface/large/btn_shop2.rttex||0|0|0|0||||-1|-1||||";
						string text4 = "|\nadd_tab_button|locks_menu|Locks And Stuff|interface/large/btn_shop2.rttex||0|1|0|0||||-1|-1||||";
						string text5 = "|\nadd_tab_button|itempack_menu|Item Packs|interface/large/btn_shop2.rttex||1|3|0|0||||-1|-1||||";
						string text6 = "|\nadd_tab_button|bigitems_menu|Awesome Items|interface/large/btn_shop2.rttex||0|4|0|0||||-1|-1||||";
						string text7 = "|\nadd_tab_button|weather_menu|Weather Machines|interface/large/btn_shop2.rttex|Tired of the same sunny sky?  We offer alternatives within...|0|5|0|0||||-1|-1||||";
						string text8 = "|\nadd_tab_button|token_menu|Growtoken Items|interface/large/btn_shop2.rttex||0|2|0|0||||-1|-1||||";
						string text9 = "|\nadd_button|world_lock|`oWorld Lock``|interface/large/store_buttons/store_buttons.rttex|`2You Get:`` 1 World Lock.<CR><CR>`5Description:`` Become the undisputed ruler of your domain with one of these babies.  It works like a normal lock except it locks the `$entire world``!  Won't work on worlds that other people already have locks on. You can even add additional normal locks to give access to certain areas to friends. `5It's a perma-item, is never lost when destroyed.``  `wRecycles for 200 Gems.``|0|7|2000|0|||-1|-1||-1|-1||1|||||||";
						string text10 = "|\nadd_button|10_wl|`oWorld Lock Pack``|interface/large/store_buttons/store_buttons18.rttex|`2You Get:`` 10 World Locks.<CR><CR>`5Description:`` 10-pack of World Locks. Become the undisputed ruler of up to TEN kingdoms with these babies. Each works like a normal lock except it locks the `$entire world``!  Won't work on worlds that other people already have locks on. You can even add additional normal locks to give access to certain areas to friends. `5It's a perma-item, is never lost when destroyed.`` `wEach recycles for 200 Gems.``|0|3|20000|0|||-1|-1||-1|-1||1|||||||";
						string text12 = "|\nadd_button|small_lock|`oSmall Lock``|interface/large/store_buttons/store_buttons.rttex|`2You Get:`` 1 Small Lock.<CR><CR>`5Description:`` Protect up to `$10`` tiles.  Can add friends to the lock so others can edit that area as well. `5It's a perma-item, is never lost when destroyed.``|1|3|50|0|||-1|-1||-1|-1||1|||||||";
						string text15 = "|\nadd_button|dpack|`oDoor And Sign Hello Pack``|interface/large/store_buttons/store_buttons.rttex|`2You Get:`` 1 Door and 1 Sign.<CR><CR>`5Description:`` Own your very own door and sign! This pack comes with one of each. Leave cryptic messages and create a door that can open to, well, anywhere.|0|3|15|0|||-1|-1||-1|-1||1|||||||";
						string text16 = "|\nadd_button|dmover|`oDoor Mover``|interface/large/store_buttons/store_buttons8.rttex|`2You Get:`` 1 Door Mover.<CR><CR>`5Description:`` Unsatisfied with your world's layout?  This one-use device can be used to move the White Door to any new location in your world, provided there are 2 empty spaces for it to fit in. Disappears when used. `2Only usable on a world you have World Locked.``|0|6|5000|0|||-1|-1||-1|-1||1|||||||";
						string text17 = "|\nadd_button|vending_machine|`oVending Machine``|interface/large/store_buttons/store_buttons13.rttex|`2You Get:`` 1 Vending Machine.<CR><CR>`5Description:`` Tired of interacting with human beings? Try a Vending Machine! You can put a stack of items inside it, set a price in World Locks, and people can buy from the machine while you sit back and rake in the profits! `5It's a perma-item, is never lost when destroyed, and it is not available any other way.``|0|6|8000|0|||-1|-1||-1|-1||1|||||||";
						string text21 = "|\nadd_button|signal_jammer|`oSignal Jammer``|interface/large/store_buttons/store_buttons.rttex|`2You Get:`` 1 Signal Jammer.<CR><CR>`5Description:`` Get off the grid! Install a `$Signal Jammer``! A single punch will cause it to whir to life, tireless hiding your world and its population from pesky snoopers - only those who know the world name will be able to enter. `5It's a perma-item, is never lost when destroyed.``|1|6|2000|0|||-1|-1||-1|-1||1|||||||";
						string text22 = "|\nadd_button|punch_jammer|`oPunch Jammer``|interface/large/store_buttons/store_buttons7.rttex|`2You Get:`` 1 Punch Jammer.<CR><CR>`5Description:`` Tired of getting bashed around? Set up a Punch Jammer in your world, and people won't be able to punch each other! Can be turned on and off as needed. `5It's a perma-item, is never lost when destroyed.``|0|4|15000|0|||-1|-1||-1|-1||1|||||||";
						string text23 = "|\nadd_button|zombie_jammer|`oZombie Jammer``|interface/large/store_buttons/store_buttons7.rttex|`2You Get:`` 1 Zombie Jammer.<CR><CR>`5Description:`` Got a parkour or race that you don't want slowed down? Turn this on and nobody can be infected by zombie bites in your world. It does not prevent direct infection by the g-Virus itself though. `5It's a perma-item, is never lost when destroyed.``|0|5|15000|0|||-1|-1||-1|-1||1|||||||";
						string text24 = "|\nadd_button|starship_blast|`oImperial Starship Blast``|interface/large/store_buttons/store_buttons21.rttex|`2You Get:`` 1 Imperial Starship Blast.<CR><CR>`5Description:`` Command your very own Starship and explore the cosmos! This blast contains one of 3 possible Imperial ship types - which will you get? Note: Each Starship comes with a full tank of gas, an Imperial Helm - Mk. I, Imperial Reactor - Mk. I and an Imperial Viewscreen - Mk. I, so you'll be all set for your adventure among the stars! Note: A Starship also comes with an assortment of space-age blocks!|0|1|20000|0|||-1|-1||-1|-1||1|||||||";
						string text25 = "|\nadd_button|surg_blast|`oSurgWorld Blast``|interface/large/store_buttons/store_buttons27.rttex|`2You Get:`` 1 SurgWorld Blast and 1 Caduceaxe.<CR><CR>`5Description:`` Your gateway to a world of medical wonders! SurgWorld is a place of care and healing, with all kinds of interesting blocks, top tips on how to treat people with surgery, and an increased chance of getting maladies while you work! Also comes with 1 Caduceaxe to extract Vaccine Drops from blocks. `6Warning:`` May break when extracting vaccine.|0|2|10000|0|||-1|-1||-1|-1||1|||||||";
						string text26 = "|\nadd_button|bountiful_blast|`oBountiful Blast``|interface/large/store_buttons/store_buttons27.rttex|`2You Get:`` 1 Bountiful Blast.<CR><CR>`5Description:`` Enter a world of fertile soil, cheerful sunshine and lush green hills, and bountiful new trees! This blast is your ticket to a different kind of farming!|0|3|5000|0|||-1|-1||-1|-1||1|||||||";
						string text27 = "|\nadd_button|thermo_blast|`oThermonuclear Blast``|interface/large/store_buttons/store_buttons8.rttex|`2You Get:`` 1 Thermonuclear Blast.<CR><CR>`5Description:`` This supervillainous device will blast you to a new world that has been scoured completely empty - it contains nothing but Bedrock and a White Door. Remember: When using this, you are creating a NEW world by typing in a new name. It would be irresponsible to let you blow up an entire existing world.|0|5|15000|0|||-1|-1||-1|-1||1|||||||";
						string text28 = "|\nadd_button|antigravity_generator|`oAntigravity Generator``|interface/large/store_buttons/store_buttons17.rttex|`2You Get:`` 1 Antigravity Generator.<CR><CR>`5Description:`` Disables gravity in your world when activated! Well, it reduces gravity, and lets everybody jump as much as they want! `5It's a perma-item - never lost when destroyed! `4Not available any other way!````|0|3|450000|0|||-1|-1||-1|-1||1|||||||";
						string text29 = "|\nadd_button|building_blocks_machine|`oBuilding Blocks Machine``|interface/large/store_buttons/store_buttons26.rttex|`2You Get:`` 1 Building Blocks Machine.<CR><CR>`5Description:`` Eager to add some new building materials to your construction stockpile? Tired of collecting them from random worlds and weirdos? Well, pop this beauty in your world and it'll start cranking out awesome blocks in no time! Contains the `5RARE Creepy Baby Block and Digital Dirt`` amongst a heap of other new blocks! Careful, though - blocks don't just come from nothing, and this machine will eventually run out of power once it makes a bunch!|0|3|8000|0|||-1|-1||-1|-1||1|||||||";
						string text30 = "|\nadd_button|builders_lock|`oBuilder's Lock``|interface/large/store_buttons/store_buttons17.rttex|`2You Get:`` 1 Builders Lock.<CR><CR>`5Description:`` Protect up to `$200`` tiles. Wrench the lock to limit it - it can either only allow building, or only allow breaking! `5It's a perma-item, is never lost when destroyed.``|0|2|50000|0|||-1|-1||-1|-1||1|||||||";
						string text31 = "|\nadd_button|weather_sunny|`oWeather Machine - Sunny``|interface/large/store_buttons/store_buttons5.rttex|`2You Get:`` 1 Weather Machine - Sunny.<CR><CR>`5Description:`` You probably don't need this one... but if you ever have a desire to turn a sunset or desert world back to normal, grab a Sunny Weather Machine to restore the default Growtopia sky! `5It's a perma-item, is never lost when destroyed.``|0|5|1000|0|||-1|-1||-1|-1||1|||||||";
						string text32 = "|\nadd_button|weather_night|`oWeather Machine - Night``|interface/large/store_buttons/store_buttons5.rttex|`2You Get:`` 1 Weather Machine - Night.<CR><CR>`5Description:`` You might not call it weather, but we do! This will turn the background of your world into a lovely night scene with stars and moon. `5It's a perma-item, is never lost when destroyed.``|0|6|10000|0|||-1|-1||-1|-1||1|||||||";
						string text33 = "|\nadd_button|weather_arid|`oWeather Machine - Arid``|interface/large/store_buttons/store_buttons5.rttex|`2You Get:`` 1 Weather Machine - Arid.<CR><CR>`5Description:`` Want your world to look like a cartoon desert? This will turn the background of your world into a desert scene with all the trimmings. `5It's a perma-item, is never lost when destroyed.``|0|7|10000|0|||-1|-1||-1|-1||1|||||||";
						string text34 = "|\nadd_button|weather_rainy|`oWeather Machine - Rainy City``|interface/large/store_buttons/store_buttons6.rttex|`2You Get:`` 1 Weather Machine - Rainy City.<CR><CR>`5Description:`` This will turn the background of your world into a dark, rainy city scene complete with sound effects. `5It's a perma-item, is never lost when destroyed.``|0|5|10000|0|||-1|-1||-1|-1||1|||||||";
						string text35 = "|\nadd_button|weather_warp|`oWeather Machine - Warp Speed``|interface/large/store_buttons/store_buttons11.rttex|`2You Get:`` 1 Weather Machine - Warp Speed.<CR><CR>`5Description:`` This Weather Machine will launch your world through space at relativistic speeds, which will cause you to age more slowly, as well as see stars flying by rapidly in the background. `5It's a perma-item, is never lost when destroyed.``|0|3|10000|0|||-1|-1||-1|-1||1|||||||";
						string text36 = "|\nadd_button|mars_blast|`oMars Blast``|interface/large/store_buttons/store_buttons6.rttex|`2You Get:`` 1 Mars Blast.<CR><CR>`5Description:`` Blast off to Mars!  This powerful rocket ship will launch you to a new world set up like the surface of Mars, with a special martian sky background, and unique terrain not found elsewhere in the solar system. Mars even has lower gravity than Growtopia normally does! Remember: When using this, you are creating a NEW world by typing in a new name. You can't convert an existing world to Mars, that would be dangerous.|0|7|15000|0|||-1|-1||-1|-1||1|||||||";
						string text37 = "|\nadd_button|undersea_blast|`oUndersea Blast``|interface/large/store_buttons/store_buttons9.rttex|`2You Get:`` 1 Undersea Blast.<CR><CR>`5Description:`` Explore the ocean!  This advanced device will terraform a new world set up like the bottom of the ocean, with a special ocean background, and special blocks like Seaweed, Coral, Jellyfish, Sharks, and maybe a special surprise... Remember, by using this you are creating a NEW world by typing in a new name. You can't convert an existing world to an ocean, that would be dangerous.|0|7|15000|0|||-1|-1||-1|-1||1|||||||";
						string text38 = "|\nadd_button|cave_blast|`oCave Blast``|interface/large/store_buttons/store_buttons15.rttex|`2You Get:`` 1 Cave Blast.<CR><CR>`5Description:`` This explosive device will punch a hole in the ground, giving you a dark cavern to explore. There are even rumors of treasure and the entrance to ancient mines, hidden deep in the caves... but make sure you bring a World Lock. The blasted world is not locked when it's created, so lock it before somebody shows up! Remember: When using this, you are creating a NEW world by typing in a new name. You can't convert an existing world to a cave, that would be dangerous.|0|2|30000|0|||-1|-1||-1|-1||1|||||||";
						string text39 = "|\nadd_button|weather_stuff|`oWeather Machine - Stuff``|interface/large/store_buttons/store_buttons15.rttex|`2You Get:`` 1 Weather Machine - Stuff.<CR><CR>`5Description:`` This is the most fun weather imaginable - Choose any item from your inventory, adjust some settings, and watch it rain down from the sky! Or up, if you prefer reversing the gravity. `5It's a perma-item, is never lost when destroyed.``|0|6|50000|0|||-1|-1||-1|-1||1|||||||";
						string text40 = "|\nadd_button|weather_jungle|`oWeather Machine - Jungle``|interface/large/store_buttons/store_buttons16.rttex|`2You Get:`` 1 Weather Machine - Jungle.<CR><CR>`5Description:`` This weather machine will turn the background of your world into a steamy jungle. `5It's a perma-item, is never lost when destroyed.``|0|5|20000|0|||-1|-1||-1|-1||1|||||||";
						string text41 = "|\nadd_button|weather_backgd|`oWeather Machine - Background``|interface/large/store_buttons/store_buttons17.rttex|`2You Get:`` 1 Weather Machine - Background.<CR><CR>`5Description:`` This amazing device can scan any Background Block, and will make your entire world look like it's been filled with that block. Also handy for hiding music notes! `5It's a perma-item, is never lost when destroyed.``|0|1|150000|0|||-1|-1||-1|-1||1|||||||";
						string text42 = "|\nadd_button|digital_rain_weather|`oWeather Machine - Digital Rain``|interface/large/store_buttons/store_buttons22.rttex|`2You Get:`` 1 Weather Machine - Digital Rain.<CR><CR>`5Description:`` Take the grow pill, and we'll show you how deep the rabbit hole goes! Splash the scrolling code of creation across the skies of your worlds. They say you learn to understand it after a while... Note: You can only have one of these per world. `5It's a perma-item, is never lost when destroyed.``|0|6|30000|0|||-1|-1||-1|-1||1|||||||";
						string text43 = "|\nadd_button|treasure_blast|`oTreasure Blast``|interface/large/store_buttons/store_buttons26.rttex|`2You Get:`` 1 Treasure Blast.<CR><CR>`5Description:`` Enter a world of snow-capped peaks and long-forgotten mysteries! Riddles and secrets - and a ton of treasure - await those who brave this blast's blocks! Remember, when you use this, it'll create a new world by typing in a new name! No sense in searching for clues to great treasures in well-trod worlds, is there?|0|6|10000|0|||-1|-1||-1|-1||1|||||||";


						storerequest(peer, text1 + text2 + text3 + text4 + text5 + text6 + text7 + text8 + text9 + text10 + text12 + text15 + text16 + text17 + text21 + text22 + text23 + text24 + text25 + text26 + text27 + text28 + text29 + text30 + text31 + text32 + text33 + text34 + text35 + text36 + text37 + text38 + text39 + text40 + text41 + text42 + text43);

					}
					if (cch.find("action|buy\nitem|bigitems") == 0) {
						string text1 = "set_description_text|`2Awesome Items!``  Select the item you'd like more info on, or BACK to go back.";
						string text2 = "|enable_tabs|1";
						string text3 = "|\nadd_tab_button|main_menu|Home|interface/large/btn_shop2.rttex||0|0|0|0||||-1|-1||||";
						string text4 = "|\nadd_tab_button|locks_menu|Locks And Stuff|interface/large/btn_shop2.rttex||0|1|0|0||||-1|-1||||";
						string text5 = "|\nadd_tab_button|itempack_menu|Item Packs|interface/large/btn_shop2.rttex||0|3|0|0||||-1|-1||||";
						string text6 = "|\nadd_tab_button|bigitems_menu|Awesome Items|interface/large/btn_shop2.rttex||1|4|0|0||||-1|-1||||";
						string text7 = "|\nadd_tab_button|weather_menu|Weather Machines|interface/large/btn_shop2.rttex|Tired of the same sunny sky?  We offer alternatives within...|0|5|0|0||||-1|-1||||";
						string text8 = "|\nadd_tab_button|token_menu|Growtoken Items|interface/large/btn_shop2.rttex||0|2|0|0||||-1|-1||||";
						string text9 = "|\nadd_button|sspitems|`oSmall Seed Pack``|interface/large/store_buttons/store_buttons.rttex|`2You Get:`` 1 Small Seed Pack.<CR><CR>`5Description:`` Contains one Small Seed Pack. Open it for `$5`` randomly chosen seeds, including 1 rare seed! Who knows what you'll get?!|1|4|100|0|||-1|-1||-1|-1||1|||||||";
						string text11 = "|\nadd_button|rare_seed|`oRare Seed Pack``|interface/large/store_buttons/store_buttons.rttex|`2You Get:`` 5 Randomly Chosen Rare Seeds.<CR><CR>`5Description:`` Expect some wondrous crops with these!|1|7|500|0|||-1|-1||-1|-1||1|||||||";
						string text12 = "|\nadd_button|grow_spray|`o5-pack of Grow Spray Fertilizer``|interface/large/store_buttons/store_buttons.rttex|`2You Get:`` 5 Grow Spray Fertilizers.<CR><CR>`5Description:`` Why wait?!  Treat yourself to a `$5-pack`` of amazing `wGrow Spray Fertilizer`` by GrowTech Corp.  Each bottle instantly ages a tree by `$1 hour``.|0|6|200|0|||-1|-1||-1|-1||1|||||||";
						string text13 = "|\nadd_button|deluxe_grow_spray|`oDeluxe Grow Spray``|interface/large/store_buttons/store_buttons11.rttex|`2You Get:`` 1 Deluxe Grow Spray.<CR><CR>`5Description:`` GrowTech's new `$Deluxe`` `wGrow Spray`` instantly ages a tree by `$24 hours`` per bottle! That's somewhere around 25 times as much as regular Grow Spray!|0|2|900|0|||-1|-1||-1|-1||1|||||||";
						string text16 = "|\nadd_button|surgical_kit|`oSurgical Kit``|interface/large/store_buttons/store_buttons7.rttex|`2You Get:`` 1 `#Rare Heart Monitor``, 1 Hospital Bed, 1 Train-E Bot, 5 of each of the 13 different Surical Tools and 10 Med-a-Checks.<CR><CR>`5Description:`` Get all the tools you need to become Chief of Surgery at Growtopia General Hospital! `#Rare`` Heart Monitor that lets people know when you are online, Hospital Bed that lets you perform surgery on anybody laying (or standing) on it, Med-a-Checks to identify patients with maladies, The Train-E bot to practice on, and 5 each of the thirteen different Surgical Tools you'll need to do that surgery!|0|2|12000|0|||-1|-1||-1|-1||1|||||||";
						string text18 = "|\nadd_button|fishin_pack|`oFishin' Pack``|interface/large/store_buttons/store_buttons14.rttex|`2You Get:`` 1 Fishing Rod, 5 Wiggly Worms, 1 Hand Drill, 1 Nuclear Detonator,  1 `#Rare Tackle Box``, 10 Fish Tanks and 1 `#Rare Fish Tank Port`` .<CR><CR>`5Description:`` Relax and sit by the shore... this pack includes a Fishing Rod, Wiggly Worms for bait, Hand Drill, Nuclear Detonator, and a `#Rare`` Tackle Box which provides you with more free bait every two days, Fish Tanks, and a `#Rare`` Fish Tank Port to put the fish you catch into your fish tank!|0|0|10000|0|||-1|-1||-1|-1||1|||||||";
						string text26 = "|\nadd_button|geiger|`oGeiger Counter``|interface/large/store_buttons/store_buttons12.rttex|`2You Get:`` 1 Geiger Counter.<CR><CR>`5Description:`` With this fantabulous device, you can detect radiation around you. It bleeps red, then yellow, then green as you get closer to the source. Who knows what you might find? `4Not available any other way!``|0|1|25000|0|||-1|-1||-1|-1||1|||||||";



						storerequest(peer, text1 + text2 + text3 + text4 + text5 + text6 + text7 + text8 + text9 + text11 + text12 + text13 + text16 + text18 + text26);

					}
					if (cch.find("action|buy\nitem|weather") == 0) {
						string text1 = "set_description_text|`2Weather Machines!``  Select the item you'd like more info on, or BACK to go back.";
						string text2 = "|enable_tabs|1";
						string text3 = "|\nadd_tab_button|main_menu|Home|interface/large/btn_shop2.rttex||0|0|0|0||||-1|-1||||";
						string text4 = "|\nadd_tab_button|locks_menu|Locks And Stuff|interface/large/btn_shop2.rttex||0|1|0|0||||-1|-1||||";
						string text5 = "|\nadd_tab_button|itempack_menu|Item Packs|interface/large/btn_shop2.rttex||0|3|0|0||||-1|-1||||";
						string text6 = "|\nadd_tab_button|bigitems_menu|Awesome Items|interface/large/btn_shop2.rttex||0|4|0|0||||-1|-1||||";
						string text7 = "|\nadd_tab_button|weather_menu|Weather Machines|interface/large/btn_shop2.rttex|Tired of the same sunny sky?  We offer alternatives within...|1|5|0|0||||-1|-1||||";
						string text8 = "|\nadd_tab_button|token_menu|Growtoken Items|interface/large/btn_shop2.rttex||0|2|0|0||||-1|-1||||";
						string text14 = "|\nadd_button|vegas_pack|`oVegas Pack``|interface/large/store_buttons/store_buttons4.rttex|`2You Get:`` 10 Neon Lights, 1 Card Block Seed, 1 `#Rare Pink Cadillac`` 4 Flipping Coins, 1 Dice Block, 1 Gamblers Visor, 1 Slot Machine, 1 Roulette Wheel and 1 Showgirl Hat, 1 Showgirl top and 1 Showgirl Leggins.<CR><CR>`5Description:`` What happens in Growtopia stays in Growtopia!|0|5|20000|0|||-1|-1||-1|-1||1|||||||";
						string text15 = "|\nadd_button|farm_pack|`oFarm Pack``|interface/large/store_buttons/store_buttons5.rttex|`2You Get:`` 1 Cow, 1 Chicken, 10 Wheat, 10 Barn Block, 10 Red Wood Walls, 1 Barn Door, 1 Straw Hat, 1 Overalls, 1 Pitchfork, 1 Farmgirl Hair, 1 `#Rare`` `2Dear John Tractor``.<CR><CR>`5Description:`` Put the `2Grow`` in Growtopia with this pack, including a Cow you can milk, a Chicken that lays eggs and a farmer's outfit. Best of all? You get a `#Rare`` `2Dear John Tractor`` you can ride that will mow down trees!|0|0|15000|0|||-1|-1||-1|-1||1|||||||";
						string text16 = "|\nadd_button|science_pack|`oMad Science Kit``|interface/large/store_buttons/store_buttons5.rttex|`2You Get:`` 1 Science Station, 1 Laboratory, 1 LabCoat, 1 Combover Hair, 1 Goggles, 5 Chemical 5, 10 Chemical G, 5 Chemical Y, 5 Chemical B, 5 Chemical P and 1 `#Rare`` `2Death Ray``.<CR><CR>`5Description:`` It's SCIENCE! Defy the natural order with a Science Station that produces chemicals, a Laboratory in which to mix them and a full outfit to do so safely! You'll also get a starter pack of assorted chemicals. Mix them up! Special bonus: A `#Rare`` `2Death Ray`` to make your science truly mad!|0|3|5000|0|||-1|-1||-1|-1||1|||||||";
						string text17 = "|\nadd_button|city_pack|`oCity Pack``|interface/large/store_buttons/store_buttons6.rttex|`2You Get:`` 10 Sidewalks, 3 Street Signs, 3 Streetlamps, 10 Gothic Building tiles, 10 Tenement Building tiles, 10 Fire Escapes, 3 Gargoyles, 10 Hedges, 1 Blue Mailbox, 1 Fire Hydrant and A `#Rare`` `2ATM Machine``.<CR><CR>`5Description:`` Life in the big city is rough but a `#Rare`` `2ATM Machine`` that dishes out gems once a day is very nice!|0|0|8000|0|||-1|-1||-1|-1||1|||||||";
						string text18 = "|\nadd_button|west_pack|`oWild West Pack``|interface/large/store_buttons/store_buttons6.rttex|`2You Get:`` 1 Cowboy Hat, 1 Cowboy Boots, 1 War Paint, 1 Face Bandana, 1 Sheriff Vest, 1 Layer Cake Dress,  1 Corset, 1 Kansas Curls, 10 Western Building 1 Saloon Doors, 5 Western Banners, 1 Buffalo, 10 Rustic Fences, 1 Campfire and 1 Parasol.<CR><CR>`5Description:`` Yippee-kai-yay! This pack includes everything you need to have wild time in the wild west! The Campfire plays cowboy music, and the `#Parasol`` lets you drift down slowly. Special bonus: A `#Rare`` `2Six Shooter`` to blast criminals with!|0|2|8000|0|||-1|-1||-1|-1||1|||||||";
						string text21 = "|\nadd_button|shop_pack|`oShop Pack``|interface/large/store_buttons/store_buttons8.rttex|`2You Get:`` 4 Display Boxes, 1 For Sale Sign, 1 Gem Sign, 1 Exclamation Sign, 1 Shop Sign, 1 Open Sign, 1 Cash Register, 1 Mannequin and 1 Security Camera.<CR><CR>`5Description:`` Run a fancy shop with these new items! Advertise your wares with an Open/Closed Sign you can switch with a punch, a Cash Register, a Mannequin you can dress up to show off clothing, and a `#Rare`` Security Camera, which reports when people enter and take items!|0|7|10000|0|||-1|-1||-1|-1||1|||||||";
						string text32 = "|\nadd_button|paintbrush|`oPainter's Pack``|interface/large/store_buttons/store_buttons15.rttex|`2You Get:`` 1 `#Rare Paintbrush`` and 20 Random Colored Paint Buckets.<CR><CR>`5Description:`` Want to paint your world? This pack includes 20 buckets of random paint colors (may include Varnish, to clean up your messes)! You can paint any block in your world different colors to personalize it.|0|1|30000|0|||-1|-1||-1|-1||1|||||||";
						string text33 = "|\nadd_button|paleo_kit|`oPaleontologist's Kit``|interface/large/store_buttons/store_buttons16.rttex|`2You Get:`` 5 Fossil Brushes, 1 Rock Hammer, 1 Rock Chisel, 1 Blue Hardhat and 1 `#Rare Fossil Prep Station``.<CR><CR>`5Description:`` If you want to dig up fossils, this is the kit for you! Includes everything you need! Use the prepstation to get your fossils ready for display.|0|0|20000|0|||-1|-1||-1|-1||1|||||||";

						storerequest(peer, text1 + text2 + text3 + text4 + text5 + text6 + text7 + text8 + text14 + text15 + text16 + text17 + text32 + text33);

					}
					if (cch.find("action|buy\nitem|token") == 0) {
						string text1 = "set_description_text|`2Spend your Growtokens!`` (You have `52``) You earn Growtokens from Crazy Jim and Sales-Man. Select the item you'd like more info on, or BACK to go back.";
						string text2 = "|enable_tabs|1";
						string text3 = "|\nadd_tab_button|main_menu|Home|interface/large/btn_shop2.rttex||0|0|0|0||||-1|-1||||";
						string text4 = "|\nadd_tab_button|locks_menu|Locks And Stuff|interface/large/btn_shop2.rttex||0|1|0|0||||-1|-1||||";
						string text5 = "|\nadd_tab_button|itempack_menu|Item Packs|interface/large/btn_shop2.rttex||0|3|0|0||||-1|-1||||";
						string text6 = "|\nadd_tab_button|bigitems_menu|Awesome Items|interface/large/btn_shop2.rttex||0|4|0|0||||-1|-1||||";
						string text7 = "|\nadd_tab_button|weather_menu|Weather Machines|interface/large/btn_shop2.rttex|Tired of the same sunny sky?  We offer alternatives within...|0|5|0|0||||-1|-1||||";
						string text8 = "|\nadd_tab_button|token_menu|Growtoken Items|interface/large/btn_shop2.rttex||1|2|0|0||||-1|-1||||";
						string text11 = "|\nadd_button|megaphone|`oMegaphone``|interface/large/store_buttons/store_buttons15.rttex|`2You Get:`` 1 Megaphone.<CR><CR>`5Description:`` You like broadcasting messages, but you're not so big on spending gems? Buy a Megaphone with Growtokens! Each Megaphone can be used once to send a super broadcast to all players in the game.|0|7|-10|0|||-1|-1||-1|-1||1|||||||";
						string text16 = "|\nadd_button|nothingness|`oWeather Machine - Nothingness``|interface/large/store_buttons/store_buttons9.rttex|`2You Get:`` 1 Weather Machine - Nothingness.<CR><CR>`5Description:`` Tired of all that fancy weather?  This machine will turn your world completely black. Yup, that's it. Not a single pixel in the background except pure blackness.|0|3|-50|0|||-1|-1||-1|-1||1|||||||";
						string text18 = "|\nadd_button|doodad|`oDoodad``|interface/large/store_buttons/store_buttons9.rttex|`2You Get:`` 1 Doodad.<CR><CR>`5Description:`` I have no idea what this thing does. It's something electronic? Maybe?|0|5|-75|0|||-1|-1||-1|-1||1|||||||";
						string text19 = "|\nadd_button|crystal_cape|`oCrystal Cape``|interface/large/store_buttons/store_buttons11.rttex|`2You Get:`` 1 Crystal Cape.<CR><CR>`5Description:`` This cape is woven of pure crystal, which makes it pretty uncomfortable. But it also makes it magical! It lets you double-jump off of an imaginary Crystal Block in mid-air. Sponsored by Edvoid20, HemeTems, and Aboge.|0|5|-90|0|||-1|-1||-1|-1||1|||||||";
						string text20 = "|\nadd_button|focused_eyes|`oFocused Eyes``|interface/large/store_buttons/store_buttons9.rttex|`2You Get:`` 1 Focused Eyes.<CR><CR>`5Description:`` This `#Untradeable`` item lets you shoot electricity from your eyes! Wear them with pride, and creepiness.|0|4|-100|0|||-1|-1||-1|-1||1|||||||";
						string text22 = "|\nadd_button|cat_eyes|`oCat Eyes``|interface/large/store_buttons/store_buttons23.rttex|`2You Get:`` 1 Cat Eyes.<CR><CR>`5Description:`` Wow, pawesome! These new eyes are the cat's meow, and the purrfect addition to any style.|0|5|-100|0|||-1|-1||-1|-1||1|||||||";
						string text23 = "|\nadd_button|night_vision|`oNight Vision Goggles``|interface/large/store_buttons/store_buttons15.rttex|`2You Get:`` 1 Night Vision Goggles.<CR><CR>`5Description:`` Scared of the dark? We have a solution. You can wear these goggles just to look cool, but if you also happen to have a D Battery (`4batteries not included``) on you, you will be able to see through darkness like it's not even there! Each D Battery can power your goggles for 1 minute. `2If you are in a world you own, the goggles will not require batteries!`` Note: you can't turn the goggles off without removing them, so you'll be wasting your battery if you wear them in daylight while carrying D Batteries.|0|3|-110|0|||-1|-1||-1|-1||1|||||||";
						string text27 = "|\nadd_button|golden_axe|`oGolden Pickaxe``|interface/large/store_buttons/store_buttons9.rttex|`2You Get:`` 1 Golden Pickaxe.<CR><CR>`5Description:`` Get your own sparkly pickaxe! This `#Untradeable`` item is a status symbol! Oh sure, it isn't any more effective than a normal pickaxe, but it sparkles!|0|1|-200|0|||-1|-1||-1|-1||1|||||||";
						string text28 = "|\nadd_button|puppy_leash|`oPuppy Leash``|interface/large/store_buttons/store_buttons11.rttex|`2You Get:`` 1 Puppy Leash.<CR><CR>`5Description:`` Get your own pet puppy! This little dog will follow you around forever, never wavering in her loyalty, thus making her `#Untradeable``.|0|4|-200|0|||-1|-1||-1|-1||1|||||||";
						string text29 = "|\nadd_button|diggers_spade|`oDigger's Spade``|interface/large/store_buttons/store_buttons13.rttex|`2You Get:`` 1 Digger's Spade.<CR><CR>`5Description:`` This may appear to be a humble shovel, but in fact it is enchanted with the greatest magic in Growtopia. It can smash Dirt or Cave Background in a single hit! Unfortunately, it's worthless at digging through anything else. Note: The spade is `#UNTRADEABLE``.|0|7|-200|0|||-1|-1||-1|-1||1|||||||";
						string text30 = "|\nadd_button|meow_ears|`oMeow Ears``|interface/large/store_buttons/store_buttons22.rttex|`2You Get:`` 1 Meow Ears.<CR><CR>`5Description:`` Meow's super special ears that everyone can now get! Note: These ears are `#UNTRADEABLE``.|0|0|-200|0|||-1|-1||-1|-1||1|||||||";
						string text31 = "|\nadd_button|frosty_hair|`oFrosty Hair``|interface/large/store_buttons/store_buttons23.rttex|`2You Get:`` 1 Frosty Hair.<CR><CR>`5Description:`` Coldplay is cold, but you can be freezing! Note: The frosty hair is `#UNTRADEABLE``.|0|0|-200|0|||-1|-1||-1|-1||1|||||||";


						storerequest(peer, text1 + text2 + text3 + text4 + text5 + text6 + text7 + text8 + text11 + text16 + text18 + text19 + text20 + text22 + text23 + text27 + text28 + text29 + text30 + text31);

					}
					if (cch.find("action|storenavigate\nitem|main\nselection|gems_rain") == 0) {
						string text1 = "set_description_text|Welcome to the `2Growtopia Store``! Select the item you'd like more info on.`o `wWant to get `5Supporter`` status? Any Gem purchase (or `57,000`` Gems earned with free `5Tapjoy`` offers) will make you one. You'll get new skin colors, the `5Recycle`` tool to convert unwanted items into Gems, and more bonuses!";
						string text2 = "|enable_tabs|1";
						string text3 = "|\nadd_tab_button|main_menu|Home|interface/large/btn_shop2.rttex||1|0|0|0||||-1|-1||||";
						string text4 = "|\nadd_tab_button|locks_menu|Locks And Stuff|interface/large/btn_shop2.rttex||0|1|0|0||||-1|-1||||";
						string text5 = "|\nadd_tab_button|itempack_menu|Item Packs|interface/large/btn_shop2.rttex||0|3|0|0||||-1|-1||||";
						string text6 = "|\nadd_tab_button|bigitems_menu|Awesome Items|interface/large/btn_shop2.rttex||0|4|0|0||||-1|-1||||";
						string text7 = "|\nadd_tab_button|weather_menu|Weather Machines|interface/large/btn_shop2.rttex|Tired of the same sunny sky?  We offer alternatives within...|0|5|0|0||||-1|-1||||";
						string text8 = "|\nadd_tab_button|token_menu|Growtoken Items|interface/large/btn_shop2.rttex||0|2|0|0||||-1|-1||||";
						string text9 = "|\nadd_banner|interface/large/gui_shop_featured_header.rttex|0|1|";


						storerequest(peer, text1 + text2 + text3 + text4 + text5 + text6 + text7 + text8 + text9);

					}
					if (cch.find("action|buy\nitem|atomi_shadow_scythe") == 0) {
						/*Fast Item Setup*/
						auto Price = 10;
						auto ItemID = 1484;
						auto count = 1;
						auto contains = false;
						auto KiekTuri = 0;
						for (auto i = 0; i < static_cast<PlayerInfo*>(peer->data)->inventory.items.size(); i++) {
							if (static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemID == 1486 && static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount >= 1) {
								KiekTuri = static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount;
							}
						}
						SearchInventoryItem(peer, 1486, Price, contains);
						if (contains) {
							if (CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && !CheckItemExists(peer, ItemID)) {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
								continue;
							}
							RemoveInventoryItem(1486, Price, peer, true);
							bool success = true;
							SaveItemMoreTimes(ItemID, count, peer, success);
							Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + getItemDef(ItemID).name + " `wfor `$" + to_string(Price) + " `wGrowtokens.\nYou have `$" + to_string(KiekTuri - Price) + " `wGrowtokens left.\n\n`5Received: ``" + to_string(count) + " " + getItemDef(ItemID).name + ""));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						else {
							Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + getItemDef(ItemID).name + "``!  You're `$" + to_string(Price - KiekTuri) + "`` Growtokens short."));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
					}

					if (cch.find("action|buy\nitem|evil_space_helmet") == 0) {
						/*Fast Item Setup*/
						auto Price = 5;
						auto ItemID = 1440;
						auto count = 1;
						auto contains = false;
						auto KiekTuri = 0;
						for (auto i = 0; i < static_cast<PlayerInfo*>(peer->data)->inventory.items.size(); i++) {
							if (static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemID == 1486 && static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount >= 1) {
								KiekTuri = static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount;
							}
						}
						SearchInventoryItem(peer, 1486, Price, contains);
						if (contains) {
							if (CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && !CheckItemExists(peer, ItemID)) {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
								continue;
							}
							RemoveInventoryItem(1486, Price, peer, true);
							bool success = true;
							SaveItemMoreTimes(ItemID, count, peer, success);
							Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + getItemDef(ItemID).name + " `wfor `$" + to_string(Price) + " `wGrowtokens.\nYou have `$" + to_string(KiekTuri - Price) + " `wGrowtokens left.\n\n`5Received: ``" + to_string(count) + " " + getItemDef(ItemID).name + ""));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						else {
							Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + getItemDef(ItemID).name + "``!  You're `$" + to_string(Price - KiekTuri) + "`` Growtokens short."));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
					}

					if (cch.find("action|buy\nitem|frosty_hair") == 0) {
						/*Fast Item Setup*/
						auto Price = 10;
						auto ItemID = 1444;
						auto count = 1;
						auto contains = false;
						auto KiekTuri = 0;
						for (auto i = 0; i < static_cast<PlayerInfo*>(peer->data)->inventory.items.size(); i++) {
							if (static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemID == 1486 && static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount >= 1) {
								KiekTuri = static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount;
							}
						}
						SearchInventoryItem(peer, 1486, Price, contains);
						if (contains) {
							if (CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && !CheckItemExists(peer, ItemID)) {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
								continue;
							}
							RemoveInventoryItem(1486, Price, peer, true);
							bool success = true;
							SaveItemMoreTimes(ItemID, count, peer, success);
							Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + getItemDef(ItemID).name + " `wfor `$" + to_string(Price) + " `wGrowtokens.\nYou have `$" + to_string(KiekTuri - Price) + " `wGrowtokens left.\n\n`5Received: ``" + to_string(count) + " " + getItemDef(ItemID).name + ""));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						else {
							Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + getItemDef(ItemID).name + "``!  You're `$" + to_string(Price - KiekTuri) + "`` Growtokens short."));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
					}

					if (cch.find("action|buy\nitem|meow_ears") == 0) {
						/*Fast Item Setup*/
						auto Price = 5;
						auto ItemID = 698;
						auto count = 1;
						auto contains = false;
						auto KiekTuri = 0;
						for (auto i = 0; i < static_cast<PlayerInfo*>(peer->data)->inventory.items.size(); i++) {
							if (static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemID == 1486 && static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount >= 1) {
								KiekTuri = static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount;
							}
						}
						SearchInventoryItem(peer, 1486, Price, contains);
						if (contains) {
							if (CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && !CheckItemExists(peer, ItemID)) {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
								continue;
							}
							RemoveInventoryItem(1486, Price, peer, true);
							bool success = true;
							SaveItemMoreTimes(ItemID, count, peer, success);
							Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + getItemDef(ItemID).name + " `wfor `$" + to_string(Price) + " `wGrowtokens.\nYou have `$" + to_string(KiekTuri - Price) + " `wGrowtokens left.\n\n`5Received: ``" + to_string(count) + " " + getItemDef(ItemID).name + ""));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						else {
							Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + getItemDef(ItemID).name + "``!  You're `$" + to_string(Price - KiekTuri) + "`` Growtokens short."));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
					}

					if (cch.find("action|buy\nitem|puppy_leash") == 0) {
						/*Fast Item Setup*/
						auto Price = 5;
						auto ItemID = 1742;
						auto count = 1;
						auto contains = false;
						auto KiekTuri = 0;
						for (auto i = 0; i < static_cast<PlayerInfo*>(peer->data)->inventory.items.size(); i++) {
							if (static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemID == 1486 && static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount >= 1) {
								KiekTuri = static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount;
							}
						}
						SearchInventoryItem(peer, 1486, Price, contains);
						if (contains) {
							if (CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && !CheckItemExists(peer, ItemID)) {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
								continue;
							}
							RemoveInventoryItem(1486, Price, peer, true);
							bool success = true;
							SaveItemMoreTimes(ItemID, count, peer, success);
							Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + getItemDef(ItemID).name + " `wfor `$" + to_string(Price) + " `wGrowtokens.\nYou have `$" + to_string(KiekTuri - Price) + " `wGrowtokens left.\n\n`5Received: ``" + to_string(count) + " " + getItemDef(ItemID).name + ""));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						else {
							Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + getItemDef(ItemID).name + "``!  You're `$" + to_string(Price - KiekTuri) + "`` Growtokens short."));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
					}

					if (cch.find("action|buy\nitem|science_pack") == 0) {
						ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
						string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
						auto gembux = atoi(content.c_str());
						if (gembux >= 5000) {
							if (CheckItemMaxed(peer, 916, 5) || CheckItemMaxed(peer, 914, 10) || CheckItemMaxed(peer, 924, 5) || CheckItemMaxed(peer, 920, 5) || CheckItemMaxed(peer, 918, 5) || CheckItemMaxed(peer, 930, 1) || CheckItemMaxed(peer, 928, 1) || CheckItemMaxed(peer, 912, 1) || CheckItemMaxed(peer, 772, 1) || CheckItemMaxed(peer, 770, 1) || CheckItemMaxed(peer, 904, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 11 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize) {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
								continue;
							}
							gembux -= 5000;
							ofstream myfile;
							myfile.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
							myfile << gembux;
							myfile.close();
							Player::OnSetBux(peer, gembux, 0);
							bool success = true;
							SaveItemMoreTimes(930, 1, peer, success);
							SaveItemMoreTimes(928, 1, peer, success);
							SaveItemMoreTimes(912, 1, peer, success);
							SaveItemMoreTimes(772, 1, peer, success);
							SaveItemMoreTimes(770, 1, peer, success);
							SaveItemMoreTimes(904, 1, peer, success);
							SaveItemMoreTimes(916, 5, peer, success);
							SaveItemMoreTimes(914, 10, peer, success);
							SaveItemMoreTimes(924, 5, peer, success);
							SaveItemMoreTimes(920, 5, peer, success);
							SaveItemMoreTimes(918, 5, peer, success);
							Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `oMad Science Kit `wfor `$" + to_string(5000) + " `wGems.\nYou have `$" + to_string(gembux) + " `wGems left.\n\n`5Received:`` Death Ray`&,`` Science Station`$,`` Laboratory`$,`` LabCoat`$,`` Combover Hair`$,`` Goggles`$,`` 5 Chemical R`$,`` 10 Chemical G`$,`` 5 Chemical Y`$,`` 5 Chemical B`$,`` 5 Chemical P\n"));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						else {
							Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `oMad Science Kit``!  You're `$" + to_string(5000 - gembux) + "`` Gems short."));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
					}
					if (cch.find("action|buy\nitem|golden_axe") == 0) {
						/*Fast Item Setup*/
						auto Price = 200;
						auto ItemID = 1438;
						auto count = 1;
						auto contains = false;
						auto KiekTuri = 0;
						for (auto i = 0; i < static_cast<PlayerInfo*>(peer->data)->inventory.items.size(); i++) {
							if (static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemID == 1486 && static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount >= 1) {
								KiekTuri = static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount;
							}
						}
						SearchInventoryItem(peer, 1486, Price, contains);
						if (contains) {
							if (CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && !CheckItemExists(peer, ItemID)) {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
								continue;
							}
							RemoveInventoryItem(1486, Price, peer, true);
							bool success = true;
							SaveItemMoreTimes(ItemID, count, peer, success);
							Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + getItemDef(ItemID).name + " `wfor `$" + to_string(Price) + " `wGrowtokens.\nYou have `$" + to_string(KiekTuri - Price) + " `wGrowtokens left.\n\n`5Received: ``" + to_string(count) + " " + getItemDef(ItemID).name + ""));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						else {
							Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + getItemDef(ItemID).name + "``!  You're `$" + to_string(Price - KiekTuri) + "`` Growtokens short."));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
					}

					if (cch.find("action|buy\nitem|cat_eyes") == 0) {
						/*Fast Item Setup*/
						auto Price = 1;
						auto ItemID = 7106;
						auto count = 1;
						auto contains = false;
						auto KiekTuri = 0;
						for (auto i = 0; i < static_cast<PlayerInfo*>(peer->data)->inventory.items.size(); i++) {
							if (static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemID == 1486 && static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount >= 1) {
								KiekTuri = static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount;
							}
						}
						SearchInventoryItem(peer, 1486, Price, contains);
						if (contains) {
							if (CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && !CheckItemExists(peer, ItemID)) {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
								continue;
							}
							RemoveInventoryItem(1486, Price, peer, true);
							bool success = true;
							SaveItemMoreTimes(ItemID, count, peer, success);
							Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + getItemDef(ItemID).name + " `wfor `$" + to_string(Price) + " `wGrowtokens.\nYou have `$" + to_string(KiekTuri - Price) + " `wGrowtokens left.\n\n`5Received: ``" + to_string(count) + " " + getItemDef(ItemID).name + ""));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						else {
							Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + getItemDef(ItemID).name + "``!  You're `$" + to_string(Price - KiekTuri) + "`` Growtokens short."));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
					}
					if (cch.find("action|buy\nitem|surgery_pack") == 0) {
						ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
						string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
						auto gembux = atoi(content.c_str());
						if (gembux >= 5000) {
							if (CheckItemMaxed(peer, 916, 5) || CheckItemMaxed(peer, 914, 10) || CheckItemMaxed(peer, 924, 5) || CheckItemMaxed(peer, 920, 5) || CheckItemMaxed(peer, 918, 5) || CheckItemMaxed(peer, 930, 1) || CheckItemMaxed(peer, 928, 1) || CheckItemMaxed(peer, 912, 1) || CheckItemMaxed(peer, 772, 1) || CheckItemMaxed(peer, 770, 1) || CheckItemMaxed(peer, 904, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 11 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize) {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
								continue;
							}
							gembux -= 5000;
							ofstream myfile;
							myfile.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
							myfile << gembux;
							myfile.close();
							Player::OnSetBux(peer, gembux, 0);
							bool success = true;
							SaveItemMoreTimes(1258, 5, peer, success);
							SaveItemMoreTimes(1260, 5, peer, success);
							SaveItemMoreTimes(1262, 5, peer, success);
							SaveItemMoreTimes(1264, 5, peer, success);
							SaveItemMoreTimes(1266, 5, peer, success);
							SaveItemMoreTimes(1268, 5, peer, success);
							SaveItemMoreTimes(1270, 5, peer, success);
							SaveItemMoreTimes(8500, 10, peer, success);
							SaveItemMoreTimes(4308, 5, peer, success);
							SaveItemMoreTimes(4310, 5, peer, success);
							SaveItemMoreTimes(4312, 5, peer, success);
							SaveItemMoreTimes(4314, 5, peer, success);
							SaveItemMoreTimes(4316, 5, peer, success);
							SaveItemMoreTimes(4318, 5, peer, success);
							SaveItemMoreTimes(1296, 5, peer, success);
							Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `oMad Science Kit `wfor `$" + to_string(5000) + " `wGems.\nYou have `$" + to_string(gembux) + " `wGems left.\n\n`5Received:`` Death Ray`&,`` Science Station`$,`` Laboratory`$,`` LabCoat`$,`` Combover Hair`$,`` Goggles`$,`` 5 Chemical R`$,`` 10 Chemical G`$,`` 5 Chemical Y`$,`` 5 Chemical B`$,`` 5 Chemical P\n"));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						else {
							Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `oMad Science Kit``!  You're `$" + to_string(5000 - gembux) + "`` Gems short."));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
					}
					if (cch.find("action|buy\nitem|focused_eyes") == 0) {
						/*Fast Item Setup*/
						auto Price = 100;
						auto ItemID = 1204;
						auto count = 1;
						auto contains = false;
						auto KiekTuri = 0;
						for (auto i = 0; i < static_cast<PlayerInfo*>(peer->data)->inventory.items.size(); i++) {
							if (static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemID == 1486 && static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount >= 1) {
								KiekTuri = static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount;
							}
						}
						SearchInventoryItem(peer, 1486, Price, contains);
						if (contains) {
							if (CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && !CheckItemExists(peer, ItemID)) {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
								continue;
							}
							RemoveInventoryItem(1486, Price, peer, true);
							bool success = true;
							SaveItemMoreTimes(ItemID, count, peer, success);
							Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + getItemDef(ItemID).name + " `wfor `$" + to_string(Price) + " `wGrowtokens.\nYou have `$" + to_string(KiekTuri - Price) + " `wGrowtokens left.\n\n`5Received: ``" + to_string(count) + " " + getItemDef(ItemID).name + ""));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						else {
							Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + getItemDef(ItemID).name + "``!  You're `$" + to_string(Price - KiekTuri) + "`` Growtokens short."));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
					}

					if (cch.find("action|buy\nitem|crystal_cape") == 0) {
						/*Fast Item Setup*/
						auto Price = 90;
						auto ItemID = 1738;
						auto count = 1;
						auto contains = false;
						auto KiekTuri = 0;
						for (auto i = 0; i < static_cast<PlayerInfo*>(peer->data)->inventory.items.size(); i++) {
							if (static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemID == 1486 && static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount >= 1) {
								KiekTuri = static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount;
							}
						}
						SearchInventoryItem(peer, 1486, Price, contains);
						if (contains) {
							if (CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && !CheckItemExists(peer, ItemID)) {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
								continue;
							}
							RemoveInventoryItem(1486, Price, peer, true);
							bool success = true;
							SaveItemMoreTimes(ItemID, count, peer, success);
							Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + getItemDef(ItemID).name + " `wfor `$" + to_string(Price) + " `wGrowtokens.\nYou have `$" + to_string(KiekTuri - Price) + " `wGrowtokens left.\n\n`5Received: ``" + to_string(count) + " " + getItemDef(ItemID).name + ""));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						else {
							Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + getItemDef(ItemID).name + "``!  You're `$" + to_string(Price - KiekTuri) + "`` Growtokens short."));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
					}

					if (cch.find("action|buy\nitem|diggers_spade") == 0) {
						/*Fast Item Setup*/
						auto Price = 200;
						auto ItemID = 2952;
						auto count = 1;
						auto contains = false;
						auto KiekTuri = 0;
						for (auto i = 0; i < static_cast<PlayerInfo*>(peer->data)->inventory.items.size(); i++) {
							if (static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemID == 1486 && static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount >= 1) {
								KiekTuri = static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount;
							}
						}
						SearchInventoryItem(peer, 1486, Price, contains);
						if (contains) {
							if (CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && !CheckItemExists(peer, ItemID)) {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
								continue;
							}
							RemoveInventoryItem(1486, Price, peer, true);
							bool success = true;
							SaveItemMoreTimes(ItemID, count, peer, success);
							Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + getItemDef(ItemID).name + " `wfor `$" + to_string(Price) + " `wGrowtokens.\nYou have `$" + to_string(KiekTuri - Price) + " `wGrowtokens left.\n\n`5Received: ``" + to_string(count) + " " + getItemDef(ItemID).name + ""));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						else {
							Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + getItemDef(ItemID).name + "``!  You're `$" + to_string(Price - KiekTuri) + "`` Growtokens short."));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
					}

					if (cch.find("action|buy\nitem|dmover") == 0) {
						std::ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
						std::string content((std::istreambuf_iterator<char>(ifsz)),
							(std::istreambuf_iterator<char>()));
						int b = atoi(content.c_str());
						if (b >= 5000)
						{
							bool success = true;
							string text = "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0\n";
							BYTE* data = new BYTE[5 + text.length()];
							BYTE zero = 0;
							int type = 3;
							memcpy(data, &type, 4);
							memcpy(data + 4, text.c_str(), text.length()); // change memcpy here
							memcpy(data + 4 + text.length(), &zero, 1); // change memcpy here, revert to 4
							ENetPacket* packetsou = enet_packet_create(data,
								5 + text.length(),
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packetsou);
							int gemcalc10k = b - 5000;
							ofstream myfile2;
							myfile2.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
							myfile2 << std::to_string(gemcalc10k);
							myfile2.close();
							std::ifstream ifszi("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
							std::string contentx((std::istreambuf_iterator<char>(ifszi)),
								(std::istreambuf_iterator<char>()));
							int updgem = atoi(contentx.c_str());
							GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), updgem));
							ENetPacket* packetpp = enet_packet_create(pp.data,
								pp.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packetpp);
							delete pp.data;
							Player::OnConsoleMessage(peer, "`5Got `o1 `2Door Mover");
							OnStorePurchaseResults(peer, "`oReceived: `o1 `2Door Mover.");
							SaveShopsItemMoreTimes(1404, 1, peer, success);


							sendSound(peer, "cash_register.wav");
						}
						else {
							OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Gems To Buy This Item. `5Try again later.");
						}
					}
					if (cch.find("action|buy\nitem|grow_spray") == 0) {
						std::ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
						std::string content((std::istreambuf_iterator<char>(ifsz)),
							(std::istreambuf_iterator<char>()));
						int b = atoi(content.c_str());
						if (b >= 200)
						{
							bool success = true;
							string text = "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0\n";
							BYTE* data = new BYTE[5 + text.length()];
							BYTE zero = 0;
							int type = 3;
							memcpy(data, &type, 4);
							memcpy(data + 4, text.c_str(), text.length()); // change memcpy here
							memcpy(data + 4 + text.length(), &zero, 1); // change memcpy here, revert to 4
							ENetPacket* packetsou = enet_packet_create(data,
								5 + text.length(),
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packetsou);
							int gemcalc10k = b - 200;
							ofstream myfile2;
							myfile2.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
							myfile2 << std::to_string(gemcalc10k);
							myfile2.close();
							std::ifstream ifszi("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
							std::string contentx((std::istreambuf_iterator<char>(ifszi)),
								(std::istreambuf_iterator<char>()));
							int updgem = atoi(contentx.c_str());
							GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), updgem));
							ENetPacket* packetpp = enet_packet_create(pp.data,
								pp.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packetpp);
							delete pp.data;
							Player::OnConsoleMessage(peer, "`5Got `o1 `2Grow Spray Feltilizer");
							OnStorePurchaseResults(peer, "`oReceived: `o1 `2Grow Spray Feltilizer.");
							SaveShopsItemMoreTimes(228, 1, peer, success);


							sendSound(peer, "cash_register.wav");
						}
						else {
							OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Gems To Buy This Item. `5Try again later.");
						}
					}
					if (cch.find("action|buy\nitem|small_lock") == 0) {
						std::ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
						std::string content((std::istreambuf_iterator<char>(ifsz)),
							(std::istreambuf_iterator<char>()));
						int b = atoi(content.c_str());
						if (b >= 50)
						{
							bool success = true;
							string text = "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0\n";
							BYTE* data = new BYTE[5 + text.length()];
							BYTE zero = 0;
							int type = 3;
							memcpy(data, &type, 4);
							memcpy(data + 4, text.c_str(), text.length()); // change memcpy here
							memcpy(data + 4 + text.length(), &zero, 1); // change memcpy here, revert to 4
							ENetPacket* packetsou = enet_packet_create(data,
								5 + text.length(),
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packetsou);
							int gemcalc10k = b - 50;
							ofstream myfile2;
							myfile2.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
							myfile2 << std::to_string(gemcalc10k);
							myfile2.close();
							std::ifstream ifszi("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
							std::string contentx((std::istreambuf_iterator<char>(ifszi)),
								(std::istreambuf_iterator<char>()));
							int updgem = atoi(contentx.c_str());
							GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), updgem));
							ENetPacket* packetpp = enet_packet_create(pp.data,
								pp.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packetpp);
							delete pp.data;
							Player::OnConsoleMessage(peer, "`5Got 1 `oWorld lock");
							OnStorePurchaseResults(peer, "`oReceived: `o1 `2World lock.");

							SaveShopsItemMoreTimes(202, 0, peer, success);

							sendSound(peer, "cash_register.wav");
						}
						else {
							OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Gems To Buy This Item. `5Try again later.");
						}
					}
					if (cch.find("action|buy\nitem|10_wl") == 0) {
						std::ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
						std::string content((std::istreambuf_iterator<char>(ifsz)),
							(std::istreambuf_iterator<char>()));
						int b = atoi(content.c_str());
						if (b >= 20000)
						{
							bool success = true;
							string text = "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0\n";
							BYTE* data = new BYTE[5 + text.length()];
							BYTE zero = 0;
							int type = 3;
							memcpy(data, &type, 4);
							memcpy(data + 4, text.c_str(), text.length()); // change memcpy here
							memcpy(data + 4 + text.length(), &zero, 1); // change memcpy here, revert to 4
							ENetPacket* packetsou = enet_packet_create(data,
								5 + text.length(),
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packetsou);
							int gemcalc10k = b - 20000;
							ofstream myfile2;
							myfile2.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
							myfile2 << std::to_string(gemcalc10k);
							myfile2.close();
							std::ifstream ifszi("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
							std::string contentx((std::istreambuf_iterator<char>(ifszi)),
								(std::istreambuf_iterator<char>()));
							int updgem = atoi(contentx.c_str());
							GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), updgem));
							ENetPacket* packetpp = enet_packet_create(pp.data,
								pp.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packetpp);
							delete pp.data;
							Player::OnConsoleMessage(peer, "`5Got 10 `oWorld lock");
							OnStorePurchaseResults(peer, "`oReceived: `o10 `2World lock.");

							SaveShopsItemMoreTimes(242, 10, peer, success);

							sendSound(peer, "cash_register.wav");
						}
						else {
							OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Gems To Buy This Item. `5Try again later.");
						}
					}
					if (cch.find("action|buy\nitem|world_lock") == 0) {
						std::ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
						std::string content((std::istreambuf_iterator<char>(ifsz)),
							(std::istreambuf_iterator<char>()));
						int b = atoi(content.c_str());
						if (b >= 2000)
						{
							bool success = true;
							string text = "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0\n";
							BYTE* data = new BYTE[5 + text.length()];
							BYTE zero = 0;
							int type = 3;
							memcpy(data, &type, 4);
							memcpy(data + 4, text.c_str(), text.length()); // change memcpy here
							memcpy(data + 4 + text.length(), &zero, 1); // change memcpy here, revert to 4
							ENetPacket* packetsou = enet_packet_create(data,
								5 + text.length(),
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packetsou);
							int gemcalc10k = b - 2000;
							ofstream myfile2;
							myfile2.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
							myfile2 << std::to_string(gemcalc10k);
							myfile2.close();
							std::ifstream ifszi("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
							std::string contentx((std::istreambuf_iterator<char>(ifszi)),
								(std::istreambuf_iterator<char>()));
							int updgem = atoi(contentx.c_str());
							GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), updgem));
							ENetPacket* packetpp = enet_packet_create(pp.data,
								pp.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packetpp);
							delete pp.data;
							Player::OnConsoleMessage(peer, "`5Got 1 `oWorld lock");
							OnStorePurchaseResults(peer, "`oReceived: `o1 `2World lock.");

							SaveShopsItemMoreTimes(242, 1, peer, success);

							sendSound(peer, "cash_register.wav");
						}
						else {
							OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Gems To Buy This Item. `5Try again later.");
						}
					}
					if (cch.find("action|buy\nitem|itemomonth") == 0) {
						std::ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
						std::string content((std::istreambuf_iterator<char>(ifsz)),
							(std::istreambuf_iterator<char>()));
						int b = atoi(content.c_str());
						if (b >= 200000)
						{
							bool success = true;
							string text = "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0\n";
							BYTE* data = new BYTE[5 + text.length()];
							BYTE zero = 0;
							int type = 3;
							memcpy(data, &type, 4);
							memcpy(data + 4, text.c_str(), text.length()); // change memcpy here
							memcpy(data + 4 + text.length(), &zero, 1); // change memcpy here, revert to 4
							ENetPacket* packetsou = enet_packet_create(data,
								5 + text.length(),
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packetsou);
							int gemcalc10k = b - 200000;
							ofstream myfile2;
							myfile2.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
							myfile2 << std::to_string(gemcalc10k);
							myfile2.close();
							std::ifstream ifszi("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
							std::string contentx((std::istreambuf_iterator<char>(ifszi)),
								(std::istreambuf_iterator<char>()));
							int updgem = atoi(contentx.c_str());
							GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), updgem));
							ENetPacket* packetpp = enet_packet_create(pp.data,
								pp.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packetpp);
							delete pp.data;
							Player::OnConsoleMessage(peer, "`5Got 1 `oPerilous Pirateship");
							OnStorePurchaseResults(peer, "`oReceived: `o1 `2Perilous Pirateship.");

							SaveShopsItemMoreTimes(10618, 1, peer, success);

							sendSound(peer, "cash_register.wav");
						}
						else {
							OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Gems To Buy This Item. `5Try again later.");
						}
					}
					if (cch.find("action|buy\nitem|rare_seed") == 0) {
						ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
						string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
						auto gembux = atoi(content.c_str());
						if (gembux >= 1500) {
							int Seed1 = 0;
							int Seed2 = 0;
							int Seed3 = 0;
							int Seed4 = 0;
							int Seed5 = 0;
							int AVGRarity = rand() % 10 + 10;
							while (Seed1 == 0 || Seed2 == 0 || Seed3 == 0 || Seed4 == 0 || Seed5 == 0) {
								for (int i = 0; i < maxItems; i++) {
									if (i >= 1000) {
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "Something went wrong.", 0, true);
										break;
									}
									if (isSeed(i) && getItemDef(i).rarity == AVGRarity || isSeed(i) && getItemDef(i).rarity == AVGRarity + 1) {
										if (Seed1 == 0) Seed1 = i;
										else if (Seed2 == 0) Seed2 = i;
										else if (Seed3 == 0) Seed3 = i;
										else if (Seed4 == 0) Seed4 = i;
										else if (Seed5 == 0) Seed5 = i;
										else break;
										AVGRarity = rand() % 10 + 10;
									}
									else if (i == maxItems - 1) {
										break;
									}
								}
							}
							if (CheckItemMaxed(peer, Seed1, 1) || CheckItemMaxed(peer, Seed2, 1) || CheckItemMaxed(peer, Seed3, 1) || CheckItemMaxed(peer, Seed4, 75) || CheckItemMaxed(peer, Seed5, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 5 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize) {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
								continue;
							}
							gembux -= 1500;
							ofstream myfile;
							myfile.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
							myfile << gembux;
							myfile.close();
							Player::OnSetBux(peer, gembux, 0);
							bool success = true;
							SaveItemMoreTimes(Seed1, 1, peer, success);
							SaveItemMoreTimes(Seed2, 1, peer, success);
							SaveItemMoreTimes(Seed3, 1, peer, success);
							SaveItemMoreTimes(Seed4, 1, peer, success);
							SaveItemMoreTimes(Seed5, 1, peer, success);
							sendSound(peer, "piano_nice.wav");
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `oRare Seed Pack `wfor `$" + to_string(1500) + " `wGems.\nYou have `$" + to_string(gembux) + " `wGems left.\n\n`5Received:`` " + getItemDef(Seed1).name + "`$,`` " + getItemDef(Seed2).name + "`$,`` " + getItemDef(Seed3).name + "`$,`` " + getItemDef(Seed4).name + "`$,`` " + getItemDef(Seed5).name + "\n"));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						else {
							Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `oRare Seed Pack``!  You're `$" + to_string(1500 - gembux) + "`` Gems short."));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
					}

					if (cch.find("action|buy\nitem|geiger") == 0) {
						/*Fast Item Setup*/
						auto Price = 7500;
						auto ItemID = 2204;
						auto count = 1;
						ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
						string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
						auto gembux = atoi(content.c_str());
						if (gembux >= Price) {
							if (CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && !CheckItemExists(peer, ItemID)) {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
								continue;
							}
							gembux -= Price;
							ofstream myfile;
							myfile.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
							myfile << gembux;
							myfile.close();
							Player::OnSetBux(peer, gembux, 0);
							bool success = true;
							SaveItemMoreTimes(ItemID, count, peer, success);
							Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + getItemDef(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(gembux) + " `wGems left.\n\n`5Received: ``" + to_string(count) + " " + getItemDef(ItemID).name + ""));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						else {
							Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + getItemDef(ItemID).name + "``!  You're `$" + to_string(Price - gembux) + "`` Gems short."));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
					}

					if (cch.find("action|buy\nitem|grow_scan") == 0) {
						/*Fast Item Setup*/
						auto Price = 3500;
						auto ItemID = 6016;
						auto count = 1;
						ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
						string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
						auto gembux = atoi(content.c_str());
						if (gembux >= Price) {
							if (CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && !CheckItemExists(peer, ItemID)) {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
								continue;
							}
							gembux -= Price;
							ofstream myfile;
							myfile.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
							myfile << gembux;
							myfile.close();
							Player::OnSetBux(peer, gembux, 0);
							bool success = true;
							SaveItemMoreTimes(ItemID, count, peer, success);
							Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + getItemDef(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(gembux) + " `wGems left.\n\n`5Received: ``" + to_string(count) + " " + getItemDef(ItemID).name + ""));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						else {
							Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + getItemDef(ItemID).name + "``!  You're `$" + to_string(Price - gembux) + "`` Gems short."));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
					}
					if (cch.find("action|buy\nitem|sspitems") == 0) {
						/*Fast Item Setup*/
						auto Price = 500;
						auto ItemID = 5706;
						auto count = 1;
						ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
						string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
						auto gembux = atoi(content.c_str());
						if (gembux >= Price) {
							if (CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && !CheckItemExists(peer, ItemID)) {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
								continue;
							}
							gembux -= Price;
							ofstream myfile;
							myfile.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
							myfile << gembux;
							myfile.close();
							Player::OnSetBux(peer, gembux, 0);
							bool success = true;
							SaveItemMoreTimes(ItemID, count, peer, success);
							Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + getItemDef(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(gembux) + " `wGems left.\n\n`5Received: ``" + to_string(count) + " " + getItemDef(ItemID).name + ""));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						else {
							Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + getItemDef(ItemID).name + "``!  You're `$" + to_string(Price - gembux) + "`` Gems short."));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
					}

					if (cch.find("action|buy\nitem|farm_pack") == 0) {
						ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
						string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
						auto gembux = atoi(content.c_str());
						if (gembux >= 4000) {
							if (CheckItemMaxed(peer, 872, 1) || CheckItemMaxed(peer, 866, 1) || CheckItemMaxed(peer, 102, 100) || CheckItemMaxed(peer, 340, 40) || CheckItemMaxed(peer, 5666, 40) || CheckItemMaxed(peer, 954, 60) || CheckItemMaxed(peer, 4584, 75) || CheckItemMaxed(peer, 898, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 8 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize) {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
								continue;
							}
							gembux -= 4000;
							ofstream myfile;
							myfile.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
							myfile << gembux;
							myfile.close();
							Player::OnSetBux(peer, gembux, 0);
							bool success = true;
							SaveItemMoreTimes(102, 100, peer, success);
							SaveItemMoreTimes(340, 40, peer, success);
							SaveItemMoreTimes(5666, 40, peer, success);
							SaveItemMoreTimes(954, 60, peer, success);
							SaveItemMoreTimes(4584, 75, peer, success);
							SaveItemMoreTimes(898, 1, peer, success);
							SaveItemMoreTimes(872, 1, peer, success);
							SaveItemMoreTimes(866, 1, peer, success);
							Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `oFarm Pack `wfor `$" + to_string(4000) + " `wGems.\nYou have `$" + to_string(gembux) + " `wGems left.\n\n`5Received:`` 100 Wooden Platforms`$,`` 40 Chandeliers`$,`` 40 Laser Grids`$,`` 60 Sugar Canes`$,`` 75 Pepper Trees`$,`` Dear John Tractor\n"));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						else {
							Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `oFarm Pack``!  You're `$" + to_string(4000 - gembux) + "`` Gems short."));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
					}

					if (cch.find("action|buy\nitem|west_pack") == 0) {
						ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
						string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
						auto gembux = atoi(content.c_str());
						if (gembux >= 8000) {
							if (CheckItemMaxed(peer, 1044, 1) || CheckItemMaxed(peer, 1046, 10) || CheckItemMaxed(peer, 1048, 1) || CheckItemMaxed(peer, 1020, 1) || CheckItemMaxed(peer, 1022, 1) || CheckItemMaxed(peer, 1030, 1) || CheckItemMaxed(peer, 1024, 1) || CheckItemMaxed(peer, 1026, 1) || CheckItemMaxed(peer, 1028, 1) || CheckItemMaxed(peer, 1036, 1) || CheckItemMaxed(peer, 1034, 1) || CheckItemMaxed(peer, 1032, 1) || CheckItemMaxed(peer, 1038, 10) || CheckItemMaxed(peer, 1040, 1) || CheckItemMaxed(peer, 1042, 5) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 15 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize) {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
								continue;
							}
							gembux -= 8000;
							ofstream myfile;
							myfile.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
							myfile << gembux;
							myfile.close();
							Player::OnSetBux(peer, gembux, 0);
							bool success = true;
							//Buffalo`$,`` 10 Rustic Fences`$,`` Campfire`$,`` Parasol
							SaveItemMoreTimes(1022, 1, peer, success);
							SaveItemMoreTimes(1030, 1, peer, success);
							SaveItemMoreTimes(1024, 1, peer, success);
							SaveItemMoreTimes(1026, 1, peer, success);
							SaveItemMoreTimes(1028, 1, peer, success);
							SaveItemMoreTimes(1036, 1, peer, success);
							SaveItemMoreTimes(1034, 1, peer, success);
							SaveItemMoreTimes(1032, 1, peer, success);
							SaveItemMoreTimes(1038, 10, peer, success);
							SaveItemMoreTimes(1040, 1, peer, success);
							SaveItemMoreTimes(1042, 5, peer, success);
							SaveItemMoreTimes(1044, 1, peer, success);
							SaveItemMoreTimes(1046, 10, peer, success);
							SaveItemMoreTimes(1048, 1, peer, success);
							SaveItemMoreTimes(1020, 1, peer, success);
							Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `oWild West Pack `wfor `$" + to_string(8000) + " `wGems.\nYou have `$" + to_string(gembux) + " `wGems left.\n\n`5Received:`` Cowboy Hat`&,`` Cowboy Boots`$,`` War Paint`$,`` Face Bandana`$,`` Sheriff Vest`$,`` Layer Cake Dress`$,`` Corset`$,`` Kansas Curls`$,`` 10 Western Building`$,`` Saloon Doors`$,`` 5 Western Banners`$,`` Buffalo`$,`` 10 Rustic Fences`$,`` Campfire`$,`` Parasol\n"));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						else {
							Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `oWild West Pack``!  You're `$" + to_string(8000 - gembux) + "`` Gems short."));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
					}

					if (cch.find("action|buy\nitem|city_pack") == 0) {
						ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
						string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
						auto gembux = atoi(content.c_str());
						if (gembux >= 8000) {
							if (CheckItemMaxed(peer, 1008, 1) || CheckItemMaxed(peer, 986, 3) || CheckItemMaxed(peer, 992, 3) || CheckItemMaxed(peer, 990, 10) || CheckItemMaxed(peer, 996, 10) || CheckItemMaxed(peer, 998, 10) || CheckItemMaxed(peer, 988, 3) || CheckItemMaxed(peer, 1004, 10) || CheckItemMaxed(peer, 1006, 1) || CheckItemMaxed(peer, 1002, 1) || CheckItemMaxed(peer, 994, 10) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 11 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize) {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
								continue;
							}
							gembux -= 8000;
							ofstream myfile;
							myfile.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
							myfile << gembux;
							myfile.close();
							Player::OnSetBux(peer, gembux, 0);
							bool success = true;
							//1 Blue Mailbox`$,`` 1 Fire Hydrant`$,`` 10 Sidewalks
							SaveItemMoreTimes(1008, 1, peer, success);
							SaveItemMoreTimes(986, 3, peer, success);
							SaveItemMoreTimes(992, 3, peer, success);
							SaveItemMoreTimes(990, 10, peer, success);
							SaveItemMoreTimes(996, 10, peer, success);

							SaveItemMoreTimes(998, 10, peer, success);

							SaveItemMoreTimes(988, 3, peer, success);

							SaveItemMoreTimes(1004, 10, peer, success);

							SaveItemMoreTimes(1006, 1, peer, success);

							SaveItemMoreTimes(1002, 1, peer, success);
							SaveItemMoreTimes(994, 10, peer, success);
							Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `oCity Pack `wfor `$" + to_string(8000) + " `wGems.\nYou have `$" + to_string(gembux) + " `wGems left.\n\n`5Received:`` ATM Machine`&,`` 3 Street Signs`$,`` 3 Streetlamps`$,`` 10 Gothic Building tiles`$,`` 10 Tenement Building tiles`$,`` 10 Fire Escapes`$,`` 3 Gargoyles`$,`` 10 Hedges`$,`` 1 Blue Mailbox`$,`` 1 Fire Hydrant`$,`` 10 Sidewalks\n"));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						else {
							Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `oCity Pack``!  You're `$" + to_string(8000 - gembux) + "`` Gems short."));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
					}

					if (cch.find("action|buy\nitem|science_pack") == 0) {
						ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
						string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
						auto gembux = atoi(content.c_str());
						if (gembux >= 5000) {
							if (CheckItemMaxed(peer, 916, 5) || CheckItemMaxed(peer, 914, 10) || CheckItemMaxed(peer, 924, 5) || CheckItemMaxed(peer, 920, 5) || CheckItemMaxed(peer, 918, 5) || CheckItemMaxed(peer, 930, 1) || CheckItemMaxed(peer, 928, 1) || CheckItemMaxed(peer, 912, 1) || CheckItemMaxed(peer, 772, 1) || CheckItemMaxed(peer, 770, 1) || CheckItemMaxed(peer, 904, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 11 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize) {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
								continue;
							}
							gembux -= 5000;
							ofstream myfile;
							myfile.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
							myfile << gembux;
							myfile.close();
							Player::OnSetBux(peer, gembux, 0);
							bool success = true;
							SaveItemMoreTimes(930, 1, peer, success);
							SaveItemMoreTimes(928, 1, peer, success);
							SaveItemMoreTimes(912, 1, peer, success);
							SaveItemMoreTimes(772, 1, peer, success);
							SaveItemMoreTimes(770, 1, peer, success);
							SaveItemMoreTimes(904, 1, peer, success);
							SaveItemMoreTimes(916, 5, peer, success);
							SaveItemMoreTimes(914, 10, peer, success);
							SaveItemMoreTimes(924, 5, peer, success);
							SaveItemMoreTimes(920, 5, peer, success);
							SaveItemMoreTimes(918, 5, peer, success);
							Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `oMad Science Kit `wfor `$" + to_string(5000) + " `wGems.\nYou have `$" + to_string(gembux) + " `wGems left.\n\n`5Received:`` Death Ray`&,`` Science Station`$,`` Laboratory`$,`` LabCoat`$,`` Combover Hair`$,`` Goggles`$,`` 5 Chemical R`$,`` 10 Chemical G`$,`` 5 Chemical Y`$,`` 5 Chemical B`$,`` 5 Chemical P\n"));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						else {
							Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `oMad Science Kit``!  You're `$" + to_string(5000 - gembux) + "`` Gems short."));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
					}

					if (cch.find("action|buy\nitem|fishin_pack") == 0) {
						ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
						string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
						auto gembux = atoi(content.c_str());
						if (gembux >= 6000) {
							if (CheckItemMaxed(peer, 3044, 1) || CheckItemMaxed(peer, 2914, 5) || CheckItemMaxed(peer, 5522, 1) || CheckItemMaxed(peer, 5524, 1) || CheckItemMaxed(peer, 2912, 1) || CheckItemMaxed(peer, 3004, 10) || CheckItemMaxed(peer, 3002, 1) || CheckItemMaxed(peer, 822, 5) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 8 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize) {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
								continue;
							}
							gembux -= 6000;
							ofstream myfile;
							myfile.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
							myfile << gembux;
							myfile.close();
							Player::OnSetBux(peer, gembux, 0);
							bool success = true;
							SaveItemMoreTimes(3044, 1, peer, success);
							SaveItemMoreTimes(2914, 5, peer, success);
							SaveItemMoreTimes(5522, 1, peer, success);
							SaveItemMoreTimes(5524, 1, peer, success);
							SaveItemMoreTimes(2912, 1, peer, success);
							SaveItemMoreTimes(3004, 10, peer, success);
							SaveItemMoreTimes(3002, 1, peer, success);
							SaveItemMoreTimes(822, 5, peer, success);
							Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `oFishin' Pack `wfor `$" + to_string(6000) + " `wGems.\nYou have `$" + to_string(gembux) + " `wGems left.\n\n`5Received:`` Tackle Box`$,`` 5 Wiggly Worms`$,`` Hand Drill`$,`` Nuclear Detonator`$,`` Fishing Rod`$,`` 10 Fish Tanks`$,`` Fish Tank Port`$,`` 5 Water Buckets\n"));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						else {
							Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `oFishin' Pack``!  You're `$" + to_string(6000 - gembux) + "`` Gems short."));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
					}
					if (cch.find("action|buy\nitem|firefighter") == 0) {
						ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
						string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
						auto gembux = atoi(content.c_str());
						if (gembux >= 3600) {
							if (CheckItemMaxed(peer, 3048, 1) || CheckItemMaxed(peer, 3056, 1) || CheckItemMaxed(peer, 3060, 1) || CheckItemMaxed(peer, 3052, 1) || CheckItemMaxed(peer, 3066, 1) || CheckItemMaxed(peer, 3072, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 6 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize) {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
								continue;
							}
							gembux -= 3600;
							ofstream myfile;
							myfile.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
							myfile << gembux;
							myfile.close();
							Player::OnSetBux(peer, gembux, 0);
							bool success = true;
							SaveItemMoreTimes(3048, 1, peer, success);
							SaveItemMoreTimes(3056, 1, peer, success);
							SaveItemMoreTimes(3060, 1, peer, success);
							SaveItemMoreTimes(3052, 1, peer, success);
							SaveItemMoreTimes(3066, 1, peer, success);
							SaveItemMoreTimes(3072, 1, peer, success);
							Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `oFirefighter Pack `wfor `$" + to_string(3600) + " `wGems.\nYou have `$" + to_string(gembux) + " `wGems left.\n\n`5Received:`` Firefighter Helmet - Yellow`$,`` Firefighter Pants - Yellow`$,`` Firefighter Jacket - Yellow`$,`` Firefighter Boots`$,`` Fire Hose`$,`` Firehouse\n"));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						else {
							Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `oFirefighter Pack``!  You're `$" + to_string(3600 - gembux) + "`` Gems short."));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
					}
					if (cch.find("action|buy\nitem|paleo_kit") == 0) {
						ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
						string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
						auto gembux = atoi(content.c_str());
						if (gembux >= 7500) {
							if (CheckItemMaxed(peer, 4132, 5) || CheckItemMaxed(peer, 3932, 1) || CheckItemMaxed(peer, 3934, 1) || CheckItemMaxed(peer, 3938, 1) || CheckItemMaxed(peer, 4128, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 5 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize) {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
								continue;
							}
							gembux -= 7500;
							ofstream myfile;
							myfile.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
							myfile << gembux;
							myfile.close();
							Player::OnSetBux(peer, gembux, 0);
							bool success = true;
							SaveItemMoreTimes(4132, 5, peer, success);
							SaveItemMoreTimes(3932, 1, peer, success);
							SaveItemMoreTimes(3934, 1, peer, success);
							SaveItemMoreTimes(3938, 1, peer, success);
							SaveItemMoreTimes(4128, 1, peer, success);
							Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `oPaleontologist's Kit `wfor `$" + to_string(7500) + " `wGems.\nYou have `$" + to_string(gembux) + " `wGems left.\n\n`5Received:`` Fossil Prep Station`$,`` 5 Fossil Brushes`$,`` Rock Hammer`$,`` Rock Chisel`$,`` Blue Hardhat\n"));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						else {
							Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `oPaleontologist's Kit``!  You're `$" + to_string(7500 - gembux) + "`` Gems short."));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
					}

					if (cch.find("action|buy\nitem|upgradebp") == 0) {
						bool success = true;
						std::ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
						std::string content((std::istreambuf_iterator<char>(ifsz)),
							(std::istreambuf_iterator<char>()));
						int b = atoi(content.c_str());
						if (b >= 1000)
						{
							string text = "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0\n";
							BYTE* data = new BYTE[5 + text.length()];
							BYTE zero = 0;
							int type = 3;
							memcpy(data, &type, 4);
							memcpy(data + 4, text.c_str(), text.length()); // change memcpy here
							memcpy(data + 4 + text.length(), &zero, 1); // change memcpy here, revert to 4
							ENetPacket* packetsou = enet_packet_create(data,
								5 + text.length(),
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packetsou);
							int gemcalc10k = b - 1000;
							ofstream myfile2;
							myfile2.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
							myfile2 << std::to_string(gemcalc10k);
							myfile2.close();
							std::ifstream ifszi("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
							std::string contentx((std::istreambuf_iterator<char>(ifszi)),
								(std::istreambuf_iterator<char>()));
							int updgem = atoi(contentx.c_str());
							GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), updgem));
							ENetPacket* packetpp = enet_packet_create(pp.data,
								pp.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packetpp);
							delete pp.data;


							bool success = true;
							short nextSpace = 0;
							if (static_cast<PlayerInfo*>(peer->data)->currentInventorySize + 30 > 200)
							{
								nextSpace = 200;
							}
							else
							{
								nextSpace = static_cast<PlayerInfo*>(peer->data)->currentInventorySize + 30;
							}

							ifstream fg("players/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".json");
							json j;
							fg >> j;
							fg.close();

							j["inventorysize"] = nextSpace;

							ofstream fs("players/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".json");
							fs << j;
							fs.close();
							if (success)
							{
								RemoveInventoryItem(242, 30, peer, true);
								OnStorePurchaseResults(peer, "`2You upgraded your inventory to `5" + to_string(nextSpace) + " `2Spaces!");
								static_cast<PlayerInfo*>(peer->data)->currentInventorySize += 30;
								SendInventory(peer, static_cast<PlayerInfo*>(peer->data)->inventory);
								const auto p3 = packetEnd(appendFloat(appendIntx(appendFloat(appendFloat(appendFloat(appendString(createPacket(), "OnSetClothing"), (static_cast<PlayerInfo*>(peer->data))->cloth_hair, (static_cast<PlayerInfo*>(peer->data))->cloth_shirt, (static_cast<PlayerInfo*>(peer->data))->cloth_pants), (static_cast<PlayerInfo*>(peer->data))->cloth_feet, (static_cast<PlayerInfo*>(peer->data))->cloth_face, (static_cast<PlayerInfo*>(peer->data))->cloth_hand), (static_cast<PlayerInfo*>(peer->data))->cloth_back, (static_cast<PlayerInfo*>(peer->data))->cloth_mask, (static_cast<PlayerInfo*>(peer->data))->cloth_necklace), (static_cast<PlayerInfo*>(peer->data))->skinColor), (static_cast<PlayerInfo*>(peer->data))->cloth_ances, 0.0f, 0.0f));
								memcpy(p3.data + 8, &((static_cast<PlayerInfo*>(peer->data))->netID), 4);
								const auto packet = enet_packet_create(p3.data, p3.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);



								sendSound(peer, "cash_register.wav");
							}
							else {
								OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Gems To Buy This Item. `5Try again later.");
							}
						}
					}
					if (cch.find("action|buy\nitem|paintbrush") == 0) {
						ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
						string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
						auto gembux = atoi(content.c_str());
						if (gembux >= 30000) {
							if (CheckItemMaxed(peer, 3494, 1) || CheckItemMaxed(peer, 3478, 5) || CheckItemMaxed(peer, 3480, 5) || CheckItemMaxed(peer, 3482, 5) || CheckItemMaxed(peer, 3484, 5) || CheckItemMaxed(peer, 3486, 5) || CheckItemMaxed(peer, 3488, 5) || CheckItemMaxed(peer, 3490, 5) || CheckItemMaxed(peer, 3492, 5) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 9 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize) {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
								continue;
							}
							gembux -= 30000;
							ofstream myfile;
							myfile.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
							myfile << gembux;
							myfile.close();
							Player::OnSetBux(peer, gembux, 0);
							bool success = true;
							SaveItemMoreTimes(3494, 1, peer, success);
							SaveItemMoreTimes(3478, 5, peer, success);
							SaveItemMoreTimes(3480, 5, peer, success);
							SaveItemMoreTimes(3482, 5, peer, success);
							SaveItemMoreTimes(3484, 5, peer, success);
							SaveItemMoreTimes(3486, 5, peer, success);
							SaveItemMoreTimes(3488, 5, peer, success);
							SaveItemMoreTimes(3490, 5, peer, success);
							SaveItemMoreTimes(3492, 5, peer, success);
							Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `oPainter's Pack `wfor `$" + to_string(30000) + " `wGems.\nYou have `$" + to_string(gembux) + " `wGems left.\n\n`5Received: ``Paintbrush`$,`` 5 Paint Bucket - Yellow`$,`` 5 Paint Bucket - Green`$,`` 5 Paint Bucket - Blue`$,`` 5 Paint Bucket - Varnish`$,`` 5 Paint Bucket - Red`$,`` 5 Paint Bucket - Charcoal`$,`` 5 Paint Bucket - Purple`$,`` 5 Paint Bucket - Aqua\n"));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						else {
							Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `oPainter's Pack``!  You're `$" + to_string(30000 - gembux) + "`` Gems short."));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
					}
					if ((cch.find("action|storenavigate") == 0) && static_cast<PlayerInfo*>(peer->data)->haveGrowId)
					{
						short nextSpace = 0;
						if (static_cast<PlayerInfo*>(peer->data)->currentInventorySize + 30 > 200)
						{
							nextSpace = 200;
						}
						else
						{
							nextSpace = static_cast<PlayerInfo*>(peer->data)->currentInventorySize + 30;
						}
						if (static_cast<PlayerInfo*>(peer->data)->currentInventorySize >= 200)
						{
							Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`2Purchase `8Inventory Upgrade`2!``|left|6204|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`4Your inventory spaces are full upgraded!|0|0|\nadd_spacer|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|");
						}
						else
						{
							Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`2Purchase `8Inventory Upgrade`2!``|left|6204|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`oYour inventory space is`8 " + to_string(static_cast<PlayerInfo*>(peer->data)->currentInventorySize) + " `onow.|\nadd_label|small|\nadd_textbox|`9After purchasing an inventory upgrade, your inventory will have`2 " + to_string(nextSpace) + "`9 spaces.|left|8|\nadd_spacer|small|\nadd_button|buyinvupgrade|`9Purchase `7[`430`2 WLS`7]!|0|0|\nadd_spacer|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|");
						}
					}
					if (cch.find("action|info") == 0)
					{
						std::stringstream ss(cch);
						std::string to;
						int id = -1;
						int count = -1;
						while (std::getline(ss, to, '\n'))
						{
							vector<string> infoDat = explode("|", to);
							if (infoDat.size() == 3)
							{
								if (infoDat[1] == "itemID") id = atoi(infoDat[2].c_str());
								if (infoDat[1] == "count") count = atoi(infoDat[2].c_str());
							}
						}
						if (id == -1 || count == -1) continue;
						if (itemDefs.size() < id || id < 0) continue;
						string properties = "\nadd_textbox|";
						ItemDefinition itemDef = getItemDef(id);
						if (itemDef.properties & Property_Untradable)
							properties += "<CR>`1This item cannot be dropped or traded.`` ";
						if (itemDef.properties & Property_Wrenchable)
							properties += "<CR>`1This item has special properties you can adjust with the Wrench.`` ";
						if (itemDef.properties & Property_NoSeed)
							properties += "<CR>`1This item never drops any seeds.`` ";
						if (itemDef.properties & Property_Permanent)
							properties += "<CR>`1This item can't be destroyed - smashing it will return it to your backpack if you have room!`` ";

						string history = "\nadd_textbox|<CR>`1Item History";
						for (auto i = 0; i < static_cast<PlayerInfo*>(peer->data)->inventory.items.size(); i++)
						{
							if (static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemID == id)
							{
								break;
							}
						}

						if (history != "\nadd_textbox|<CR>`1Item History") history += "|left|";

						else history = "";
						if (properties != "\nadd_textbox|") properties += "|left|";
						else properties = "";

						Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_ele_icon|big|`wAbout " + itemDef.name + "``|left|" + std::to_string(id) + "|3|\nadd_spacer|small|\nadd_textbox|" + itemDef.description + "|left|" + properties + "|" + history + "\nend_dialog|continue||OK|");
					}
					if (cch.find("action|dialog_return") == 0)
					{
						if (static_cast<PlayerInfo*>(peer->data)->isIn == false)
						{
							break;
						}
						std::stringstream ss(cch);
						std::string to;
						bool isGuildDialog = false;
						bool isGrowscan = false;
						string gguildname;
						string gguildstatement;
						string addItemToStore = "";
						string addItemToDonationBox = "";
						string gguildflagbg;
						string gguildflagfg;
						string stuffitem = "";
						string magplantitem = "";
						string worldname3 = "";
						string worldheight3 = "";
						string worldwidth3 = "";
						string worldforeground3 = "";
						string emeraldbfg = "";
						string worldbackground3 = "";
						string worldbedrock3 = "";
						string minimum_level = "";
						string gravitystr = "";
						string btn = "";
						bool isRegisterDialog = false;
						string username = "";
						string restrictedname = "";
						string password = "";
						string passwordver = "";
						string password2 = "";
						string email = "";
						string code = "";
						string passwords = "";
						string passwordss = "";
						string password2verify = "";
						string oldpass = "";
						string netid = "";
						string pin = "";
						string text = "";
						bool isepoch = false;
						bool ice = false;
						bool vol = false;
						bool land = false;

						bool isBuyItemByRarityDialog = false;
						bool isDropDialog = false;
						bool isTrashDialog = false;
						bool isStuffDialog = false;
						bool isMagDialog = false;
						bool isAutoPlaceDialog = false;
						bool isBfgDialog = false;
						bool isLockDialog = false;
						bool isEntranceDialog = false;
						bool isTradeDialogs = false;
						bool isTradeDialog = false;
						bool isTradingDialog = false;
						string tradeitemcount = "";
						bool MagUpdateDialog = false;
						bool isGenDialog = false;
						bool isUranusDialog = false;
						bool isTeleDialog = false;
						string dropitemcount = "";
						string trashitemcount = "";
						bool isPasswordDialog = false;
						bool isFindDialog = false;
						bool isEditDoorDialog = false;
						string destworld = "", destid = "", label = "", currid = "";
						bool isCreateStoreDialog = false;
						bool isWorldTradeDialog = false;
						string entranceresult = "";
						bool isWorldLockBuyDialog = false;
						bool isDarkStoneBuyDialog = false;
						bool isDiamondLockBuyDialog = false;
						bool signEditor = false;
						string item1count = "";
						string item2count = "";
						string muted = "";
						string publicremote = "";
						string item3count = "";
						string telefonas = "";
						string item4count = "";
						string storelinkname = "";
						string playerNetId = "";
						string uranusnames = "";
						string itemFind = "";
						string warntext = "";
						string strBuyOffer = "";
						string strBuyWorldLockOffer = "";
						string reqBuyDarkStoneOffer = "";
						string strBuyDiamondLockOffer = "";
						string message321 = "";
						string strResult = "";
						string strButItemByRarityCount = "";
						int buyOffer;
						string createstorefg = "";
						string createstorename = "";
						string createstoredesc = "";
						string storeItemPickerCount = "";
						string storeItemId = "";
						string storeItemDescription = "";
						string storeItemSellForItem = "";
						string storeItemSellPer = "";
						string storeWriteReviewShopName = "";
						string storeWriteReview = "";
						string storeWriteReviewStar = "";
						string buyPlayerStoreAposition = "";
						string buyPlayerStoreName = "";
						string buyPlayerStoreQuantity = "";
						string givedonationboxitemCount = "";
						string boxlvl1AddItemDialog = "";
						string boxlvl2AddItemDialog = "";
						string boxlvl3AddItemDialog = "";
						string SafeAddItemDialog = "";
						string MyTradeItem = "";
						string safedepositcount = "";
						string safedepositcoord = "";
						string safedeposititemID = "";
						int givesafeitemItemIDInt = 0;
						bool isMyTradeDialog = false;
						bool isMergeDialog = false;
						int givesafeitemCountInt = 0;
						string safe_withdrawConfirmCount = "";
						int safe_withdrawConfirmCountInt = 0;
						string safe_withdrawConfirmApos = "";
						int safe_withdrawConfirmAposInt = 0;
						string safe_withdrawConfirmCoord = "";
						int givedonationboxitemCountInt = 0;
						string givedonationboxitemCoord = "";
						string givedonationboxitemItemID = "";
						int givedonationboxitemItemIDInt = 0;
						bool checkCodeDialog = false;
						string checkCodeText = "";
						bool changeCodeDialog = false;
						string changeCodeText = "";
						string givedonationboxitem = "";
						string givedonationboxitemNote = "";
						bool isstoreReviewConfirmDialog = false;
						bool isaddItemStoreOnSaleDialog = false;
						bool isbuyPlayerStoreItemDialog = false;
						bool isaddItemToStoreDialog = false;
						bool isgivedonationboxitemConfirm = false;
						bool isaddItemToDonationBox = false;
						bool isboxlvl1AddItemDialog = false;
						bool isboxlvl2AddItemDialog = false;
						bool isboxlvl3AddItemDialog = false;
						bool isSafeAddItemDialog = false;
						bool issafedepositconfirmDialog = false;
						bool issafewithdrawConfirmDialog = false;
						//rift cape
						bool riftcape = false;
						string checkbox_auraonoff = "";

						string checkbox_portalaura = "";
						string checkbox_starfieldaura = "";
						string checkbox_electricalaura = "";


						/*Notebook*/
						bool notebook_edit = false;
						/*title*/
						bool title_save = false;
						string title_name = "";
						string personal_note = "";
						/*vend*/
						bool vending = false;
						int setprice = 0;
						int setprices = 0;
						int chk_peritem = 0;
						int chk_perlock = 0;
						int stockitem = 0;
						int stockitems = 0;
						int buyprice = 0;

						bool ispaint = false;
						string pid = "";
						string psign = "";

						/*Surgery*/

						bool SurgeryDialog = false;

						/*SurgEnd*/

						while (std::getline(ss, to, '\n'))
						{
							vector<string> infoDat = explode("|", to);
							if (infoDat.size() == 2)
							{
								if (infoDat[0] == "buttonClicked") btn = infoDat[1];
								if (static_cast<PlayerInfo*>(peer->data)->haveGrowId == false && infoDat[0] == "dialog_name" && infoDat[1] != "register") break;
								if (static_cast<PlayerInfo*>(peer->data)->haveGrowId == false && btn != "") break;
								if (infoDat[0] == "dialog_name" && infoDat[1] == "vending")
								{
									vending = true;
								}
								if (infoDat[0] == "dialog_name" && infoDat[1] == "findid")
								{
									isFindDialog = true;
								}
								if (infoDat[0] == "dialog_name" && infoDat[1] == "autoplace") isAutoPlaceDialog = true;
								if (infoDat[0] == "dialog_name" && infoDat[1] == "givedonationboxitemConfirm")
								{
									isgivedonationboxitemConfirm = true;
								}
								if (infoDat[0] == "dialog_name" && infoDat[1] == "notebook_edit")
								{
									notebook_edit = true;
								}
								if (infoDat[0] == "dialog_name" && infoDat[1] == "epochweather")
									isepoch = true;
								if (isepoch) {
									if (infoDat[0] == "epochice") ice = atoi(infoDat[1].c_str());
									if (infoDat[0] == "epochvol") vol = atoi(infoDat[1].c_str());
									if (infoDat[0] == "epochland") land = atoi(infoDat[1].c_str());
								}
								if (infoDat[0] == "dialog_name" && infoDat[1] == "riftcape")
								{
									riftcape = true;
								}
								if (infoDat[0] == "dialog_name" && infoDat[1] == "reqoffer")
								{
									isTradeDialog = true;
								}
								if (infoDat[0] == "dialog_name" && infoDat[1] == "title_save")
								{
									title_save = true;
								}
								if (infoDat[0] == "dialog_name" && infoDat[1] == "painting")
									ispaint = true;
								if (infoDat[0] == "dialog_name" && infoDat[1] == "entrance")
								{
									isEntranceDialog = true;
								}
								if (infoDat[0] == "dialog_name" && infoDat[1] == "editsign")
								{
									signEditor = true;
								}
								if (infoDat[0] == "dialog_name" && infoDat[1] == "lock_edit")
								{
									isLockDialog = true;
								}
								if (infoDat[0] == "dialog_name" && infoDat[1] == "magplantupdate")
								{
									MagUpdateDialog = true;
								}
								if (infoDat[0] == "dialog_name" && infoDat[1] == "tradingdialog")
								{
									isTradingDialog = true;
								}
								if (infoDat[0] == "dialog_name" && infoDat[1] == "trade_item")
								{
									isTradeDialogs = true;
								}
								if (isTradeDialogs) {

									if (infoDat[0] == "trditemcount") tradeitemcount = infoDat[1];
								}
								
									if (btn == "instructions")
									{
										//Player::OnConsoleMessage(peer, "`oResetted to default!");
										//Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`oResetted to default!", 0, true);
										Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`oInstruction``|left|10424|\nadd_spacer|small|\nadd_textbox|`oUse RGB for setting a color (RED, GREEN, BLUE), portal aura for effect like portal, electrical aura for effect like electric.|0|0|\nadd_quick_exit|\n\nend_dialog|gazette|`oClose||");
									}
									if (btn == "editriftcape")
									{
										string starfield = "0";
										string portal = "0";
										string electrical = "0";
										string auraonoff = "0";
										string capecollar = "0";
										//RGB  mtherfker
										auto Rnumber = 0;
										ifstream rnumber("riftcape/RGBsettings/R/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										rnumber >> Rnumber;
										rnumber.close();
										auto Gnumber = 0;
										ifstream gnumber("riftcape/RGBsettings/G/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										gnumber >> Gnumber;
										gnumber.close();
										auto Bnumber = 0;
										ifstream bnumber("riftcape/RGBsettings/B/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										bnumber >> Bnumber;
										bnumber.close();

										//RGB 2 mtherfker
										auto R2number = 0;
										ifstream r2number("riftcape/RGBsettings/R2/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										r2number >> R2number;
										r2number.close();
										auto G2number = 0;
										ifstream g2number("riftcape/RGBsettings/G2/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										g2number >> G2number;
										g2number.close();
										auto B2number = 0;
										ifstream b2number("riftcape/RGBsettings2/B2/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										b2number >> B2number;
										b2number.close();

										//collar  mtherfker
										auto Rcollar = 0;
										ifstream rcollar("riftcape/collarsettings/collarR/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										rcollar >> Rcollar;
										rcollar.close();
										auto Gcollar = 0;
										ifstream gcollar("riftcape/collarsettings/collarG/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										gcollar >> Gcollar;
										gcollar.close();
										auto Bcollar = 0;
										ifstream bcollar("riftcape/collarsettings/collarB/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										bcollar >> Bcollar;
										bcollar.close();

										//collar 2 mtherfker
										auto R2collar = 0;
										ifstream r2collar("riftcape/collarsettings2/collarR2/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										r2collar >> R2collar;
										r2collar.close();
										auto G2collar = 0;
										ifstream g2collar("riftcape/collarsettings2/collarG2/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										g2collar >> G2collar;
										g2collar.close();
										auto B2collar = 0;
										ifstream b2collar("riftcape/collarsettings2/collarB2/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										b2collar >> B2collar;
										b2collar.close();

										//starfieldaura checker
										auto starfieldcheck = 0;
										ifstream starfieldchecker("riftcape/starfieldaura/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										starfieldchecker >> starfieldcheck;
										starfieldchecker.close();

										//portalaura checker
										auto portalcheck = 0;
										ifstream portalchecker("riftcape/portalaura/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										portalchecker >> portalcheck;
										portalchecker.close();

										//electricalaura checker
										auto electricalcheck = 0;
										ifstream electricalchecker("riftcape/electricalaura/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										electricalchecker >> electricalcheck;
										electricalchecker.close();

										//checker if aura is on or off
										auto auracheck = 0;
										ifstream aurachecker("riftcape/auraonoff/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										aurachecker >> auracheck;
										aurachecker.close();

										//checker if collar is on or off
										auto collarcheck = 0;
										ifstream collarchecker("riftcape/capecollar/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										collarchecker >> collarcheck;
										collarchecker.close();

										//checker if closed cape is on or off
										auto closedcheck = 0;
										ifstream closedchecker("riftcape/closedcape/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										closedchecker >> closedcheck;
										closedchecker.close();

										//checker if time dilation is on or off
										auto timecheck = 0;
										ifstream timechecker("riftcape/timedilationcheckbox/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										timechecker >> timecheck;
										timechecker.close();

										//checker if open cape movement is on or off
										auto opencheck = 0;
										ifstream openchecker("riftcape/opencapemovement/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										openchecker >> opencheck;
										openchecker.close();



										//rgb numbers
										string R = to_string(Rnumber) + ",";
										string G = to_string(Gnumber) + ",";
										string B = to_string(Bnumber);
										//rgb collars
										string collarR = to_string(Rcollar) + ",";
										string collarG = to_string(Gcollar) + ",";
										string collarB = to_string(Bcollar);
										//rgb numbers 2
										string R2 = to_string(R2number) + ",";
										string G2 = to_string(G2number) + ",";
										string B2 = to_string(B2number);
										//rgb collars 2
										string collarR2 = to_string(R2collar) + ",";
										string collarG2 = to_string(G2collar) + ",";
										string collarB2 = to_string(B2collar);

										//this is for saving checkboxes
										if (starfieldcheck == 1)
										{
											starfield = "1";
										}
										else
										{
											starfield = "0";
										}

										if (portalcheck == 1)
										{
											portal = "1";
										}
										else
										{
											portal = "0";
										}

										if (electricalcheck == 1)
										{
											electrical = "1";
										}
										else
										{
											electrical = "0";
										}

										if (auracheck == 1)
										{
											auraonoff = "1";
										}
										else
										{
											auraonoff = "0";
										}

										if (collarcheck == 1)
										{
											capecollar = "1";
										}
										else
										{
											capecollar = "0";
										}

										if (timecheck == 1)
										{
											Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wRift Cape|left|10424|\nadd_spacer|small|\nadd_text_input|timedilation|Time Dilation Cycle Time:|" + to_string(timecheck) + "|6|\nadd_checkbox|checkbox_timedilation|Time Dilation On / Off|1|\nadd_button|instructions|Instructions|\nadd_spacer|small|\nadd_label|big|Cape Style 1|\nadd_spacer|small|\nadd_textbox|Cape Color:|left|\nadd_text_input|capergb|Cape - R,G,B:|" + R + G + B + "|12|\nadd_spacer|small|\nadd_checkbox|checkbox_capecollar|Cape Collar On / Off|" + capecollar + "|\nadd_textbox|Cape Collar Color:|\nadd_text_input|collarrgb|Collar - R,G,B:|" + collarR + collarG + collarB + "|12|\nadd_spacer|small|\nadd_checkbox|checkbox_closedcape|Closed Cape|" + to_string(closedcheck) + "\nadd_checkbox|checkbox_opencapemovement|Open Cape on Movement|" + to_string(opencheck) + "|\nadd_checkbox|checkbox_auraonoff|Aura On / Off|" + auraonoff + "\nadd_checkbox|checkbox_portalaura|Portal Aura|" + portal + "\nadd_checkbox|checkbox_starfieldaura|Starfield Aura|" + starfield + "\nadd_checkbox|checkbox_electricalaura|Electrical Aura|" + electrical + "\nadd_button|restoretodefault|Restore to Default|\nend_dialog|riftcape|Close|`wUpdate|\nadd_quick_exit|\n");
											//\nadd_label|big|Cape Style 2|\nadd_spacer|small|\nadd_textbox|Cape Color:|\nadd_text_input|capergb2|Cape - R,G,B:|" + R2 + G2 + B2 + "|12|\nadd_spacer|small|\nadd_checkbox|checkbox_capecollar|Cape Collar On / Off|1\nadd_textbox|Cape Collar Color:|\nadd_text_input|collarrgb2|Collar - R,G,B:|" + collarR2 + collarG2 + collarB2 + "|12|\nadd_spacer|small|\nadd_checkbox|checkbox_closedcape|Closed Cape|0\nadd_checkbox|checkbox_opencapemovement|Open Cape on Movement|1\nadd_checkbox|checkbox_auraonoff|Aura On / Off|1\nadd_checkbox|checkbox_portalaura|Portal Aura|0\nadd_checkbox|checkbox_starfieldaura|Starfield Aura|"+to_string(static_cast<PlayerInfo*>(peer->data)->checkbox_starfieldaura)+"\nadd_checkbox|checkbox_electricalaura|Electrical Aura|0\nadd_button|restoretodefault|Restore to Default|\nend_dialog|riftcape|Close|`wUpdate|\nadd_quick_exit|\n");
											//dialog soon
										}
										else
										{
											Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wRift Cape|left|10424|\nadd_spacer|small|\nadd_text_input|timedilation|Time Dilation Cycle Time:|" + to_string(timecheck) + "|6|\nadd_checkbox|checkbox_timedilation|Time Dilation On / Off|0|\nadd_button|instructions|Instructions|\nadd_spacer|small|\nadd_label|big|Cape Style 1|\nadd_spacer|small|\nadd_textbox|Cape Color:|left|\nadd_text_input|capergb|Cape - R,G,B:|" + R + G + B + "|12|\nadd_spacer|small|\nadd_checkbox|checkbox_capecollar|Cape Collar On / Off|" + capecollar + "|\nadd_textbox|Cape Collar Color:|\nadd_text_input|collarrgb|Collar - R,G,B:|" + collarR + collarG + collarB + "|12|\nadd_spacer|small|\nadd_checkbox|checkbox_closedcape|Closed Cape|" + to_string(closedcheck) + "\nadd_checkbox|checkbox_opencapemovement|Open Cape on Movement|" + to_string(opencheck) + "|\nadd_checkbox|checkbox_auraonoff|Aura On / Off|" + auraonoff + "\nadd_checkbox|checkbox_portalaura|Portal Aura|" + portal + "\nadd_checkbox|checkbox_starfieldaura|Starfield Aura|" + starfield + "\nadd_checkbox|checkbox_electricalaura|Electrical Aura|" + electrical + "\nadd_button|restoretodefault|Restore to Default|\nend_dialog|riftcape|Close|`wUpdate|\nadd_quick_exit|\n");
											//\nadd_label|big|Cape Style 2|\nadd_spacer|small|\nadd_textbox|Cape Color:|\nadd_text_input|capergb2|Cape - R,G,B:|" + R2 + G2+ B2 + "|12|\nadd_spacer|small|\nadd_checkbox|checkbox_capecollar|Cape Collar On / Off|1\nadd_textbox|Cape Collar Color:|\nadd_text_input|collarrgb2|Collar - R,G,B:|" + collarR2 + collarG2 + collarB2 + "|12|\nadd_spacer|small|\nadd_checkbox|checkbox_closedcape|Closed Cape|0\nadd_checkbox|checkbox_opencapemovement|Open Cape on Movement|1\nadd_checkbox|checkbox_auraonoff|Aura On / Off|1\nadd_checkbox|checkbox_portalaura|Portal Aura|0\nadd_checkbox|checkbox_starfieldaura|Starfield Aura|"+to_string(static_cast<PlayerInfo*>(peer->data)->checkbox_electricalaura)+"\nadd_checkbox|checkbox_electricalaura|Electrical Aura|0\nadd_button|restoretodefault|Restore to Default|\nend_dialog|riftcape|Close|`wUpdate|\nadd_quick_exit|\n");
											//dialog soon
										}
									}
									if (riftcape) {
										if (infoDat[0] == "checkbox_capecollar") {
											if (infoDat[1] == "1")
											{
												ofstream capecollar("riftcape/capecollar/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
												capecollar << 1;
												capecollar.close();

											}
											else
											{
												ofstream capecollar("riftcape/capecollar/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
												capecollar << 0;
												capecollar.close();
											}
										}
										if (infoDat[0] == "checkbox_timedilation") {
											if (infoDat[1] == "1")
											{

												ofstream capetimes("riftcape/timedilationcheckbox/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
												capetimes << 1;
												capetimes.close();
											}
											else
											{

												ofstream capecollar("riftcape/timedilationcheckbox/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
												capecollar << 0;
												capecollar.close();
											}
										}
										/*if (infoDat[0] == "checkbox_closedcape") {
											if (infoDat[1] == "1")
											{
												static_cast<PlayerInfo*>(peer->data)->checkbox_closedcape = 1;
											}
											else
											{
												static_cast<PlayerInfo*>(peer->data)->checkbox_closedcape = 0;
											}
										}
										/*if (infoDat[0] == "checkbox_opencapemovement") {
											if (infoDat[1] == "1")
											{
												static_cast<PlayerInfo*>(peer->data)->checkbox_opencapemovement = 1;
											}
											else
											{
												static_cast<PlayerInfo*>(peer->data)->checkbox_opencapemovement = 0;
											}
										}*/
										if (infoDat[0] == "checkbox_auraonoff") {
											checkbox_auraonoff = infoDat[1];
										}
										if (infoDat[0] == "checkbox_portalaura") {
											checkbox_portalaura = infoDat[1];
										}
										if (infoDat[0] == "checkbox_starfieldaura") {
											checkbox_starfieldaura = infoDat[1];
										}
										if (infoDat[0] == "checkbox_electricalaura") {
											if (checkbox_auraonoff == "1")
											{
												if (checkbox_portalaura == "1" && checkbox_starfieldaura == "1" && infoDat[1] == "1")
												{
													Player::OnConsoleMessage(peer, "You can't have it both ways.");
													Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "You can't have it both ways.", 0, true);
													break;
												}
												if (checkbox_portalaura == "1" && checkbox_starfieldaura == "1")
												{
													Player::OnConsoleMessage(peer, "You can't have it both ways.");
													Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "You can't have it both ways.", 0, true);
													break;
												}
												if (checkbox_portalaura == "1" && infoDat[1] == "1")
												{
													Player::OnConsoleMessage(peer, "You can't have it both ways.");
													Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "You can't have it both ways.", 0, true);
													break;
												}
												if (checkbox_starfieldaura == "1" && infoDat[1] == "1")
												{
													Player::OnConsoleMessage(peer, "You can't have it both ways.");
													Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "You can't have it both ways.", 0, true);
													break;
												}

												if (infoDat[1] == "1")
												{

													ofstream capeee("riftcape/electricalaura/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
													capeee << 1;
													capeee.close();
												}
												if (checkbox_starfieldaura == "1")
												{

													ofstream capess("riftcape/starfieldaura/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
													capess << 1;
													capess.close();
												}
												if (checkbox_portalaura == "1")
												{
													ofstream capepp("riftcape/portalaura/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
													capepp << 1;
													capepp.close();
												}

												if (infoDat[1] == "0")
												{
													ofstream capee("riftcape/electricalaura/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
													capee << 0;
													capee.close();
												}
												if (checkbox_starfieldaura == "0")
												{
													ofstream capes("riftcape/starfieldaura/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
													capes << 0;
													capes.close();
												}
												if (checkbox_portalaura == "0")
												{
													ofstream capep("riftcape/portalaura/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
													capep << 1;
													capep.close();
												}
											}
											else
											{
												if (checkbox_portalaura == "1" && checkbox_starfieldaura == "1" && infoDat[1] == "1")
												{
													Player::OnConsoleMessage(peer, "You can't have it both ways.");
													Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "You can't have it both ways.", 0, true);
													break;
												}
												if (checkbox_portalaura == "1" && checkbox_starfieldaura == "1")
												{
													Player::OnConsoleMessage(peer, "You can't have it both ways.");
													Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "You can't have it both ways.", 0, true);
													break;
												}
												if (checkbox_portalaura == "1" && infoDat[1] == "1")
												{
													Player::OnConsoleMessage(peer, "You can't have it both ways.");
													Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "You can't have it both ways.", 0, true);
													break;
												}
												if (checkbox_starfieldaura == "1" && infoDat[1] == "1")
												{
													Player::OnConsoleMessage(peer, "You can't have it both ways.");
													Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "You can't have it both ways.", 0, true);
													break;
												}

												if (infoDat[1] == "1")
												{
													Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wTurn off first the aura", 0, true);
													break;
												}
												if (checkbox_starfieldaura == "1")
												{
													Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wTurn off first the aura", 0, true);
													break;
												}
												if (checkbox_portalaura == "1")
												{
													Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wTurn off first the aura", 0, true);
													break;
												}
											}
										}
										if (infoDat[0] == "timedilation") {
											string settimedilation = infoDat[1];
											if (settimedilation.size() > 2 || settimedilation.size() <= 0 || settimedilation.size() < 1)
											{
												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wYou can't set Time Dilation > 30", 0, true);
												break;
											}
											if (settimedilation.find_first_not_of("0123456789") != string::npos)
											{
												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wYou can't set Time Dilation with non digits", 0, true);
												break;
											}
											if (stoi(settimedilation) < 0)
											{
												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wYou can't set Time Dilation < 0", 0, true);
												break;
											}
											if (settimedilation == "")
											{
												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wYou can't set Time Dilation < 0", 0, true);
												break;
											}

											ofstream capetime("riftcape/timedilation/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
											capetime << stoi(infoDat[1]);
											capetime.close();
										}
										if (infoDat[0] == "collarrgb") {
											string setcollarrgb = infoDat[1];
											if (setcollarrgb.size() > 11 || setcollarrgb.size() <= 0 || setcollarrgb.size() < 5)
											{
												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wYou can't set RGB > 255", 0, true);
												break;
											}
											if (setcollarrgb.find_first_not_of("0123456789,") != string::npos)
											{
												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wYou can't set RGB non digits", 0, true);
												break;
											}
											vector<string> gay = explode(",", infoDat[1]); // more good & faster
											int R2 = atoi(gay[0].c_str());
											int G2 = atoi(gay[1].c_str());
											int B2 = atoi(gay[2].c_str()); //helped by kipas and samuel
											int A2 = 255;

											//RGB  mtherfker
											auto Rnumber = 0;
											ifstream rnumber("riftcape/RGBsettings/R/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
											rnumber >> Rnumber;

											auto Gnumber = 0;
											ifstream gnumber("riftcape/RGBsettings/G/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
											gnumber >> Gnumber;

											auto Bnumber = 0;
											ifstream bnumber("riftcape/RGBsettings/B/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
											bnumber >> Bnumber;


											//collar  mtherfker

											ofstream rcollar("riftcape/collarsettings/collarR/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
											rcollar << Rnumber;
											rcollar.close();

											ofstream gcollar("riftcape/collarsettings/collarG/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
											gcollar << Gnumber;
											gcollar.close();

											ofstream bcollar("riftcape/collarsettings/collarB/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
											bcollar << Bnumber;
											bcollar.close();
											bnumber.close();
											gnumber.close();
											rnumber.close();
											//cout << R << endl;	

											if (R2 < 0 || G2 < 0 || B2 < 0) {
												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wYou can't set RGB > from 255", 0, true);
												break;
											}
											if (R2 > 255 || G2 > 255 || B2 > 255) {
												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wYou can't set RGB > from 255", 0, true);
												break;
											}
										}
										if (infoDat[0] == "collarrgb2") {
											string setcollarrgb = infoDat[1];
											if (setcollarrgb.size() > 11 || setcollarrgb.size() <= 0 || setcollarrgb.size() < 5)
											{
												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wYou can't set RGB > 255", 0, true);
												break;
											}
											if (setcollarrgb.find_first_not_of("0123456789,") != string::npos)
											{
												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wYou can't set RGB non digits", 0, true);
												break;
											}
											vector<string> gay = explode(",", infoDat[1]); // more good & faster
											int R2 = atoi(gay[0].c_str());
											int G2 = atoi(gay[1].c_str());
											int B2 = atoi(gay[2].c_str()); //helped by kipas and samuel
											int A2 = 255;

											ofstream rcollar2("riftcape/collarsettings2/collarR2/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
											rcollar2 << atoi(gay[0].c_str());
											rcollar2.close();

											ofstream gcollar2("riftcape/collarsettings2/collarG2/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
											gcollar2 << atoi(gay[1].c_str());
											gcollar2.close();

											ofstream bcollar2("riftcape/collarsettings2/collarB2/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
											bcollar2 << atoi(gay[2].c_str());
											bcollar2.close();
											//cout << R << endl;	

											if (R2 < 0 || G2 < 0 || B2 < 0) {
												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wYou can't set RGB > from 255", 0, true);
												break;
											}
											if (R2 > 255 || G2 > 255 || B2 > 255) {
												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wYou can't set RGB > from 255", 0, true);
												break;
											}
										}
										if (infoDat[0] == "capergb2") {
											string setcapergb = infoDat[1];
											if (setcapergb.size() > 11 || setcapergb.size() <= 0 || setcapergb.size() < 5)
											{
												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wYou can't set RGB > 255", 0, true);
												break;
											}
											if (setcapergb.find_first_not_of("0123456789,") != string::npos)
											{
												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wYou can't set RGB non digits", 0, true);
												break;
											}
											vector<string> gay = explode(",", infoDat[1]); // more good & faster
											int R = atoi(gay[0].c_str());
											int G = atoi(gay[1].c_str());
											int B = atoi(gay[2].c_str()); //helped by kipas and samuel
											int A = 255;

											ofstream rcape2("riftcape/RGBsettings2/R2/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
											rcape2 << atoi(gay[0].c_str());
											rcape2.close();

											ofstream gcollar2("riftcape/RGBsettings2/G2/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
											gcollar2 << atoi(gay[1].c_str());
											gcollar2.close();

											ofstream bcape2("riftcape/RGBsettings2/B2/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
											bcape2 << atoi(gay[2].c_str());
											bcape2.close();
											//cout << R << endl;	

											if (R < 0 || G < 0 || B < 0) {
												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wYou can't set RGB > from 255", 0, true);
												break;
											}
											if (R > 255 || G > 255 || B > 255) {
												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wYou can't set RGB > from 255", 0, true);
												break;
											}
										}
										if (infoDat[0] == "capergb") {
											string setcapergb = infoDat[1];
											if (setcapergb.size() > 11 || setcapergb.size() <= 0 || setcapergb.size() < 5)
											{
												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wYou can't set RGB > 255", 0, true);
												break;
											}
											if (setcapergb.find_first_not_of("0123456789,") != string::npos)
											{
												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wYou can't set RGB non digits", 0, true);
												break;
											}
											vector<string> gay = explode(",", infoDat[1]); // more good & faster
											int R = atoi(gay[0].c_str());
											int G = atoi(gay[1].c_str());
											int B = atoi(gay[2].c_str()); //helped by kipas and samuel
											int A = 255;

											ofstream rcape("riftcape/RGBsettings/R/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
											rcape << atoi(gay[0].c_str());
											rcape.close();

											ofstream gcape("riftcape/RGBsettings/G/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
											gcape << atoi(gay[1].c_str());
											gcape.close();

											ofstream bcape("riftcape/RGBsettings/B/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
											bcape << atoi(gay[2].c_str());
											bcape.close();
											//cout << R << endl;	

											if (R < 0 || G < 0 || B < 0) {
												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wYou can't set RGB > from 255", 0, true);
												break;
											}
											if (R > 255 || G > 255 || B > 255) {
												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wYou can't set RGB > from 255", 0, true);
												break;
											}
										}

										int effect = 0;

										int collar = 0;
										int timedilation2 = 0;
										int A = 255;

										//checker if collar is on or off
										auto collarcheck = 0;
										ifstream collarchecker("riftcape/capecollar/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										collarchecker >> collarcheck;
										collarchecker.close();

										//checker if time dilation is on or off
										auto timecheck = 0;
										ifstream timechecker("riftcape/timedilationcheckbox/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										timechecker >> timecheck;
										timechecker.close();

										//RGB  mtherfker
										auto Rnumber = 0;
										ifstream rnumber("riftcape/RGBsettings/R/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										rnumber >> Rnumber;
										rnumber.close();
										auto Gnumber = 0;
										ifstream gnumber("riftcape/RGBsettings/G/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										gnumber >> Gnumber;
										gnumber.close();
										auto Bnumber = 0;
										ifstream bnumber("riftcape/RGBsettings/B/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										bnumber >> Bnumber;
										bnumber.close();

										//RGB 2 mtherfker
										auto R2number = 0;
										ifstream r2number("riftcape/RGBsettings/R2/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										r2number >> R2number;
										r2number.close();
										auto G2number = 0;
										ifstream g2number("riftcape/RGBsettings/G2/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										g2number >> G2number;
										g2number.close();
										auto B2number = 0;
										ifstream b2number("riftcape/RGBsettings2/B2/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										b2number >> B2number;
										b2number.close();

										//collar  mtherfker
										auto Rcollar = 0;
										ifstream rcollar("riftcape/collarsettings/collarR/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										rcollar >> Rcollar;
										rcollar.close();
										auto Gcollar = 0;
										ifstream gcollar("riftcape/collarsettings/collarG/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										gcollar >> Gcollar;
										gcollar.close();
										auto Bcollar = 0;
										ifstream bcollar("riftcape/collarsettings/collarB/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										bcollar >> Bcollar;
										bcollar.close();

										//collar 2 mtherfker
										auto R2collar = 0;
										ifstream r2collar("riftcape/collarsettings2/collarR2/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										r2collar >> R2collar;
										r2collar.close();
										auto G2collar = 0;
										ifstream g2collar("riftcape/collarsettings2/collarG2/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										g2collar >> G2collar;
										g2collar.close();
										auto B2collar = 0;
										ifstream b2collar("riftcape/collarsettings2/collarB2/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										b2collar >> B2collar;
										b2collar.close();

										if (collarcheck == 1)
										{
											collar = 6;

										}

										if (checkbox_portalaura == "1")
										{
											effect = 2555;
											ofstream capeppp("riftcape/portalaura/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
											capeppp << 1;
											capeppp.close();
										}

										if (checkbox_electricalaura == "1")
										{
											effect = 5091;
											ofstream capeeee("riftcape/electricalaura/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
											capeeee << 1;
											capeeee.close();
										}

										if (checkbox_starfieldaura == "1")
										{
											effect = 5091;
											ofstream capepps("riftcape/starfieldaura/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
											capepps << 1;
											capepps.close();
										}

										if (!timecheck == 1)
										{
											timedilation2 = 1000000000000000;
										}

										ifstream fg("players/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".json");
										json j;
										fg >> j;
										fg.close();

										j["udahsettingorno"] = true;

										ofstream fs("players/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".json");
										fs << j;
										fs.close();
										ENetPeer* currentPeer;
										for (currentPeer = server->peers;
											currentPeer < &server->peers[server->peerCount];
											++currentPeer)
										{
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
											if (isHere(peer, currentPeer))
											{
												PlayerRiftCape(currentPeer, effect, createRGBA(Bnumber, Gnumber, Rnumber, A), createRGBA(Bnumber, Gnumber, Rnumber, A), createRGBA(Bnumber, Gnumber, Rnumber, A), createRGBA(Bnumber, Gnumber, Rnumber, A), timedilation2, collar); //yg collar urutan 4 sama 5
											}
										}
									}
								if (isTradeDialogs) {
									short int currentItemCount = 0;
									for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++)
									{
										if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(peer->data))->lastTradeItem)
										{
											currentItemCount = (unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
											if (currentItemCount < 0)
											{
												currentItemCount = FixCountItem((unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount);
											}
										}
									}
									if (atoi(tradeitemcount.c_str()) > currentItemCount)
									{
										continue;
									}
									else if (atoi(tradeitemcount.c_str()) < 1)
									{
										continue;
									}
									if (((PlayerInfo*)(peer->data))->currentTradeItems.find("add_slot|" + to_string(((PlayerInfo*)(peer->data))->lastTradeItem) + "|") != std::string::npos)
									{
										replace(((PlayerInfo*)(peer->data))->currentTradeItems, "add_slot|" + to_string(((PlayerInfo*)(peer->data))->lastTradeItem) + "|", "");
									}
									((PlayerInfo*)(peer->data))->currentTradeItems += "add_slot|" + to_string(((PlayerInfo*)(peer->data))->lastTradeItem) + "|" + tradeitemcount + "\n"; // TODO TRADE
									ENetPeer* currentPeer;
									for (currentPeer = server->peers;
										currentPeer < &server->peers[server->peerCount];
										++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
											continue;
										if (isHere(peer, currentPeer))
										{
											if (((PlayerInfo*)(currentPeer->data))->netID == ((PlayerInfo*)(peer->data))->lastTradeNetID)
											{
												if (((PlayerInfo*)(peer->data))->currentTradeItems.find("accepted|1") != std::string::npos)
												{
													replace(((PlayerInfo*)(peer->data))->currentTradeItems, "accepted|1", "");
												}
												if (((PlayerInfo*)(currentPeer->data))->currentTradeItems.find("accepted|1") != std::string::npos)
												{
													replace(((PlayerInfo*)(currentPeer->data))->currentTradeItems, "accepted|1", "");
												}
												Player::OnTradeStatus(currentPeer, ((PlayerInfo*)(peer->data))->netID, ((PlayerInfo*)(peer->data))->displayName + "`o", ((PlayerInfo*)(peer->data))->currentTradeItems);
												Player::OnTradeStatus(peer, ((PlayerInfo*)(peer->data))->netID, ((PlayerInfo*)(peer->data))->displayName + "`o", ((PlayerInfo*)(currentPeer->data))->currentTradeItems);
												Player::OnTradeStatus(currentPeer, ((PlayerInfo*)(peer->data))->netID, ((PlayerInfo*)(peer->data))->displayName + "`o", ((PlayerInfo*)(peer->data))->currentTradeItems);
												Player::OnTradeStatus(peer, ((PlayerInfo*)(peer->data))->netID, ((PlayerInfo*)(peer->data))->displayName + "`o", ((PlayerInfo*)(peer->data))->currentTradeItems);
												if (((PlayerInfo*)(currentPeer->data))->isTradingWithUser == 1)
												{
													Player::OnTextOverlay(peer, "The deal has changed");
													Player::OnTextOverlay(currentPeer, "The deal has changed");
													Player::PlayAudio(peer, "audio/tile_removed.wav", 0);
													Player::PlayAudio(currentPeer, "audio/tile_removed.wav", 0);
												}
												else
												{
													Player::OnTextOverlay(peer, "The deal has changed");
													Player::PlayAudio(peer, "audio/tile_removed.wav", 0);
												}
											}

										}
									}
								}if (isTradingDialog)
								{
									if (infoDat[0] == "itemcount") item1count = infoDat[1];
									if (infoDat[0] == "itemcount2") item2count = infoDat[1];
									if (infoDat[0] == "itemcount3") item3count = infoDat[1];
									if (infoDat[0] == "itemcount4") item4count = infoDat[1];
								}
								if (isTradingDialog)
								{
									int x = 0;
									if (item1count != "")
									{
										bool contains_non_int = !std::regex_match(item1count, std::regex("^[0-9]+$"));
										if (contains_non_int == true)
										{
											((PlayerInfo*)(peer->data))->item1 = 0;
											((PlayerInfo*)(peer->data))->item1count = 0;
											continue;
										}
										if (item1count.size() > 3 || item1count.size() <= 0)
										{
											continue;
										}
										x = stoi(item1count);

										short int currentItemCount = 0;
										for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++)
										{
											if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(peer->data))->item1)
											{
												currentItemCount = (unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
											}
										}
										if (x <= 0 || x > currentItemCount) {
											((PlayerInfo*)(peer->data))->item1 = 0;
											((PlayerInfo*)(peer->data))->item1count = 0;
											Player::OnConsoleMessage(peer, "`^That too many or too less to trade!");
											continue;
										}

										if (((PlayerInfo*)(peer->data))->item2 == ((PlayerInfo*)(peer->data))->item1 || ((PlayerInfo*)(peer->data))->item3 == ((PlayerInfo*)(peer->data))->item1 || ((PlayerInfo*)(peer->data))->item4 == ((PlayerInfo*)(peer->data))->item1)
										{
											((PlayerInfo*)(peer->data))->item1 = 0;
											((PlayerInfo*)(peer->data))->item1count = 0;
											continue;
										}

										((PlayerInfo*)(peer->data))->item1count = x;
									}
									if (item2count != "")
									{
										bool contains_non_int = !std::regex_match(item2count, std::regex("^[0-9]+$"));
										if (contains_non_int == true)
										{
											((PlayerInfo*)(peer->data))->item2 = 0;
											((PlayerInfo*)(peer->data))->item2count = 0;
											continue;
										}
										if (item2count.size() > 3 || item2count.size() <= 0)
										{
											continue;
										}
										x = stoi(item2count);

										short int currentItemCount = 0;
										for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++)
										{
											if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(peer->data))->item2)
											{
												currentItemCount = (unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
											}
										}
										if (x <= 0 || x > currentItemCount) {
											((PlayerInfo*)(peer->data))->item2 = 0;
											((PlayerInfo*)(peer->data))->item2count = 0;
											Player::OnConsoleMessage(peer, "`^That too many or too less to trade!");
											continue;
										}

										if (((PlayerInfo*)(peer->data))->item1 == ((PlayerInfo*)(peer->data))->item2 || ((PlayerInfo*)(peer->data))->item3 == ((PlayerInfo*)(peer->data))->item2 || ((PlayerInfo*)(peer->data))->item4 == ((PlayerInfo*)(peer->data))->item2)
										{
											((PlayerInfo*)(peer->data))->item2 = 0;
											((PlayerInfo*)(peer->data))->item2count = 0;
											continue;
										}

										((PlayerInfo*)(peer->data))->item2count = x;
									}
									if (item3count != "")
									{
										bool contains_non_int = !std::regex_match(item3count, std::regex("^[0-9]+$"));
										if (contains_non_int == true)
										{
											((PlayerInfo*)(peer->data))->item3 = 0;
											((PlayerInfo*)(peer->data))->item3count = 0;
											continue;
										}
										if (item3count.size() > 3 || item3count.size() <= 0)
										{
											continue;
										}
										x = stoi(item3count);

										short int currentItemCount = 0;
										for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++)
										{
											if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(peer->data))->item3)
											{
												currentItemCount = (unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
											}
										}
										if (x <= 0 || x > currentItemCount) {
											((PlayerInfo*)(peer->data))->item3 = 0;
											((PlayerInfo*)(peer->data))->item3count = 0;
											Player::OnConsoleMessage(peer, "`^That too many or too less to trade!");
											continue;
										}

										if (((PlayerInfo*)(peer->data))->item1 == ((PlayerInfo*)(peer->data))->item3 || ((PlayerInfo*)(peer->data))->item2 == ((PlayerInfo*)(peer->data))->item3 || ((PlayerInfo*)(peer->data))->item4 == ((PlayerInfo*)(peer->data))->item2)
										{
											((PlayerInfo*)(peer->data))->item3 = 0;
											((PlayerInfo*)(peer->data))->item3count = 0;
											continue;
										}

										((PlayerInfo*)(peer->data))->item3count = x;
									}
									if (item4count != "")
									{
										bool contains_non_int = !std::regex_match(item4count, std::regex("^[0-9]+$"));
										if (contains_non_int == true)
										{
											((PlayerInfo*)(peer->data))->item4 = 0;
											((PlayerInfo*)(peer->data))->item4count = 0;
											continue;
										}
										if (item4count.size() > 3 || item4count.size() <= 0)
										{
											continue;
										}
										x = stoi(item4count);

										short int currentItemCount = 0;
										for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++)
										{
											if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(peer->data))->item4)
											{
												currentItemCount = (unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
											}
										}
										if (x <= 0 || x > currentItemCount) {
											((PlayerInfo*)(peer->data))->item4 = 0;
											((PlayerInfo*)(peer->data))->item4count = 0;
											Player::OnConsoleMessage(peer, "`^That too many or too less to trade!");
											continue;
										}

										if (((PlayerInfo*)(peer->data))->item1 == ((PlayerInfo*)(peer->data))->item4 || ((PlayerInfo*)(peer->data))->item2 == ((PlayerInfo*)(peer->data))->item4 || ((PlayerInfo*)(peer->data))->item3 == ((PlayerInfo*)(peer->data))->item4)
										{
											((PlayerInfo*)(peer->data))->item4 = 0;
											((PlayerInfo*)(peer->data))->item4count = 0;
											continue;
										}

										((PlayerInfo*)(peer->data))->item4count = x;
									}
									ENetPeer* currentPeer;
									for (currentPeer = server->peers;
										currentPeer < &server->peers[server->peerCount];
										++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
											continue;


										tradestatus(peer, ((PlayerInfo*)(currentPeer->data))->netID, "", ((PlayerInfo*)(currentPeer->data))->displayName, "add_slot|" + to_string(((PlayerInfo*)(currentPeer->data))->item1) + "|" + to_string(((PlayerInfo*)(currentPeer->data))->item1count) + "\nadd_slot|" + to_string(((PlayerInfo*)(currentPeer->data))->item2) + "|" + to_string(((PlayerInfo*)(currentPeer->data))->item2count) + "\nadd_slot|" + to_string(((PlayerInfo*)(currentPeer->data))->item3) + "|" + to_string(((PlayerInfo*)(currentPeer->data))->item3count) + "\nadd_slot|" + to_string(((PlayerInfo*)(currentPeer->data))->item4) + "|" + to_string(((PlayerInfo*)(currentPeer->data))->item4count));
										tradestatus(currentPeer, ((PlayerInfo*)(peer->data))->netID, "", ((PlayerInfo*)(peer->data))->displayName, "add_slot|" + to_string(((PlayerInfo*)(peer->data))->item1) + "|" + to_string(((PlayerInfo*)(peer->data))->item1count) + "\nadd_slot|" + to_string(((PlayerInfo*)(peer->data))->item2) + "|" + to_string(((PlayerInfo*)(peer->data))->item2count) + "\nadd_slot|" + to_string(((PlayerInfo*)(peer->data))->item3) + "|" + to_string(((PlayerInfo*)(peer->data))->item3count) + "\nadd_slot|" + to_string(((PlayerInfo*)(peer->data))->item4) + "|" + to_string(((PlayerInfo*)(peer->data))->item4count));
									}
								}
								if (infoDat[0] == "dialog_name" && infoDat[1] == "reqoffer")
								{
									isWorldTradeDialog = true;
								}
								if (infoDat[0] == "dialog_name" && infoDat[1] == "createstoreconfirm")
								{
									isCreateStoreDialog = true;
								}
								if (infoDat[0] == "dialog_name" && infoDat[1] == "safe_withdrawConfirm")
								{
									issafewithdrawConfirmDialog = true;
								}
								if (infoDat[0] == "dialog_name" && infoDat[1] == "safedepositconfirm")
								{
									issafedepositconfirmDialog = true;
								}
								if (infoDat[0] == "addItemToStore")
								{
									isaddItemToStoreDialog = true;
								}
								if (infoDat[0] == "dialog_name" && infoDat[1] == "surge")
								{
									SurgeryDialog = true;
								}
								if (infoDat[0].substr(0, 16) == "addDonationItem_")
								{
									isaddItemToDonationBox = true;
								}
								if (infoDat[0].substr(0, 14) == "trademypicker_")
								{
									isMyTradeDialog = true;
								}
								if (infoDat[0].substr(0, 12) == "mergepicker_")
								{
									isMergeDialog = true;
								}
								if (infoDat[0].substr(0, 12) == "safedeposit_")
								{
									isSafeAddItemDialog = true;
								}
								if (infoDat[0].substr(0, 15) == "boxlvl1deposit_")
								{
									isboxlvl1AddItemDialog = true;
								}
								if (infoDat[0].substr(0, 15) == "boxlvl2deposit_")
								{
									isboxlvl2AddItemDialog = true;
								}
								if (infoDat[0].substr(0, 15) == "boxlvl3deposit_")
								{
									isboxlvl3AddItemDialog = true;
								}
								if (infoDat[0] == "dialog_name" && infoDat[1] == "storeReviewConfirm")
								{
									isstoreReviewConfirmDialog = true;
								}
								if (infoDat[0] == "dialog_name" && infoDat[1] == "buyPlayerStoreItem")
								{
									isbuyPlayerStoreItemDialog = true;
								}
								if (infoDat[0] == "dialog_name" && infoDat[1] == "addItemStoreOnSale")
								{
									isaddItemStoreOnSaleDialog = true;
								}
								if (infoDat[0] == "stuffitem")
								{
									isStuffDialog = true;
								}
								if (infoDat[0] == "magplantitem")
								{
									isMagDialog = true;
								}
								if (infoDat[0] == "emeraldbfg")
								{
									isBfgDialog = true;
								}
								if (infoDat[0] == "dialog_name" && infoDat[1] == "reqworldlockoffer")
								{
									isWorldLockBuyDialog = true;
								}
								if (ispaint) {
									if (infoDat[0] == "paints") pid = infoDat[1];
									if (infoDat[0] == "psign") psign = infoDat[1];
								}
								if (ispaint) {
									if (infoDat[0] == "psign")
									{
										if (pid != "" || psign != "") {

											psign = infoDat[1];
											PlayerInfo* pinfo = ((PlayerInfo*)(peer->data));
											int x = pinfo->wrenchedBlockLocation % world->width;
											int y = pinfo->wrenchedBlockLocation / world->width;
											string sign = psign;
											int id = atoi(pid.c_str());
											SendCanvasData(peer, world->items[x + (y * world->width)].foreground, world->items[x + (y * world->width)].background, x, y, id, sign);
											world->items[x + (y * world->width)].sign = sign;
											world->items[x + (y * world->width)].intdata = id;


										}
									}
								}
								if (infoDat[0] == "dialog_name" && infoDat[1] == "reqdarkstoneoffer")
								{
									isDarkStoneBuyDialog = true;
								}
								if (infoDat[0] == "dialog_name" && infoDat[1] == "reqdiamondlockoffer")
								{
									isDiamondLockBuyDialog = true;
								}
								if (infoDat[0] == "dialog_name" && infoDat[1] == "buyitembyrarity")
								{
									isBuyItemByRarityDialog = true;
								}
								if (infoDat[0] == "dialog_name" && infoDat[1] == "growscan_float")
								{
									isGrowscan = true;
								}
								if (infoDat[0] == "dialog_name" && infoDat[1] == "dropdialog")
								{
									isDropDialog = true;
								}
								if (infoDat[0] == "dialog_name" && infoDat[1] == "trashdialog")
								{
									isTrashDialog = true;
								}
								if (infoDat[0] == "dialog_name" && infoDat[1] == "guildconfirm")
								{
									isGuildDialog = true;
								}
								if (infoDat[0] == "dialog_name" && infoDat[1] == "editdoor")
								{
									isEditDoorDialog = true;
								}
								if (infoDat[0] == "dialog_name" && infoDat[1] == "checkCodeDialog")
								{
									checkCodeDialog = true;
								}
								if (infoDat[0] == "dialog_name" && infoDat[1] == "changeCodeDialog")
								{
									changeCodeDialog = true;
								}
								if (checkCodeDialog)
								{
									if (infoDat[0] == "checkCodeText") {
										checkCodeText = infoDat[1];

										if (((PlayerInfo*)(peer->data))->registercode != checkCodeText)
										{
											GamePacket p2code = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"),
												"set_default_color|`o\n\nadd_label_with_icon|big|`oNew device detected``|left|32|\n\nadd_spacer|small|\nadd_label|small|`wIt seems you joined from another location. `wPlease confirm your identity by entering your `@security `wcode.|left||\n\nadd_spacer|small||\nadd_text_input|checkCodeText|Code||5|left|32|\n\nadd_spacer|small|\nadd_label_with_icon|small|`@Wrong answer. Try again.||\n\nadd_spacer|small|\nend_dialog|checkCodeDialog||Accept|\n"));
											ENetPacket* packet2 = enet_packet_create(p2code.data,
												p2code.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(peer, 0, packet2);
											delete p2code.data;
										}
										else
										{
											((PlayerInfo*)(peer->data))->isConfirmingCode = false;
											Player::OnConsoleMessage(peer, "`@Successfully passed verification.");
											((PlayerInfo*)(peer->data))->registermac = ((PlayerInfo*)(peer->data))->mac;
											((PlayerInfo*)(peer->data))->registerrid = ((PlayerInfo*)(peer->data))->rid;
											((PlayerInfo*)(peer->data))->registersid = ((PlayerInfo*)(peer->data))->sid;
											((PlayerInfo*)(peer->data))->registergid = ((PlayerInfo*)(peer->data))->gid;
											((PlayerInfo*)(peer->data))->registervid = ((PlayerInfo*)(peer->data))->vid;
											((PlayerInfo*)(peer->data))->registeraid = ((PlayerInfo*)(peer->data))->aid;
											((PlayerInfo*)(peer->data))->registerIP = ((PlayerInfo*)(peer->data))->charIP;
											ofstream saveNewSecurity("accountSecurity/" + ((PlayerInfo*)(peer->data))->rawName + ".txt");
											saveNewSecurity << "true" << endl;
											saveNewSecurity << ((PlayerInfo*)(peer->data))->registercode << endl;
											saveNewSecurity << ((PlayerInfo*)(peer->data))->registermac << endl;
											saveNewSecurity << ((PlayerInfo*)(peer->data))->registerrid << endl;
											saveNewSecurity << ((PlayerInfo*)(peer->data))->registersid << endl;
											saveNewSecurity << ((PlayerInfo*)(peer->data))->registergid << endl;
											saveNewSecurity << ((PlayerInfo*)(peer->data))->registervid << endl;
											saveNewSecurity << ((PlayerInfo*)(peer->data))->registeraid << endl;
											saveNewSecurity << ((PlayerInfo*)(peer->data))->registerIP << endl;
											saveNewSecurity.close();
										}
									}
								}

								if (changeCodeDialog)
								{
									if (infoDat[0] == "changeCodeText")
									{
										changeCodeText = infoDat[1];

										if (changeCodeText.find_first_not_of("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789") != string::npos)
										{
											Player::OnConsoleMessage(peer, "`5Sorry but the `4Code `@must consist of `25 `@characters.``");
											continue;
										}
										if (changeCodeText.length() < 5)
										{
											Player::OnConsoleMessage(peer, "`5Sorry but the code must have 5 symbols!``");
											continue;
										}

										((PlayerInfo*)(peer->data))->registercode = changeCodeText;
										Player::OnConsoleMessage(peer, "`@You successfully changed security code to:`2 " + changeCodeText + "`@. Remember it!");

										ofstream fsCode("accountSecurity/" + ((PlayerInfo*)(peer->data))->rawName + ".txt");

										string tekstasFalseArTrue = "error";
										if (((PlayerInfo*)(peer->data))->isUseCode)
										{
											tekstasFalseArTrue = "true";
										}
										else
										{
											tekstasFalseArTrue = "false";
										}

										fsCode << tekstasFalseArTrue << endl;
										fsCode << ((PlayerInfo*)(peer->data))->registercode << endl;
										fsCode << ((PlayerInfo*)(peer->data))->registermac << endl;
										fsCode << ((PlayerInfo*)(peer->data))->registerrid << endl;
										fsCode << ((PlayerInfo*)(peer->data))->registersid << endl;
										fsCode << ((PlayerInfo*)(peer->data))->registergid << endl;
										fsCode << ((PlayerInfo*)(peer->data))->registervid << endl;
										fsCode << ((PlayerInfo*)(peer->data))->registeraid << endl;
										fsCode << ((PlayerInfo*)(peer->data))->registerIP << endl;

										fsCode.close();
									}
								}

								if (btn == "popup")
								{
									if (((PlayerInfo*)(peer->data))->haveSuperSupporterName == false)
									{
										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|Growmojis|left|1366|\nadd_spacer|small|\nadd_smalltext_forced| (sigh) |left|\nadd_spacer|small|\nadd_smalltext|`9You need to be a Supporter to get these Growmojis.``|left|\nadd_smalltext_forced_alpha| (no) |0.5|left|\nadd_button|chc0|Cancel|noflags|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|"));
										ENetPacket* packet = enet_packet_create(p.data,
											p.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete p.data;
									}
									else {
										GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|Growmojis|left|1366|\nadd_spacer|small|\nadd_smalltext_forced| (sigh) |left|\nadd_spacer|small|\nadd_smalltext|`$You unlocked growmoji (`2Super supporter`$)``|left|\nadd_smalltext_forced| (no) |left|\nadd_button|chc0|Cancel|noflags|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|"));
										ENetPacket* packet = enet_packet_create(p2.data,
											p2.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete p2.data;

									}
								}
								if (btn == "accountsecurity")
								{
									string codeInfo = "0";
									string statusText = "";
									if (((PlayerInfo*)(peer->data))->isUseCode)
									{
										codeInfo = "`@Disable `wPIN Code.";
										statusText = "`wAt the moment, you have PIN code protection `1Enabled`w.";
									}
									else
									{
										codeInfo = "`1Enable `wPIN Code.";
										statusText = "`wAt the moment, you have PIN code protection `@Disabled`w.";
									}
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"),
										"set_default_color|`o\n\nadd_label_with_icon|big|`5Secure My Account``|left|1436|\n\nadd_spacer|small|\nadd_label|small|`5Hello you can control you account security here!|left|\nadd_label|small|`wYour email/code will be used to retrieve your lost password|left|\n\nadd_spacer|small|\nadd_button|passbutton|`wChange Password|\n\nadd_spacer|small|\nadd_label_with_icon|small|`1Secret Code: " + ((PlayerInfo*)(peer->data))->registercode + "|left|1424|\nadd_spacer|small|\n\nadd_button|changecode|`wChange Code```|\n\nadd_spacer|small|\nadd_label|small|" + statusText + "|left|small|\nadd_spacer|small|\nadd_button|enableordisablecode|" + codeInfo + "`|4|\nadd_spacer|small|\nadd_quick_exit|\nadd_button|chc0|Close|noflags|0|0|\nnend_dialog|gazette||OK|"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);

									enet_peer_send(peer, 0, packet2);
									delete p2.data;
								}

								if (btn == "enableordisablecode")
								{
									string tekstasFalseArTrue = "";
									if (((PlayerInfo*)(peer->data))->isUseCode == false)
									{
										((PlayerInfo*)(peer->data))->isUseCode = true;
										Player::OnConsoleMessage(peer, "`1Successfully `^Enabled `1Account protection.");
										tekstasFalseArTrue = "true";
									}
									else
									{
										((PlayerInfo*)(peer->data))->isUseCode = false;
										Player::OnConsoleMessage(peer, "`1Successfully `@Disabled `1Account protection.");
										tekstasFalseArTrue = "false";
									}
									ofstream fsCode("accountSecurity/" + ((PlayerInfo*)(peer->data))->rawName + ".txt");

									fsCode << tekstasFalseArTrue << endl;
									fsCode << ((PlayerInfo*)(peer->data))->registercode << endl;
									fsCode << ((PlayerInfo*)(peer->data))->registermac << endl;
									fsCode << ((PlayerInfo*)(peer->data))->registerrid << endl;
									fsCode << ((PlayerInfo*)(peer->data))->registersid << endl;
									fsCode << ((PlayerInfo*)(peer->data))->registergid << endl;
									fsCode << ((PlayerInfo*)(peer->data))->registervid << endl;
									fsCode << ((PlayerInfo*)(peer->data))->registeraid << endl;
									fsCode << ((PlayerInfo*)(peer->data))->registerIP << endl;

									fsCode.close();
								}

								if (btn == "changecode")
								{
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"),
										"set_default_color|`o\n\nadd_label_with_icon|big|`5Change Security Code``|left|32|\n\nadd_spacer|small|\nadd_label_with_icon|small|`1Your current PIN code is: `@" + ((PlayerInfo*)(peer->data))->registercode + " |left|1424|\n\nadd_spacer|small|\nadd_label|small|`oEnter a `w5-character code. Write your code in `wnotepad `oto not forget it, otherwise, the account will be difficult to recover.|left|\n\nadd_spacer|small||\nadd_text_input|changeCodeText|Code||5|\n\nadd_spacer|small|\nend_dialog|changeCodeDialog|Cancel|OK|\n"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);

									enet_peer_send(peer, 0, packet2);
									delete p2.data;
								}
								if (vending)
								{
									if (world == nullptr || world->name == "EXIT" || serverIsFrozen) break;
									if (infoDat[0] == "stockitem")
									{
										if (world->owner != "" && !isWorldOwner(peer, world)) break;
										string stockitemstr = infoDat[1];
										if (stockitemstr.size() > 5 || stockitemstr.size() <= 0) break;
										stockitem = atoi(stockitemstr.c_str());
										if (stockitem < 0 || stockitem > maxItems) break;
										if (stockitem == 18 || stockitem == 32 || stockitem == 6336 || getItemDef(stockitem).blockType == BlockTypes::LOCK || getItemDef(stockitem).properties & Property_Untradable || getItemDef(stockitem).blockType == BlockTypes::FISH || stockitem == 8552 || stockitem == 9472 || stockitem == 9482 || stockitem == 9356 || stockitem == 9492 || stockitem == 9498 || stockitem == 8774 || stockitem == 1790 || stockitem == 2592 || stockitem == 1784 || stockitem == 1792 || stockitem == 1794 || stockitem == 7734 || stockitem == 8306 || stockitem == 9458)
										{
											Player::OnConsoleMessage(peer, "`o`wCan't put that in a Vending Machine.");
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wCan't put that in a Vending Machine.", 0, true);
											break;
										}
										int count = 1;
										for (auto i = 0; i < static_cast<PlayerInfo*>(peer->data)->inventory.items.size(); i++)
										{
											if (static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemID == stockitem)
											{
												count = static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount;
												break;
											}
										}
										if (stockitem == 0 || count == 0) break;
										auto contains = false;
										SearchInventoryItem(peer, stockitem, count, contains);
										if (!contains)
										{
											autoBan(peer, false, 24 * 7, "Used vend exploit");
											break;
										}
										RemoveInventoryItem(stockitem, count, peer, true);
										updateplayerset(peer, stockitem);
										int x = static_cast<PlayerInfo*>(peer->data)->lastPunchX;
										int y = static_cast<PlayerInfo*>(peer->data)->lastPunchY;
										int squaresign = x + (y * 100);
										string currentworld = static_cast<PlayerInfo*>(peer->data)->currentWorld + "X" + std::to_string(squaresign);
										ofstream fdss("vend/price/" + currentworld + ".txt");
										fdss << setprice;
										fdss.close();
										string itemid = "";
										ofstream fdss3("vend/id/" + currentworld + ".txt");
										fdss3 << stockitem;
										fdss3.close();
										ofstream fdsss("vend/count/" + currentworld + ".txt");
										fdsss << count;
										fdsss.close();
										string withdraw = "";
										ifstream fdssss("vend/withdraw/" + currentworld + ".txt");
										fdssss >> withdraw;
										fdssss.close();
										auto islocks = false;
										if (atoi(withdraw.c_str()) >= 1)
										{
											islocks = true;
										}
										ENetPeer* currentPeer;
										for (currentPeer = server->peers;
											currentPeer < &server->peers[server->peerCount];
											++currentPeer)
										{
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
											if (isHere(peer, currentPeer))
											{
												Player::OnConsoleMessage(currentPeer, "`7[`o" + static_cast<PlayerInfo*>(peer->data)->displayName + " `oput `2" + getItemDef(stockitem).name + " `oin the Vending Machine.`7]");
												Player::OnTalkBubble(currentPeer, static_cast<PlayerInfo*>(peer->data)->netID, "`7[`w" + static_cast<PlayerInfo*>(peer->data)->displayName + " `wput `2" + getItemDef(stockitem).name + "`w in the Vending Machine.`7]", 0, false);
												UpdateVend(currentPeer, x, y, stockitem, islocks, setprice, world->items[x + (y * world->width)].background);
											}
										}
										SendVendDialog(peer);
										break;
									}
									if (world == nullptr || world->name == "EXIT" || serverIsFrozen) break;
									if (infoDat[0] == "stockitems")
									{
										if (world->owner != "" && !isWorldOwner(peer, world)) break;
										string stockitemstr = infoDat[1];
										if (stockitemstr.size() > 5 || stockitemstr.size() <= 0) break;
										stockitem = atoi(stockitemstr.c_str());
										if (stockitem < 0 || stockitem > maxItems) break;
										if (stockitem == 18 || stockitem == 32 || stockitem == 6336 || getItemDef(stockitem).blockType == BlockTypes::LOCK || getItemDef(stockitem).properties & Property_Untradable || getItemDef(stockitem).blockType == BlockTypes::FISH || stockitem == 8552 || stockitem == 9472 || stockitem == 9482 || stockitem == 9356 || stockitem == 9492 || stockitem == 9498 || stockitem == 8774 || stockitem == 1790 || stockitem == 2592 || stockitem == 1784 || stockitem == 1792 || stockitem == 1794 || stockitem == 7734 || stockitem == 8306 || stockitem == 9458)
										{
											Player::OnConsoleMessage(peer, "`o`wCan't put that in a Vending Machine.");
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wCan't put that in a Vending Machine.", 0, true);
											break;
										}
										int count = 1;
										for (auto i = 0; i < static_cast<PlayerInfo*>(peer->data)->inventory.items.size(); i++)
										{
											if (static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemID == stockitem)
											{
												count = static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount;
												break;
											}
										}
										if (stockitem == 0 || count == 0) break;
										auto contains = false;
										SearchInventoryItem(peer, stockitem, count, contains);
										if (!contains)
										{
											autoBan(peer, false, 24 * 7, "Used vend exploit");
											break;
										}
										RemoveInventoryItem(stockitem, count, peer, true);
										updateplayerset(peer, stockitem);
										int x = static_cast<PlayerInfo*>(peer->data)->lastPunchX;
										int y = static_cast<PlayerInfo*>(peer->data)->lastPunchY;
										int squaresign = x + (y * 100);
										string currentworld = static_cast<PlayerInfo*>(peer->data)->currentWorld + "X" + std::to_string(squaresign);
										ofstream sfdss("vend/prices/" + currentworld + ".txt");
										sfdss << setprices;
										sfdss.close();
										string itemid = "";
										ofstream fdss3("vend/id/" + currentworld + ".txt");
										fdss3 << stockitem;
										fdss3.close();
										ofstream fdsss("vend/count/" + currentworld + ".txt");
										fdsss << count;
										fdsss.close();
										string withdraw = "";
										ifstream fdssss("vend/withdraw/" + currentworld + ".txt");
										fdssss >> withdraw;
										fdssss.close();
										auto islocks = false;
										if (atoi(withdraw.c_str()) >= 1)
										{
											islocks = true;
										}
										ENetPeer* currentPeer;
										for (currentPeer = server->peers;
											currentPeer < &server->peers[server->peerCount];
											++currentPeer)
										{
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
											if (isHere(peer, currentPeer))
											{
												Player::OnConsoleMessage(currentPeer, "`7[`o" + static_cast<PlayerInfo*>(peer->data)->displayName + " `oput `2" + getItemDef(stockitem).name + " `oin the Vending Machine.`7]");
												Player::OnTalkBubble(currentPeer, static_cast<PlayerInfo*>(peer->data)->netID, "`7[`w" + static_cast<PlayerInfo*>(peer->data)->displayName + " `wput `2" + getItemDef(stockitem).name + "`w in the Vending Machine.`7]", 0, false);
												UpdateVend(currentPeer, x, y, stockitem, islocks, setprices, world->items[x + (y * world->width)].background);
											}
										}
										SendVendDialog(peer);
										break;
									}
									if (infoDat[0] == "setprice")
									{
										if (world->owner != "" && !isWorldOwner(peer, world)) break;
										string setpricestr = infoDat[1];
										if (setpricestr.size() > 5 || setpricestr.size() <= 0) break;
										setprice = atoi(setpricestr.c_str());
										if (setprice <= 0) break;
										if (setprice > 200)
										{
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "Well, that's a silly price.", 0, true);
											break;
										}
										int x = static_cast<PlayerInfo*>(peer->data)->lastPunchX;
										int y = static_cast<PlayerInfo*>(peer->data)->lastPunchY;
										int squaresign = x + (y * 100);
										string currentworld = static_cast<PlayerInfo*>(peer->data)->currentWorld + "X" + std::to_string(squaresign);
										string dabprice = "";
										ifstream fdss322("vend/price/" + currentworld + ".txt");
										fdss322 >> dabprice;
										fdss322.close();
										if (setprice == atoi(dabprice.c_str())) break;
										ofstream fdss("vend/price/" + currentworld + ".txt");
										fdss << setprice;
										fdss.close();
										string itemid = "";
										ifstream fdss3("vend/id/" + currentworld + ".txt");
										fdss3 >> itemid;
										fdss3.close();
										string itemcount = "";
										ifstream fdsss("vend/count/" + currentworld + ".txt");
										fdsss >> itemcount;
										fdsss.close();
										string withdraw = "";
										ifstream fdssss("vend/withdraw/" + currentworld + ".txt");
										fdssss >> withdraw;
										fdssss.close();
										auto islocks = false;
										if (atoi(withdraw.c_str()) >= 1)
										{
											islocks = true;
										}
										ENetPeer* currentPeer;
										for (currentPeer = server->peers;
											currentPeer < &server->peers[server->peerCount];
											++currentPeer)
										{
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
											if (isHere(peer, currentPeer))
											{
												Player::OnConsoleMessage(currentPeer, "`7[`o" + static_cast<PlayerInfo*>(peer->data)->displayName + " `ochanged the price of `2" + getItemDef(atoi(itemid.c_str())).name + "`o to `5" + to_string(setprice) + " World Locks each.`7]");
												Player::OnTalkBubble(currentPeer, static_cast<PlayerInfo*>(peer->data)->netID, "`7[`w" + static_cast<PlayerInfo*>(peer->data)->displayName + " `wchanged the price of `2" + getItemDef(atoi(itemid.c_str())).name + "`w to `5" + to_string(setprice) + " World Locks each.`7]", 0, true);
												Player::OnParticleEffect(currentPeer, 44, x * 32, y * 32 + 16, 0);
												UpdateVend(currentPeer, x, y, atoi(itemid.c_str()), islocks, setprice, world->items[x + (y * world->width)].background);
											}
										}
										break;
									}
									if (infoDat[0] == "setprices")
									{
										if (world->owner != "" && !isWorldOwner(peer, world)) break;
										string setpricesstr = infoDat[1];
										if (setpricesstr.size() > 5 || setpricesstr.size() <= 0) break;
										setprices = atoi(setpricesstr.c_str());
										if (setprices <= 0) break;
										if (setprices > 200)
										{
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "Well, that's a silly price.", 0, true);
											break;
										}
										int x = static_cast<PlayerInfo*>(peer->data)->lastPunchX;
										int y = static_cast<PlayerInfo*>(peer->data)->lastPunchY;
										int squaresign = x + (y * 100);
										string currentworld = static_cast<PlayerInfo*>(peer->data)->currentWorld + "X" + std::to_string(squaresign);
										string dabprices = "";
										ifstream fdss322("vend/prices/" + currentworld + ".txt");
										fdss322 >> dabprices;
										fdss322.close();
										if (setprices == atoi(dabprices.c_str())) break;
										ofstream sfdss("vend/price/" + currentworld + ".txt");
										sfdss << setprices;
										sfdss.close();
										string itemid = "";
										ifstream fdss3("vend/id/" + currentworld + ".txt");
										fdss3 >> itemid;
										fdss3.close();
										string itemcount = "";
										ifstream fdsss("vend/count/" + currentworld + ".txt");
										fdsss >> itemcount;
										fdsss.close();
										string withdraw = "";
										ifstream fdssss("vend/withdraw/" + currentworld + ".txt");
										fdssss >> withdraw;
										fdssss.close();
										auto islocks = false;
										if (atoi(withdraw.c_str()) >= 1)
										{
											islocks = true;
										}
										ENetPeer* currentPeer;
										for (currentPeer = server->peers;
											currentPeer < &server->peers[server->peerCount];
											++currentPeer)
										{
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
											if (isHere(peer, currentPeer))
											{
												Player::OnConsoleMessage(currentPeer, "`7[`o" + static_cast<PlayerInfo*>(peer->data)->displayName + " `ochanged the price of `2" + getItemDef(atoi(itemid.c_str())).name + "`o to `5" + to_string(setprice) + "Per World Lock.`7]");
												Player::OnTalkBubble(currentPeer, static_cast<PlayerInfo*>(peer->data)->netID, "`7[`w" + static_cast<PlayerInfo*>(peer->data)->displayName + " `wchanged the price of `2" + getItemDef(atoi(itemid.c_str())).name + "`w to `5" + to_string(setprice) + " Per World Lock.`7]", 0, true);
												Player::OnParticleEffect(currentPeer, 44, x * 32, y * 32 + 16, 0);
												UpdateVend(currentPeer, x, y, atoi(itemid.c_str()), islocks, setprices, world->items[x + (y * world->width)].background);
											}
										}
										break;
									}
									/*Buyerio Puse*/
									if (infoDat[0] == "buycount")
									{
										string buycountstr = infoDat[1];
										if (buycountstr.size() > 3 || buycountstr.size() <= 0) break;
										buyprice = atoi(buycountstr.c_str());
										if (buyprice <= 0) break;
										int x = static_cast<PlayerInfo*>(peer->data)->lastPunchX;
										int y = static_cast<PlayerInfo*>(peer->data)->lastPunchY;
										int squaresign = x + (y * 100);
										string currentworld = static_cast<PlayerInfo*>(peer->data)->currentWorld + "X" + std::to_string(squaresign);
										string itemid = "";
										ifstream fdss3("vend/id/" + currentworld + ".txt");
										fdss3 >> itemid;
										fdss3.close();
										string withdraw = "";
										ifstream fdssss("vend/withdraw/" + currentworld + ".txt");
										fdssss >> withdraw;
										fdssss.close();
										string price = "";
										ifstream fdsssss("vend/price/" + currentworld + ".txt");
										fdsssss >> price;
										fdsssss.close();
										auto realprice = atoi(price.c_str());
										auto kiekmoketi = buyprice * realprice;
										auto worldlocks = 0;
										auto diamondlocks = 0;
										auto locks = 0;
										for (auto i = 0; i < static_cast<PlayerInfo*>(peer->data)->inventory.items.size(); i++)
										{
											if (static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemID == 242)
											{
												worldlocks = static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount;
											}
											if (static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemID == 1796)
											{
												diamondlocks = static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount;
											}
										}
										if (diamondlocks > 0)
										{
											locks = diamondlocks * 100;
										}
										locks += worldlocks;
										if (kiekmoketi > locks)
										{
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "You can't afford that many!", 0, true);
											break;
										}
										else
										{
											if (CheckItemMaxed(peer, atoi(itemid.c_str()), buyprice))
											{
												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "That wouldnt fit into my inventory!", 0, true);
												break;
											}
											string itemcount = "";
											ifstream fdsss("vend/count/" + currentworld + ".txt");
											fdsss >> itemcount;
											fdsss.close();
											int yracount = atoi(itemcount.c_str());
											int yrawithdraw = atoi(withdraw.c_str());
											if (yracount < buyprice)
											{
												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "Out of order", 0, true);
												break;
											}
											float worldlockskaina = 0;
											int diamondlockkiek = 0;
											int worldlockkiek = 0;
											if (kiekmoketi > 0) worldlockkiek = kiekmoketi;
											int grazinti_wl = 0;
											if (worldlockkiek != 0)
											{
												auto iscontainseas = false;
												SearchInventoryItem(peer, 242, worldlockkiek, iscontainseas);
												if (!iscontainseas)
												{
													//cout << "nera wl " + to_string(worldlockkiek) << endl;
													diamondlockkiek += 1;
													grazinti_wl = 100 - worldlockkiek;
													while (grazinti_wl < 0)
													{
														if (grazinti_wl < 0)
														{
															//cout << "grazinti_wl buvo " + to_string(grazinti_wl) << endl;
															diamondlockkiek += 1;
															grazinti_wl = 100 + grazinti_wl;
														}
														else break;
													}
													worldlockkiek = 0;
												}
											}
											if (diamondlockkiek != 0)
											{
												auto iscontainseas3 = false;
												SearchInventoryItem(peer, 1796, diamondlockkiek, iscontainseas3);
												if (!iscontainseas3)
												{
													//cout << "nera dl " + to_string(diamondlockkiek) << endl;
													diamondlockkiek -= 1;
													worldlockkiek += 100;
												}
											}
											if (worldlockkiek == 0 && diamondlockkiek == 0)
											{
												if (kiekmoketi == worldlocks)
												{
													worldlockkiek = worldlocks;
												}
											}
											auto iscontainseas = false;
											SearchInventoryItem(peer, 242, worldlockkiek, iscontainseas);
											if (!iscontainseas)
											{
												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "Uhm something went wrong...", 0, true);
												break;
											}
											if (worldlockkiek < 0 || diamondlockkiek < 0 || grazinti_wl < 0)
											{
												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "Uhm something went wrong...", 0, true);
												break;
											}
											if (worldlockkiek == 0 && diamondlockkiek == 0) break;
											//cout << "duoda wl: " + to_string(worldlockkiek) << endl;
											//cout << "duoda dl: " + to_string(diamondlockkiek) << endl;
											//cout << "grazina wl: " + to_string(grazinti_wl) << endl;
											bool success = true;
											if (worldlockkiek != 0)
											{
												RemoveInventoryItem(242, worldlockkiek, peer, true);
											}
											if (diamondlockkiek != 0)
											{
												RemoveInventoryItem(1796, diamondlockkiek, peer, true);
											}
											if (grazinti_wl != 0)
											{
												if (CheckItemMaxed(peer, 242, grazinti_wl))
												{
													if (grazinti_wl >= 100 && !CheckItemMaxed(peer, 1796, 1))
													{
														SaveItemMoreTimes(1796, 1, peer, success);
													}
												}
												else
												{
													SaveItemMoreTimes(242, grazinti_wl, peer, success);
												}
											}
											int kiekgrazinti = yracount - buyprice;
											if (kiekgrazinti < 0) kiekgrazinti = 0;
											yrawithdraw += kiekmoketi;
											ofstream save("vend/count/" + currentworld + ".txt");
											save << kiekgrazinti;
											save.close();
											ofstream saves("vend/withdraw/" + currentworld + ".txt");
											saves << yrawithdraw;
											saves.close();
											SaveItemMoreTimes(atoi(itemid.c_str()), buyprice, peer, success);
											int kiekpakrauti = realprice;
											int tikrasid = atoi(itemid.c_str());
											if (kiekgrazinti == 0)
											{
												kiekpakrauti = 0;
												tikrasid = 0;
											}
											ENetPeer* currentPeer;
											for (currentPeer = server->peers;
												currentPeer < &server->peers[server->peerCount];
												++currentPeer)
											{
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
												if (isHere(peer, currentPeer))
												{
													Player::OnConsoleMessage(currentPeer, "`7[`9" + static_cast<PlayerInfo*>(peer->data)->displayName + " `9bought " + to_string(buyprice) + " " + getItemDef(atoi(itemid.c_str())).name + " for " + to_string(kiekmoketi) + " World Locks.`7]");
													SendTradeEffect(currentPeer, atoi(itemid.c_str()), static_cast<PlayerInfo*>(peer->data)->netID, static_cast<PlayerInfo*>(peer->data)->netID, 150);
													UpdateVend(currentPeer, x, y, tikrasid, true, kiekpakrauti, world->items[x + (y * world->width)].background);
													Player::PlayAudio(currentPeer, "audio/cash_register.wav", 0);
												}
											}
										}
									}
								}
								if (isDropDialog)
								{
									if (world == nullptr || world->name == "EXIT" || serverIsFrozen) break;
									if (infoDat[0] == "dropitemcount")
									{
										dropitemcount = infoDat[1];
										if (dropitemcount.size() > 3 || dropitemcount.size() <= 0) break;
										if (world->DisableDrop && static_cast<PlayerInfo*>(peer->data)->rawName != world->owner)
										{
											Player::OnTextOverlay(peer, "Dropping is disabled here!");
											break;
										}
										auto x = atoi(dropitemcount.c_str());
										short int currentItemCount = 0;
										for (auto i = 0; i < static_cast<PlayerInfo*>(peer->data)->inventory.items.size(); i++)
										{
											if (static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemID == static_cast<PlayerInfo*>(peer->data)->lastdropitem)
											{
												currentItemCount = static_cast<unsigned int>(static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount);
											}
										}
										if (x <= 0 || x > currentItemCount) break;
										else
										{
											auto iscontainseas = false;
											SearchInventoryItem(peer, static_cast<PlayerInfo*>(peer->data)->lastdropitem, 1, iscontainseas);
											if (!iscontainseas)
											{
												autoBan(peer, false, 24 * 7, "isDropDialog didnt has " + to_string(static_cast<PlayerInfo*>(peer->data)->lastdropitem) + " item");
												break;
											}
											else
											{

												if (getItemDef(static_cast<PlayerInfo*>(peer->data)->lastdropitem).properties & Property_Untradable || static_cast<PlayerInfo*>(peer->data)->lastdropitem == 18 || static_cast<PlayerInfo*>(peer->data)->lastdropitem == 32 || static_cast<PlayerInfo*>(peer->data)->lastdropitem == 6336 || static_cast<PlayerInfo*>(peer->data)->lastdropitem == 8552 || static_cast<PlayerInfo*>(peer->data)->lastdropitem == 9472 || static_cast<PlayerInfo*>(peer->data)->lastdropitem == 9482 || static_cast<PlayerInfo*>(peer->data)->lastdropitem == 9356 || static_cast<PlayerInfo*>(peer->data)->lastdropitem == 9492 || static_cast<PlayerInfo*>(peer->data)->lastdropitem == 9498 || static_cast<PlayerInfo*>(peer->data)->lastdropitem == 8774 || static_cast<PlayerInfo*>(peer->data)->lastdropitem == 1790 || static_cast<PlayerInfo*>(peer->data)->lastdropitem == 2592 || static_cast<PlayerInfo*>(peer->data)->lastdropitem == 1784 || static_cast<PlayerInfo*>(peer->data)->lastdropitem == 1792 || static_cast<PlayerInfo*>(peer->data)->lastdropitem == 1794 || static_cast<PlayerInfo*>(peer->data)->lastdropitem == 7734 || static_cast<PlayerInfo*>(peer->data)->lastdropitem == 8306 || static_cast<PlayerInfo*>(peer->data)->lastdropitem == 9458 || static_cast<PlayerInfo*>(peer->data)->lastdropitem == 5640)
												{
													Player::OnTextOverlay(peer, "You can't drop that.");
													break;
												}
												string history = "";
												for (auto i = 0; i < static_cast<PlayerInfo*>(peer->data)->inventory.items.size(); i++)
												{
													if (static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemID == static_cast<PlayerInfo*>(peer->data)->lastdropitem)
													{
														break;
													}
												}

												if (getItemDef(static_cast<PlayerInfo*>(peer->data)->lastdropitem).blockType == BlockTypes::FISH && x != currentItemCount) break;
												if (static_cast<PlayerInfo*>(peer->data)->rawName != world->owner && isMod(peer) && world->owner != "")
												{
													auto islegitnow = false;
													for (auto i = 0; i < world->width * world->height; i++)
													{
														if (world->items[i].foreground == 1436)
														{
															islegitnow = true;
															break;
														}
													}
													if (islegitnow == true)
													{
														string toLogs = "";
														toLogs = static_cast<PlayerInfo*>(peer->data)->displayName + " `w(" + static_cast<PlayerInfo*>(peer->data)->rawName + "`w) `5Dropped `2" + to_string(x) + " " + getItemDef(static_cast<PlayerInfo*>(peer->data)->lastdropitem).name + "`5.";
														ofstream breaklogs("securitycam/logs/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + ".txt", ios::app);
														breaklogs << toLogs << endl;
														breaklogs.close();
													}
												}
												auto xx = static_cast<PlayerInfo*>(peer->data)->x + (32 * (static_cast<PlayerInfo*>(peer->data)->isRotatedLeft ? -1 : 1));
												auto yy = static_cast<PlayerInfo*>(peer->data)->y;
												RemoveInventoryItem(static_cast<PlayerInfo*>(peer->data)->lastdropitem, x, peer, true);
												updateplayerset(peer, static_cast<PlayerInfo*>(peer->data)->lastdropitem);
												if (world->name == "GROWGANOTH" && GrowganothEvent && yy / 32 == 15 && static_cast<PlayerInfo*>(peer->data)->x / 32 >= 48 && static_cast<PlayerInfo*>(peer->data)->x / 32 <= 51)
												{
													SendSacrifice(peer, static_cast<PlayerInfo*>(peer->data)->lastdropitem, x);
													continue;
												}
												if (world->name != "EXIT" && static_cast<PlayerInfo*>(peer->data)->isIn)
												{
													DropItem(peer, -1, xx, yy + (rand() % 16), static_cast<PlayerInfo*>(peer->data)->lastdropitem, x, 0, history);
												}
											}
										}
									}
								}
								if (isTrashDialog)
								{
									if (world == nullptr || world->name == "EXIT" || serverIsFrozen) break;
									if (infoDat[0] == "trashitemcount")
									{
										trashitemcount = infoDat[1];
										if (trashitemcount.size() > 3 || trashitemcount.size() <= 0) break;
										auto gemtrashcount = 0;
										auto x = atoi(trashitemcount.c_str());
										short int currentItemCount = 0;
										for (auto i = 0; i < static_cast<PlayerInfo*>(peer->data)->inventory.items.size(); i++)
										{
											if (static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemID == static_cast<PlayerInfo*>(peer->data)->lasttrashitem)
											{
												currentItemCount = static_cast<unsigned int>(static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount);
											}
										}
										if (x <= 0 || x > currentItemCount) break;
										else
										{
											if (!isDev(peer))
											{
												auto iscontainseas = false;
												SearchInventoryItem(peer, static_cast<PlayerInfo*>(peer->data)->lasttrashitem, 1, iscontainseas);
												if (!iscontainseas)
												{
													autoBan(peer, false, 24 * 7, "isDropDialog didnt has " + to_string(static_cast<PlayerInfo*>(peer->data)->lastdropitem) + " item");
													break;
												}
											}
											if (getItemDef(static_cast<PlayerInfo*>(peer->data)->lasttrashitem).blockType == BlockTypes::FISH && x != currentItemCount) break;
											static_cast<PlayerInfo*>(peer->data)->trashgemmeritem = x;
											if (static_cast<PlayerInfo*>(peer->data)->lasttrashitem == 242)
											{
												gemtrashcount = gemtrashcount + 200 * static_cast<PlayerInfo*>(peer->data)->trashgemmeritem;
											}
											if (static_cast<PlayerInfo*>(peer->data)->lasttrashitem == 1796)
											{
												gemtrashcount = gemtrashcount + 20000 * static_cast<PlayerInfo*>(peer->data)->trashgemmeritem;
											}
											if (static_cast<PlayerInfo*>(peer->data)->lasttrashitem == 7188)
											{
												gemtrashcount = gemtrashcount + 2000000 * static_cast<PlayerInfo*>(peer->data)->trashgemmeritem;
											}
											if (getItemDef(static_cast<PlayerInfo*>(peer->data)->lasttrashitem).blockType == BlockTypes::FISH)
											{
												gemtrashcount = gemtrashcount + 5 * static_cast<PlayerInfo*>(peer->data)->trashgemmeritem;
											}
											Player::OnConsoleMessage(peer, "`w" + std::to_string(static_cast<PlayerInfo*>(peer->data)->trashgemmeritem) + " " + getItemDef(static_cast<PlayerInfo*>(peer->data)->lasttrashitem).name + " `orecycled, `w" + std::to_string(gemtrashcount) + " `ogems earned.");
											RemoveInventoryItem(static_cast<PlayerInfo*>(peer->data)->lasttrashitem, x, peer, true);
											sendSound(peer, "trash.wav");
											updateplayerset(peer, static_cast<PlayerInfo*>(peer->data)->lasttrashitem);
											std::ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
											std::string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
											auto gembux = atoi(content.c_str());
											auto fingembux = gembux + gemtrashcount;
											ofstream myfile;
											myfile.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
											myfile << fingembux;
											myfile.close();
											int gemcalc = gembux + gemtrashcount;
											static_cast<PlayerInfo*>(peer->data)->eikiscia = gemcalc;
										}
										Player::OnSetBux(peer, static_cast<PlayerInfo*>(peer->data)->eikiscia, 0);
									}
								}
								if (isepoch) {
									PlayerInfo* pinfo = ((PlayerInfo*)(peer->data));
									int x = pinfo->wrenchedBlockLocation % world->width;
									int y = pinfo->wrenchedBlockLocation / world->width;
									if (land == true) {
										world->weather = 40;
										ENetPeer* currentPeer;

										for (currentPeer = server->peers;
											currentPeer < &server->peers[server->peerCount];
											++currentPeer)
										{
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
												continue;
											if (isHere(peer, currentPeer))
											{
												GamePacket p2 = packetEnd(appendInt(appendString(createPacket(), "OnSetCurrentWeather"), world->weather));
												ENetPacket* packet2 = enet_packet_create(p2.data,
													p2.len,
													ENET_PACKET_FLAG_RELIABLE);

												enet_peer_send(currentPeer, 0, packet2);
												delete p2.data;
												continue;
											}
										}

									}
									else {
										world->land = false;
									}
									if (vol == true) {
										world->weather = 39;
										ENetPeer* currentPeer;

										for (currentPeer = server->peers;
											currentPeer < &server->peers[server->peerCount];
											++currentPeer)
										{
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
												continue;
											if (isHere(peer, currentPeer))
											{
												GamePacket p2 = packetEnd(appendInt(appendString(createPacket(), "OnSetCurrentWeather"), world->weather));
												ENetPacket* packet2 = enet_packet_create(p2.data,
													p2.len,
													ENET_PACKET_FLAG_RELIABLE);

												enet_peer_send(currentPeer, 0, packet2);
												delete p2.data;
												continue;
											}
										}

									}
									else {
										world->vol = false;
									}
									if (ice == true) {
										world->weather = 38;
										ENetPeer* currentPeer;

										for (currentPeer = server->peers;
											currentPeer < &server->peers[server->peerCount];
											++currentPeer)
										{
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
												continue;
											if (isHere(peer, currentPeer))
											{
												GamePacket p2 = packetEnd(appendInt(appendString(createPacket(), "OnSetCurrentWeather"), world->weather));
												ENetPacket* packet2 = enet_packet_create(p2.data,
													p2.len,
													ENET_PACKET_FLAG_RELIABLE);

												enet_peer_send(currentPeer, 0, packet2);
												delete p2.data;
												continue;
											}
										}

									}
									else {
										world->ice = false;
									}

								}
								if (SurgeryDialog)
								{
									if (world == nullptr || world->name == "EXIT" || static_cast<PlayerInfo*>(peer->data)->SurgeryCooldown) break;
									bool HardToSeeWork = static_cast<PlayerInfo*>(peer->data)->HardToSee;
									bool PatientLosingBlood = static_cast<PlayerInfo*>(peer->data)->PatientLosingBlood;
									string WorkSee = "";
									string LosingBlood = "";
									if (infoDat[1] == "Surgical Anesthetic" || infoDat[1] == "Surgical Antiseptic" || infoDat[1] == "Surgical Stitches" || infoDat[1] == "Surgical Pins" || infoDat[1] == "Surgical Transfusion" || infoDat[1] == "Surgical Defibrillator" || infoDat[1] == "Surgical Clamp")
									{
										Player::OnTextOverlay(peer, "This surgery tool isnt available yet!");
										stringstream Temperaturas;
										Temperaturas << static_cast<PlayerInfo*>(peer->data)->PatientTemperature;
										auto PTemp = Temperaturas.str();
										if (HardToSeeWork) WorkSee = "\nadd_smalltext|`6It is becoming hard to see your work.``|left|";
										if (PatientLosingBlood) LosingBlood = "\nadd_smalltext|Patient is losing blood `3slowly.``|left|";
										if (static_cast<PlayerInfo*>(peer->data)->PerformingSurgery) Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wSurg-E``|left|18|\nadd_smalltext|" + static_cast<PlayerInfo*>(peer->data)->PatientDiagnosis + ".``|left|\nadd_smalltext|Pulse: " + static_cast<PlayerInfo*>(peer->data)->PatientPulse + "``    Status: " + static_cast<PlayerInfo*>(peer->data)->PatientStatus + "``|left|\nadd_smalltext|Temp: " + static_cast<PlayerInfo*>(peer->data)->TempColor + PTemp + "``    Operation site: " + static_cast<PlayerInfo*>(peer->data)->OperationSite + "``|left|" + WorkSee + "\nadd_smalltext|Incisions: " + static_cast<PlayerInfo*>(peer->data)->IncisionsColor + to_string(static_cast<PlayerInfo*>(peer->data)->PatientIncisions) + "``    |left|" + LosingBlood + "\nadd_spacer|small|\nadd_smalltext|`3The patient is prepped for surgery.``|left|\ntext_scaling_string|Defibrillator|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem1).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem1) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem1) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem2).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem2) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem2) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem3).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem3) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem3) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem4).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem4) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem4) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem5).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem5) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem5) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem6).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem6) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem6) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem7).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem7) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem7) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem8).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem8) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem8) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem9).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem9) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem9) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem10).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem10) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem10) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem11).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem11) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem11) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem12).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem12) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem12) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem13).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem13) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem13) + "|\nadd_button_with_icon|Empty Surgery Tray||noflags|4320||\nadd_button_with_icon|Empty Surgery Tray||noflags|4320||\nadd_button_with_icon||END_LIST|noflags|0||\nadd_button|cancel|Give up!|noflags|0|0|\nend_dialog|surge|||");
										continue;
									}
									if (static_cast<PlayerInfo*>(peer->data)->PatientDiagnosis != "")
									{
										float temperatura2 = static_cast<PlayerInfo*>(peer->data)->PatientTemperature;
										temperatura2 += static_cast<PlayerInfo*>(peer->data)->PatientTemperatureRise;
										if (temperatura2 >= 113)
										{

											end_surgery(peer, true);
											break;
										}
										if (temperatura2 >= 109)
										{
											static_cast<PlayerInfo*>(peer->data)->TempColor = "`4";
										}
										else if (temperatura2 >= 106)
										{
											static_cast<PlayerInfo*>(peer->data)->TempColor = "`3";
										}
										else
										{
											static_cast<PlayerInfo*>(peer->data)->TempColor = "`2";
										}

										float test = temperatura2;
										float value = (int)(test * 100 + .5);
										float newvalue = (float)value / 100;
										static_cast<PlayerInfo*>(peer->data)->PatientTemperature = newvalue;

									}
									if (infoDat[1] == "Surgical Lab Kit")
									{
										auto contains = false;
										SearchInventoryItem(peer, 4318, 1, contains);
										if (!contains)
										{
											autoBan(peer, false, 24 * 7, "Used surgery exploit");
											break;
										}
										RemoveInventoryItem(4318, 1, peer, true);
										auto KiekTuri = 0;
										for (auto i = 0; i < static_cast<PlayerInfo*>(peer->data)->inventory.items.size(); i++)
										{
											if (static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemID == 4318 && static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount >= 1)
											{
												KiekTuri = static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount;
											}
										}
										if (KiekTuri <= 0) UpdateSurgeryItems(peer);



										string Notification = "`3The patient is prepped for surgery.";
										if (surgery_skill_fail(peer))
										{
											Notification = "`3[`4Skill Fail`3] `6You contaminated the sample.";
										}
										else
										{
											Notification = "";
											static_cast<PlayerInfo*>(peer->data)->UnlockedAntibiotic = true;
											UpdateSurgeryItems(peer);
										}



										stringstream Temperaturas;
										Temperaturas << static_cast<PlayerInfo*>(peer->data)->PatientTemperature;
										auto PTemp = Temperaturas.str();
										if (HardToSeeWork) WorkSee = "\nadd_smalltext|`6It is becoming hard to see your work.``|left|";
										if (PatientLosingBlood) LosingBlood = "\nadd_smalltext|Patient is losing blood `3slowly.``|left|";
										if (static_cast<PlayerInfo*>(peer->data)->PerformingSurgery) Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wSurg-E``|left|18|\nadd_smalltext|" + static_cast<PlayerInfo*>(peer->data)->PatientDiagnosis + ".``|left|\nadd_smalltext|Pulse: " + static_cast<PlayerInfo*>(peer->data)->PatientPulse + "``    Status: " + static_cast<PlayerInfo*>(peer->data)->PatientStatus + "``|left|\nadd_smalltext|Temp: " + static_cast<PlayerInfo*>(peer->data)->TempColor + PTemp + "``    Operation site: " + static_cast<PlayerInfo*>(peer->data)->OperationSite + "``|left|" + WorkSee + "\nadd_smalltext|Incisions: " + static_cast<PlayerInfo*>(peer->data)->IncisionsColor + to_string(static_cast<PlayerInfo*>(peer->data)->PatientIncisions) + "``    |left|" + LosingBlood + "\nadd_spacer|small|\nadd_smalltext|" + Notification + "``|left|\ntext_scaling_string|Defibrillator|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem1).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem1) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem1) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem2).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem2) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem2) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem3).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem3) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem3) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem4).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem4) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem4) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem5).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem5) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem5) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem6).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem6) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem6) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem7).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem7) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem7) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem8).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem8) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem8) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem9).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem9) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem9) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem10).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem10) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem10) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem11).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem11) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem11) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem12).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem12) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem12) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem13).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem13) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem13) + "|\nadd_button_with_icon|nulltool||noflags|4320||\nadd_button_with_icon|nulltool||noflags|4320||\nadd_button_with_icon||END_LIST|noflags|0||\nadd_button|cancel|Give up!|noflags|0|0|\nend_dialog|surge|||");

									}
									if (infoDat[1] == "Fix it")
									{
										string Notification = "`3The patient is prepped for surgery.";
										if (surgery_skill_fail(peer))
										{
											Notification = "`3[`4Skill Fail`3] `6You screwed it up! Try again.";
											stringstream Temperaturas;
											Temperaturas << static_cast<PlayerInfo*>(peer->data)->PatientTemperature;
											auto PTemp = Temperaturas.str();

											if (HardToSeeWork) WorkSee = "\nadd_smalltext|`6It is becoming hard to see your work.``|left|";
											if (PatientLosingBlood) LosingBlood = "\nadd_smalltext|Patient is losing blood `3slowly.``|left|";
											if (static_cast<PlayerInfo*>(peer->data)->PerformingSurgery) Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wSurg-E``|left|18|\nadd_smalltext|" + static_cast<PlayerInfo*>(peer->data)->PatientDiagnosis + ".``|left|\nadd_smalltext|Pulse: " + static_cast<PlayerInfo*>(peer->data)->PatientPulse + "``    Status: " + static_cast<PlayerInfo*>(peer->data)->PatientStatus + "``|left|\nadd_smalltext|Temp: " + static_cast<PlayerInfo*>(peer->data)->TempColor + PTemp + "``    Operation site: " + static_cast<PlayerInfo*>(peer->data)->OperationSite + "``|left|" + WorkSee + "\nadd_smalltext|Incisions: " + static_cast<PlayerInfo*>(peer->data)->IncisionsColor + to_string(static_cast<PlayerInfo*>(peer->data)->PatientIncisions) + "``    |left|" + LosingBlood + "\nadd_spacer|small|\nadd_smalltext|" + Notification + "``|left|\ntext_scaling_string|Defibrillator|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem1).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem1) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem1) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem2).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem2) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem2) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem3).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem3) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem3) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem4).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem4) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem4) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem5).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem5) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem5) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem6).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem6) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem6) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem7).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem7) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem7) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem8).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem8) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem8) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem9).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem9) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem9) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem10).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem10) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem10) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem11).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem11) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem11) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem12).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem12) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem12) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem13).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem13) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem13) + "|\nadd_button_with_icon|nulltool||noflags|4320||\nadd_button_with_icon|nulltool||noflags|4320||\nadd_button_with_icon||END_LIST|noflags|0||\nadd_button|cancel|Give up!|noflags|0|0|\nend_dialog|surge|||");
										}
										else
										{

											Notification = "";
											if (static_cast<PlayerInfo*>(peer->data)->PatientRealDiagnosis == "nose job")
											{
												complete_surgery(peer);
												break;
											}
										}
									}
									if (infoDat[1] == "Surgical Antibiotics")
									{
										auto contains = false;
										SearchInventoryItem(peer, 1266, 1, contains);
										if (!contains)
										{
											autoBan(peer, false, 24 * 7, "Used surgery exploit");
											break;
										}
										RemoveInventoryItem(1266, 1, peer, true);
										auto KiekTuri = 0;
										for (auto i = 0; i < static_cast<PlayerInfo*>(peer->data)->inventory.items.size(); i++)
										{
											if (static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemID == 1266 && static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount >= 1)
											{
												KiekTuri = static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount;
											}
										}
										if (KiekTuri <= 0) UpdateSurgeryItems(peer);

										string Notification = "`3The patient is prepped for surgery.";
										if (surgery_skill_fail(peer))
										{
											Notification = "`3[`4Skill Fail`3] `6This is the wrong medication! The bacteria like it.";
										}
										else
										{
											Notification = "";

											float temperatura2 = static_cast<PlayerInfo*>(peer->data)->PatientTemperature;
											temperatura2 -= 2.6;
											if (temperatura2 <= 100)
											{

												end_surgery(peer, true);

												break;
											}
											if (temperatura2 >= 109)
											{
												static_cast<PlayerInfo*>(peer->data)->TempColor = "`4";
											}
											else if (temperatura2 >= 106)
											{
												static_cast<PlayerInfo*>(peer->data)->TempColor = "`3";
											}
											else if (temperatura2 < 106)
											{
												static_cast<PlayerInfo*>(peer->data)->TempColor = "`2";
											}
											if (temperatura2 <= 105.5)
											{
												static_cast<PlayerInfo*>(peer->data)->TempColor = "`2";
												if (static_cast<PlayerInfo*>(peer->data)->PatientRealDiagnosis == "monkey flu" || static_cast<PlayerInfo*>(peer->data)->PatientRealDiagnosis == "turtle flu" || static_cast<PlayerInfo*>(peer->data)->PatientRealDiagnosis == "bird flu")
												{
													complete_surgery(peer);
													break;
												}
												else if (temperatura2 <= 105)
												{
													end_surgery(peer, true);
													break;
												}
												static_cast<PlayerInfo*>(peer->data)->TempColor = "`6";
											}

											float test = temperatura2;
											float value = (int)(test * 100 + .5);
											float sss = (float)value / 100;
											static_cast<PlayerInfo*>(peer->data)->PatientTemperature = sss;

										}

										stringstream Temperaturas;
										Temperaturas << static_cast<PlayerInfo*>(peer->data)->PatientTemperature;
										auto PTemp = Temperaturas.str();

										if (HardToSeeWork) WorkSee = "\nadd_smalltext|`6It is becoming hard to see your work.``|left|";
										if (PatientLosingBlood) LosingBlood = "\nadd_smalltext|Patient is losing blood `3slowly.``|left|";
										if (static_cast<PlayerInfo*>(peer->data)->PerformingSurgery) Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wSurg-E``|left|18|\nadd_smalltext|" + static_cast<PlayerInfo*>(peer->data)->PatientDiagnosis + ".``|left|\nadd_smalltext|Pulse: " + static_cast<PlayerInfo*>(peer->data)->PatientPulse + "``    Status: " + static_cast<PlayerInfo*>(peer->data)->PatientStatus + "``|left|\nadd_smalltext|Temp: " + static_cast<PlayerInfo*>(peer->data)->TempColor + PTemp + "``    Operation site: " + static_cast<PlayerInfo*>(peer->data)->OperationSite + "``|left|" + WorkSee + "\nadd_smalltext|Incisions: " + static_cast<PlayerInfo*>(peer->data)->IncisionsColor + to_string(static_cast<PlayerInfo*>(peer->data)->PatientIncisions) + "``    |left|" + LosingBlood + "\nadd_spacer|small|\nadd_smalltext|" + Notification + "``|left|\ntext_scaling_string|Defibrillator|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem1).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem1) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem1) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem2).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem2) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem2) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem3).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem3) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem3) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem4).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem4) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem4) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem5).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem5) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem5) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem6).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem6) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem6) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem7).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem7) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem7) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem8).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem8) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem8) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem9).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem9) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem9) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem10).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem10) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem10) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem11).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem11) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem11) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem12).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem12) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem12) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem13).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem13) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem13) + "|\nadd_button_with_icon|nulltool||noflags|4320||\nadd_button_with_icon|nulltool||noflags|4320||\nadd_button_with_icon||END_LIST|noflags|0||\nadd_button|cancel|Give up!|noflags|0|0|\nend_dialog|surge|||");
									}
									if (infoDat[1] == "Surgical Sponge")
									{
										auto contains = false;
										SearchInventoryItem(peer, 1258, 1, contains);
										if (!contains)
										{
											autoBan(peer, false, 24 * 7, "Used surgery exploit");
											break;
										}
										RemoveInventoryItem(1258, 1, peer, true);
										auto KiekTuri = 0;
										for (auto i = 0; i < static_cast<PlayerInfo*>(peer->data)->inventory.items.size(); i++)
										{
											if (static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemID == 1258 && static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount >= 1)
											{
												KiekTuri = static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount;
											}
										}
										if (KiekTuri <= 0) UpdateSurgeryItems(peer);

										string Notification = "`3The patient is prepped for surgery.";
										if (surgery_skill_fail(peer))
										{
											Notification = "`3[`4Skill Fail`3] `6You somehow managed to eat the sponge.";
										}
										else
										{
											Notification = "";
											if (static_cast<PlayerInfo*>(peer->data)->HardToSee)
											{
												static_cast<PlayerInfo*>(peer->data)->HardToSee = false;
												HardToSeeWork = false;
											}
										}

										stringstream Temperaturas;
										Temperaturas << static_cast<PlayerInfo*>(peer->data)->PatientTemperature;
										auto PTemp = Temperaturas.str();
										if (HardToSeeWork) WorkSee = "\nadd_smalltext|`6It is becoming hard to see your work.``|left|";
										if (PatientLosingBlood) LosingBlood = "\nadd_smalltext|Patient is losing blood `3slowly.``|left|";
										if (static_cast<PlayerInfo*>(peer->data)->PerformingSurgery) Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wSurg-E``|left|18|\nadd_smalltext|" + static_cast<PlayerInfo*>(peer->data)->PatientDiagnosis + ".``|left|\nadd_smalltext|Pulse: " + static_cast<PlayerInfo*>(peer->data)->PatientPulse + "``    Status: " + static_cast<PlayerInfo*>(peer->data)->PatientStatus + "``|left|\nadd_smalltext|Temp: " + static_cast<PlayerInfo*>(peer->data)->TempColor + PTemp + "``    Operation site: " + static_cast<PlayerInfo*>(peer->data)->OperationSite + "``|left|" + WorkSee + "\nadd_smalltext|Incisions: " + static_cast<PlayerInfo*>(peer->data)->IncisionsColor + to_string(static_cast<PlayerInfo*>(peer->data)->PatientIncisions) + "``    |left|" + LosingBlood + "\nadd_spacer|small|\nadd_smalltext|" + Notification + "``|left|\ntext_scaling_string|Defibrillator|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem1).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem1) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem1) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem2).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem2) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem2) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem3).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem3) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem3) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem4).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem4) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem4) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem5).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem5) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem5) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem6).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem6) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem6) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem7).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem7) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem7) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem8).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem8) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem8) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem9).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem9) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem9) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem10).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem10) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem10) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem11).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem11) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem11) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem12).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem12) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem12) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem13).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem13) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem13) + "|\nadd_button_with_icon|nulltool||noflags|4320||\nadd_button_with_icon|nulltool||noflags|4320||\nadd_button_with_icon||END_LIST|noflags|0||\nadd_button|cancel|Give up!|noflags|0|0|\nend_dialog|surge|||");
									}
									if (infoDat[1] == "Surgical Ultrasound")
									{
										auto contains = false;
										SearchInventoryItem(peer, 4316, 1, contains);
										if (!contains)
										{
											autoBan(peer, false, 24 * 7, "Used surgery exploit");
											break;
										}
										RemoveInventoryItem(4316, 1, peer, true);
										auto KiekTuri = 0;
										for (auto i = 0; i < static_cast<PlayerInfo*>(peer->data)->inventory.items.size(); i++)
										{
											if (static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemID == 4316 && static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount >= 1)
											{
												KiekTuri = static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount;
											}
										}
										if (KiekTuri <= 0) UpdateSurgeryItems(peer);

										string Notification = "`3The patient is prepped for surgery.";
										if (surgery_skill_fail(peer))
										{
											Notification = "`3[`4Skill Fail`3] `6You scanned the nurse with your ultrasound!";
										}
										else
										{

											Notification = "";

											static_cast<PlayerInfo*>(peer->data)->Ultrasound++;

											if (static_cast<PlayerInfo*>(peer->data)->Ultrasound >= 2)
											{
												static_cast<PlayerInfo*>(peer->data)->PatientTemperatureRise = 1.3;
											}

											static_cast<PlayerInfo*>(peer->data)->PatientDiagnosis = "Patient has " + static_cast<PlayerInfo*>(peer->data)->PatientRealDiagnosis + "";
										}

										stringstream Temperaturas;
										Temperaturas << static_cast<PlayerInfo*>(peer->data)->PatientTemperature;
										auto PTemp = Temperaturas.str();
										if (HardToSeeWork) WorkSee = "\nadd_smalltext|`6It is becoming hard to see your work.``|left|";
										if (PatientLosingBlood) LosingBlood = "\nadd_smalltext|Patient is losing blood `3slowly.``|left|";
										if (static_cast<PlayerInfo*>(peer->data)->PerformingSurgery) Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wSurg-E``|left|18|\nadd_smalltext|" + static_cast<PlayerInfo*>(peer->data)->PatientDiagnosis + ".``|left|\nadd_smalltext|Pulse: " + static_cast<PlayerInfo*>(peer->data)->PatientPulse + "``    Status: " + static_cast<PlayerInfo*>(peer->data)->PatientStatus + "``|left|\nadd_smalltext|Temp: " + static_cast<PlayerInfo*>(peer->data)->TempColor + PTemp + "``    Operation site: " + static_cast<PlayerInfo*>(peer->data)->OperationSite + "``|left|" + WorkSee + "\nadd_smalltext|Incisions: " + static_cast<PlayerInfo*>(peer->data)->IncisionsColor + to_string(static_cast<PlayerInfo*>(peer->data)->PatientIncisions) + "``    |left|" + LosingBlood + "\nadd_spacer|small|\nadd_smalltext|" + Notification + "``|left|\ntext_scaling_string|Defibrillator|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem1).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem1) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem1) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem2).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem2) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem2) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem3).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem3) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem3) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem4).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem4) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem4) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem5).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem5) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem5) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem6).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem6) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem6) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem7).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem7) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem7) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem8).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem8) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem8) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem9).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem9) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem9) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem10).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem10) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem10) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem11).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem11) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem11) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem12).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem12) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem12) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem13).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem13) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem13) + "|\nadd_button_with_icon|nulltool||noflags|4320||\nadd_button_with_icon|nulltool||noflags|4320||\nadd_button_with_icon||END_LIST|noflags|0||\nadd_button|cancel|Give up!|noflags|0|0|\nend_dialog|surge|||");
									}
									if (infoDat[1] == "Surgical Scalpel")
									{
										auto contains = false;
										SearchInventoryItem(peer, 1260, 1, contains);
										if (!contains)
										{
											autoBan(peer, false, 24 * 7, "Used surgery exploit");
											break;
										}
										RemoveInventoryItem(1260, 1, peer, true);
										auto KiekTuri = 0;
										for (auto i = 0; i < static_cast<PlayerInfo*>(peer->data)->inventory.items.size(); i++)
										{
											if (static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemID == 1260 && static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount >= 1)
											{
												KiekTuri = static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount;
											}
										}
										if (KiekTuri <= 0) UpdateSurgeryItems(peer);



										string Notification = "`3The patient is prepped for surgery.";
										if (surgery_skill_fail(peer))
										{
											Notification = "`3[`4Skill Fail`3] `6This will leave a nasty scar, but you managed to cut the right place.";
										}
										else
										{

											Notification = "";



											static_cast<PlayerInfo*>(peer->data)->PatientIncisions++;

											if (static_cast<PlayerInfo*>(peer->data)->PatientIncisions == 1 && static_cast<PlayerInfo*>(peer->data)->PatientRealDiagnosis == "nose job")
											{
												static_cast<PlayerInfo*>(peer->data)->IncisionsColor = "`2";
											}
											else if (static_cast<PlayerInfo*>(peer->data)->PatientIncisions == 2 && static_cast<PlayerInfo*>(peer->data)->PatientRealDiagnosis == "nose job")
											{
												static_cast<PlayerInfo*>(peer->data)->IncisionsColor = "`2";
												static_cast<PlayerInfo*>(peer->data)->FixIt = true;
												UpdateSurgeryItems(peer);
											}
											else
											{
												static_cast<PlayerInfo*>(peer->data)->IncisionsColor = "`4";
												static_cast<PlayerInfo*>(peer->data)->PatientTemperatureRise = 1.6;
											}

										}

										stringstream Temperaturas;
										Temperaturas << static_cast<PlayerInfo*>(peer->data)->PatientTemperature;
										auto PTemp = Temperaturas.str();
										if (HardToSeeWork) WorkSee = "\nadd_smalltext|`6It is becoming hard to see your work.``|left|";
										if (PatientLosingBlood) LosingBlood = "\nadd_smalltext|Patient is losing blood `3slowly.``|left|";
										if (static_cast<PlayerInfo*>(peer->data)->PerformingSurgery) Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wSurg-E``|left|18|\nadd_smalltext|" + static_cast<PlayerInfo*>(peer->data)->PatientDiagnosis + ".``|left|\nadd_smalltext|Pulse: " + static_cast<PlayerInfo*>(peer->data)->PatientPulse + "``    Status: " + static_cast<PlayerInfo*>(peer->data)->PatientStatus + "``|left|\nadd_smalltext|Temp: " + static_cast<PlayerInfo*>(peer->data)->TempColor + PTemp + "``    Operation site: " + static_cast<PlayerInfo*>(peer->data)->OperationSite + "``|left|" + WorkSee + "\nadd_smalltext|Incisions: " + static_cast<PlayerInfo*>(peer->data)->IncisionsColor + to_string(static_cast<PlayerInfo*>(peer->data)->PatientIncisions) + "``    |left|" + LosingBlood + "\nadd_spacer|small|\nadd_smalltext|" + Notification + "``|left|\ntext_scaling_string|Defibrillator|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem1).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem1) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem1) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem2).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem2) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem2) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem3).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem3) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem3) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem4).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem4) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem4) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem5).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem5) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem5) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem6).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem6) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem6) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem7).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem7) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem7) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem8).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem8) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem8) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem9).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem9) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem9) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem10).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem10) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem10) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem11).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem11) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem11) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem12).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem12) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem12) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem13).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem13) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem13) + "|\nadd_button_with_icon|nulltool||noflags|4320||\nadd_button_with_icon|nulltool||noflags|4320||\nadd_button_with_icon||END_LIST|noflags|0||\nadd_button|cancel|Give up!|noflags|0|0|\nend_dialog|surge|||");
									}
									if (infoDat[1] == "Empty Surgery Tray")
									{

										stringstream Temperaturas;
										Temperaturas << static_cast<PlayerInfo*>(peer->data)->PatientTemperature;
										auto PTemp = Temperaturas.str();
										if (HardToSeeWork) WorkSee = "\nadd_smalltext|`6It is becoming hard to see your work.``|left|";
										if (PatientLosingBlood) LosingBlood = "\nadd_smalltext|Patient is losing blood `3slowly.``|left|";
										if (static_cast<PlayerInfo*>(peer->data)->PerformingSurgery) Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wSurg-E``|left|18|\nadd_smalltext|" + static_cast<PlayerInfo*>(peer->data)->PatientDiagnosis + ".``|left|\nadd_smalltext|Pulse: " + static_cast<PlayerInfo*>(peer->data)->PatientPulse + "``    Status: " + static_cast<PlayerInfo*>(peer->data)->PatientStatus + "``|left|\nadd_smalltext|Temp: " + static_cast<PlayerInfo*>(peer->data)->TempColor + PTemp + "``    Operation site: " + static_cast<PlayerInfo*>(peer->data)->OperationSite + "``|left|" + WorkSee + "\nadd_smalltext|Incisions: " + static_cast<PlayerInfo*>(peer->data)->IncisionsColor + to_string(static_cast<PlayerInfo*>(peer->data)->PatientIncisions) + "``    |left|" + LosingBlood + "\nadd_spacer|small|\nadd_smalltext|`3The patient is prepped for surgery.``|left|\ntext_scaling_string|Defibrillator|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem1).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem1) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem1) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem2).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem2) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem2) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem3).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem3) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem3) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem4).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem4) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem4) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem5).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem5) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem5) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem6).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem6) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem6) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem7).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem7) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem7) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem8).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem8) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem8) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem9).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem9) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem9) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem10).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem10) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem10) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem11).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem11) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem11) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem12).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem12) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem12) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem13).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem13) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem13) + "|\nadd_button_with_icon|nulltool||noflags|4320||\nadd_button_with_icon|nulltool||noflags|4320||\nadd_button_with_icon||END_LIST|noflags|0||\nadd_button|cancel|Give up!|noflags|0|0|\nend_dialog|surge|||");
									}
									if (infoDat[1] == "cancel")
									{
										end_surgery(peer, true);



										break;
									}
									else if (!static_cast<PlayerInfo*>(peer->data)->PerformingSurgery && static_cast<PlayerInfo*>(peer->data)->RequestedSurgery)
									{
										static_cast<PlayerInfo*>(peer->data)->RequestedSurgery = false;
										vector<string> Diagnosis{ "monkey flu", "bird flu", "turtle flu", "nose job", "nose job", "nose job" };
										static_cast<PlayerInfo*>(peer->data)->PatientRealDiagnosis = Diagnosis[rand() % Diagnosis.size()];
										if (static_cast<PlayerInfo*>(peer->data)->PatientRealDiagnosis == "monkey flu" || static_cast<PlayerInfo*>(peer->data)->PatientRealDiagnosis == "bird flu" || static_cast<PlayerInfo*>(peer->data)->PatientRealDiagnosis == "turtle flu")
										{
											static_cast<PlayerInfo*>(peer->data)->PatientDiagnosis = "`4The patient has not been diagnosed";
											static_cast<PlayerInfo*>(peer->data)->PatientPulse = "`2Strong";
											static_cast<PlayerInfo*>(peer->data)->PatientStatus = "`4Awake";
											static_cast<PlayerInfo*>(peer->data)->PatientTemperatureRise = 0.75;
											float test = 107.6;
											float value = (int)(test * 100 + .5);
											float newvalue = (float)value / 100;
											static_cast<PlayerInfo*>(peer->data)->PatientTemperature = newvalue;
											static_cast<PlayerInfo*>(peer->data)->OperationSite = "`3Not sanitized";
											static_cast<PlayerInfo*>(peer->data)->PatientIncisions = 0;
											static_cast<PlayerInfo*>(peer->data)->IncisionsColor = "`3";
											static_cast<PlayerInfo*>(peer->data)->TempColor = "`3";
											static_cast<PlayerInfo*>(peer->data)->HardToSee = true;
											HardToSeeWork = true;

										}
										else if (static_cast<PlayerInfo*>(peer->data)->PatientRealDiagnosis == "nose job")
										{
											static_cast<PlayerInfo*>(peer->data)->PatientDiagnosis = "`4The patient has not been diagnosed";
											static_cast<PlayerInfo*>(peer->data)->PatientPulse = "`2Strong";
											static_cast<PlayerInfo*>(peer->data)->PatientStatus = "`4Awake";
											static_cast<PlayerInfo*>(peer->data)->PatientTemperatureRise = 0.35;
											float test = 106.5;
											float value = (int)(test * 100 + .5);
											float newvalue = (float)value / 100;
											static_cast<PlayerInfo*>(peer->data)->PatientTemperature = newvalue;
											static_cast<PlayerInfo*>(peer->data)->OperationSite = "`3Not sanitized";
											static_cast<PlayerInfo*>(peer->data)->PatientIncisions = 0;
											static_cast<PlayerInfo*>(peer->data)->IncisionsColor = "`3";
											static_cast<PlayerInfo*>(peer->data)->TempColor = "`3";
											static_cast<PlayerInfo*>(peer->data)->HardToSee = true;
											HardToSeeWork = true;
										}



										static_cast<PlayerInfo*>(peer->data)->PerformingSurgery = true;
										ENetPeer* currentPeer;
										for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer)
										{
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
											if (isHere(peer, currentPeer))
											{
												Player::OnConsoleMessage(currentPeer, "`7[```2" + static_cast<PlayerInfo*>(peer->data)->displayName + "`o is performing surgery on Surg-E!`7]``");
												Player::OnTalkBubble(currentPeer, static_cast<PlayerInfo*>(peer->data)->netID, "`7[```2" + static_cast<PlayerInfo*>(peer->data)->displayName + "`w is performing surgery on Surg-E!`7]``", 0, true);
											}
										}

										stringstream Temperaturas;
										Temperaturas << static_cast<PlayerInfo*>(peer->data)->PatientTemperature;
										auto PTemp = Temperaturas.str();
										if (HardToSeeWork) WorkSee = "\nadd_smalltext|`6It is becoming hard to see your work.``|left|";
										if (PatientLosingBlood) LosingBlood = "\nadd_smalltext|Patient is losing blood `3slowly.``|left|";
										if (static_cast<PlayerInfo*>(peer->data)->PerformingSurgery) Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wSurg-E``|left|18|\nadd_smalltext|" + static_cast<PlayerInfo*>(peer->data)->PatientDiagnosis + ".``|left|\nadd_smalltext|Pulse: " + static_cast<PlayerInfo*>(peer->data)->PatientPulse + "``    Status: " + static_cast<PlayerInfo*>(peer->data)->PatientStatus + "``|left|\nadd_smalltext|Temp: " + static_cast<PlayerInfo*>(peer->data)->TempColor + PTemp + "``    Operation site: " + static_cast<PlayerInfo*>(peer->data)->OperationSite + "``|left|" + WorkSee + "\nadd_smalltext|Incisions: " + static_cast<PlayerInfo*>(peer->data)->IncisionsColor + to_string(static_cast<PlayerInfo*>(peer->data)->PatientIncisions) + "``    |left|" + LosingBlood + "\nadd_spacer|small|\nadd_smalltext|`3The patient is prepped for surgery.``|left|\ntext_scaling_string|Defibrillator|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem1).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem1) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem1) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem2).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem2) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem2) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem3).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem3) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem3) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem4).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem4) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem4) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem5).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem5) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem5) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem6).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem6) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem6) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem7).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem7) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem7) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem8).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem8) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem8) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem9).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem9) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem9) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem10).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem10) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem10) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem11).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem11) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem11) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem12).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem12) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem12) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem13).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem13) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem13) + "|\nadd_button_with_icon|Empty Surgery Tray||noflags|4320||\nadd_button_with_icon|Empty Surgery Tray||noflags|4320||\nadd_button_with_icon||END_LIST|noflags|0||\nadd_button|cancel|Give up!|noflags|0|0|\nend_dialog|surge|||");
									}



								}
								if (issafewithdrawConfirmDialog)
								{
									if (world == nullptr || world->name == "EXIT" || serverIsFrozen) break;
									if (infoDat[0].substr(0, 13) == "safewithdraw_")
									{
										safe_withdrawConfirmCount = infoDat[1];
										if (safe_withdrawConfirmCount.size() > 5) break;
										string coord_and_apos = infoDat[0].erase(0, 13);
										string::size_type pos = coord_and_apos.find('_');
										if (pos != std::string::npos)
										{
											safe_withdrawConfirmCoord = coord_and_apos.substr(0, pos);
											coord_and_apos.erase(0, pos + 1);
											safe_withdrawConfirmApos = coord_and_apos;
										}
										else
										{
											autoBan(peer, false, 24 * 7, "Incorrect parameters issafewithdrawConfirmDialog. Coord and id were: " + coord_and_apos);
											break;
										}
										auto isdbox = std::experimental::filesystem::exists("safevault/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + safe_withdrawConfirmCoord + ".json");
										if (!isdbox)
										{
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4An error occured while getting safe vault info.", 0, true);
											break;
										}

										bool contains_non_int3 = !std::regex_match(safe_withdrawConfirmApos, std::regex("^[0-9]+$"));
										if (contains_non_int3 == true)
										{
											autoBan(peer, false, 24 * 7, "Proxy detect! issafewithdrawConfirmDialog apos was: " + safe_withdrawConfirmApos);
											break;
										}

										bool contains_non_int4 = !std::regex_match(safe_withdrawConfirmCount, std::regex("^[0-9]+$"));
										if (contains_non_int4 == true)
										{
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4Count should be only 1-200", 0, true);
											break;
										}
										safe_withdrawConfirmCountInt = atoi(safe_withdrawConfirmCount.c_str());

										safe_withdrawConfirmAposInt = atoi(safe_withdrawConfirmApos.c_str());

										if (safe_withdrawConfirmCountInt < 1 || safe_withdrawConfirmCountInt > 200)
										{
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4Count should be only 1-200", 0, true);
											break;
										}

										try
										{
											ifstream ifff("safevault/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + safe_withdrawConfirmCoord + ".json");
											json j;
											ifff >> j;
											ifff.close();

											int itemid = 0;
											bool success = true;

											for (int i = 0; i < 20; i++)
											{
												if (j["safe"][i]["aposition"] == safe_withdrawConfirmAposInt)
												{
													itemid = j["safe"][i]["itemid"];

													if (itemid == 0) break;

													if (safe_withdrawConfirmCountInt > j["safe"][i]["itemcount"])
													{
														Player::OnTextOverlay(peer, "`4Your safe vault does not contains such many.");
														break;
													}

													if (CheckItemExists(peer, j["safe"][i]["itemid"]))
													{
														int currentlyHave = GetQuantityOfItem(peer, j["safe"][i]["itemid"]);
														if (safe_withdrawConfirmCountInt + currentlyHave < 201)
														{
															SaveItemMoreTimes(j["safe"][i]["itemid"], safe_withdrawConfirmCountInt, peer, success);
														}
														else
														{
															Player::OnTextOverlay(peer, "`4You don't have enough space.");
															break;
														}
													}
													else
													{
														if (static_cast<PlayerInfo*>(peer->data)->inventory.items.size() == static_cast<PlayerInfo*>(peer->data)->currentInventorySize)
														{
															Player::OnTextOverlay(peer, "`4Your inventory is full! You can purchase an inventory upgrade in the shop.");
															break;
														}

														SaveItemMoreTimes(j["safe"][i]["itemid"], safe_withdrawConfirmCountInt, peer, success);
													}

													Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wRemoved " + to_string(safe_withdrawConfirmCountInt) + " " + itemDefs[itemid].name + " from the Safe Vault", 0, true);


													if (j["safe"][i]["itemcount"] == safe_withdrawConfirmCountInt)
													{
														j["safe"][i]["placedby"] = "There was " + to_string(safe_withdrawConfirmCountInt) + " of " + to_string(itemid) + " item, and " + static_cast<PlayerInfo*>(peer->data)->rawName + " withdrawed them.";
														j["safe"][i]["itemid"] = 0;
														j["safe"][i]["itemcount"] = 0;
														j["insafe"] = j["insafe"].get<double>() - 1;
													}
													else
													{
														j["safe"][i]["itemcount"] = j["safe"][i]["itemcount"].get<double>() - safe_withdrawConfirmCountInt;
													}

													ofstream of("safevault/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + safe_withdrawConfirmCoord + ".json");
													of << j << std::endl;
													of.close();
													break;
												}
											}
										}
										catch (std::exception&)
										{
											SendConsole("safewithdraw_ Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
											enet_peer_disconnect_now(peer, 0);
										}
										catch (std::runtime_error&)
										{
											SendConsole("safewithdraw_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
											enet_peer_disconnect_now(peer, 0);
										}
										catch (...)
										{
											SendConsole("safewithdraw_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
											enet_peer_disconnect_now(peer, 0);
										}
									}
								}
								if (isboxlvl2AddItemDialog)
								{
									if (infoDat[0].substr(0, 15) == "boxlvl2deposit_") boxlvl2AddItemDialog = infoDat[1];
									if (boxlvl1AddItemDialog.size() > 5) break;
									string coord = infoDat[0].substr(15, infoDat[0].length() - 1).c_str();
									int itemid = atoi(boxlvl2AddItemDialog.c_str());


									if (itemid < 1 || itemid > maxItems)
									{
										autoBan(peer, false, 24 * 7, "Proxy detect! In isboxlvl2AddItemDialog, item itemid was: " + to_string(itemid) + "");
										break;
									}
									if (itemid == 18 || itemid == 32 || itemid == 6336 || getItemDef(itemid).properties & Property_Untradable || getItemDef(itemid).blockType == BlockTypes::FISH || itemid == 8552 || itemid == 9472 || itemid == 9482 || itemid == 9356 || itemid == 9492 || itemid == 9498 || itemid == 8774 || itemid == 1790 || itemid == 2592 || itemid == 1784 || itemid == 1792 || itemid == 1794 || itemid == 7734 || itemid == 8306 || itemid == 9458)
									{
										Player::OnTextOverlay(peer, "`4You can't place " + getItemDef(itemid).name + ".");
										break;
									}



									auto issafe = std::experimental::filesystem::exists("storageboxlvl2/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
									if (!issafe)
									{
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4An error occured while getting Storage Box Xtreme - Level 2 info", 0, true);
										break;
									}

									int currentlyHave = 0;
									currentlyHave = GetQuantityOfItem(peer, itemid);

									auto contains = false;
									SearchInventoryItem(peer, itemid, currentlyHave, contains);
									if (!contains)
									{
										autoBan(peer, false, 24 * 7, "Used storage box lvl 2 exploit");
										break;
									}

									try
									{
										ifstream ifff("storageboxlvl2/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
										json j;
										ifff >> j;
										ifff.close();

										if (j["instorage"] > 19)
										{
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4Storage Box Xtreme - Level 2 is full!", 0, true);
											break;
										}

										GTDialog mysafe;
										mysafe.addLabelWithIcon("`wStorage Box Xtreme - Level 2 info", 6288, LABEL_BIG);
										mysafe.addSmallText("You have " + to_string(currentlyHave) + " " + getItemDef(itemid).name + ". How many to store?");
										mysafe.addInputBox("boxlvl2depositcount_" + coord + "_" + to_string(itemid) + "", "", "", 5);
										mysafe.addSpacer(SPACER_SMALL);
										mysafe.addButton("boxlvl2depositconfirm", "Store items");
										mysafe.addSpacer(SPACER_SMALL);
										mysafe.addQuickExit();
										mysafe.endDialog("Close", "", "Exit");
										Player::OnDialogRequest(peer, mysafe.finishDialog());
									}
									catch (std::exception&)
									{
										SendConsole("boxlvl2deposit_ Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_now(peer, 0);
									}
									catch (std::runtime_error&)
									{
										SendConsole("boxlvl2deposit_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_now(peer, 0);
									}
									catch (...)
									{
										SendConsole("boxlvl2deposit_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_now(peer, 0);
									}
								}
								if (isboxlvl3AddItemDialog)
								{
									if (infoDat[0].substr(0, 15) == "boxlvl3deposit_") boxlvl3AddItemDialog = infoDat[1];
									if (boxlvl1AddItemDialog.size() > 5) break;
									string coord = infoDat[0].substr(15, infoDat[0].length() - 1).c_str();
									int itemid = atoi(boxlvl3AddItemDialog.c_str());


									if (itemid < 1 || itemid > maxItems)
									{
										autoBan(peer, false, 24 * 7, "Proxy detect! In isboxlvl3AddItemDialog, item itemid was: " + to_string(itemid) + "");
										break;
									}
									if (itemid == 18 || itemid == 32 || itemid == 6336 || getItemDef(itemid).properties & Property_Untradable || getItemDef(itemid).blockType == BlockTypes::FISH || itemid == 8552 || itemid == 9472 || itemid == 9482 || itemid == 9356 || itemid == 9492 || itemid == 9498 || itemid == 8774 || itemid == 1790 || itemid == 2592 || itemid == 1784 || itemid == 1792 || itemid == 1794 || itemid == 7734 || itemid == 8306 || itemid == 9458)
									{
										Player::OnTextOverlay(peer, "`4You can't place " + getItemDef(itemid).name + ".");
										break;
									}

									auto issafe = std::experimental::filesystem::exists("storageboxlvl3/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
									if (!issafe)
									{
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4An error occured while getting Storage Box Xtreme - Level 3 info", 0, true);
										break;
									}

									int currentlyHave = 0;
									currentlyHave = GetQuantityOfItem(peer, itemid);

									auto contains = false;
									SearchInventoryItem(peer, itemid, currentlyHave, contains);
									if (!contains)
									{
										autoBan(peer, false, 24 * 7, "Used storage box lvl 3 exploit");
										break;
									}

									try
									{
										ifstream ifff("storageboxlvl3/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
										json j;
										ifff >> j;
										ifff.close();

										if (j["instorage"] > 19)
										{
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4Storage Box Xtreme - Level 3 is full!", 0, true);
											break;
										}

										GTDialog mysafe;
										mysafe.addLabelWithIcon("`wStorage Box Xtreme - Level 3 info", 6290, LABEL_BIG);
										mysafe.addSmallText("You have " + to_string(currentlyHave) + " " + getItemDef(itemid).name + ". How many to store?");
										mysafe.addInputBox("boxlvl3depositcount_" + coord + "_" + to_string(itemid) + "", "", "", 5);
										mysafe.addSpacer(SPACER_SMALL);
										mysafe.addButton("boxlvl3depositconfirm", "Store items");
										mysafe.addSpacer(SPACER_SMALL);
										mysafe.addQuickExit();
										mysafe.endDialog("Close", "", "Exit");
										Player::OnDialogRequest(peer, mysafe.finishDialog());
									}
									catch (std::exception&)
									{
										SendConsole("boxlvl3deposit_ Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_now(peer, 0);
									}
									catch (std::runtime_error&)
									{
										SendConsole("boxlvl3deposit_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_now(peer, 0);
									}
									catch (...)
									{
										SendConsole("boxlvl3deposit_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_now(peer, 0);
									}
								}
								if (isboxlvl1AddItemDialog)
								{
									if (infoDat[0].substr(0, 15) == "boxlvl1deposit_") boxlvl1AddItemDialog = infoDat[1];
									if (boxlvl1AddItemDialog.size() > 5) break;
									string coord = infoDat[0].substr(15, infoDat[0].length() - 1).c_str();
									int itemid = atoi(boxlvl1AddItemDialog.c_str());


									if (itemid < 1 || itemid > maxItems)
									{
										autoBan(peer, false, 24 * 7, "Proxy detect! In isaddItemToDonationBox, item itemid was: " + to_string(itemid) + "");
										break;
									}
									if (itemid == 18 || itemid == 32 || itemid == 6336 || getItemDef(itemid).properties & Property_Untradable || getItemDef(itemid).blockType == BlockTypes::FISH || itemid == 8552 || itemid == 9472 || itemid == 9482 || itemid == 9356 || itemid == 9492 || itemid == 9498 || itemid == 8774 || itemid == 1790 || itemid == 2592 || itemid == 1784 || itemid == 1792 || itemid == 1794 || itemid == 7734 || itemid == 8306 || itemid == 9458)
									{
										Player::OnTextOverlay(peer, "`4You can't place " + getItemDef(itemid).name + ".");
										break;
									}

									auto issafe = std::experimental::filesystem::exists("storageboxlvl1/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
									if (!issafe)
									{
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4An error occured while getting Storage Box Xtreme - Level 1 info", 0, true);
										break;
									}

									int currentlyHave = 0;
									currentlyHave = GetQuantityOfItem(peer, itemid);

									auto contains = false;
									SearchInventoryItem(peer, itemid, currentlyHave, contains);
									if (!contains)
									{
										autoBan(peer, false, 24 * 7, "Used storage box lvl 1 exploit");
										break;
									}

									try
									{
										ifstream ifff("storageboxlvl1/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
										json j;
										ifff >> j;
										ifff.close();

										if (j["instorage"] > 19)
										{
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4Storage Box Xtreme - Level 1 is full!", 0, true);
											break;
										}

										GTDialog mysafe;
										mysafe.addLabelWithIcon("`wStorage Box Xtreme - Level 1 info", 6286, LABEL_BIG);
										mysafe.addSmallText("You have " + to_string(currentlyHave) + " " + getItemDef(itemid).name + ". How many to store?");
										mysafe.addInputBox("boxlvl1depositcount_" + coord + "_" + to_string(itemid) + "", "", "", 5);
										mysafe.addSpacer(SPACER_SMALL);
										mysafe.addButton("boxlvl1depositconfirm", "Store items");
										mysafe.addSpacer(SPACER_SMALL);
										mysafe.addQuickExit();
										mysafe.endDialog("Close", "", "Exit");
										Player::OnDialogRequest(peer, mysafe.finishDialog());
									}
									catch (std::exception&)
									{
										SendConsole("boxlvl1deposit_ Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_now(peer, 0);
									}
									catch (std::runtime_error&)
									{
										SendConsole("boxlvl1deposit_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_now(peer, 0);
									}
									catch (...)
									{
										SendConsole("boxlvl1deposit_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_now(peer, 0);
									}
								}
								if (isMyTradeDialog)
								{
									if (infoDat[0].substr(0, 14) == "trademypicker_") {
										MyTradeItem = infoDat[1];
										if (SafeAddItemDialog.size() > 5) break;
										string number = infoDat[0].substr(14, infoDat[0].length() - 1).c_str();
										bool contains_non_int3 = !std::regex_match(number, std::regex("^[0-9]+$"));
										if (contains_non_int3 == true)
										{
											autoBan(peer, false, 24 * 7, "Proxy detect! isMyTradeDialog number was: " + number);
											break;
										}
										if (number.size() != 1)
										{
											autoBan(peer, false, 24 * 7, "Proxy detect! isMyTradeDialog number was: " + number);
											break;
										}
										if (number != "1" && number != "2" && number != "3" && number != "4")
										{
											autoBan(peer, false, 24 * 7, "Proxy detect! isMyTradeDialog number was: " + number);
											break;
										}

										int itemid = atoi(MyTradeItem.c_str());
										if (itemid < 1 || itemid > maxItems)
										{
											autoBan(peer, false, 24 * 7, "Proxy detect! In isMyTradeDialog, item itemid was: " + to_string(itemid) + "");
											break;
										}
										if (itemid == 18 || itemid == 3308 || itemid == 32 || itemid == 6336 || getItemDef(itemid).properties & Property_Untradable || getItemDef(itemid).blockType == BlockTypes::FISH || itemid == 8552 || itemid == 9472 || itemid == 9482 || itemid == 9356 || itemid == 9492 || itemid == 9498 || itemid == 8774 || itemid == 1790 || itemid == 2592 || itemid == 1784 || itemid == 1792 || itemid == 1794 || itemid == 7734 || itemid == 8306 || itemid == 9458)
										{
											Player::OnConsoleMessage(peer, "`4You can't place " + getItemDef(itemid).name + ".");
											TradeMainMenu(peer);
											break;
										}
										if (number == "1")
										{
											static_cast<PlayerInfo*>(peer->data)->mySellingItem1 = to_string(itemid);
										}
										if (number == "2")
										{
											static_cast<PlayerInfo*>(peer->data)->mySellingItem2 = to_string(itemid);
										}
										if (number == "3")
										{
											static_cast<PlayerInfo*>(peer->data)->mySellingItem3 = to_string(itemid);
										}
										if (number == "4")
										{
											static_cast<PlayerInfo*>(peer->data)->mySellingItem4 = to_string(itemid);
										}

										GTDialog picker;
										if (number == "1")
										{
											if (static_cast<PlayerInfo*>(peer->data)->mySellingItem1 == "3308")
											{
												picker.addLabelWithIcon("`wSelect which item you want to sell.", 1434, LABEL_SMALL);
												picker.addSpacer(SPACER_SMALL);
												picker.addPicker("trademypicker_" + number, "Choose item for sell", "Select your item");
												picker.addSpacer(SPACER_SMALL);
												picker.addButton("trademypickerback", "Back to main.");
												picker.addQuickExit();
												picker.endDialog("", "", "");
												Player::OnDialogRequest(peer, picker.finishDialog());
											}
											else
											{
												picker.addLabelWithIcon("`wSelect which item you want to sell and how much.", 1434, LABEL_SMALL);
												picker.addSpacer(SPACER_SMALL);
												picker.addPicker("trademypicker_" + number, "Change item for sell", "Select your item");
												picker.addSpacer(SPACER_SMALL);
												picker.addSmallText("`$You have Selected: `2" + getItemDef(atoi(static_cast<PlayerInfo*>(peer->data)->mySellingItem1.c_str())).name);
												picker.addInputBox("trademypickercount_" + number, "Select how much you want to sell", "", 5);
												picker.addSpacer(SPACER_SMALL);
												picker.addButton("trademypickerconfirm", "Confirm");
												picker.addSpacer(SPACER_SMALL);
												picker.addButton("trademypickerback", "Back to main.");
												picker.addQuickExit();
												picker.endDialog("", "", "");
												Player::OnDialogRequest(peer, picker.finishDialog());
											}
										}

										if (number == "2")
										{
											if (static_cast<PlayerInfo*>(peer->data)->mySellingItem2 == "3308")
											{
												picker.addLabelWithIcon("`wSelect which item you want to sell.", 1434, LABEL_SMALL);
												picker.addSpacer(SPACER_SMALL);
												picker.addPicker("trademypicker_" + number, "Choose item for sell", "Select your item");
												picker.addSpacer(SPACER_SMALL);
												picker.addButton("trademypickerback", "Back to main.");
												picker.addQuickExit();
												picker.endDialog("", "", "");
												Player::OnDialogRequest(peer, picker.finishDialog());
											}
											else
											{
												picker.addLabelWithIcon("`wSelect which item you want to sell and how much.", 1434, LABEL_SMALL);
												picker.addSpacer(SPACER_SMALL);
												picker.addPicker("trademypicker_" + number, "Change item for sell", "Select your item");
												picker.addSpacer(SPACER_SMALL);
												picker.addSmallText("`$You have Selected: `2" + getItemDef(atoi(static_cast<PlayerInfo*>(peer->data)->mySellingItem2.c_str())).name);
												picker.addInputBox("trademypickercount_" + number, "Select how much you want to sell", "", 5);
												picker.addSpacer(SPACER_SMALL);
												picker.addButton("trademypickerconfirm", "Confirm");
												picker.addSpacer(SPACER_SMALL);
												picker.addButton("trademypickerback", "Back to main.");
												picker.addQuickExit();
												picker.endDialog("", "", "");
												Player::OnDialogRequest(peer, picker.finishDialog());
											}
										}

										if (number == "3")
										{
											if (static_cast<PlayerInfo*>(peer->data)->mySellingItem3 == "3308")
											{
												picker.addLabelWithIcon("`wSelect which item you want to sell.", 1434, LABEL_SMALL);
												picker.addSpacer(SPACER_SMALL);
												picker.addPicker("trademypicker_" + number, "Choose item for sell", "Select your item");
												picker.addSpacer(SPACER_SMALL);
												picker.addButton("trademypickerback", "Back to main.");
												picker.addQuickExit();
												picker.endDialog("", "", "");
												Player::OnDialogRequest(peer, picker.finishDialog());
											}
											else
											{
												picker.addLabelWithIcon("`wSelect which item you want to sell and how much.", 1434, LABEL_SMALL);
												picker.addSpacer(SPACER_SMALL);
												picker.addPicker("trademypicker_" + number, "Change item for sell", "Select your item");
												picker.addSpacer(SPACER_SMALL);
												picker.addSmallText("`$You have Selected: `2" + getItemDef(atoi(static_cast<PlayerInfo*>(peer->data)->mySellingItem3.c_str())).name);
												picker.addInputBox("trademypickercount_" + number, "Select how much you want to sell", "", 5);
												picker.addSpacer(SPACER_SMALL);
												picker.addButton("trademypickerconfirm", "Confirm");
												picker.addSpacer(SPACER_SMALL);
												picker.addButton("trademypickerback", "Back to main.");
												picker.addQuickExit();
												picker.endDialog("", "", "");
												Player::OnDialogRequest(peer, picker.finishDialog());
											}
										}

										if (number == "4")
										{
											if (static_cast<PlayerInfo*>(peer->data)->mySellingItem4 == "3308")
											{
												picker.addLabelWithIcon("`wSelect which item you want to sell.", 1434, LABEL_SMALL);
												picker.addSpacer(SPACER_SMALL);
												picker.addPicker("trademypicker_" + number, "Choose item for sell", "Select your item");
												picker.addSpacer(SPACER_SMALL);
												picker.addButton("trademypickerback", "Back to main.");
												picker.addQuickExit();
												picker.endDialog("", "", "");
												Player::OnDialogRequest(peer, picker.finishDialog());
											}
											else
											{
												picker.addLabelWithIcon("`wSelect which item you want to sell and how much.", 1434, LABEL_SMALL);
												picker.addSpacer(SPACER_SMALL);
												picker.addPicker("trademypicker_" + number, "Change item for sell", "Select your item");
												picker.addSpacer(SPACER_SMALL);
												picker.addSmallText("`$You have Selected: `2" + getItemDef(atoi(static_cast<PlayerInfo*>(peer->data)->mySellingItem4.c_str())).name);
												picker.addInputBox("trademypickercount_" + number, "Select how much you want to sell", "", 5);
												picker.addSpacer(SPACER_SMALL);
												picker.addButton("trademypickerconfirm", "Confirm");
												picker.addSpacer(SPACER_SMALL);
												picker.addButton("trademypickerback", "Back to main.");
												picker.addQuickExit();
												picker.endDialog("", "", "");
												Player::OnDialogRequest(peer, picker.finishDialog());
											}
										}
									}
								}
								if (isMergeDialog)
								{
									if (infoDat[0].substr(0, 12) == "mergepicker_") {
										MyTradeItem = infoDat[1];
										//if (SafeAddItemDialog.size() > 5) break;
										string number = infoDat[0].substr(12, infoDat[0].length() - 1).c_str();
										bool contains_non_int3 = !std::regex_match(number, std::regex("^[0-9]+$"));
										if (contains_non_int3 == true)
										{
											autoBan(peer, false, 24 * 7, "Proxy detect! isMergeDialog number was: " + number);
											break;
										}
										if (number.size() != 1)
										{
											autoBan(peer, false, 24 * 7, "Proxy detect! isMergeDialog number was: " + number);
											break;
										}
										if (number != "1" && number != "2")
										{
											autoBan(peer, false, 24 * 7, "Proxy detect! isMergeDialog number was: " + number);
											break;
										}

										int itemid = atoi(MyTradeItem.c_str());
										if (itemid < 1 || itemid > maxItems)
										{
											autoBan(peer, false, 24 * 7, "Proxy detect! In isMergeDialog, item itemid was: " + to_string(itemid) + "");
											break;
										}
										if (itemid == 18 || itemid == 3308 || itemid == 32 || getItemDef(itemid).blockType != BlockTypes::FOREGROUND && getItemDef(itemid).blockType != BlockTypes::BACKGROUND && getItemDef(itemid).blockType != BlockTypes::PAIN_BLOCK && getItemDef(itemid).blockType != BlockTypes::GROUND_BLOCK || itemid == 6336 || getItemDef(itemid).properties & Property_Untradable || getItemDef(itemid).blockType == BlockTypes::FISH || itemid == 8552 || itemid == 9472 || itemid == 9482 || itemid == 9356 || itemid == 9492 || itemid == 9498 || itemid == 8774 || itemid == 1790 || itemid == 2592 || itemid == 1784 || itemid == 1792 || itemid == 1794 || itemid == 7734 || itemid == 8306 || itemid == 9458)
										{
											SendMergeDialog(peer, atoi(static_cast<PlayerInfo*>(peer->data)->MergeItem1.c_str()), atoi(static_cast<PlayerInfo*>(peer->data)->MergeItem2.c_str()), 0, "|\nadd_label_with_icon|small|Cant merge " + getItemDef(itemid).name + "!|left|1432|");
											break;
										}
										if (number == "1")
										{
											if (static_cast<PlayerInfo*>(peer->data)->MergeItem2 == to_string(itemid))
											{
												SendMergeDialog(peer, atoi(static_cast<PlayerInfo*>(peer->data)->MergeItem1.c_str()), atoi(static_cast<PlayerInfo*>(peer->data)->MergeItem2.c_str()), 0, "|\nadd_label_with_icon|small|Cant merge " + getItemDef(itemid).name + "!|left|1432|");
												break;
											}
											static_cast<PlayerInfo*>(peer->data)->MergeItem1 = to_string(itemid);
										}
										if (number == "2")
										{
											if (static_cast<PlayerInfo*>(peer->data)->MergeItem1 == to_string(itemid))
											{
												SendMergeDialog(peer, atoi(static_cast<PlayerInfo*>(peer->data)->MergeItem1.c_str()), atoi(static_cast<PlayerInfo*>(peer->data)->MergeItem2.c_str()), 0, "|\nadd_label_with_icon|small|Cant merge " + getItemDef(itemid).name + "!|left|1432|");
												break;
											}
											static_cast<PlayerInfo*>(peer->data)->MergeItem2 = to_string(itemid);
										}
										SendMergeDialog(peer, atoi(static_cast<PlayerInfo*>(peer->data)->MergeItem1.c_str()), atoi(static_cast<PlayerInfo*>(peer->data)->MergeItem2.c_str()), 0, "");
									}
								}
								if (isSafeAddItemDialog)
								{
									if (infoDat[0].substr(0, 12) == "safedeposit_") SafeAddItemDialog = infoDat[1];
									if (SafeAddItemDialog.size() > 5) break;
									string coord = infoDat[0].substr(12, infoDat[0].length() - 1).c_str();
									int itemid = atoi(SafeAddItemDialog.c_str());


									if (itemid < 1 || itemid > maxItems)
									{
										autoBan(peer, false, 24 * 7, "Proxy detect! In isSafeAddItemDialog, item itemid was: " + to_string(itemid) + "");
										break;
									}
									if (itemid == 18 || itemid == 32 || itemid == 6336 || getItemDef(itemid).properties & Property_Untradable || getItemDef(itemid).blockType == BlockTypes::FISH || itemid == 8552 || itemid == 9472 || itemid == 9482 || itemid == 9356 || itemid == 9492 || itemid == 9498 || itemid == 8774 || itemid == 1790 || itemid == 2592 || itemid == 1784 || itemid == 1792 || itemid == 1794 || itemid == 7734 || itemid == 8306 || itemid == 9458)
									{
										Player::OnTextOverlay(peer, "`4You can't place " + getItemDef(itemid).name + ".");
										break;
									}

									auto issafe = std::experimental::filesystem::exists("safevault/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
									if (!issafe)
									{
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4An error occured while getting donation box info.", 0, true);
										break;
									}

									int currentlyHave = 0;
									currentlyHave = GetQuantityOfItem(peer, itemid);

									auto contains = false;
									SearchInventoryItem(peer, itemid, currentlyHave, contains);
									if (!contains)
									{
										autoBan(peer, false, 24 * 7, "Used safe vault exploit");
										break;
									}

									try
									{
										ifstream ifff("safevault/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
										json j;
										ifff >> j;
										ifff.close();

										if (j["insafe"] > 19)
										{
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4Safe Vault is full!", 0, true);
											break;
										}

										GTDialog mysafe;
										mysafe.addLabelWithIcon("`wSafe fault", 8878, LABEL_BIG);
										mysafe.addSmallText("You have " + to_string(currentlyHave) + " " + getItemDef(itemid).name + ". How many to store?");
										mysafe.addInputBox("safedepositcount_" + coord + "_" + to_string(itemid) + "", "", "", 5);
										mysafe.addSpacer(SPACER_SMALL);
										mysafe.addQuickExit();
										mysafe.endDialog("safedepositconfirm", "Store items", "Cancel");
										Player::OnDialogRequest(peer, mysafe.finishDialog());
									}
									catch (std::exception&)
									{
										SendConsole("safedeposit_ Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_now(peer, 0);
									}
									catch (std::runtime_error&)
									{
										SendConsole("safedeposit_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_now(peer, 0);
									}
									catch (...)
									{
										SendConsole("safedeposit_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_now(peer, 0);
									}
								}
								if (issafedepositconfirmDialog)
								{
									if (world == nullptr || world->name == "EXIT" || serverIsFrozen) break;
									if (infoDat[0].substr(0, 17) == "safedepositcount_")
									{
										safedepositcount = infoDat[1];

										string coord_and_id = infoDat[0].erase(0, 17);
										string::size_type pos = coord_and_id.find('_');
										if (pos != std::string::npos)
										{
											safedepositcoord = coord_and_id.substr(0, pos);
											coord_and_id.erase(0, pos + 1);
											safedeposititemID = coord_and_id;
										}
										else
										{
											autoBan(peer, false, 24 * 7, "Incorrect parameters issafedepositconfirmDialog. Coord and id were: " + coord_and_id);
											break;
										}
										auto isdbox = std::experimental::filesystem::exists("safevault/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + safedepositcoord + ".json");
										if (!isdbox)
										{
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4An error occured while getting safe vault info.", 0, true);
											break;
										}

										bool contains_non_int3 = !std::regex_match(safedeposititemID, std::regex("^[0-9]+$"));
										if (contains_non_int3 == true)
										{
											autoBan(peer, false, 24 * 7, "Proxy detect! issafedepositconfirmDialog item id was: " + safedeposititemID);
											break;
										}

										bool contains_non_int4 = !std::regex_match(safedepositcount, std::regex("^[0-9]+$"));
										if (contains_non_int4 == true)
										{
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4Count should be only 1-200", 0, true);
											break;
										}
										givesafeitemCountInt = atoi(safedepositcount.c_str());

										givesafeitemItemIDInt = atoi(safedeposititemID.c_str());
										if (givesafeitemItemIDInt < 1 || givesafeitemItemIDInt > maxItems)
										{
											autoBan(peer, false, 24 * 7, "Proxy detect! In issafedepositconfirmDialog, givesafeitemItemIDInt was: " + to_string(givesafeitemItemIDInt) + "");
											break;
										}

										if (givesafeitemCountInt < 1 || givesafeitemCountInt > 200)
										{
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4Count should be only 1-200", 0, true);
											break;
										}

										try
										{
											ifstream ifff("safevault/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + safedepositcoord + ".json");
											json j;
											ifff >> j;
											ifff.close();

											if (j["insafe"] > 19)
											{
												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4Safe fault is full!", 0, true);
												break;
											}
											bool isContains = false;
											SearchInventoryItem(peer, givesafeitemItemIDInt, givesafeitemCountInt, isContains);
											if (isContains == false)
											{
												Player::OnTextOverlay(peer, "`4You don't have enough " + itemDefs[givesafeitemItemIDInt].name + " in your inventory.");
												break;
											}
											j["insafe"] = j["insafe"].get<double>() + 1;

											for (int i = 0; i < 20; i++)
											{
												if (j["safe"][i]["itemid"] == 0)
												{
													j["safe"][i]["itemid"] = givesafeitemItemIDInt;
													j["safe"][i]["itemcount"] = givesafeitemCountInt;
													j["safe"][i]["placedby"] = static_cast<PlayerInfo*>(peer->data)->rawName;
													Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wStored " + to_string(givesafeitemCountInt) + " " + itemDefs[givesafeitemItemIDInt].name + " in the Safe Vault", 0, true);
													break;
												}
											}

											ofstream of("safevault/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + safedepositcoord + ".json");
											of << j << std::endl;
											of.close();
											RemoveInventoryItem(givesafeitemItemIDInt, givesafeitemCountInt, peer, true);
											updateplayerset(peer, givesafeitemItemIDInt);
										}
										catch (std::exception&)
										{
											SendConsole("safedepositcount_ Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
											enet_peer_disconnect_now(peer, 0);
										}
										catch (std::runtime_error&)
										{
											SendConsole("safedepositcount_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
											enet_peer_disconnect_now(peer, 0);
										}
										catch (...)
										{
											SendConsole("safedepositcount_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
											enet_peer_disconnect_now(peer, 0);
										}
									}
								}
								if (isEditDoorDialog)
								{
									if (world == nullptr || world->name == "EXIT" || serverIsFrozen) continue;
									if (infoDat[0] == "dest")
									{
										string a = getStrUpper(infoDat[1]);
										vector<string> b = explode(":", a);
										if (b.size() == 1)
										{
											destworld = b[0];
										}
										else if (b.size() > 1)
										{
											destworld = b[0];
											destid = b[1];
										}
									}
									if (infoDat[0] == "label")
									{
										label = infoDat[1];
									}
									if (infoDat[0] == "doorid")
									{
										currid = getStrUpper(infoDat[1]);
									}
									if (infoDat[0] == "doorpw")
									{
										passwordss = getStrUpper(infoDat[1]);
									}
								}
								if (signEditor)
								{
									if (world == nullptr || world->name == "EXIT" || serverIsFrozen) continue;
									if (infoDat[0] == "signtextas") message321 = infoDat[1];
								}
								if (isLockDialog)
								{
									if (world == nullptr || world->name == "EXIT" || serverIsFrozen) continue;
									if (infoDat[0] == "playerNetID") playerNetId = infoDat[1];
									if (infoDat[0] == "checkbox_muted") muted = infoDat[1];
									if (infoDat[0] == "minimum_level") minimum_level = infoDat[1];
								}
								if (isEntranceDialog) {
									if (infoDat[0] == "opentopublic")
									{
										entranceresult = infoDat[1];
										if (entranceresult != "0" && entranceresult != "1") break;
										if (getItemDef(world->items[static_cast<PlayerInfo*>(peer->data)->wrenchx + (static_cast<PlayerInfo*>(peer->data)->wrenchy * world->width)].foreground).blockType != BlockTypes::GATEWAY) break;
										if (static_cast<PlayerInfo*>(peer->data)->rawName != PlayerDB::getProperName(world->owner) && !isMod(peer)) break;
										int squar = static_cast<PlayerInfo*>(peer->data)->wrenchx + (static_cast<PlayerInfo*>(peer->data)->wrenchy * world->width);
										auto currentworld = world->name + "/X" + std::to_string(squar);
										auto isheartm = std::experimental::filesystem::exists("gateway/" + currentworld + ".txt");

										if (!isheartm)
										{
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4Error!", 0, true);
											break;
										}
										ofstream os("gateway/" + currentworld + ".txt");
										os << entranceresult;
										os.close();
										updateEntrance(peer, world->items[static_cast<PlayerInfo*>(peer->data)->wrenchx + (static_cast<PlayerInfo*>(peer->data)->wrenchy * world->width)].foreground, static_cast<PlayerInfo*>(peer->data)->wrenchx, static_cast<PlayerInfo*>(peer->data)->wrenchy, entranceresult == "0" ? 0 : 1, world->items[static_cast<PlayerInfo*>(peer->data)->wrenchx + (static_cast<PlayerInfo*>(peer->data)->wrenchy * world->width)].background, true);
										break;
									}
								}
								if (MagUpdateDialog)
								{
									if (world == nullptr || world->name == "EXIT" || serverIsFrozen) continue;
									if (infoDat[0] == "checkbox_publicremote")
									{
										publicremote = infoDat[1];
										if (publicremote != "1" && publicremote != "0") break;
										if (isWorldOwner(peer, world) || isMod(peer))
										{
											int x = static_cast<PlayerInfo*>(peer->data)->lastPunchX;
											int y = static_cast<PlayerInfo*>(peer->data)->lastPunchY;
											int squaresign = x + (y * 100);
											string currentworld = static_cast<PlayerInfo*>(peer->data)->currentWorld + "X" + std::to_string(squaresign);
											string status = "0";
											if (publicremote == "1") status = "true";
											else if (publicremote == "0") status = "false";
											ofstream fdss("magplant/publicremote/" + currentworld + ".txt");
											fdss << status;
											fdss.close();
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "Finished!", 0, true);
											break;
										}
									}
								}
								if (isGrowscan && btn.substr(0, 4) == "item")
								{
									if (world == nullptr || world->name == "EXIT" || serverIsFrozen) continue;
									int Id = atoi(btn.substr(4, btn.length() - 4).c_str());
									int intid = atoi(btn.substr(4, btn.length() - 4).c_str());
									string ide = btn.substr(4, btn.length() - 4).c_str();
									sendArrow(peer, Id, true);
								}
								if (isgivedonationboxitemConfirm)
								{
									if (world == nullptr || world->name == "EXIT" || serverIsFrozen) break;
									if (infoDat[0].substr(0, 25) == "givedonationboxitemCount_")
									{
										givedonationboxitemCount = infoDat[1];
										string coord_and_id = infoDat[0].erase(0, 25);
										string::size_type pos = coord_and_id.find('_');
										if (pos != std::string::npos)
										{
											givedonationboxitemCoord = coord_and_id.substr(0, pos);
											coord_and_id.erase(0, pos + 1);
											givedonationboxitemItemID = coord_and_id;
										}
										else
										{
											autoBan(peer, false, 24 * 7, "Incorrect parameters isgivedonationboxitemConfirm. Coord and id were: " + coord_and_id);
											break;
										}
										auto isdbox = std::experimental::filesystem::exists("donationboxes/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + givedonationboxitemCoord + ".json");
										if (!isdbox)
										{
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4An error occured while getting donation box info.", 0, true);
											break;
										}
										bool contains_non_int3 = !std::regex_match(givedonationboxitemItemID, std::regex("^[0-9]+$"));
										if (contains_non_int3 == true)
										{
											autoBan(peer, false, 24 * 7, "Proxy detect! isgivedonationboxitemConfirm id was: " + givedonationboxitemItemID);
											break;
										}
										bool contains_non_int4 = !std::regex_match(givedonationboxitemCount, std::regex("^[0-9]+$"));
										if (contains_non_int4 == true)
										{
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4Count should be only 1-200", 0, true);
											break;
										}
										givedonationboxitemCountInt = atoi(givedonationboxitemCount.c_str());
										givedonationboxitemItemIDInt = atoi(givedonationboxitemItemID.c_str());
										if (givedonationboxitemItemIDInt < 1 || givedonationboxitemItemIDInt > maxItems)
										{
											autoBan(peer, false, 24 * 7, "Proxy detect! In isgivedonationboxitemConfirm, givedonationboxitemCountInt was: " + to_string(givedonationboxitemItemIDInt) + "");
											break;
										}

										if (getItemDef(givedonationboxitemItemIDInt).rarity < 2)
										{
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4You can donate items higher than 2 rarity!", 0, true);
											break;
										}
										if (givedonationboxitemCountInt < 1 || givedonationboxitemCountInt > 200)
										{
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4Count should be only 1-200", 0, true);
											break;
										}
									}
									if (infoDat[0] == "givedonationboxitemNote")
									{
										givedonationboxitemNote = infoDat[1];
										if (givedonationboxitemNote.size() < 1 || givedonationboxitemNote.size() > 50)
										{
											Player::OnTextOverlay(peer, "`4The note should be at least 1 letter.");
											break;
										}
										try
										{
											ifstream ifff("donationboxes/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + givedonationboxitemCoord + ".json");
											json j;
											ifff >> j;
											ifff.close();
											if (j["donated"] > 19)
											{
												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4Donation box is full!", 0, true);
												break;
											}
											bool isContains = false;
											SearchInventoryItem(peer, givedonationboxitemItemIDInt, givedonationboxitemCountInt, isContains);
											if (isContains == false)
											{
												autoBan(peer, false, 24 * 7, "Used donate box exploit");
												break;
											}
											j["donated"] = j["donated"].get<double>() + 1;
											for (int i = 0; i < 20; i++)
											{
												if (j["donatedItems"][i]["itemid"] == 0)
												{
													j["donatedItems"][i]["itemid"] = givedonationboxitemItemIDInt;
													j["donatedItems"][i]["itemcount"] = givedonationboxitemCountInt;
													j["donatedItems"][i]["sentBy"] = static_cast<PlayerInfo*>(peer->data)->displayName;
													j["donatedItems"][i]["note"] = givedonationboxitemNote;
													ENetPeer* currentPeer;
													for (currentPeer = server->peers;
														currentPeer < &server->peers[server->peerCount];
														++currentPeer)
													{
														if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
														if (isHere(peer, currentPeer))
														{
															Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`w[`5[`w" + static_cast<PlayerInfo*>(peer->data)->displayName + " `wplaces `5" + to_string(givedonationboxitemCountInt) + " `2" + getItemDef(givedonationboxitemItemIDInt).name + " `winto the Donation Box`5]`w]", 0, true);
															Player::OnConsoleMessage(currentPeer, "`w[`5[`w" + static_cast<PlayerInfo*>(peer->data)->displayName + " `wplaces `5" + to_string(givedonationboxitemCountInt) + " `2" + getItemDef(givedonationboxitemItemIDInt).name + " `winto the Donation Box`5]`w]");
															if (static_cast<PlayerInfo*>(peer->data)->lastPunchX >= 0 && static_cast<PlayerInfo*>(peer->data)->lastPunchY >= 0)
															{
																SendItemPacket(currentPeer, 1452, 0, static_cast<PlayerInfo*>(peer->data)->lastPunchX, static_cast<PlayerInfo*>(peer->data)->lastPunchY, 1);
															}
														}
													}
													break;
												}
											}
											ofstream of("donationboxes/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + givedonationboxitemCoord + ".json");
											of << j << std::endl;
											of.close();
											RemoveInventoryItem(givedonationboxitemItemIDInt, givedonationboxitemCountInt, peer, true);
											updateplayerset(peer, givedonationboxitemItemIDInt);
										}
										catch (std::exception&)
										{
											SendConsole("givedonationboxitemCount_ Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
											enet_peer_disconnect_now(peer, 0);
										}
										catch (std::runtime_error&)
										{
											SendConsole("givedonationboxitemCount_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
											enet_peer_disconnect_now(peer, 0);
										}
										catch (...)
										{
											SendConsole("givedonationboxitemCount_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
											enet_peer_disconnect_now(peer, 0);
										}
									}
								}

								if (isaddItemToDonationBox)
								{
									if (world == nullptr || world->name == "EXIT" || serverIsFrozen) break;
									if (infoDat[0].substr(0, 16) == "addDonationItem_") addItemToDonationBox = infoDat[1];
									if (addItemToDonationBox.size() > 5) break;
									string coord = infoDat[0].substr(16, infoDat[0].length() - 1).c_str();
									int itemid = atoi(addItemToDonationBox.c_str());


									if (itemid < 1 || itemid > maxItems)
									{
										autoBan(peer, false, 24 * 7, "Proxy detect! In isaddItemToDonationBox, item itemid was: " + to_string(itemid) + "");
										break;
									}
									if (itemid == 18 || itemid == 32 || itemid == 6336 || itemid == 8552 || getItemDef(itemid).blockType == BlockTypes::FISH)
									{
										Player::OnTextOverlay(peer, "`4You can't donate " + getItemDef(itemid).name + ".");
										break;
									}

									if (getItemDef(itemid).rarity < 2)
									{
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4You can donate items higher than 2 rarity!", 0, true);
										break;
									}

									auto isdbox = std::experimental::filesystem::exists("donationboxes/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
									if (!isdbox)
									{
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4An error occured while getting donation box info.", 0, true);
										break;
									}

									try
									{
										ifstream ifff("donationboxes/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
										json j;
										ifff >> j;
										ifff.close();

										if (j["donated"] > 19)
										{
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4Donation box is full!", 0, true);
											break;
										}

										GTDialog myDbox;
										myDbox.addLabelWithIcon(getItemDef(itemid).name, itemid, LABEL_BIG);
										myDbox.addSmallText("`$How many to put in the box as a gift? (Note: you will `4LOSE `$the items you give!)");
										myDbox.addInputBox("givedonationboxitemCount_" + coord + "_" + to_string(itemid) + "", "Count:", "", 5);
										myDbox.addSpacer(SPACER_SMALL);
										myDbox.addInputBox("givedonationboxitemNote", "Optional Note:", "", 50);

										myDbox.addSpacer(SPACER_SMALL);
										myDbox.addQuickExit();
										myDbox.endDialog("givedonationboxitemConfirm", "`4Give the item(s)", "Cancel");
										Player::OnDialogRequest(peer, myDbox.finishDialog());
									}
									catch (std::exception&)
									{
										SendConsole("addDonationItem_ Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_now(peer, 0);
									}
									catch (std::runtime_error&)
									{
										SendConsole("addDonationItem_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_now(peer, 0);
									}
									catch (...)
									{
										SendConsole("addDonationItem_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_now(peer, 0);
									}
								}
								if (isEditDoorDialog)
								{
									if (world == nullptr || world->name == "EXIT" || serverIsFrozen) continue;
									PlayerInfo* pinfo = static_cast<PlayerInfo*>(peer->data);
									string wrldname = destworld;
									if (pinfo->wrenchsession < 0 || pinfo->wrenchsession > 6000) break;
									ofstream DestWorld("door/destworld/" + pinfo->currentWorld + "X" + to_string(pinfo->wrenchsession) + ".txt");
									DestWorld << destworld;
									DestWorld.close();
									world->items[pinfo->wrenchsession].destWorld = destworld;
									ofstream DestId("door/destid/" + pinfo->currentWorld + "X" + to_string(pinfo->wrenchsession) + ".txt");
									DestId << destid;
									DestId.close();
									world->items[pinfo->wrenchsession].destId = destid;
									ofstream CurrId("door/currid/" + pinfo->currentWorld + "X" + to_string(pinfo->wrenchsession) + ".txt");
									CurrId << currid;
									CurrId.close();
									world->items[pinfo->wrenchsession].currId = currid;
									ofstream Label("door/label/" + pinfo->currentWorld + "X" + to_string(pinfo->wrenchsession) + ".txt");
									Label << label;
									Label.close();
									world->items[pinfo->wrenchsession].label = label;
									ofstream Password("door/password/" + pinfo->currentWorld + "X" + to_string(pinfo->wrenchsession) + ".txt");
									Password << passwordss;
									Password.close();
									world->items[pinfo->wrenchsession].password = passwordss;
									string labelForDoor = label == "" ? (destid == "" ? destworld : destworld + "...") : label;
									updateDoor(peer, world->items[pinfo->wrenchsession].foreground, pinfo->wrenchsession % world->width, pinfo->wrenchsession / world->width, labelForDoor);
								}
								if (isbuyPlayerStoreItemDialog)
								{
									if (world == nullptr || world->name == "EXIT" || serverIsFrozen) continue;
									if (infoDat[0].substr(0, 23) == "buyPlayerStoreQuantity_")
									{
										buyPlayerStoreQuantity = infoDat[1];
										string pos_and_whoseStore = infoDat[0].erase(0, 23);
										string::size_type pos = pos_and_whoseStore.find('_');
										string apos = "";
										string whosStore = "";
										if (pos != std::string::npos)
										{
											apos = pos_and_whoseStore.substr(0, pos);
											pos_and_whoseStore.erase(0, pos + 1); // +1, kad "_" erase
											whosStore = pos_and_whoseStore;
										}
										else
										{
											autoBan(peer, false, 24 * 7, "Incorrect parameters in isbuyPlayerStoreItemDialog . Was:" + pos_and_whoseStore);
											break;
										}
										bool contains_non_int2 = !std::regex_match(apos, std::regex("^[0-9]+$"));
										if (contains_non_int2 == true)
										{
											autoBan(peer, false, 24 * 7, "Incorrect aPos in isbuyPlayerStoreItemDialog .Was: " + apos);
											break;
										}
										bool existx = std::experimental::filesystem::exists("store/" + PlayerDB::getProperName(whosStore) + ".json");
										if (!existx)
										{
											Player::OnTextOverlay(peer, "`4Store does not exist");
											break;
										}
										buyPlayerStoreAposition = apos;
										buyPlayerStoreName = whosStore;
										if (buyPlayerStoreAposition.size() > 4 || buyPlayerStoreAposition.size() <= 0) break;
										int a_pos = stoi(buyPlayerStoreAposition);
										string name = buyPlayerStoreName;
										bool contains_non_int3 = !std::regex_match(buyPlayerStoreQuantity, std::regex("^[0-9]+$"));
										if (contains_non_int3 == true)
										{
											Player::OnTextOverlay(peer, "`4Quantity should be 1-200");
											break;
										}
										if (buyPlayerStoreQuantity.size() > 3 || buyPlayerStoreQuantity.size() <= 0) break;
										int quantityBuy = stoi(buyPlayerStoreQuantity);
										if (quantityBuy < 1 || quantityBuy > 200)
										{
											Player::OnTextOverlay(peer, "`4Quantity should be 1-200");
											break;
										}
										try
										{
											ifstream ifff("store/" + PlayerDB::getProperName(name) + ".json");
											json j;
											ifff >> j;
											ifff.close();
											bool found = false;
											bool error = false;
											bool error2 = false;
											for (int i = 0; i < j["itemsInStore"].size(); i++)
											{
												if (j["itemsInStore"][i]["aposition"] == a_pos)
												{
													found = true;
													if (j["itemsInStore"][i]["itemid"] == 0)
													{
														error = true;
														break;
													}
													if (j["itemsInStore"][i]["quantityOfItems"] == 0)
													{
														error2 = true;
														break;
													}
													int itemprice = j["itemsInStore"][i]["sellForItem"];
													int itempricePer = j["itemsInStore"][i]["sellPer"];
													int itemId = j["itemsInStore"][i]["itemid"];
													int quantity = j["itemsInStore"][i]["quantityOfItems"];
													if (quantityBuy > quantity)
													{
														Player::OnTextOverlay(peer, "`4There is no in shop " + to_string(quantityBuy) + " items.");
														break;
													}
													if (CheckItemExists(peer, j["itemsInStore"][i]["sellForItem"]) == false)
													{
														Player::OnConsoleMessage(peer, "`4You don't have " + itemDefs[j["itemsInStore"][i]["sellForItem"]].name + ".");
														break;
													}
													bool iscontains = false;
													SearchInventoryItem(peer, j["itemsInStore"][i]["sellForItem"], quantityBuy * itempricePer, iscontains);
													if (iscontains == false)
													{
														Player::OnConsoleMessage(peer, "`4You don't have enough(" + to_string(quantityBuy * itempricePer) + ") " + itemDefs[j["itemsInStore"][i]["sellForItem"]].name + ".");
														break;
													}
													bool success = false;
													if (CheckItemExists(peer, j["itemsInStore"][i]["itemid"]))
													{
														int currentlyHave = GetQuantityOfItem(peer, j["itemsInStore"][i]["itemid"]);
														if (quantityBuy + currentlyHave < 201)
														{
															SaveItemMoreTimes(j["itemsInStore"][i]["itemid"], quantityBuy, peer, success);
															j["itemsInStore"][i]["quantityOfItems"] = j["itemsInStore"][i]["quantityOfItems"].get<double>() - quantityBuy;
															Player::OnConsoleMessage(peer, "`2Successfully bought " + to_string(quantityBuy) + " " + itemDefs[j["itemsInStore"][i]["itemid"]].name + ".");
														}
														else
														{
															Player::OnConsoleMessage(peer, "`4You don't have enough space in your inventory to buy " + to_string(quantityBuy) + " " + itemDefs[j["itemsInStore"][i]["itemid"]].name + ".");
															break;
														}
													}
													else
													{
														if (static_cast<PlayerInfo*>(peer->data)->inventory.items.size() == static_cast<PlayerInfo*>(peer->data)->currentInventorySize)
														{
															Player::OnTextOverlay(peer, "`4Your inventory is full! You can purchase an inventory upgrade in the shop.");
															break;
														}
														SaveItemMoreTimes(j["itemsInStore"][i]["itemid"], quantityBuy, peer, success);
														j["itemsInStore"][i]["quantityOfItems"] = j["itemsInStore"][i]["quantityOfItems"].get<double>() - quantityBuy;
														Player::OnConsoleMessage(peer, "`2Successfully bought " + to_string(quantityBuy) + " " + itemDefs[j["itemsInStore"][i]["itemid"]].name + ".");
													}
													RemoveInventoryItem(j["itemsInStore"][i]["sellForItem"], quantityBuy * itempricePer, peer, true);
													j["itemsInStore"][i]["boughtItems"] = j["itemsInStore"][i]["boughtItems"].get<double>() + (quantityBuy * itempricePer);
													vector<string> currentLogs;
													for (int i = 0; i < j["logs"].size(); i++)
													{
														currentLogs.push_back(j["logs"][i]);
													}
													time_t _tm = time(nullptr);
													struct tm* curtime = localtime(&_tm);
													string test = asctime(curtime);
													string tolog = test + " A new purchase from" + PlayerDB::getProperName(static_cast<PlayerInfo*>(peer->data)->rawName) + ": " + to_string(quantityBuy) + " " + itemDefs[j["itemsInStore"][i]["itemid"]].name + "";
													currentLogs.push_back(tolog);
													j["logs"] = currentLogs;
													j["newLogs"] = j["newLogs"].get<double>() + 1;
													std::ofstream oo("store/" + PlayerDB::getProperName(name) + ".json");
													if (!oo.is_open()) continue;
													oo << j << std::endl;
													ENetPeer* currentPeer;
													for (currentPeer = server->peers;
														currentPeer < &server->peers[server->peerCount];
														++currentPeer)
													{
														if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
															continue;
														if (PlayerDB::getProperName(name) == PlayerDB::getProperName(static_cast<PlayerInfo*>(currentPeer->data)->rawName))
														{
															Player::OnConsoleMessage(currentPeer, "`#You have received a new notification in your store! `$Check it out.");
															break;
														}
													}
													break;
												}
											}
											if (error)
											{
												Player::OnTextOverlay(peer, "`4Item does not exist in this store.");
												break;
											}
											if (error2)
											{
												Player::OnTextOverlay(peer, "`4Item sold out.");
												break;
											}
											if (!found)
											{
												Player::OnTextOverlay(peer, "`4Item does not exist in this store.");
												break;
											}
										}
										catch (std::exception&)
										{
											SendConsole("buyPlayerStoreQuantity_ Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
											enet_peer_disconnect_now(peer, 0);
										}
										catch (std::runtime_error&)
										{
											SendConsole("buyPlayerStoreQuantity_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
											enet_peer_disconnect_now(peer, 0);
										}
										catch (...)
										{
											SendConsole("buyPlayerStoreQuantity_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
											enet_peer_disconnect_now(peer, 0);
										}
									}
								}
								if (isstoreReviewConfirmDialog)
								{
									if (world == nullptr || world->name == "EXIT" || serverIsFrozen) continue;
									if (infoDat[0].substr(0, 17) == "storeWriteReview_")
									{
										storeWriteReview = infoDat[1];
										storeWriteReviewShopName = infoDat[0].substr(infoDat[0].find("_") + 1);
										if (storeWriteReview.size() < 15)
										{
											Player::OnTextOverlay(peer, "`4Too short review.");
											break;
										}
										if (storeWriteReviewShopName.size() < 3)
										{
											Player::OnTextOverlay(peer, "`4System error. Try again.");
											break;
										}
									}

									if (infoDat[0] == "storeWriteReviewStar")
									{
										storeWriteReviewStar = infoDat[1];

										bool contains_non_int2 = !std::regex_match(storeWriteReviewStar, std::regex("^[0-9]+$"));
										if (contains_non_int2 == true)
										{
											Player::OnTextOverlay(peer, "`4Stars should be 0-5");
											break;
										}
										if (storeWriteReviewStar.size() > 1 || storeWriteReviewStar.size() <= 0) break;
										int stars = stoi(storeWriteReviewStar);
										if (stars < 1 || stars > 5)
										{
											Player::OnTextOverlay(peer, "`4Stars should be 0-5");
											break;
										}
										bool existx = std::experimental::filesystem::exists("store/" + PlayerDB::getProperName(storeWriteReviewShopName) + ".json");
										if (!existx)
										{
											Player::OnTextOverlay(peer, "`4Store does not exist");
											continue;
										}
										try
										{
											ifstream ifff("store/" + PlayerDB::getProperName(storeWriteReviewShopName) + ".json");
											json j;
											ifff >> j;
											ifff.close();

											bool arRase = false;
											bool arRado = false;

											for (int i = 0; i < 50; i++)
											{
												if (j["storeReview"][i]["sentBy"].get<string>() == static_cast<PlayerInfo*>(peer->data)->displayName)
												{
													arRase = true;
													Player::OnTextOverlay(peer, "`4Unfortunately, but you have already sent the review in this store.");
													break;
												}
											}

											if (arRase == true)
											{
												break;
											}

											for (int i = 0; i < 50; i++)
											{
												if (j["storeReview"][i]["sentBy"].get<string>() == "")
												{
													j["storeReview"][i]["review"] = storeWriteReview;
													j["storeReview"][i]["sentBy"] = static_cast<PlayerInfo*>(peer->data)->displayName;
													j["storeReview"][i]["stars"] = stars;
													j["newLogs"] = j["newLogs"].get<double>() + 1;
													vector<string> currentLogs;
													for (int i = 0; i < j["logs"].size(); i++)
													{
														currentLogs.push_back(j["logs"][i]);
													}
													time_t _tm = time(nullptr);
													struct tm* curtime = localtime(&_tm);
													string test = asctime(curtime);

													string tolog = test + " You have received a new review from " + PlayerDB::getProperName(static_cast<PlayerInfo*>(peer->data)->rawName) + "(" + to_string(stars) + "/5): " + storeWriteReview + "";
													currentLogs.push_back(tolog);

													j["logs"] = currentLogs;


													std::ofstream oo("store/" + PlayerDB::getProperName(storeWriteReviewShopName) + ".json");
													if (!oo.is_open()) continue;
													oo << j << std::endl;

													Player::OnTextOverlay(peer, "`2Successfully sent.");
													arRado = true;


													ENetPeer* currentPeer;
													for (currentPeer = server->peers;
														currentPeer < &server->peers[server->peerCount];
														++currentPeer)
													{
														if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
															continue;
														if (PlayerDB::getProperName(storeWriteReviewShopName) == PlayerDB::getProperName(static_cast<PlayerInfo*>(currentPeer->data)->rawName))
														{
															Player::OnConsoleMessage(currentPeer, "`#You have received a new notification in your store! `$Check it out.");
															break;
														}
													}
													break;
												}
											}
											if (arRado == false)
											{
												Player::OnTextOverlay(peer, "`4Unfortunately, but the reviews in this store are overflowing.");
												break;
											}
										}
										catch (std::exception&)
										{
											SendConsole("storeWriteReview_ Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
											enet_peer_disconnect_now(peer, 0);
										}
										catch (std::runtime_error&)
										{
											SendConsole("storeWriteReview_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
											enet_peer_disconnect_now(peer, 0);
										}
										catch (...)
										{
											SendConsole("storeWriteReview_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
											enet_peer_disconnect_now(peer, 0);
										}
									}
								}
								if (isaddItemStoreOnSaleDialog)
								{
									if (world == nullptr || world->name == "EXIT" || serverIsFrozen) continue;
									if (infoDat[0].substr(0, 21) == "storeItemPickerCount_")
									{
										storeItemPickerCount = infoDat[1];
										storeItemId = infoDat[0].substr(infoDat[0].find("_") + 1);
										if (storeItemPickerCount == "")
										{
											Player::OnTextOverlay(peer, "`4Quantity should be more than 0 and lower than 201.");
											break;
										}
										bool contains_non_int2 = !std::regex_match(storeItemPickerCount, std::regex("^[0-9]+$"));
										if (contains_non_int2 == true)
										{
											Player::OnTextOverlay(peer, "`4Quantity should be more than 0 and lower than 201.");
											break;
										}
										if (storeItemPickerCount.size() > 3 || storeItemPickerCount.size() <= 0) break;
										int count = stoi(storeItemPickerCount);
										if (count < 1 || count > 200)
										{
											Player::OnTextOverlay(peer, "`4Quantity should be more than 0 and lower than 201.");
											break;
										}
										bool contains_non_int3 = !std::regex_match(storeItemId, std::regex("^[0-9]+$"));
										if (contains_non_int3 == true)
										{
											autoBan(peer, false, 24 * 7, "Proxy detect! In isaddItemStoreOnSaleDialog, item id was: " + storeItemId + "");
											break;
										}
										if (storeItemId.size() > 5 || storeItemId.size() <= 0) break;
										int id = stoi(storeItemId);
										if (id < 1 || id > maxItems)
										{
											autoBan(peer, false, 24 * 7, "Proxy detect! In isaddItemStoreOnSaleDialog, item id was: " + storeItemId + "");
											break;
										}
										if (id == 18 || id == 32 || id == 6336 || getItemDef(id).properties & Property_Untradable || getItemDef(id).blockType == BlockTypes::FISH || id == 8552 || id == 9472 || id == 9482 || id == 9356 || id == 9492 || id == 9498 || id == 8774 || id == 1790 || id == 2592 || id == 1784 || id == 1792 || id == 1794 || id == 7734 || id == 8306 || id == 9458)
										{
											Player::OnTextOverlay(peer, "`4You can't place on sale " + getItemDef(id).name + ".");
											break;
										}
										bool isContains = false;
										SearchInventoryItem(peer, id, count, isContains);
										if (isContains == false)
										{
											Player::OnTextOverlay(peer, "`4You don't have enough " + itemDefs[id].name + " in your inventory.");
											break;
										}
										bool existx = std::experimental::filesystem::exists("store/" + PlayerDB::getProperName(static_cast<PlayerInfo*>(peer->data)->rawName) + ".json");
										if (!existx)
										{
											Player::OnTextOverlay(peer, "`4You don't have your own store!");
											break;
										}
									}
									if (infoDat[0] == "storeItemDescription")
									{
										storeItemDescription = infoDat[1];
										if (storeItemDescription.size() <= 5)
										{
											Player::OnTextOverlay(peer, "`4Too short description.");
											break;
										}
									}
									if (infoDat[0] == "storeItemSellForItem")
									{
										storeItemSellForItem = infoDat[1];
										bool contains_non_int2 = !std::regex_match(storeItemSellForItem, std::regex("^[0-9]+$"));
										if (contains_non_int2 == true)
										{
											Player::OnTextOverlay(peer, "`4Item Id should be more than 0 and lower than 201.");
											break;
										}
										if (storeItemSellForItem.size() > 5 || storeItemSellForItem.size() <= 0) break;
										int idd = stoi(storeItemSellForItem);
										if (idd < 1 || idd > maxItems)
										{
											Player::OnTextOverlay(peer, "`4Item Id should be more than 0 and lower than " + to_string(maxItems) + ".");
											break;
										}
										if (idd == 18 || idd == 32 || idd == 6336 || getItemDef(idd).properties & Property_Untradable || getItemDef(idd).blockType == BlockTypes::FISH || idd == 8552 || idd == 9472 || idd == 9482 || idd == 9356 || idd == 9492 || idd == 9498 || idd == 8774 || idd == 1790 || idd == 2592 || idd == 1784 || idd == 1792 || idd == 1794 || idd == 7734 || idd == 8306 || idd == 9458)
										{
											Player::OnTextOverlay(peer, "`4You can't choose " + getItemDef(idd).name + " as a price item.");
											break;
										}
									}
									if (infoDat[0] == "storeItemSellPer")
									{
										if (storeItemId.size() > 5 || storeItemId.size() <= 0) break;
										int id = stoi(storeItemId);
										if (storeItemPickerCount.size() > 3 || storeItemPickerCount.size() <= 0) break;
										int count = stoi(storeItemPickerCount);
										storeItemSellPer = infoDat[1];
										bool contains_non_int2 = !std::regex_match(storeItemSellPer, std::regex("^[0-9]+$"));
										if (contains_non_int2 == true)
										{
											Player::OnTextOverlay(peer, "`4Quantity should be more than 0 and lower than 201.");
											break;
										}
										if (storeItemSellPer.size() > 5 || storeItemSellPer.size() <= 0) break;
										int sellPer = stoi(storeItemSellPer);
										if (sellPer < 1 || sellPer > 200)
										{
											Player::OnTextOverlay(peer, "`4Quantity should be more than 0 and lower than 201.");
											break;
										}
										if (storeItemSellForItem.size() > 5 || storeItemSellForItem.size() <= 0) break;
										int sellForItem = stoi(storeItemSellForItem);
										try
										{
											ifstream ifff("store/" + PlayerDB::getProperName(static_cast<PlayerInfo*>(peer->data)->rawName) + ".json");
											json j;
											ifff >> j;
											ifff.close();
											int currentSpaceInStore = j["currentSpaceInStore"];
											bool arYraLaisvu = false;
											for (int i = 0; i < currentSpaceInStore; i++)
											{
												if (j["itemsInStore"][i]["itemid"] == 0)
												{
													j["itemsInStore"][i]["itemDesc"] = storeItemDescription;
													j["itemsInStore"][i]["itemid"] = id;
													j["itemsInStore"][i]["quantityOfItems"] = count;
													j["itemsInStore"][i]["sellForItem"] = sellForItem;
													j["itemsInStore"][i]["sellPer"] = sellPer;
													std::ofstream oo("store/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".json");
													if (!oo.is_open()) continue;
													oo << j << std::endl;
													RemoveInventoryItem(id, count, peer, true);
													updateplayerset(peer, id);
													Player::OnTextOverlay(peer, "`2Successfully placed on sale!");
													arYraLaisvu = true;
													break;
												}
											}
											if (arYraLaisvu == false)
											{
												Player::OnTextOverlay(peer, "`4You don't have enough space in your store to put this item! Please buy an upgrade.");
												break;
											}
										}
										catch (std::exception&)
										{
											SendConsole("storeItemSellPer Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
											enet_peer_disconnect_now(peer, 0);
										}
										catch (std::runtime_error&)
										{
											SendConsole("storeItemSellPer Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
											enet_peer_disconnect_now(peer, 0);
										}
										catch (...)
										{
											SendConsole("storeItemSellPer Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
											enet_peer_disconnect_now(peer, 0);
										}
									}
								}
								if (isBuyItemByRarityDialog)
								{
									if (world == nullptr || world->name == "EXIT" || serverIsFrozen) break;
									if (infoDat[0].substr(0, 18) == "buyitembyrarityid_")
									{
										strButItemByRarityCount = infoDat[1];
										string id = infoDat[0].substr(infoDat[0].find("_") + 1);

										if (strButItemByRarityCount == "")
										{
											Player::OnTextOverlay(peer, "`4Quantity should be more than 0 and lower than 201.");
											break;
										}
										if (strButItemByRarityCount.length() > 5)
										{
											Player::OnTextOverlay(peer, "`4Quantity should be more than 0 and lower than 201.");
											break;
										}
										bool contains_non_int2 = !std::regex_match(strButItemByRarityCount, std::regex("^[0-9]+$"));
										if (contains_non_int2 == true)
										{
											Player::OnTextOverlay(peer, "`4Quantity should be more than 0 and lower than 201.");
											break;
										}
										if (strButItemByRarityCount.size() > 3 || strButItemByRarityCount.size() <= 0)
										{
											break;
										}
										if (strButItemByRarityCount.size() > 3) break;
										int converted_count = stoi(strButItemByRarityCount);
										if (converted_count < 1 || converted_count > 200)
										{
											Player::OnTextOverlay(peer, "`4Quantity should be more than 0 and lower than 201.");
											break;
										}

										int realPrice = 0;
										if (id.size() > 5 || id.size() <= 0) break;
										if (realPrice <= 0)
										{
											realPrice = 1;
										}
										bool contains_non_int4 = !std::regex_match(id, std::regex("^[0-9]+$"));
										if (contains_non_int4 == true)
										{
											autoBan(peer, false, 24 * 7, "Proxy detect! when buying item by rarity from /buy. item id was: " + id);
											break;
										}
										int itemID = stoi(id);
										int itemid = stoi(id);
										if (getItemDef(itemID).name.find("Mooncake") != string::npos || getItemDef(itemID).name.find("Harvest") != string::npos && itemID != 1830 || getItemDef(itemID).name.find("Autumn") != string::npos || itemID == 1056 || itemID == 1804 || getItemDef(itemID).blockType == BlockTypes::COMPONENT || getItemDef(itemID).properties & Property_Chemical || itemID == 6920 || itemID == 6922 || itemID == 1874 || itemID == 1876 || itemID == 1904 || itemID == 1932 || itemID == 1900 || itemID == 1986 || itemID == 1996 || itemID == 2970 || itemID == 3140 || itemID == 3174 || itemID == 6028 || itemID == 6846 || itemID == 8962 || itemID == 2408 || itemID == 4428 || itemID == 5086 || itemID == 1486 || itemID == 9306 || itemID == 9290 || itemID == 7328 || itemID == 9416 || itemID == 10386 || itemID == 9410 || itemID == 1458 || itemID == 9408 || itemID == 9360 || itemID == 6866 || itemID == 6868 || itemID == 6870 || itemID == 6872 || itemID == 6874 || itemID == 6876 || itemID == 6878 || itemID == 2480 || itemID == 8452 || itemID == 5132 || itemID == 7166 || itemID == 5126 || itemID == 5128 || itemID == 5130 || itemID == 5144 || itemID == 5146 || itemID == 5148 || itemID == 5150 || itemID == 5162 || itemID == 5164 || itemID == 5166 || itemID == 5168 || itemID == 5180 || itemID == 5182 || itemID == 5184 || itemID == 5186 || itemID == 7168 || itemID == 7170 || itemID == 7172 || itemID == 7174 || itemID == 8834 || itemID == 7912 || itemID == 9212 || itemID == 5134 || itemID == 5152 || itemID == 5170 || itemID == 5188 || itemID == 980 || itemID == 9448 || itemID == 9310 || itemID == 10034 || itemID == 10036 || itemID == 8470 || itemID == 8286 || itemID == 6026 || itemID == 1970 || itemID == 1784 || itemID == 9356 || itemID == 10022 || itemID == 902 || itemID == 10032 || itemID == 834 || itemID == 6 || itemID == 5640 || itemID == 9492 || itemID == 1782 || itemID == 9288 || itemID == 1780 || itemID == 8306 || itemID == 202 || itemID == 204 || itemID == 206 || itemID == 2950 || itemID == 4802 || itemID == 4994 || itemID == 5260 || itemID == 5814 || itemID == 5980 || itemID == 7734 || itemID == 2592 || itemID == 2242 || itemID == 1794 || itemID == 1792 || itemID == 778 || itemID == 9510 || itemID == 8774 || itemID == 2568 || itemID == 9512 || itemID == 9502 || itemID == 9482 || itemID == 2250 || itemID == 2248 || itemID == 2244 || itemID == 2246 || itemID == 2286 || itemID == 9508 || itemID == 9504 || itemID == 9506 || itemID == 274 || itemID == 276 || itemID == 9476 || itemID == 1486 || itemID == 9498 || itemID == 4426 || itemID == 9496 || itemID == 278 || itemID == 9490 || itemID == 2410 || itemID == 9488 || itemID == 9452 || itemID == 9454 || itemID == 9472 || itemID == 9456 || itemID == 732 || itemID == 9458 || itemID == 6336 || itemID == 112 || itemID == 8 || itemID == 3760 || getItemDef(itemID).blockType == BlockTypes::FISH || itemID == 7372 || itemID == 9438 || itemID == 9462 || itemID == 9440 || itemID == 9442 || itemID == 9444 || itemID == 7960 || itemID == 7628 || itemID == 8552) break;
										if (itemid == 4296 || itemid == 6212 || itemid == 1212 || itemid == 10388 || itemid == 10390 || itemid == 1360 || itemid == 1190 || itemid == 1206 || itemid == 1166 || itemid == 1964 || itemid == 1976 || itemid == 1998 || itemid == 1946 || itemid == 2002 || itemid == 1958 || itemid == 1952 || itemid == 2030 || itemid == 3104 || itemid == 3112 || itemid == 3120 || itemid == 3092 || itemid == 3094 || itemid == 3096 || itemid == 4184 || itemid == 4178 || itemid == 4174 || itemid == 4180 || itemid == 4170 || itemid == 4168 || itemid == 4150 || itemid == 1180 || itemid == 1224 || itemid == 5226 || itemid == 5228 || itemid == 5230 || itemid == 5212 || itemid == 5246 || itemid == 5242 || itemid == 5234 || itemid == 7134 || itemid == 7118 || itemid == 7132 || itemid == 7120 || itemid == 7098 || itemid == 9018 || itemid == 9038 || itemid == 9026 || itemid == 9066 || itemid == 9058 || itemid == 9044 || itemid == 9024 || itemid == 9032 || itemid == 9036 || itemid == 9028 || itemid == 9030 || itemid == 9110 || itemid == 9112 || itemid == 10386 || itemid == 10326 || itemid == 10324 || itemid == 10322 || itemid == 10328 || itemid == 10316 || itemid == 1198 || itemid == 1208 || itemid == 1222 || itemid == 1200 || itemid == 1220 || itemid == 1202 || itemid == 1238 || itemid == 1168 || itemid == 1172 || itemid == 1230 || itemid == 1194 || itemid == 1192 || itemid == 1226 || itemid == 1196 || itemid == 1236 || itemid == 1182 || itemid == 1184 || itemid == 1186 || itemid == 1188 || itemid == 1170 || itemid == 1212 || itemid == 1214 || itemid == 1232 || itemid == 1178 || itemid == 1234 || itemid == 1250 || itemid == 1956 || itemid == 1990 || itemid == 1968 || itemid == 1960 || itemid == 1948 || itemid == 1966 || itemid == 3114 || itemid == 3118 || itemid == 3100 || itemid == 3122 || itemid == 3124 || itemid == 3126 || itemid == 3108 || itemid == 3098 || itemid == 1962 || itemid == 2000 || itemid == 1970 || itemid == 4186 || itemid == 4188 || itemid == 4246 || itemid == 4248 || itemid == 4192 || itemid == 4156 || itemid == 4136 || itemid == 4152 || itemid == 4166 || itemid == 4190 || itemid == 4172 || itemid == 4182 || itemid == 4144 || itemid == 4146 || itemid == 4148 || itemid == 4140 || itemid == 4138 || itemid == 4142 || itemid == 5256 || itemid == 5208 || itemid == 5216 || itemid == 5218 || itemid == 5220 || itemid == 5214 || itemid == 5210 || itemid == 5254 || itemid == 5250 || itemid == 5252 || itemid == 5244 || itemid == 5236 || itemid == 7104 || itemid == 7124 || itemid == 7122 || itemid == 7102 || itemid == 7100 || itemid == 7126 || itemid == 7104 || itemid == 7124 || itemid == 7122 || itemid == 7102 || itemid == 7100 || itemid == 9048 || itemid == 9056 || itemid == 9114 || itemid == 9034 || itemid == 1210 || itemid == 1216 || itemid == 1218 || itemid == 1992 || itemid == 1982 || itemid == 1994 || itemid == 1972 || itemid == 1980 || itemid == 1988 || itemid == 1984 || itemid == 3116 || itemid == 3102 || itemid == 3106 || itemid == 3110 || itemid == 4160 || itemid == 4162 || itemid == 4164 || itemid == 4154 || itemid == 4158 || itemid == 5224 || itemid == 5222 || itemid == 5232 || itemid == 5240 || itemid == 5248 || itemid == 5238 || itemid == 5256 || itemid == 7116 || itemid == 7108 || itemid == 7110 || itemid == 7128 || itemid == 7112 || itemid == 7114 || itemid == 7130) break;
										if (isDev(peer) && itemid == 10026 || itemid == 6398 || itemid == 1796 || itemid == 6426 || itemid == 6340 || itemid == 6342 || itemid == 6350 || itemid == 6818 || itemid == 8244 || itemid == 8242 || itemid == 8240 || itemid == 8452 || itemid == 8454 || itemid == 8488 || itemid == 8498 || itemid == 8474 || itemid == 8476 || itemid == 8492 || itemid == 1498 || itemid == 1500 || itemid == 2804 || itemid == 2806 || itemid == 8270 || itemid == 8272 || itemid == 8274 || itemid == 3172 || itemid == 8478 || itemid == 8480 || itemid == 8486 || itemid == 8484 || itemid == 8482 || itemid == 8468 || itemid == 8494 || itemid == 8466 || itemid == 8490 || itemid == 8456 || itemid == 8458 || itemid == 8496 || itemid == 8472 || itemid == 5482 || itemid == 2240 || itemid == 3204 || itemid == 6114 || itemid == 4328 || itemid == 4326 || itemid == 4330 || itemid == 4324 || itemid == 4334 || itemid == 1242 || itemid == 1244 || itemid == 1246 || itemid == 1248 || itemid == 1282 || itemid == 1284 || itemid == 1286 || itemid == 1290 || itemid == 1288 || itemid == 1292 || itemid == 1294 || itemid == 1256 || itemid == 2586 || itemid == 782 || itemid == 3536 || itemid == 764 || itemid == 4176 || itemid == 4322 || itemid == 4080 || itemid == 2992 || itemid == 2976 || itemid == 3790 || itemid == 4990 || itemid == 1506 || itemid == 1274 || itemid == 9000 || itemid == 1252 || itemid == 8284 || itemid == 8954 || itemid == 8534 || itemid == 1460 || itemid == 1462 || itemid == 1466 || itemid == 1464 || itemid == 2386 || itemid == 2392 || itemid == 2394 || itemid == 4414 || itemid == 4420 || itemid == 4428 || itemid == 4426 || itemid == 5662 || itemid == 5642 || itemid == 5654 || itemid == 5646 || itemid == 5650 || itemid == 7828 || itemid == 7832 || itemid == 7834 || itemid == 9322 || itemid == 9344 || itemid == 9326 || itemid == 9316 || itemid == 9318 || itemid == 362 || itemid == 3398 || itemid == 386 || itemid == 4422 || itemid == 364 || itemid == 9340 || itemid == 9342 || itemid == 9332 || itemid == 9334 || itemid == 9336 || itemid == 9338 || itemid == 366 || itemid == 2388 || itemid == 7808 || itemid == 7810 || itemid == 4416 || itemid == 7818 || itemid == 7820 || itemid == 5652 || itemid == 7822 || itemid == 7824 || itemid == 5644 || itemid == 390 || itemid == 7826 || itemid == 7830 || itemid == 9324 || itemid == 5658 || itemid == 3396 || itemid == 2384 || itemid == 5660 || itemid == 3400 || itemid == 4418 || itemid == 4412 || itemid == 388 || itemid == 3408 || itemid == 1470 || itemid == 3404 || itemid == 3406 || itemid == 2390 || itemid == 5656 || itemid == 5648 || itemid == 2396 || itemid == 384 || itemid == 5664 || itemid == 4424 || itemid == 4400 || itemid == 362 || itemid == 3398 || itemid == 386 || itemid == 392 || itemid == 4422 || itemid == 364 || itemid == 9340 || itemid == 9342 || itemid == 9332 || itemid == 9334 || itemid == 9336 || itemid == 9338 || itemid == 366 || itemid == 2388 || itemid == 7808 || itemid == 7810 || itemid == 4416 || itemid == 7818 || itemid == 7820 || itemid == 5652 || itemid == 7822 || itemid == 7824 || itemid == 5644 || itemid == 390 || itemid == 7826 || itemid == 7830 || itemid == 9324 || itemid == 5658 || itemid == 3396 || itemid == 2384 || itemid == 5660 || itemid == 3400 || itemid == 4418 || itemid == 4412 || itemid == 388 || itemid == 3408 || itemid == 1470 || itemid == 3404 || itemid == 3406 || itemid == 2390 || itemid == 5656 || itemid == 5648 || itemid == 2396 || itemid == 384 || itemid == 5664 || itemid == 4424 || itemid == 4400 || itemid == 1458 || itemid == 362 || itemid == 3398 || itemid == 386 || itemid == 4422 || itemid == 364 || itemid == 9340 || itemid == 9342 || itemid == 9332 || itemid == 9334 || itemid == 9336 || itemid == 9338 || itemid == 366 || itemid == 2388 || itemid == 7808 || itemid == 7810 || itemid == 4416 || itemid == 7818 || itemid == 7820 || itemid == 5652 || itemid == 7822 || itemid == 7824 || itemid == 5644 || itemid == 390 || itemid == 7826 || itemid == 7830 || itemid == 9324 || itemid == 5658 || itemid == 3396 || itemid == 2384 || itemid == 5660 || itemid == 3400 || itemid == 4418 || itemid == 4412 || itemid == 388 || itemid == 3408 || itemid == 1470 || itemid == 3404 || itemid == 3406 || itemid == 2390 || itemid == 5656 || itemid == 5648 || itemid == 2396 || itemid == 384 || itemid == 5664 || itemid == 4424 || itemid == 4400 || itemid == 1458 || itemid == 5040 || itemid == 5042 || itemid == 5044 || itemid == 3402 || itemid == 5032 || itemid == 5034 || itemid == 5036 || itemid == 5038 || itemid == 5018 || itemid == 5022 || itemid == 5060 || itemid == 5054 || itemid == 5058 || itemid == 5056 || itemid == 5050 || itemid == 5046 || itemid == 5052 || itemid == 5048 || itemid == 5070 || itemid == 5072 || itemid == 5074 || itemid == 5076 || itemid == 5066 || itemid == 5062 || itemid == 5068 || itemid == 5064 || itemid == 5080 || itemid == 5082 || itemid == 5084 || itemid == 5078 || itemid == 10236 || itemid == 10232 || itemid == 10194 || itemid == 10206 || itemid == 10184 || itemid == 10192 || itemid == 10190 || itemid == 10186 || itemid == 10212 || itemid == 10214 || itemid == 10216 || itemid == 10220 || itemid == 10222 || itemid == 10224 || itemid == 10226 || itemid == 10208 || itemid == 10210 || itemid == 10218 || itemid == 10196 || itemid == 10198 || itemid == 10200 || itemid == 10202 || itemid == 10204) break;

										ItemDefinition itemDef = getItemDef(itemID);
										/*if (getItemDef(itemID).blockType == BlockTypes::FOREGROUND || getItemDef(itemID).blockType == BlockTypes::BACKGROUND || getItemDef(itemID).blockType == BlockTypes::GROUND_BLOCK)
										{
											if (getItemDef(itemID).rarity <= 10)
											{
												realPrice = round(static_cast<float>(1 * converted_count) / 10);
											}
											else if (getItemDef(itemID).rarity <= 20)
											{
												realPrice = round(static_cast<float>(5 * converted_count) / 10);
											}
											else if (getItemDef(itemID).rarity <= 40)
											{
												realPrice = round(static_cast<float>(15 * converted_count) / 10);
											}
											else if (getItemDef(itemID).rarity <= 60)
											{
												realPrice = round(static_cast<float>(20 * converted_count) / 10);
											}
											else if (getItemDef(itemID).rarity <= 80)
											{
												realPrice = round(static_cast<float>(25 * converted_count) / 10);
											}
											else if (getItemDef(itemID).rarity <= 100)
											{
												realPrice = round(static_cast<float>(30 * converted_count) / 10);
											}
											else
											{
												realPrice = round(static_cast<float>(35 * converted_count) / 10);
											}
										}*/
										if (getItemDef(itemID).rarity == 999 && getItemDef(itemID).name.find("Golden") != string::npos)
										{
											realPrice = 9000 * converted_count;
										}
										else if (getItemDef(itemID).rarity == 999 && getItemDef(itemID).name.find("Phoenix") != string::npos)
										{
											realPrice = 5000 * converted_count;
										}
										else if (getItemDef(itemID).rarity == 999 && getItemDef(itemID).name.find("Nightmare") != string::npos)
										{
											realPrice = 4000 * converted_count;
										}
										else if (itemDef.properties & Property_Untradable)
										{
											realPrice = 3000 * converted_count;
										}
										else if (getItemDef(itemID).blockType == BlockTypes::CLOTHING)
										{
											ifstream infile("pricedata.txt");
											for (string line; getline(infile, line);)
											{
												if (line.length() > 3 && line[0] != '/' && line[1] != '/')
												{
													auto ex = explode("|", line);
													if (ex[0] == to_string(itemID))
													{
														realPrice = atoi(ex[1].c_str()) * converted_count;
														break;
													}
												}
											}
										}
										else if (itemID == 2912)
										{
											realPrice = 10 * converted_count;
										}
										else if (itemID == 1006)
										{
											realPrice = 15 * converted_count;
										}
										else if (itemID == 656)
										{
											realPrice = 15 * converted_count;
										}
										else if (itemID == 6286)
										{
											realPrice = 20 * converted_count;
										}
										else if (itemID == 6288)
										{
											realPrice = 50 * converted_count;
										}
										else if (itemID == 6290)
										{
											realPrice = 120 * converted_count;
										}
										else if (itemID == 3010)
										{
											realPrice = 120 * converted_count;
										}
										else if (itemID == 3040)
										{
											realPrice = 690 * converted_count;
										}
										else if (itemID == 3100)
										{
											realPrice = 3200 * converted_count;
										}
										else if (itemID == 5740)
										{
											realPrice = 9600 * converted_count;
										}
										else if (itemID == 2914)
										{
											realPrice = round(static_cast<float>(1 * converted_count) / 5);
										}
										else if (itemID == 3098)
										{
											realPrice = 5 * converted_count;
										}
										else if (itemID == 3218)
										{
											realPrice = 8 * converted_count;
										}
										else if (itemID == 3432)
										{
											realPrice = 90 * converted_count;
										}
										else if (itemID == 4246)
										{
											realPrice = 3 * converted_count;
										}
										else if (itemID == 4248)
										{
											realPrice = 3 * converted_count;
										}
										else if (itemID == 5528)
										{
											realPrice = 15 * converted_count;
										}
										else if (itemID == 1662)
										{
											realPrice = 30 * converted_count;
										}
										else if (itemID == 1452)
										{
											realPrice = 10 * converted_count;
										}
										else if (itemID == 1240)
										{
											realPrice = 10 * converted_count;
										}
										else if (itemID == 8878)
										{
											realPrice = 80 * converted_count;
										}
										else if (itemID == 6918)
										{
											realPrice = 80 * converted_count;
										}
										else if (itemID == 6924)
										{
											realPrice = 60 * converted_count;
										}
										else if (itemID == 6840)
										{
											realPrice = 1200 * converted_count;
										}
										else if (itemID == 1436)
										{
											realPrice = 5 * converted_count;
										}
										else if (itemID == 2978)
										{
											realPrice = 5 * converted_count;
										}
										else if (itemID == 898)
										{
											realPrice = 60 * converted_count;
										}
										else if (itemID == 1966)
										{
											realPrice = 800 * converted_count;
										}
										else if (itemID == 5022)
										{
											realPrice = 350 * converted_count;
										}
										else if (itemID == 528)
										{
											realPrice = 25 * converted_count;
										}
										else if (itemID == 5638)
										{
											realPrice = 3500 * converted_count;
										}
										else if (itemID == 6946)
										{
											realPrice = 900 * converted_count;
										}
										else if (itemID == 6948)
										{
											realPrice = 300 * converted_count;
										}
										else if (itemID == 10012)
										{
											realPrice = 1800 * converted_count;
										}
										else if (itemID == 10016)
										{
											realPrice = 3500 * converted_count;
										}
										else if (itemID == 10018)
										{
											realPrice = 1200 * converted_count;
										}
										else if (getItemDef(itemID).clothType == ClothTypes::BACK && getItemDef(itemID).rarity == 999)
										{
											realPrice = 900 * converted_count;
										}
										else if (itemID == 10014)
										{
											realPrice = 1500 * converted_count;
										}
										else if (itemID == 2946)
										{
											realPrice = 5 * converted_count;
										}
										else if (itemID == 1404)
										{
											realPrice = 15 * converted_count;
										}
										else if (itemID == 874)
										{
											realPrice = 3 * converted_count;
										}
										else if (getItemDef(itemID).rarity == 999)
										{
											realPrice = 600 * converted_count;
										}
										else
										{
											realPrice = round(static_cast<float>(round(static_cast<float>(getItemDef(itemID).rarity) * 5) * converted_count) / 10);
										}
										if (realPrice <= 0)
										{
											realPrice = 1;
											//Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`1You can't buy below the minimum!", 0, true);
											//break;
										}
										if (CheckItemMaxed(peer, itemID, converted_count))
										{
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`1(Item maxed)", 0, true);
											break;
										}
										if (CheckItemExists(peer, itemID) == false)
										{
											if (static_cast<PlayerInfo*>(peer->data)->inventory.items.size() == static_cast<PlayerInfo*>(peer->data)->currentInventorySize)
											{
												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`1(Inventory is full)", 0, true);
												break;
											}
										}

										if (itemID == 9644)
										{
											ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
											string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
											int b = atoi(content.c_str());
											if (b > 25000 * converted_count)
											{
												bool success = true;
												SaveShopsItemMoreTimes(9644, converted_count, peer, success);
												if (!success)break;
												int gemcalc10k = b - 25000 * converted_count;
												ofstream myfile2;
												myfile2.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
												myfile2 << std::to_string(gemcalc10k);
												myfile2.close();
												ifstream ifszi("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
												string contentx((std::istreambuf_iterator<char>(ifszi)), (std::istreambuf_iterator<char>()));
												int updgem = atoi(contentx.c_str());
												Player::OnSetBux(peer, updgem, 0);
												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`oYou have bought `$" + to_string(converted_count) + " " + getItemDef(itemID).name + " `ofor `$" + to_string(25000 * converted_count) + " Gems`o!", 0, true);
												ENetPeer* currentPeer;
												for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer)
												{
													if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
													if (isHere(peer, currentPeer))
													{
														SendTradeEffect(currentPeer, itemID, static_cast<PlayerInfo*>(peer->data)->netID, static_cast<PlayerInfo*>(peer->data)->netID, 150);
														Player::PlayAudio(currentPeer, "audio/cash_register.wav", 0);
													}
												}
											}
											else Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "You can't afford that many!", 0, true);
											break;
										}
										if (itemID == 9644) break; /*svarbu!*/

										if (itemID == 2204)
										{
											ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
											string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
											int b = atoi(content.c_str());
											if (b > 60000 * converted_count)
											{
												bool success = true;
												SaveShopsItemMoreTimes(2204, converted_count, peer, success);
												if (!success)break;
												int gemcalc10k = b - 60000 * converted_count;
												ofstream myfile2;
												myfile2.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
												myfile2 << std::to_string(gemcalc10k);
												myfile2.close();
												ifstream ifszi("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
												string contentx((std::istreambuf_iterator<char>(ifszi)), (std::istreambuf_iterator<char>()));
												int updgem = atoi(contentx.c_str());
												Player::OnSetBux(peer, updgem, 0);
												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`oYou have bought `$" + to_string(converted_count) + " " + getItemDef(itemID).name + " `ofor `$" + to_string(60000 * converted_count) + " Gems`o!", 0, true);
												ENetPeer* currentPeer;
												for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer)
												{
													if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
													if (isHere(peer, currentPeer))
													{
														SendTradeEffect(currentPeer, itemID, static_cast<PlayerInfo*>(peer->data)->netID, static_cast<PlayerInfo*>(peer->data)->netID, 150);
														Player::PlayAudio(currentPeer, "audio/cash_register.wav", 0);
													}
												}
											}
											else Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "You can't afford that many!", 0, true);
											break;
										}
										if (itemID == 2204) break; /*svarbu!*/

										if (CheckItemExists(peer, 242) == false && CheckItemExists(peer, 1796) == false)
										{
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`1You don't have wls and dls", 0, true);
											break;
										}

										auto worldlocks = 0;
										auto diamondlocks = 0;
										auto locks = 0;
										for (auto i = 0; i < static_cast<PlayerInfo*>(peer->data)->inventory.items.size(); i++)
										{
											if (static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemID == 242)
											{
												worldlocks = static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount;
											}
											if (static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemID == 1796)
											{
												diamondlocks = static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount;
											}
										}
										if (diamondlocks > 0)
										{
											locks = diamondlocks * 100;
										}
										locks += worldlocks;
										if (realPrice > locks)
										{
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "You can't afford that many!", 0, true);
											break;
										}
										else
										{
											float worldlockskaina = 0;
											int diamondlockkiek = 0;
											int worldlockkiek = 0;
											if (realPrice > 0) worldlockkiek = realPrice;
											int grazinti_wl = 0;
											if (worldlockkiek != 0)
											{
												auto iscontainseas = false;
												SearchInventoryItem(peer, 242, worldlockkiek, iscontainseas);
												if (!iscontainseas)
												{
													//cout << "nera wl " + to_string(worldlockkiek) << endl;
													diamondlockkiek += 1;
													grazinti_wl = 100 - worldlockkiek;
													while (grazinti_wl < 0)
													{
														if (grazinti_wl < 0)
														{
															//cout << "grazinti_wl buvo " + to_string(grazinti_wl) << endl;
															diamondlockkiek += 1;
															grazinti_wl = 100 + grazinti_wl;
														}
														else break;
													}
													worldlockkiek = 0;
												}
											}
											if (diamondlockkiek != 0)
											{
												auto iscontainseas3 = false;
												SearchInventoryItem(peer, 1796, diamondlockkiek, iscontainseas3);
												if (!iscontainseas3)
												{
													//cout << "nera dl " + to_string(diamondlockkiek) << endl;
													diamondlockkiek -= 1;
													worldlockkiek += 100;
												}
											}
											if (worldlockkiek == 0 && diamondlockkiek == 0)
											{
												if (realPrice == worldlocks)
												{
													worldlockkiek = worldlocks;
												}
											}
											auto iscontainseas = false;
											SearchInventoryItem(peer, 242, worldlockkiek, iscontainseas);
											if (!iscontainseas)
											{
												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "Uhm something went wrong...", 0, true);
												break;
											}
											if (worldlockkiek < 0 || diamondlockkiek < 0 || grazinti_wl < 0)
											{
												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "Uhm something went wrong...", 0, true);
												break;
											}
											if (worldlockkiek == 0 && diamondlockkiek == 0) break;
											//cout << "duoda wl: " + to_string(worldlockkiek) << endl;
											//cout << "duoda dl: " + to_string(diamondlockkiek) << endl;
											//cout << "grazina wl: " + to_string(grazinti_wl) << endl;
											bool success = true;
											if (worldlockkiek != 0)
											{
												RemoveInventoryItem(242, worldlockkiek, peer, true);
											}
											if (diamondlockkiek != 0)
											{
												RemoveInventoryItem(1796, diamondlockkiek, peer, true);
											}
											if (grazinti_wl != 0)
											{
												if (CheckItemMaxed(peer, 242, grazinti_wl))
												{
													if (grazinti_wl >= 100 && !CheckItemMaxed(peer, 1796, 1))
													{
														SaveItemMoreTimes(1796, 1, peer, success);
													}
												}
												else
												{
													SaveItemMoreTimes(242, grazinti_wl, peer, success);
												}
											}
											SaveItemMoreTimes(itemID, converted_count, peer, success);
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`oYou have bought `$" + to_string(converted_count) + " " + getItemDef(itemID).name + " `ofor `$" + to_string(realPrice) + " World Locks`o!", 0, true);
											ENetPeer* currentPeer;
											for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer)
											{
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
												if (isHere(peer, currentPeer))
												{
													SendTradeEffect(currentPeer, itemID, static_cast<PlayerInfo*>(peer->data)->netID, static_cast<PlayerInfo*>(peer->data)->netID, 150);
													Player::PlayAudio(currentPeer, "audio/cash_register.wav", 0);
												}
											}
										}

									}
								}
								if (title_save)
								{
									if (infoDat[0] == "title_name")
									{
										title_name = infoDat[1];
										if (title_name.size() > 10 || title_name.size() < 0)
										{
											break;
										}
										if (title_name.find("`6@") != string::npos || title_name.find("`#@") != string::npos)
										{
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`oSorry this title cannot be used for security reasons!", 0, true);
											break;
										}


										ifstream fg("players/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".json");
										json j;
										fg >> j;
										fg.close();

										j["title"] = title_name;

										ofstream fs("players/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".json");
										fs << j;
										fs.close();
										/*stringstream basic_stringstream;
										basic_stringstream << "UPDATE PlayerState SET nick = '' WHERE username = '" + static_cast<PlayerInfo*>(peer->data)->rawName + "'";
										const auto cs = basic_stringstream.str();
										const auto string = cs.c_str();
										if (mysql_query(conn, q))
										{
													string ers = mysql_error(conn); if (ers.find("Lost connection") != string::npos) ConnectToDatabase();
											cout << mysql_error(conn) << endl;
										}*/
										if (title_name.size() == 0)
										{
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`oTitle have been removed!", 0, true);
											if (static_cast<PlayerInfo*>(peer->data)->isNicked)
											{
												for (auto currentPeer = server->peers;
													currentPeer < &server->peers[server->peerCount];
													++currentPeer)
												{
													if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
													if (isHere(peer, currentPeer))
													{
														Player::OnNameChanged(currentPeer, static_cast<PlayerInfo*>(peer->data)->netID, static_cast<PlayerInfo*>(peer->data)->OriName);
													}
												}
											}
											else
											{
												updateworldremove(peer);
											}
											static_cast<PlayerInfo*>(peer->data)->NickPrefix = "";
											if (static_cast<PlayerInfo*>(peer->data)->haveGrowId)
											{
												if (static_cast<PlayerInfo*>(peer->data)->rawName == getPlyersWorld(peer)->owner)
												{
													if (isPlayer(peer))
													{
														if (static_cast<PlayerInfo*>(peer->data)->NickPrefix != "")
														{
															static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->NickPrefix + ". " + static_cast<PlayerInfo*>(peer->data)->tankIDName;
														}
														else if (static_cast<PlayerInfo*>(peer->data)->isNicked)
														{
															static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->OriName;
														}
														else
														{
															static_cast<PlayerInfo*>(peer->data)->displayName = "`2" + static_cast<PlayerInfo*>(peer->data)->tankIDName;
														}
													}
												}
												else
												{
													if (isPlayer(peer))
													{
														if (static_cast<PlayerInfo*>(peer->data)->NickPrefix != "")
														{
															static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->NickPrefix + ". " + static_cast<PlayerInfo*>(peer->data)->tankIDName;
														}
														else if (static_cast<PlayerInfo*>(peer->data)->isNicked)
														{
															static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->OriName;
														}
														else
														{
															static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->tankIDName;
														}
													}
												}
											}
											else
											{
												if (static_cast<PlayerInfo*>(peer->data)->rawName == getPlyersWorld(peer)->owner)
												{
													if (isPlayer(peer))
													{
														if (static_cast<PlayerInfo*>(peer->data)->NickPrefix != "")
														{
															static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->NickPrefix + ". " + static_cast<PlayerInfo*>(peer->data)->tankIDName;
														}
														else if (static_cast<PlayerInfo*>(peer->data)->isNicked)
														{
															static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->OriName;
														}
														else
														{
															static_cast<PlayerInfo*>(peer->data)->displayName = "`2" + static_cast<PlayerInfo*>(peer->data)->tankIDName;
														}
													}
												}
												else
												{
													if (isPlayer(peer))
													{
														if (static_cast<PlayerInfo*>(peer->data)->NickPrefix != "")
														{
															static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->NickPrefix + ". " + static_cast<PlayerInfo*>(peer->data)->tankIDName;
														}
														else if (static_cast<PlayerInfo*>(peer->data)->isNicked)
														{
															static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->OriName;
														}
														else
														{
															static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->tankIDName;
														}
													}
												}
											}
											if (static_cast<PlayerInfo*>(peer->data)->haveGrowId)
											{
												if (static_cast<PlayerInfo*>(peer->data)->rawName == getPlyersWorld(peer)->owner)
												{
													if (isMod(peer))
													{
														if (static_cast<PlayerInfo*>(peer->data)->NickPrefix != "")
														{
															static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->NickPrefix + ". " + static_cast<PlayerInfo*>(peer->data)->tankIDName;
														}
														else if (static_cast<PlayerInfo*>(peer->data)->isNicked)
														{
															static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->OriName;
														}
														else
														{
															static_cast<PlayerInfo*>(peer->data)->displayName = "`#@" + static_cast<PlayerInfo*>(peer->data)->tankIDName;
														}
													}
												}
												else
												{
													if (isMod(peer))
													{
														if (static_cast<PlayerInfo*>(peer->data)->NickPrefix != "")
														{
															static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->NickPrefix + ". " + static_cast<PlayerInfo*>(peer->data)->tankIDName;
														}
														else if (static_cast<PlayerInfo*>(peer->data)->isNicked)
														{
															static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->OriName;
														}
														else
														{
															static_cast<PlayerInfo*>(peer->data)->displayName = "`#@" + static_cast<PlayerInfo*>(peer->data)->tankIDName;
														}
													}
												}
											}
											else
											{
												if (static_cast<PlayerInfo*>(peer->data)->rawName == getPlyersWorld(peer)->owner)
												{
													if (isMod(peer))
													{
														if (static_cast<PlayerInfo*>(peer->data)->NickPrefix != "")
														{
															static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->NickPrefix + ". " + static_cast<PlayerInfo*>(peer->data)->tankIDName;
														}
														else if (static_cast<PlayerInfo*>(peer->data)->isNicked)
														{
															static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->OriName;
														}
														else
														{
															static_cast<PlayerInfo*>(peer->data)->displayName = "`#@" + static_cast<PlayerInfo*>(peer->data)->tankIDName;
														}
													}
												}
												else
												{
													if (isMod(peer))
													{
														if (static_cast<PlayerInfo*>(peer->data)->NickPrefix != "")
														{
															static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->NickPrefix + ". " + static_cast<PlayerInfo*>(peer->data)->tankIDName;
														}
														else if (static_cast<PlayerInfo*>(peer->data)->isNicked)
														{
															static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->OriName;
														}
														else
														{
															static_cast<PlayerInfo*>(peer->data)->displayName = "`#@" + static_cast<PlayerInfo*>(peer->data)->tankIDName;
														}
													}
												}
											}
											if (static_cast<PlayerInfo*>(peer->data)->haveGrowId)
											{
												if (static_cast<PlayerInfo*>(peer->data)->rawName == getPlyersWorld(peer)->owner)
												{
													if (isDev(peer))
													{
														if (static_cast<PlayerInfo*>(peer->data)->NickPrefix != "")
														{
															static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->NickPrefix + ". " + static_cast<PlayerInfo*>(peer->data)->tankIDName;
														}
														else if (static_cast<PlayerInfo*>(peer->data)->isNicked)
														{
															static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->OriName;
														}
														else
														{
															static_cast<PlayerInfo*>(peer->data)->displayName = "`6@" + static_cast<PlayerInfo*>(peer->data)->tankIDName;
														}
													}
												}
												else
												{
													if (isDev(peer))
													{
														if (static_cast<PlayerInfo*>(peer->data)->NickPrefix != "")
														{
															static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->NickPrefix + ". " + static_cast<PlayerInfo*>(peer->data)->tankIDName;
														}
														else if (static_cast<PlayerInfo*>(peer->data)->isNicked)
														{
															static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->OriName;
														}
														else
														{
															static_cast<PlayerInfo*>(peer->data)->displayName = "`6@" + static_cast<PlayerInfo*>(peer->data)->tankIDName;
														}
													}
												}
											}
											else
											{
												if (static_cast<PlayerInfo*>(peer->data)->rawName == getPlyersWorld(peer)->owner)
												{
													if (isDev(peer))
													{
														if (static_cast<PlayerInfo*>(peer->data)->NickPrefix != "")
														{
															static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->NickPrefix + ". " + static_cast<PlayerInfo*>(peer->data)->tankIDName;
														}
														else if (static_cast<PlayerInfo*>(peer->data)->isNicked)
														{
															static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->OriName;
														}
														else
														{
															static_cast<PlayerInfo*>(peer->data)->displayName = "`6@" + static_cast<PlayerInfo*>(peer->data)->tankIDName;
														}
													}
												}
												else
												{
													if (isDev(peer))
													{
														if (static_cast<PlayerInfo*>(peer->data)->NickPrefix != "")
														{
															static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->NickPrefix + ". " + static_cast<PlayerInfo*>(peer->data)->tankIDName;
														}
														else if (static_cast<PlayerInfo*>(peer->data)->isNicked)
														{
															static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->OriName;
														}
														else
														{
															static_cast<PlayerInfo*>(peer->data)->displayName = "`6@" + static_cast<PlayerInfo*>(peer->data)->tankIDName;
														}
													}
												}
											}
										}
										else
										{
											static_cast<PlayerInfo*>(peer->data)->NickPrefix = title_name;
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`oTitle changed to " + title_name + "!", 0, true);
											//restoreplayernick(peer);
											if (static_cast<PlayerInfo*>(peer->data)->haveGrowId)
											{
												if (static_cast<PlayerInfo*>(peer->data)->rawName == getPlyersWorld(peer)->owner)
												{
													if (isPlayer(peer))
													{
														if (static_cast<PlayerInfo*>(peer->data)->NickPrefix != "")
														{
															if (static_cast<PlayerInfo*>(peer->data)->isNicked)
															{
																static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->NickPrefix + ". " + static_cast<PlayerInfo*>(peer->data)->OriName;
															}
															else
															{
																static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->NickPrefix + ". " + static_cast<PlayerInfo*>(peer->data)->tankIDName;
															}
														}
														else if (static_cast<PlayerInfo*>(peer->data)->isNicked)
														{
															static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->OriName;
														}
														else
														{
															static_cast<PlayerInfo*>(peer->data)->displayName = "`2" + static_cast<PlayerInfo*>(peer->data)->tankIDName;
														}
													}
												}
												else
												{
													if (isPlayer(peer))
													{
														if (static_cast<PlayerInfo*>(peer->data)->NickPrefix != "")
														{
															if (static_cast<PlayerInfo*>(peer->data)->isNicked)
															{
																static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->NickPrefix + ". " + static_cast<PlayerInfo*>(peer->data)->OriName;
															}
															else
															{
																static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->NickPrefix + ". " + static_cast<PlayerInfo*>(peer->data)->tankIDName;
															}
														}
														else if (static_cast<PlayerInfo*>(peer->data)->isNicked)
														{
															static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->OriName;
														}
														else
														{
															static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->tankIDName;
														}
													}
												}
											}
											else
											{
												if (static_cast<PlayerInfo*>(peer->data)->rawName == getPlyersWorld(peer)->owner)
												{
													if (isPlayer(peer))
													{
														if (static_cast<PlayerInfo*>(peer->data)->NickPrefix != "")
														{
															if (static_cast<PlayerInfo*>(peer->data)->isNicked)
															{
																static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->NickPrefix + ". " + static_cast<PlayerInfo*>(peer->data)->OriName;
															}
															else
															{
																static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->NickPrefix + ". " + static_cast<PlayerInfo*>(peer->data)->tankIDName;
															}
														}
														else if (static_cast<PlayerInfo*>(peer->data)->isNicked)
														{
															static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->OriName;
														}
														else
														{
															static_cast<PlayerInfo*>(peer->data)->displayName = "`2" + static_cast<PlayerInfo*>(peer->data)->tankIDName;
														}
													}
												}
												else
												{
													if (isPlayer(peer))
													{
														if (static_cast<PlayerInfo*>(peer->data)->NickPrefix != "")
														{
															if (static_cast<PlayerInfo*>(peer->data)->isNicked)
															{
																static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->NickPrefix + ". " + static_cast<PlayerInfo*>(peer->data)->OriName;
															}
															else
															{
																static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->NickPrefix + ". " + static_cast<PlayerInfo*>(peer->data)->tankIDName;
															}
														}
														else if (static_cast<PlayerInfo*>(peer->data)->isNicked)
														{
															static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->OriName;
														}
														else
														{
															static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->tankIDName;
														}
													}
												}
											}
											if (static_cast<PlayerInfo*>(peer->data)->haveGrowId)
											{
												if (static_cast<PlayerInfo*>(peer->data)->rawName == getPlyersWorld(peer)->owner)
												{
													if (isMod(peer))
													{
														if (static_cast<PlayerInfo*>(peer->data)->NickPrefix != "")
														{
															if (static_cast<PlayerInfo*>(peer->data)->isNicked)
															{
																static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->NickPrefix + ". " + static_cast<PlayerInfo*>(peer->data)->OriName;
															}
															else
															{
																static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->NickPrefix + ". " + static_cast<PlayerInfo*>(peer->data)->tankIDName;
															}
														}
														else if (static_cast<PlayerInfo*>(peer->data)->isNicked)
														{
															static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->OriName;
														}
														else
														{
															static_cast<PlayerInfo*>(peer->data)->displayName = "`#@" + static_cast<PlayerInfo*>(peer->data)->tankIDName;
														}
													}
												}
												else
												{
													if (isMod(peer))
													{
														if (static_cast<PlayerInfo*>(peer->data)->NickPrefix != "")
														{
															if (static_cast<PlayerInfo*>(peer->data)->isNicked)
															{
																static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->NickPrefix + ". " + static_cast<PlayerInfo*>(peer->data)->OriName;
															}
															else
															{
																static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->NickPrefix + ". " + static_cast<PlayerInfo*>(peer->data)->tankIDName;
															}
														}
														else if (static_cast<PlayerInfo*>(peer->data)->isNicked)
														{
															static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->OriName;
														}
														else
														{
															static_cast<PlayerInfo*>(peer->data)->displayName = "`#@" + static_cast<PlayerInfo*>(peer->data)->tankIDName;
														}
													}
												}
											}
											else
											{
												if (static_cast<PlayerInfo*>(peer->data)->rawName == getPlyersWorld(peer)->owner)
												{
													if (isMod(peer))
													{
														if (static_cast<PlayerInfo*>(peer->data)->NickPrefix != "")
														{
															if (static_cast<PlayerInfo*>(peer->data)->isNicked)
															{
																static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->NickPrefix + ". " + static_cast<PlayerInfo*>(peer->data)->OriName;
															}
															else
															{
																static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->NickPrefix + ". " + static_cast<PlayerInfo*>(peer->data)->tankIDName;
															}
														}
														else if (static_cast<PlayerInfo*>(peer->data)->isNicked)
														{
															static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->OriName;
														}
														else
														{
															static_cast<PlayerInfo*>(peer->data)->displayName = "`#@" + static_cast<PlayerInfo*>(peer->data)->tankIDName;
														}
													}
												}
												else
												{
													if (isMod(peer))
													{
														if (static_cast<PlayerInfo*>(peer->data)->NickPrefix != "")
														{
															if (static_cast<PlayerInfo*>(peer->data)->isNicked)
															{
																static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->NickPrefix + ". " + static_cast<PlayerInfo*>(peer->data)->OriName;
															}
															else
															{
																static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->NickPrefix + ". " + static_cast<PlayerInfo*>(peer->data)->tankIDName;
															}
														}
														else if (static_cast<PlayerInfo*>(peer->data)->isNicked)
														{
															static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->OriName;
														}
														else
														{
															static_cast<PlayerInfo*>(peer->data)->displayName = "`#@" + static_cast<PlayerInfo*>(peer->data)->tankIDName;
														}
													}
												}
											}
											if (static_cast<PlayerInfo*>(peer->data)->haveGrowId)
											{
												if (static_cast<PlayerInfo*>(peer->data)->rawName == getPlyersWorld(peer)->owner)
												{
													if (isDev(peer))
													{
														if (static_cast<PlayerInfo*>(peer->data)->NickPrefix != "")
														{
															if (static_cast<PlayerInfo*>(peer->data)->isNicked)
															{
																static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->NickPrefix + ". " + static_cast<PlayerInfo*>(peer->data)->OriName;
															}
															else
															{
																static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->NickPrefix + ". " + static_cast<PlayerInfo*>(peer->data)->tankIDName;
															}
														}
														else if (static_cast<PlayerInfo*>(peer->data)->isNicked)
														{
															static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->OriName;
														}
														else
														{
															static_cast<PlayerInfo*>(peer->data)->displayName = "`6@" + static_cast<PlayerInfo*>(peer->data)->tankIDName;
														}
													}
												}
												else
												{
													if (isDev(peer))
													{
														if (static_cast<PlayerInfo*>(peer->data)->NickPrefix != "")
														{
															if (static_cast<PlayerInfo*>(peer->data)->isNicked)
															{
																static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->NickPrefix + ". " + static_cast<PlayerInfo*>(peer->data)->OriName;
															}
															else
															{
																static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->NickPrefix + ". " + static_cast<PlayerInfo*>(peer->data)->tankIDName;
															}
														}
														else if (static_cast<PlayerInfo*>(peer->data)->isNicked)
														{
															static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->OriName;
														}
														else
														{
															static_cast<PlayerInfo*>(peer->data)->displayName = "`6@" + static_cast<PlayerInfo*>(peer->data)->tankIDName;
														}
													}
												}
											}
											else
											{
												if (static_cast<PlayerInfo*>(peer->data)->rawName == getPlyersWorld(peer)->owner)
												{
													if (isDev(peer))
													{
														if (static_cast<PlayerInfo*>(peer->data)->NickPrefix != "")
														{
															if (static_cast<PlayerInfo*>(peer->data)->isNicked)
															{
																static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->NickPrefix + ". " + static_cast<PlayerInfo*>(peer->data)->OriName;
															}
															else
															{
																static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->NickPrefix + ". " + static_cast<PlayerInfo*>(peer->data)->tankIDName;
															}
														}
														else if (static_cast<PlayerInfo*>(peer->data)->isNicked)
														{
															static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->OriName;
														}
														else
														{
															static_cast<PlayerInfo*>(peer->data)->displayName = "`6@" + static_cast<PlayerInfo*>(peer->data)->tankIDName;
														}
													}
												}
												else
												{
													if (isDev(peer))
													{
														if (static_cast<PlayerInfo*>(peer->data)->NickPrefix != "")
														{
															if (static_cast<PlayerInfo*>(peer->data)->isNicked)
															{
																static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->NickPrefix + ". " + static_cast<PlayerInfo*>(peer->data)->OriName;
															}
															else
															{
																static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->NickPrefix + ". " + static_cast<PlayerInfo*>(peer->data)->tankIDName;
															}
														}
														else if (static_cast<PlayerInfo*>(peer->data)->isNicked)
														{
															static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->OriName;
														}
														else
														{
															static_cast<PlayerInfo*>(peer->data)->displayName = "`6@" + static_cast<PlayerInfo*>(peer->data)->tankIDName;
														}
													}
												}
											}

											if (static_cast<PlayerInfo*>(peer->data)->isNicked)
											{
												GamePacket p7 = packetEnd(appendString(appendString(createPacket(), "OnNameChanged"), title_name + ". " + static_cast<PlayerInfo*>(peer->data)->OriName));
												memcpy(p7.data + 8, &(static_cast<PlayerInfo*>(peer->data)->netID), 4);
												ENetPacket* packet7 = enet_packet_create(p7.data, p7.len, ENET_PACKET_FLAG_RELIABLE);
												ENetPeer* currentPeer;
												for (currentPeer = server->peers;
													currentPeer < &server->peers[server->peerCount];
													++currentPeer)
												{
													if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
													if (isHere(peer, currentPeer))
													{
														enet_peer_send(currentPeer, 0, packet7);
													}
												}
												delete p7.data;
											}
											else
											{
												GamePacket p7 = packetEnd(appendString(appendString(createPacket(), "OnNameChanged"), title_name + ". " + static_cast<PlayerInfo*>(peer->data)->rawName));
												memcpy(p7.data + 8, &(static_cast<PlayerInfo*>(peer->data)->netID), 4);
												ENetPacket* packet7 = enet_packet_create(p7.data, p7.len, ENET_PACKET_FLAG_RELIABLE);
												ENetPeer* currentPeer;
												for (currentPeer = server->peers;
													currentPeer < &server->peers[server->peerCount];
													++currentPeer)
												{
													if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
													if (isHere(peer, currentPeer))
													{
														enet_peer_send(currentPeer, 0, packet7);
													}
												}
												delete p7.data;
											}
										}
									}
								}
								if (notebook_edit)
								{
									if (infoDat[0] == "personal_note")
									{
										personal_note = infoDat[1];
										if (personal_note.size() >= 128 || personal_note.size() <= 0) break;

										ifstream fg("players/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".json");
										json j;
										fg >> j;
										fg.close();

										j["notebook"] = personal_note;

										ofstream fs("players/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".json");
										fs << j;
										fs.close();
										static_cast<PlayerInfo*>(peer->data)->notebook = personal_note;
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`2Text saved.", 0, true);
									}
								}
								if (signEditor)
								{
									if (world == nullptr || world->name == "EXIT" || serverIsFrozen) break;
									PlayerInfo* pinfo = static_cast<PlayerInfo*>(peer->data);
									WorldInfo* world = getPlyersWorld(peer);
									int x = pinfo->wrenchedBlockLocation % world->width;
									int y = pinfo->wrenchedBlockLocation / world->width;
									if (x < 0 || y < 0) break;
									world->items[pinfo->wrenchedBlockLocation].sign = message321;
									UpdateMessageVisuals(peer, world->items[pinfo->wrenchedBlockLocation].foreground, x, y, message321, world->items[pinfo->wrenchedBlockLocation].background);
								}
								if (isLockDialog)
								{
									if (world == nullptr || world->name == "EXIT" || serverIsFrozen) break;
									bool ekk = false;
									int x = static_cast<PlayerInfo*>(peer->data)->wrenchedBlockLocation % world->width;
									int y = static_cast<PlayerInfo*>(peer->data)->wrenchedBlockLocation / world->width;
									if (x < 0 || y < 0) break;
									int fg = world->items[x + (y * world->width)].foreground;
									int bg = world->items[x + (y * world->width)].background;
									ENetPeer* currentPeer;
									for (currentPeer = server->peers;
										currentPeer < &server->peers[server->peerCount];
										++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
											continue;
										if (isHere(peer, currentPeer))
										{
											if (static_cast<PlayerInfo*>(currentPeer->data)->netID == atoi(playerNetId.c_str()))
											{
												if (!isWorldAdmin(currentPeer, world) && !isWorldOwner(currentPeer, world))
												{
													accessPlayer(peer, static_cast<PlayerInfo*>(currentPeer->data)->rawName, world);
												}
											}
										}
									}
									if (getItemDef(fg).blockType == BlockTypes::LOCK && has_only_digits(minimum_level)) {
										uint8_t lol = 0x00;


										int minimum_levels = atoi(minimum_level.c_str());


										world->worldlevel = minimum_levels;
									}
									if (muted == "1")
									{
										world->silence = true;
									}
									else
									{
										world->silence = false;
									}
								}
								if (isaddItemToStoreDialog)
								{
									if (world == nullptr || world->name == "EXIT" || serverIsFrozen) break;
									if (infoDat[0] == "addItemToStore") addItemToStore = infoDat[1];
									if (addItemToStore.size() > 5) break;
									int itemid = atoi(addItemToStore.c_str());
									GTDialog dialogaddItemToStore;
									dialogaddItemToStore.addSpacer(SPACER_SMALL);
									dialogaddItemToStore.addSmallText("`$How many of " + itemDefs[itemid].name + " you want to put on sale?");
									dialogaddItemToStore.addInputBox("storeItemPickerCount_" + to_string(itemid) + "", "How many you want to put?", "", 3);
									dialogaddItemToStore.addSpacer(SPACER_SMALL);
									dialogaddItemToStore.addSmallText("`$Write a description about this item for buyers.");
									dialogaddItemToStore.addInputBox("storeItemDescription", "Description:", "", 50);
									dialogaddItemToStore.addSpacer(SPACER_SMALL);
									dialogaddItemToStore.addSmallText("`$Enter item id that will be used as the price for your selling item.");
									dialogaddItemToStore.addSmallText("`$PS: you can find any items id using (`#/findid <item name>`$) command.");
									dialogaddItemToStore.addInputBox("storeItemSellForItem", "Item id:", "", 5);
									dialogaddItemToStore.addSpacer(SPACER_SMALL);
									dialogaddItemToStore.addSmallText("`$How many of these items that you wrote above need to buy your selling item?");
									dialogaddItemToStore.addInputBox("storeItemSellPer", "How many per?", "", 3);
									dialogaddItemToStore.addSpacer(SPACER_SMALL);
									dialogaddItemToStore.addQuickExit();
									dialogaddItemToStore.endDialog("addItemStoreOnSale", "Add item on sale", "Cancel");
									Player::OnDialogRequest(peer, dialogaddItemToStore.finishDialog());
								}
								if (isStuffDialog)
								{
									if (world == nullptr || world->name == "EXIT" || serverIsFrozen) break;
									int stuffitemi = 0;
									int gravity = 100;
									int x = static_cast<PlayerInfo*>(peer->data)->lastPunchX;
									int y = static_cast<PlayerInfo*>(peer->data)->lastPunchY;
									if (infoDat[0] == "stuffitem")
									{
										if (stuffitem.size() > 5 || stuffitem.size() <= 0) break;
										stuffitem = infoDat[1];
									}
									if (infoDat[0] == "gravity")
									{
										if (gravitystr.size() > 3 || gravitystr.size() <= 0) break;
										gravitystr = infoDat[1];
									}
									if (has_only_digits(stuffitem))
									{
										stuffitemi = atoi(stuffitem.c_str());
										if (stuffitemi > maxItems) break;
									}
									if (has_only_digits_wnegative(gravitystr)) gravity = atoi(gravitystr.c_str());
									if (gravity > -1000 && gravity < 1000 && stuffitemi > -1 && stuffitemi < 9142)
									{
										world->items[x + (y * world->width)].displayBlock = stuffitemi;
										world->items[x + (y * world->width)].gravity = gravity;
									}
									updateStuffWeather(peer, x, y, stuffitemi, world->items[x + (y * world->width)].background, gravity, false, false);
									getPlyersWorld(peer)->weather = 29;
								}
								if (isMagDialog)
								{
									if (world == nullptr || world->name == "EXIT" || serverIsFrozen || static_cast<PlayerInfo*>(peer->data)->rawName != world->owner && !isMod(peer) && world->owner != "") break;
									int magplantitemi = 0;
									int x = static_cast<PlayerInfo*>(peer->data)->lastPunchX;
									int y = static_cast<PlayerInfo*>(peer->data)->lastPunchY;
									int suckerid = static_cast<PlayerInfo*>(peer->data)->suckerid;
									string suckername = static_cast<PlayerInfo*>(peer->data)->suckername;
									if (infoDat[0] == "magplantitem")
									{
										magplantitem = infoDat[1];
									}
									magplantitemi = atoi(magplantitem.c_str());
									int squaresign = x + (y * 100);
									string currentworld = static_cast<PlayerInfo*>(peer->data)->currentWorld + "X" + std::to_string(squaresign);
									bool allow = true;
									for (int i = 0; i < world->width * world->height; i++)
									{
										if (world->items[i].foreground == 5638 || world->items[i].foreground == 6946 || world->items[i].foreground == 6948)
										{
											string SuckerName3 = "";
											if (world->items[i].foreground == 5638) SuckerName3 = "magplant";
											if (world->items[i].foreground == 6946) SuckerName3 = "gaiabeacon";
											if (world->items[i].foreground == 6948) SuckerName3 = "unstabletesseract";
											int itemid = 0;
											ifstream fdss(SuckerName3 + "/storeditem/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "X" + std::to_string(i) + ".txt");
											fdss >> itemid;
											fdss.close();
											if (magplantitemi == itemid)
											{
												allow = false;
											}
										}
									}
									if (magplantitemi == 18 || magplantitemi == 32 || getItemDef(magplantitemi).properties & Property_Untradable)
									{
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "You cannot use this item in " + getItemDef(suckerid).name + "!", 0, true);
									}
									else if (suckerid == 6946 && !isSeed(magplantitemi))
									{
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, getItemDef(suckerid).name + " supports only seeds!", 0, true);
									}
									else if (suckerid == 6948 && getItemDef(magplantitemi).blockType != BlockTypes::FOREGROUND && getItemDef(magplantitemi).blockType != BlockTypes::PAIN_BLOCK && getItemDef(magplantitemi).blockType != BlockTypes::GROUND_BLOCK && getItemDef(magplantitemi).blockType != BlockTypes::BACKGROUND)
									{
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, getItemDef(suckerid).name + " supports only foregrounds or backgrounds!", 0, true);
									}
									else if (allow == false)
									{
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "There is already Item Sucker with such item!", 0, true);
									}
									else
									{
										auto contains = false;
										SearchInventoryItem(peer, magplantitemi, 1, contains);
										if (!contains)
										{
											autoBan(peer, false, 24 * 7, "Used magplant exploit");
											break;
										}
										ENetPeer* currentPeer;
										for (currentPeer = server->peers;
											currentPeer < &server->peers[server->peerCount];
											++currentPeer)
										{
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
												continue;
											if (isHere(peer, currentPeer))
											{
												SendItemSucker(currentPeer, suckerid, x, y, magplantitemi, 0, true, true);
											}
										}
										ofstream fdss(suckername + "/storeditem/" + currentworld + ".txt");
										fdss << magplantitemi;
										fdss.close();
										ofstream fdss3(suckername + "/count/" + currentworld + ".txt");
										fdss3 << 0;
										fdss3.close();
									}
								}
								if (isBfgDialog)
								{
									if (world == nullptr || world->name == "EXIT" || serverIsFrozen || static_cast<PlayerInfo*>(peer->data)->rawName != world->owner) break;
									int magplantitemi = 0;
									int x = static_cast<PlayerInfo*>(peer->data)->lastPunchX;
									int y = static_cast<PlayerInfo*>(peer->data)->lastPunchY;
									int suckerid = static_cast<PlayerInfo*>(peer->data)->suckerid;
									string suckername = static_cast<PlayerInfo*>(peer->data)->suckername;
									if (infoDat[0] == "emeraldbfg")
									{
										emeraldbfg = infoDat[1];
									}
									magplantitemi = atoi(emeraldbfg.c_str());
									int squaresign = x + (y * 100);
									string currentworld = static_cast<PlayerInfo*>(peer->data)->currentWorld + "X" + std::to_string(squaresign);
									if (magplantitemi == 18 || magplantitemi == 32 || getItemDef(magplantitemi).properties & Property_Untradable)
									{
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "You cannot use this item in " + getItemDef(suckerid).name + "!", 0, true);
									}
									else if (suckerid == 2408 && getItemDef(magplantitemi).blockType != BlockTypes::FOREGROUND && getItemDef(magplantitemi).blockType != BlockTypes::PAIN_BLOCK && getItemDef(magplantitemi).blockType != BlockTypes::GROUND_BLOCK && getItemDef(magplantitemi).blockType != BlockTypes::BACKGROUND)
									{
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, getItemDef(suckerid).name + " supports only foregrounds or backgrounds!", 0, true);
									}
									else
									{
										ofstream fdss("bfg/" + currentworld + ".txt");
										fdss << magplantitemi;
										fdss.close();
										getPlyersWorld(peer)->interactableid = magplantitemi;
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "Applied!", 0, true);
									}
								}
								if (isFindDialog)
								{
									if (infoDat[0] == "item") itemFind = infoDat[1];
								}
								if (isDarkStoneBuyDialog)
								{
									if (world == nullptr || world->name == "EXIT" || serverIsFrozen) break;
									if (infoDat[0] == "darkstoneoffer")
									{
										reqBuyDarkStoneOffer = infoDat[1];
										bool contains_non_int = !std::regex_match(reqBuyDarkStoneOffer, std::regex("^[0-9]+$"));
										if (contains_non_int == true)
										{
											Player::OnTextOverlay(peer, "`@Invalid `bDark Stone's `@Format!");
											break;
										}
										else
										{
											if (reqBuyDarkStoneOffer.size() > 3 || reqBuyDarkStoneOffer.size() <= 0)
											{
												break;
											}
											int konvertuotasInt = stoi(reqBuyDarkStoneOffer);
											if (CheckItemMaxed(peer, 10026, konvertuotasInt))
											{
												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "Those dark stones wont fit into my backpack!", 0, true);
												break;
											}
											if (konvertuotasInt <= 0 || konvertuotasInt >= 200)
											{
												Player::OnTextOverlay(peer, "`bDark Stone's `@Should Be Between `91-199`@!");
												break;
											}
											else
											{
												std::ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
												std::string content((std::istreambuf_iterator<char>(ifsz)),
													(std::istreambuf_iterator<char>()));
												int b = atoi(content.c_str());
												if (b > 500000 * konvertuotasInt)
												{
													bool success = true;
													SaveShopsItemMoreTimes(10026, konvertuotasInt, peer, success); // aposition, itemid, quantity, peer, success
													if (!success)break;
													Player::OnTextOverlay(peer, "`9You have bought `bDark Stone's`9!");
													string text = "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0\n";
													BYTE* data = new BYTE[5 + text.length()];
													BYTE zero = 0;
													int type = 3;
													memcpy(data, &type, 4);
													memcpy(data + 4, text.c_str(), text.length()); // change memcpy here
													memcpy(data + 4 + text.length(), &zero, 1); // change memcpy here, revert to 4
													ENetPacket* packetsou = enet_packet_create(data,
														5 + text.length(),
														ENET_PACKET_FLAG_RELIABLE);
													enet_peer_send(peer, 0, packetsou);
													int gemcalc10k = b - 500000 * konvertuotasInt;
													ofstream myfile2;
													myfile2.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
													myfile2 << std::to_string(gemcalc10k);
													myfile2.close();
													std::ifstream ifszi("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
													std::string contentx((std::istreambuf_iterator<char>(ifszi)),
														(std::istreambuf_iterator<char>()));
													int updgem = atoi(contentx.c_str());
													GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), updgem));
													ENetPacket* packetpp = enet_packet_create(pp.data,
														pp.len,
														ENET_PACKET_FLAG_RELIABLE);
													enet_peer_send(peer, 0, packetpp);
													delete pp.data;
												}
												else
												{
													Player::OnTextOverlay(peer, "`9You `@Don't `9Have enough `9Gem's`9!");
												}
											}
										}
									}
								}
								if (isWorldLockBuyDialog)
								{
									if (world == nullptr || world->name == "EXIT" || serverIsFrozen) break;
									if (infoDat[0] == "worldlockoffer")
									{
										strBuyWorldLockOffer = infoDat[1];
										bool contains_non_int = !std::regex_match(strBuyWorldLockOffer, std::regex("^[0-9]+$"));
										if (contains_non_int == true)
										{
											GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`@Invalid `2World Lock's `@Format!"));
											ENetPacket* packet2 = enet_packet_create(p2.data,
												p2.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(peer, 0, packet2);
											delete p2.data;
											break;
										}
										else
										{
											if (strBuyWorldLockOffer.size() > 3 || strBuyWorldLockOffer.size() <= 0)
											{
												break;
											}
											int konvertuotasInt = stoi(strBuyWorldLockOffer);
											if (CheckItemMaxed(peer, 242, konvertuotasInt))
											{
												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "Those world locks wont fit into my backpack!", 0, true);
												break;
											}
											if (konvertuotasInt <= 0 || konvertuotasInt >= 200)
											{
												GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9World Lock's `@Should Be Between `91-199`@!"));
												ENetPacket* packet2 = enet_packet_create(p2.data,
													p2.len,
													ENET_PACKET_FLAG_RELIABLE);
												enet_peer_send(peer, 0, packet2);
												delete p2.data;
												break;
											}
											else
											{
												std::ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
												std::string content((std::istreambuf_iterator<char>(ifsz)),
													(std::istreambuf_iterator<char>()));
												int b = atoi(content.c_str());
												if (b > 1000 * konvertuotasInt)
												{
													bool success = true;
													SaveShopsItemMoreTimes(242, konvertuotasInt, peer, success); // aposition, itemid, quantity, peer, success
													if (!success) break;
													GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You have bought `2World Lock's`9!"));
													ENetPacket* packet2 = enet_packet_create(p2.data,
														p2.len,
														ENET_PACKET_FLAG_RELIABLE);
													enet_peer_send(peer, 0, packet2);
													delete p2.data;
													string text = "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0\n";
													BYTE* data = new BYTE[5 + text.length()];
													BYTE zero = 0;
													int type = 3;
													memcpy(data, &type, 4);
													memcpy(data + 4, text.c_str(), text.length()); // change memcpy here
													memcpy(data + 4 + text.length(), &zero, 1); // change memcpy here, revert to 4
													ENetPacket* packetsou = enet_packet_create(data,
														5 + text.length(),
														ENET_PACKET_FLAG_RELIABLE);
													enet_peer_send(peer, 0, packetsou);
													int gemcalc10k = b - 1000 * konvertuotasInt;
													ofstream myfile2;
													myfile2.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
													myfile2 << std::to_string(gemcalc10k);
													myfile2.close();
													std::ifstream ifszi("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
													std::string contentx((std::istreambuf_iterator<char>(ifszi)),
														(std::istreambuf_iterator<char>()));
													int updgem = atoi(contentx.c_str());
													GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), updgem));
													ENetPacket* packetpp = enet_packet_create(pp.data,
														pp.len,
														ENET_PACKET_FLAG_RELIABLE);
													enet_peer_send(peer, 0, packetpp);
													delete pp.data;
												}
												else
												{
													GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You `@Don't `9Have enough `9Gem's`9!"));
													ENetPacket* packet2 = enet_packet_create(p2.data,
														p2.len,
														ENET_PACKET_FLAG_RELIABLE);
													enet_peer_send(peer, 0, packet2);
													delete p2.data;
												}
											}
										}
									}
								}
								if (isDiamondLockBuyDialog)
								{
									if (world == nullptr || world->name == "EXIT" || serverIsFrozen) break;
									if (infoDat[0] == "diamondlockoffer")
									{
										strBuyDiamondLockOffer = infoDat[1];
										bool contains_non_int = !std::regex_match(strBuyDiamondLockOffer, std::regex("^[0-9]+$"));
										if (contains_non_int == true)
										{
											GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`@Invalid `2World Lock's `@Format!"));
											ENetPacket* packet2 = enet_packet_create(p2.data,
												p2.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(peer, 0, packet2);
											delete p2.data;
											break;
										}
										else
										{
											if (strBuyDiamondLockOffer.size() > 3 || strBuyDiamondLockOffer.size() <= 0)
											{
												break;
											}
											int konvertuotasInt = stoi(strBuyDiamondLockOffer);
											if (CheckItemMaxed(peer, 1796, konvertuotasInt))
											{
												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "Those diamond locks wont fit into my backpack!", 0, true);
												break;
											}
											if (konvertuotasInt <= 0 || konvertuotasInt >= 200)
											{
												GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`1Diamond Lock's `@Should Be Between `91-199`@!"));
												ENetPacket* packet2 = enet_packet_create(p2.data,
													p2.len,
													ENET_PACKET_FLAG_RELIABLE);
												enet_peer_send(peer, 0, packet2);
												delete p2.data;
												break;
											}
											else
											{
												std::ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
												std::string content((std::istreambuf_iterator<char>(ifsz)),
													(std::istreambuf_iterator<char>()));
												int b = atoi(content.c_str());
												if (b > 100000 * konvertuotasInt)
												{
													bool success = true;
													SaveShopsItemMoreTimes(1796, konvertuotasInt, peer, success);
													if (!success) break;
													GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You have bought `1Diamond Lock's`9!"));
													ENetPacket* packet2 = enet_packet_create(p2.data,
														p2.len,
														ENET_PACKET_FLAG_RELIABLE);
													enet_peer_send(peer, 0, packet2);
													delete p2.data;
													string text = "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0\n";
													BYTE* data = new BYTE[5 + text.length()];
													BYTE zero = 0;
													int type = 3;
													memcpy(data, &type, 4);
													memcpy(data + 4, text.c_str(), text.length()); // change memcpy here
													memcpy(data + 4 + text.length(), &zero, 1); // change memcpy here, revert to 4
													ENetPacket* packetsou = enet_packet_create(data,
														5 + text.length(),
														ENET_PACKET_FLAG_RELIABLE);
													enet_peer_send(peer, 0, packetsou);
													int gemcalc10k = b - 100000 * konvertuotasInt;
													ofstream myfile2;
													myfile2.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
													myfile2 << std::to_string(gemcalc10k);
													myfile2.close();
													std::ifstream ifszi("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
													std::string contentx((std::istreambuf_iterator<char>(ifszi)),
														(std::istreambuf_iterator<char>()));
													int updgem = atoi(contentx.c_str());
													GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), updgem));
													ENetPacket* packetpp = enet_packet_create(pp.data,
														pp.len,
														ENET_PACKET_FLAG_RELIABLE);
													enet_peer_send(peer, 0, packetpp);
													delete pp.data;
												}
												else
												{
													GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You `@Don't `9Have enough `9Gem's`9!"));
													ENetPacket* packet2 = enet_packet_create(p2.data,
														p2.len,
														ENET_PACKET_FLAG_RELIABLE);
													enet_peer_send(peer, 0, packet2);
													delete p2.data;
												}
											}
										}
									}
								}

								if (isCreateStoreDialog)
								{
									if (world == nullptr || world->name == "EXIT" || serverIsFrozen) continue;
									if (infoDat[0] == "createstorefg")
									{
										createstorefg = infoDat[1];
										bool contains_non_int
											= !std::regex_match(createstorefg, std::regex("^[0-9]+$"));
										if (contains_non_int == true || createstorefg == "" || createstorefg.size() > 5 || createstorefg.size() <= 0)
										{
											Player::OnTextOverlay(peer, "`@You may only use `^Positive `@Numbers to create your own store!");
											break;
										}
									}
									if (infoDat[0] == "createstorename")
									{
										createstorename = infoDat[1];
										bool contains_non_alpha
											= createstorename.find_first_not_of("abcdefghijklmnopqrstuvwxyz") != std::string::npos;
										if (contains_non_alpha == true || createstorename == "")
										{
											Player::OnTextOverlay(peer, "`@You may only use letters in your store name!");
											break;
										}
										if (createstorename.size() <= 6)
										{
											Player::OnTextOverlay(peer, "`@Store name is too short!");
											break;
										}
									}
									if (infoDat[0] == "createstoredesc")
									{
										createstoredesc = infoDat[1];
										if (createstoredesc.size() < 10)
										{
											Player::OnTextOverlay(peer, "`@Too short description!");
											break;
										}
										std::ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										std::string content((std::istreambuf_iterator<char>(ifsz)),
											(std::istreambuf_iterator<char>()));
										int b = atoi(content.c_str());
										if (b >= 40000)
										{
											try
											{
												time_t _tm = time(nullptr);
												struct tm* curtime = localtime(&_tm);
												string test = asctime(curtime);
												string tolog = test + " You have successfully created your store!";
												vector<string> logs = { tolog };
												json j;
												j["fg"] = createstorefg;
												j["name"] = createstorename;
												j["desc"] = createstoredesc;
												j["currentSpaceInStore"] = 5;
												j["logs"] = logs;
												j["newLogs"] = 1;
												json storeReviewall = json::array();
												json storeReview;
												for (int i = 1; i <= 50; i++)
												{
													storeReview["aposition"] = i;
													storeReview["sentBy"] = "";
													storeReview["review"] = "";
													storeReview["stars"] = 0;
													storeReviewall.push_back(storeReview);
												}
												j["storeReview"] = storeReviewall;
												json jjall = json::array();
												json jj;
												for (int i = 1; i <= 100; i++)
												{
													jj["aposition"] = i;
													jj["itemid"] = 0;
													jj["quantityOfItems"] = 0;
													jj["sellPer"] = 0;
													jj["sellForItem"] = 0;
													jj["itemDesc"] = "";
													jj["boughtItems"] = 0;
													jjall.push_back(jj);
												}
												j["itemsInStore"] = jjall;
												vector<string> allStores;
												ifstream iffff("storeinfo/stores.json");
												json j2;
												iffff >> j2;
												iffff.close();
												bool arYraToksId = false;
												for (int i = 0; i < j2["owners"].size(); i++)
												{
													allStores.push_back(j2["owners"][i]);
													ifstream iifff("store/" + PlayerDB::getProperName(allStores[i]) + ".json");
													json jh;
													iifff >> jh;
													iifff.close();
													if (jh["name"].get<string>() == createstorename)
													{
														arYraToksId = true;
														break;
													}
												}
												if (arYraToksId == true)
												{
													Player::OnTextOverlay(peer, "`4This name is already taken by another seller! Use another.");
													break;
												}
												int gemcalc10k = b - 40000;
												ofstream myfile2;
												myfile2.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
												myfile2 << std::to_string(gemcalc10k);
												myfile2.close();
												std::ifstream ifszi("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
												std::string contentx((std::istreambuf_iterator<char>(ifszi)),
													(std::istreambuf_iterator<char>()));
												int updgem = atoi(contentx.c_str());
												GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), updgem));
												ENetPacket* packetpp = enet_packet_create(pp.data,
													pp.len,
													ENET_PACKET_FLAG_RELIABLE);
												enet_peer_send(peer, 0, packetpp);
												delete pp.data;
												allStores.push_back(static_cast<PlayerInfo*>(peer->data)->rawName);
												j2["owners"] = allStores;
												std::ofstream oo("store/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".json");
												if (!oo.is_open()) break;
												oo << j << std::endl;
												std::ofstream oo2("storeinfo/stores.json");
												if (!oo2.is_open()) break;
												oo2 << j2 << std::endl;
												Player::OnConsoleMessage(peer, "`2You have succeessfully created your own store.");
											}
											catch (std::exception&)
											{
												SendConsole("createstoredesc Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
												enet_peer_disconnect_now(peer, 0);
											}
											catch (std::runtime_error&)
											{
												SendConsole("createstoredesc Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
												enet_peer_disconnect_now(peer, 0);
											}
											catch (...)
											{
												SendConsole("createstoredesc Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
												enet_peer_disconnect_now(peer, 0);
											}
										}
										else
										{
											Player::OnTextOverlay(peer, "`4You don't have enough gems.");
											break;
										}
									}
								}
								if (isWorldTradeDialog)
								{
									if (world == nullptr || world->name == "EXIT" || serverIsFrozen) continue;
									if (infoDat[0] == "worldoffer")
									{
										bool islegitnow = true;
										strBuyOffer = infoDat[1];
										bool contains_non_int
											= !std::regex_match(strBuyOffer, std::regex("^[0-9]+$"));
										if (contains_non_int == true)
										{
											Player::OnTextOverlay(peer, "`@You may only use `^Positive `@Numbers to begin a Trade!");
										}
										else
										{
											for (int i = 0; i < world->width * world->height; i++)
											{
												if (world->items[i].foreground == 1790)
												{
													Player::OnTextOverlay(peer, "`@You `4Cannot `@Buy World With `4Untradeable `@Blocks!");
													islegitnow = false;
													continue;
												}
											}
											if (islegitnow == true)
											{
												buyOffer = std::atoi(strBuyOffer.c_str());
												Player::OnTextOverlay(peer, "`2World Trade Request Sended To `c" + static_cast<PlayerInfo*>(peer->data)->lastInfo + "`2! For `4" + strBuyOffer + " `cGems.");
												ENetPeer* currentPeerpx;
												for (currentPeerpx = server->peers;
													currentPeerpx < &server->peers[server->peerCount];
													++currentPeerpx)
												{
													if (currentPeerpx->state != ENET_PEER_STATE_CONNECTED)
														continue;
													if (isHere(peer, currentPeerpx))
													{
														if (static_cast<PlayerInfo*>(currentPeerpx->data)->rawName == static_cast<PlayerInfo*>(peer->data)->lastInfo)
														{
															Player::OnConsoleMessage(currentPeerpx, static_cast<PlayerInfo*>(peer->data)->displayName + " `2Wants To `cBuy Your World `2For `4" + strBuyOffer + " `cGems. `2Do `c/tradeworld `2To `cAccept/Decline`2!");
															static_cast<PlayerInfo*>(peer->data)->lastBuyer = static_cast<PlayerInfo*>(currentPeerpx->data)->rawName;
															static_cast<PlayerInfo*>(currentPeerpx->data)->lastSeller = static_cast<PlayerInfo*>(peer->data)->rawName;
															static_cast<PlayerInfo*>(currentPeerpx->data)->lastTradeAmount = buyOffer;
															static_cast<PlayerInfo*>(peer->data)->lastTradeAmount = buyOffer;
															static_cast<PlayerInfo*>(currentPeerpx->data)->lastSellWorld = getPlyersWorld(currentPeerpx)->name;
															static_cast<PlayerInfo*>(peer->data)->lastSellWorld = getPlyersWorld(peer)->name;
														}
													}
												}
											}
										}
									}
								}
								if (infoDat[0] == "dialog_name" && infoDat[1] == "pssdia") isPasswordDialog = true;
								if (infoDat[0] == "dialog_name" && infoDat[1] == "register") isRegisterDialog = true;
								if (infoDat[0] == "dialog_name" && infoDat[1] == "wgmgen") isGenDialog = true;
								if (infoDat[0] == "dialog_name" && infoDat[1] == "useuranusblast") isUranusDialog = true;
								if (infoDat[0] == "dialog_name" && infoDat[1] == "usetelephone") isTeleDialog = true;
								if (isPasswordDialog)
								{
									if (infoDat[0] == "oldpass") oldpass = infoDat[1];
									if (infoDat[0] == "newpass") password2 = infoDat[1];
									if (infoDat[0] == "verifypass") password2verify = infoDat[1];
								}
								if (isGenDialog)
								{
									if (world == nullptr || world->name == "EXIT" || serverIsFrozen) continue;
									if (infoDat[0] == "worldname")
									{
										worldname3 = infoDat[1];
										string upsd = worldname3;
										string act = worldname3;
										std::transform(upsd.begin(), upsd.end(), upsd.begin(), ::toupper);
										if (act.find(" ") != string::npos || act.find("  ") != string::npos || act.find(".") != string::npos || act.find("?") != string::npos || act.find(",") != string::npos || act.find("@") != string::npos || act.find("[") != string::npos || act.find("]") != string::npos || act.find("#") != string::npos || act.find("<") != string::npos || act.find(">") != string::npos || act.find(":") != string::npos || act.find("\"") != string::npos || act.find("{") != string::npos || act.find("}") != string::npos || act.find("|") != string::npos || act.find("+") != string::npos || act.find("_") != string::npos || act.find("~") != string::npos || act.find("-") != string::npos || act.find("!") != string::npos || act.find("$") != string::npos || act.find("%") != string::npos || act.find("^") != string::npos || act.find("&") != string::npos || act.find("`") != string::npos || act.find("*") != string::npos || act.find("(") != string::npos || act.find(")") != string::npos || act.find("=") !=
											string::npos || act.find("'") != string::npos || act.find(";") != string::npos || act.find("/") != string::npos)
										{
											Player::OnTextOverlay(peer, "You cant use symbols in world name");
											Player::OnFailedToEnterWorld(peer);
											continue;
											break;
										}
										bool existx = std::experimental::filesystem::exists("worlds/_" + worldname3 + ".json");
										if (!existx)
										{
											if (worldname3.find_first_not_of("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789") != string::npos)
											{
												Player::OnConsoleMessage(peer, "`oSymbols are not allowed!");
												continue;
											}
											if (upsd.find(" ") != string::npos)
											{
												Player::OnConsoleMessage(peer, "`oSpaces are not allowed!");
												continue;
											}
											if (upsd == "EXIT")
											{
												Player::OnConsoleMessage(peer, "`oEntered world name is not allowed!");
												continue;
											}
											if (upsd == static_cast<PlayerInfo*>(peer->data)->currentWorld)
											{
												Player::OnTextOverlay(peer, "This world already exists!");
												continue;
											}
											static_cast<PlayerInfo*>(peer->data)->passedname = true;
										}
										else
										{
											Player::OnTextOverlay(peer, "This world already exists!");
										}
									}
									if (infoDat[0] == "worldheight")
									{
										worldheight3 = infoDat[1];
										if (has_only_digits(worldheight3) == false) continue;
										stringstream geek(worldheight3);
										int wheight = 0;
										geek >> wheight;
										if (worldheight3.find_first_not_of("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789") != string::npos)
										{
											Player::OnConsoleMessage(peer, "`oSymbols are not allowed!");
											continue;
										}
										if (worldheight3.find(" ") != string::npos)
										{
											Player::OnConsoleMessage(peer, "`oSpaces are not allowed!");
											continue;
										}
										if (wheight > 200 || wheight < 50)
										{
											Player::OnConsoleMessage(peer, "`oIncorrect world height value! It must be between `450 `@and `4200`@!");
											continue;
										}
										static_cast<PlayerInfo*>(peer->data)->passedheight = true;
										genheight = wheight;
									}
									if (infoDat[0] == "worldwidth")
									{
										worldwidth3 = infoDat[1];
										if (has_only_digits(worldwidth3) == false) continue;
										stringstream geeks(worldwidth3);
										int wwidth = 0;
										geeks >> wwidth;
										if (worldwidth3.find_first_not_of("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789") != string::npos)
										{
											Player::OnConsoleMessage(peer, "`oSymbols are not allowed!");
											continue;
										}
										if (worldwidth3.find(" ") != string::npos)
										{
											Player::OnConsoleMessage(peer, "`oSpaces are not allowed!");
											continue;
										}
										if (wwidth > 200 || wwidth < 50)
										{
											Player::OnConsoleMessage(peer, "`oIncorrect world width value! It must be between `450 `@and `4200`@!");
											continue;
										}
										static_cast<PlayerInfo*>(peer->data)->passedwidth = true;
										genwidth = wwidth;
									}
									if (infoDat[0] == "worldforeground")
									{
										worldforeground3 = infoDat[1];
										if (has_only_digits(worldforeground3) == false) continue;
										stringstream geekss(worldforeground3);
										int wforeground = 0;
										geekss >> wforeground;
										if (worldforeground3.find_first_not_of("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789") != string::npos)
										{
											Player::OnConsoleMessage(peer, "`oSymbols are not allowed!");
											continue;
										}
										if (worldforeground3.find(" ") != string::npos)
										{
											Player::OnConsoleMessage(peer, "`oSpaces are not allowed!");
											continue;
										}
										if (wforeground >= 30 || wforeground < 0)
										{
											Player::OnConsoleMessage(peer, "`oWorld foreground must be between `40 `@and `430`@!");
											continue;
										}
										if (isSeed(wforeground))
										{
											Player::OnConsoleMessage(peer, "`oYou cannot use seeds as ids!");
											continue;
										}
										static_cast<PlayerInfo*>(peer->data)->passedforeground = true;
										genforeground = wforeground;
									}
									if (infoDat[0] == "worldbackground")
									{
										worldbackground3 = infoDat[1];
										if (has_only_digits(worldbackground3) == false) continue;
										stringstream geeksss(worldbackground3);
										int wbackground = 0;
										geeksss >> wbackground;
										if (worldbackground3.find_first_not_of("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789") != string::npos)
										{
											Player::OnConsoleMessage(peer, "`oSymbols are not allowed!");
											continue;
										}
										if (worldbackground3.find(" ") != string::npos)
										{
											Player::OnConsoleMessage(peer, "`oSpaces are not allowed!");
											continue;
										}
										if (wbackground >= 30 || wbackground < 0)
										{
											Player::OnConsoleMessage(peer, "`oWorld background must be between `40 `@and `430`@!");
											continue;
										}
										if (isSeed(wbackground))
										{
											Player::OnConsoleMessage(peer, "`oYou cannot use seeds as ids!");
											continue;
										}
										static_cast<PlayerInfo*>(peer->data)->passedbackground = true;
										genbackground = wbackground;
									}
									if (infoDat[0] == "worldbedrock")
									{
										worldbedrock3 = infoDat[1];
										if (has_only_digits(worldbedrock3) == false) continue;
										stringstream geekssss(worldbedrock3);
										int wbedrock = 0;
										geekssss >> wbedrock;
										if (worldbedrock3.find_first_not_of("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789") != string::npos)
										{
											Player::OnConsoleMessage(peer, "`oSymbols are not allowed!");
											continue;
										}
										if (worldbedrock3.find(" ") != string::npos)
										{
											Player::OnConsoleMessage(peer, "`oSpaces are not allowed!");
											continue;
										}
										if (wbedrock >= 30 || wbedrock < 0)
										{
											Player::OnConsoleMessage(peer, "`oWorld bedrock must be between `40 `@and `430`@!");
											continue;
										}
										if (isSeed(wbedrock))
										{
											Player::OnConsoleMessage(peer, "`oYou cannot use seeds as ids!");
											continue;
										}
										static_cast<PlayerInfo*>(peer->data)->passedbedrock = true;
										genbedrock = wbedrock;
									}
									if (static_cast<PlayerInfo*>(peer->data)->passedname == true && static_cast<PlayerInfo*>(peer->data)->passedheight == true && static_cast<PlayerInfo*>(peer->data)->passedwidth == true && static_cast<PlayerInfo*>(peer->data)->passedforeground == true && static_cast<PlayerInfo*>(peer->data)->passedbackground == true && static_cast<PlayerInfo*>(peer->data)->passedbedrock == true)
									{
										usedgenworld = true;
										static_cast<PlayerInfo*>(peer->data)->passedname = false;
										static_cast<PlayerInfo*>(peer->data)->passedheight = false;
										static_cast<PlayerInfo*>(peer->data)->passedwidth = false;
										static_cast<PlayerInfo*>(peer->data)->passedforeground = false;
										static_cast<PlayerInfo*>(peer->data)->passedbackground = false;
										static_cast<PlayerInfo*>(peer->data)->passedbedrock = false;
										WorldInfo info = worldDB.get(worldname3);
										string act = worldname3;
										sendPlayerLeave(peer, static_cast<PlayerInfo*>(peer->data));
										joinWorld(peer, act, 0, 0);
									}
								}
								if (isTeleDialog)
								{
									if (world == nullptr || world->name == "EXIT" || serverIsFrozen) continue;
									if (infoDat[0] == "telephonenumber")
									{
										telefonas = infoDat[1];
										if (telefonas.size() > 5 || telefonas.size() <= 0)
										{
											continue;
										}
										if (telefonas != "12345" && telefonas != "53785")
										{
											Player::OnTextOverlay(peer, "This phone number does not exist!");
										}
										else if (telefonas == "12345")
										{
											Player::OnDialogRequest(peer, "set_default_color|`o\n\nadd_label_with_icon|big|`wLocke The Salesman``|left|2398|0|0|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`oI'm selling all kind of `9Stuff `oFor `9Various Items `oTell Me, Which kind of `9Stuff `oDo you want to `^Buy`o?|\nadd_spacer|small|\nadd_button|purchaseyellowcrystal|`oPurchase `9Yellow Crystal `o(`@15 `2Green Crystals`o)|\nadd_button|purchaselegendaryorb|`oPurchase `8Legendary Orb `o(`@1 `cSummer Clash Ticket`o)|\nadd_spacer|small|\nadd_button|store|`#Back|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|");
										}
										else
										{
											Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wSales-Man``|left|4358|\nadd_textbox|It is I, Sales-Man, savior of the wealthy! Let me rescue you from your riches. What would you like to buy today?|left|\nadd_button|chc0|Surgery Items|noflags|0|0|\nadd_button|chc1|Wolfworld Items|noflags|0|0|\nadd_button|chc2|Zombie Defense Items|noflags|0|0|\nadd_button|chc3|Cooking Items|noflags|0|0|\nadd_button|chc4|Startopia Items|noflags|0|0|\nadd_button|chc5|Blue Gem Lock|noflags|0|0|\nend_dialog|phonecall|Hang Up||");
										}
									}
								}
								if (isUranusDialog)
								{
									if (world == nullptr || world->name == "EXIT" || serverIsFrozen) continue;
									if (infoDat[0] == "uranusname")
									{
										uranusnames = infoDat[1];
										string upsd = uranusnames;
										string act = uranusnames;
										std::transform(upsd.begin(), upsd.end(), upsd.begin(), ::toupper);
										if (act.find(" ") != string::npos || act.find("  ") != string::npos || act.find(".") != string::npos || act.find("?") != string::npos || act.find(",") != string::npos || act.find("@") != string::npos || act.find("[") != string::npos || act.find("]") != string::npos || act.find("#") != string::npos || act.find("<") != string::npos || act.find(">") != string::npos || act.find(":") != string::npos || act.find("\"") != string::npos || act.find("{") != string::npos || act.find("}") != string::npos || act.find("|") != string::npos || act.find("+") != string::npos || act.find("_") != string::npos || act.find("~") != string::npos || act.find("-") != string::npos || act.find("!") != string::npos || act.find("$") != string::npos || act.find("%") != string::npos || act.find("^") != string::npos || act.find("&") != string::npos || act.find("`") != string::npos || act.find("*") != string::npos || act.find("(") != string::npos || act.find(")") != string::npos || act.find("=") !=
											string::npos || act.find("'") != string::npos || act.find(";") != string::npos || act.find("/") != string::npos)
										{
											Player::OnTextOverlay(peer, "You cant use symbols in world name");
											continue;
										}
										bool existx = std::experimental::filesystem::exists("worlds/_" + uranusnames + ".json");
										if (!existx)
										{
											if (upsd.find_first_not_of("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789") != string::npos)
											{
												Player::OnConsoleMessage(peer, "`oSymbols are not allowed!");
												continue;
											}
											if (upsd.find(" ") != string::npos)
											{
												Player::OnConsoleMessage(peer, "`oSpaces are not allowed!");
												continue;
											}
											if (upsd == "EXIT")
											{
												Player::OnConsoleMessage(peer, "`oEntered world name is not allowed!");
												continue;
											}
											if (upsd == static_cast<PlayerInfo*>(peer->data)->currentWorld)
											{
												Player::OnTextOverlay(peer, "This world already exists!");
												continue;
											}
											RemoveInventoryItem(8428, 1, peer, true);
											useduranusblast = true;
											WorldInfo info = worldDB.get(uranusnames);
											string act = uranusnames;
											sendPlayerLeave(peer, static_cast<PlayerInfo*>(peer->data));
											joinWorld(peer, act, 0, 0);
											ENetPeer* currentPeer;
											for (currentPeer = server->peers;
												currentPeer < &server->peers[server->peerCount];
												++currentPeer)
											{
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
													continue;
												if (isHere(peer, currentPeer))
												{
													if (static_cast<PlayerInfo*>(peer->data)->currentWorld != "EXIT")
													{
														getPlyersWorld(peer)->weather = 17;
													}
													GamePacket p2 = packetEnd(appendInt(appendString(createPacket(), "OnSetCurrentWeather"), 17));
													ENetPacket* packet2 = enet_packet_create(p2.data,
														p2.len,
														ENET_PACKET_FLAG_RELIABLE);
													enet_peer_send(currentPeer, 0, packet2);
													delete p2.data;
													continue;
												}
											}
										}
										else
										{
											Player::OnTextOverlay(peer, "This world already exists!");
										}
									}
								}
								if (isRegisterDialog)
								{
									if (world == nullptr || world->name == "EXIT" || serverIsFrozen) continue;
									if (infoDat[0] == "username") username = infoDat[1];
									if (infoDat[0] == "password") password = infoDat[1];
									if (infoDat[0] == "password_verify") passwordver = infoDat[1];
									if (infoDat[0] == "email") email = infoDat[1];
									if (infoDat[0] == "code") code = infoDat[1];
								}
							}
							if (isGuildDialog)
							{
								if (infoDat[0] == "gname") gguildname = infoDat[1];
								if (infoDat[0] == "gstatement") gguildstatement = infoDat[1];
								if (infoDat[0] == "ggcflagbg") gguildflagbg = infoDat[1];
								if (infoDat[0] == "ggcflagfg") gguildflagfg = infoDat[1];
							}
							if (isGuildDialog)
							{
								if (world == nullptr || world->name == "EXIT" || serverIsFrozen) continue;
								int GCState = PlayerDB::guildRegister(peer, gguildname, gguildstatement, gguildflagbg, gguildflagfg);
								if (GCState == -1)
								{
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`4Guild creation has failed, because special characters isnt allowed!``"));
									ENetPacket* packet = enet_packet_create(p.data,
										p.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									continue;
								}
								else if (GCState == -2)
								{
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`4Guild creation has failed, because guild name is too short!``"));
									ENetPacket* packet = enet_packet_create(p.data,
										p.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									continue;
								}
								else if (GCState == -3)
								{
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`4Guild creation has failed, because guild name is too long!``"));
									ENetPacket* packet = enet_packet_create(p.data,
										p.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									continue;
								}
								else if (GCState == -4)
								{
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`4Guild creation has failed, because the guild name is already taken!``"));
									ENetPacket* packet = enet_packet_create(p.data,
										p.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									continue;
								}
								else if (GCState == -5)
								{
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`4Guild creation has failed, because the background block must be a number!``"));
									ENetPacket* packet = enet_packet_create(p.data,
										p.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									continue;
								}
								if (GCState == -6)
								{
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`4Guild creation has failed, because the foreground block must be a number!``"));
									ENetPacket* packet = enet_packet_create(p.data,
										p.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									continue;
								}
								else if (GCState == -7)
								{
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`4Guild creation has failed, because the background id is too long!``"));
									ENetPacket* packet = enet_packet_create(p.data,
										p.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									continue;
								}
								if (GCState == -8)
								{
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`4Guild creation has failed, because the foreground id is too long!``"));
									ENetPacket* packet = enet_packet_create(p.data,
										p.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									continue;
								}
								else
								{
									if (GCState == 1)
									{
										static_cast<PlayerInfo*>(peer->data)->createGuildName = gguildname;
										static_cast<PlayerInfo*>(peer->data)->createGuildStatement = gguildstatement;
										static_cast<PlayerInfo*>(peer->data)->createGuildFlagBg = gguildflagbg;
										static_cast<PlayerInfo*>(peer->data)->createGuildFlagFg = gguildflagfg;
										GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`wGrow Guild|left|242|\nadd_textbox|`1Guild Name: `o" + gguildname + "``|\nadd_textbox|`1Guild Statement: `o" + gguildstatement + "``|\nadd_label_with_icon|small|`1<-Guild Flag Background``|left|" + gguildflagbg + "|\nadd_label_with_icon|small|`1<-Guild Flag Foreground``|left|" + gguildflagfg + "|\n\nadd_spacer|small|\nadd_textbox|`oCost: `4250,000 Gems``|\n\nadd_spacer|small|\nadd_button|confirmcreateguild|`oCreate Guild``|\nend_dialog||`wCancel``||\n"));
										ENetPacket* packet = enet_packet_create(ps.data,
											ps.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete ps.data;
									}
								}
							}
						}

						int x = static_cast<PlayerMoving*>(peer->data)->punchX;
						int y = static_cast<PlayerMoving*>(peer->data)->punchY;
						int causedBy = static_cast<PlayerMoving*>(peer->data)->netID;
						int tile = static_cast<PlayerMoving*>(peer->data)->plantingTree;
						if (btn.substr(0, 17) == "putMySellingItem_")
						{
							if (world == nullptr || world->name == "EXIT" || serverIsFrozen) continue;
							string number = btn.substr(btn.find("_") + 1);
							bool contains_non_int3 = !std::regex_match(number, std::regex("^[0-9]+$"));
							if (contains_non_int3 == true)
							{
								autoBan(peer, false, 24 * 7, "Proxy detect! putMySellingItem_ number was: " + number);
								break;
							}
							if (number.size() != 1)
							{
								autoBan(peer, false, 24 * 7, "Proxy detect! putMySellingItem_ number was: " + number);
								break;
							}
							if (number != "1" && number != "2" && number != "3" && number != "4")
							{
								autoBan(peer, false, 24 * 7, "Proxy detect! putMySellingItem_ number was: " + number);
								break;
							}

							GTDialog picker;
							if (number == "1")
							{
								if (static_cast<PlayerInfo*>(peer->data)->mySellingItem1 == "3308")
								{
									picker.addLabelWithIcon("`wSelect which item you want to sell.", 1434, LABEL_SMALL);
									picker.addSpacer(SPACER_SMALL);
									picker.addPicker("trademypicker_" + number, "Choose item for sell", "Select your item");
									picker.addSpacer(SPACER_SMALL);
									picker.addButton("trademypickerback", "Back to main.");
									picker.addQuickExit();
									picker.endDialog("", "", "");
									Player::OnDialogRequest(peer, picker.finishDialog());
								}
								else
								{
									picker.addLabelWithIcon("`wSelect which item you want to sell and how much.", 1434, LABEL_SMALL);
									picker.addSpacer(SPACER_SMALL);
									picker.addPicker("trademypicker_" + number, "Change item for sell", "Select your item");
									picker.addSpacer(SPACER_SMALL);
									picker.addSmallText("`$You have Selected: `2" + getItemDef(atoi(static_cast<PlayerInfo*>(peer->data)->mySellingItem1.c_str())).name);
									picker.addInputBox("trademypickercount_" + number, "Select how much you want to sell", "", 5);
									picker.addSpacer(SPACER_SMALL);
									picker.addButton("trademypickerconfirm", "Confirm");
									picker.addSpacer(SPACER_SMALL);
									picker.addButton("trademypickerback", "Back to main.");
									picker.addQuickExit();
									picker.endDialog("", "", "");
									Player::OnDialogRequest(peer, picker.finishDialog());
								}
							}

							if (number == "2")
							{
								if (static_cast<PlayerInfo*>(peer->data)->mySellingItem2 == "3308")
								{
									picker.addLabelWithIcon("`wSelect which item you want to sell.", 1434, LABEL_SMALL);
									picker.addSpacer(SPACER_SMALL);
									picker.addPicker("trademypicker_" + number, "Choose item for sell", "Select your item");
									picker.addSpacer(SPACER_SMALL);
									picker.addButton("trademypickerback", "Back to main.");
									picker.addQuickExit();
									picker.endDialog("", "", "");
									Player::OnDialogRequest(peer, picker.finishDialog());
								}
								else
								{
									picker.addLabelWithIcon("`wSelect which item you want to sell and how much.", 1434, LABEL_SMALL);
									picker.addSpacer(SPACER_SMALL);
									picker.addPicker("trademypicker_" + number, "Change item for sell", "Select your item");
									picker.addSpacer(SPACER_SMALL);
									picker.addSmallText("`$You have Selected: `2" + getItemDef(atoi(static_cast<PlayerInfo*>(peer->data)->mySellingItem2.c_str())).name);
									picker.addInputBox("trademypickercount_" + number, "Select how much you want to sell", "", 5);
									picker.addSpacer(SPACER_SMALL);
									picker.addButton("trademypickerconfirm", "Confirm");
									picker.addSpacer(SPACER_SMALL);
									picker.addButton("trademypickerback", "Back to main.");
									picker.addQuickExit();
									picker.endDialog("", "", "");
									Player::OnDialogRequest(peer, picker.finishDialog());
								}
							}

							if (number == "3")
							{
								if (static_cast<PlayerInfo*>(peer->data)->mySellingItem3 == "3308")
								{
									picker.addLabelWithIcon("`wSelect which item you want to sell.", 1434, LABEL_SMALL);
									picker.addSpacer(SPACER_SMALL);
									picker.addPicker("trademypicker_" + number, "Choose item for sell", "Select your item");
									picker.addSpacer(SPACER_SMALL);
									picker.addButton("trademypickerback", "Back to main.");
									picker.addQuickExit();
									picker.endDialog("", "", "");
									Player::OnDialogRequest(peer, picker.finishDialog());
								}
								else
								{
									picker.addLabelWithIcon("`wSelect which item you want to sell and how much.", 1434, LABEL_SMALL);
									picker.addSpacer(SPACER_SMALL);
									picker.addPicker("trademypicker_" + number, "Change item for sell", "Select your item");
									picker.addSpacer(SPACER_SMALL);
									picker.addSmallText("`$You have Selected: `2" + getItemDef(atoi(static_cast<PlayerInfo*>(peer->data)->mySellingItem3.c_str())).name);
									picker.addInputBox("trademypickercount_" + number, "Select how much you want to sell", "", 5);
									picker.addSpacer(SPACER_SMALL);
									picker.addButton("trademypickerconfirm", "Confirm");
									picker.addSpacer(SPACER_SMALL);
									picker.addButton("trademypickerback", "Back to main.");
									picker.addQuickExit();
									picker.endDialog("", "", "");
									Player::OnDialogRequest(peer, picker.finishDialog());
								}
							}

							if (number == "4")
							{
								if (static_cast<PlayerInfo*>(peer->data)->mySellingItem4 == "3308")
								{
									picker.addLabelWithIcon("`wSelect which item you want to sell.", 1434, LABEL_SMALL);
									picker.addSpacer(SPACER_SMALL);
									picker.addPicker("trademypicker_" + number, "Choose item for sell", "Select your item");
									picker.addSpacer(SPACER_SMALL);
									picker.addButton("trademypickerback", "Back to main.");
									picker.addQuickExit();
									picker.endDialog("", "", "");
									Player::OnDialogRequest(peer, picker.finishDialog());
								}
								else
								{
									picker.addLabelWithIcon("`wSelect which item you want to sell and how much.", 1434, LABEL_SMALL);
									picker.addSpacer(SPACER_SMALL);
									picker.addPicker("trademypicker_" + number, "Change item for sell", "Select your item");
									picker.addSpacer(SPACER_SMALL);
									picker.addSmallText("`$You have Selected: `2" + getItemDef(atoi(static_cast<PlayerInfo*>(peer->data)->mySellingItem4.c_str())).name);
									picker.addInputBox("trademypickercount_" + number, "Select how much you want to sell", "", 5);
									picker.addSpacer(SPACER_SMALL);
									picker.addButton("trademypickerconfirm", "Confirm");
									picker.addSpacer(SPACER_SMALL);
									picker.addButton("trademypickerback", "Back to main.");
									picker.addQuickExit();
									picker.endDialog("", "", "");
									Player::OnDialogRequest(peer, picker.finishDialog());
								}
							}

						}
						if (btn.substr(0, 13) == "putMergeItem_")
						{
							if (world == nullptr || world->name == "EXIT" || serverIsFrozen) continue;
							string number = btn.substr(btn.find("_") + 1);
							bool contains_non_int3 = !std::regex_match(number, std::regex("^[0-9]+$"));
							if (contains_non_int3 == true)
							{
								autoBan(peer, false, 24 * 7, "Proxy detect! putMergeItem_ number was: " + number);
								break;
							}
							if (number.size() != 1)
							{
								autoBan(peer, false, 24 * 7, "Proxy detect! isMergeDialog number was: " + number);
								break;
							}
							if (number == "3")
							{
								SendMergeDialog(peer, atoi(static_cast<PlayerInfo*>(peer->data)->MergeItem1.c_str()), atoi(static_cast<PlayerInfo*>(peer->data)->MergeItem2.c_str()), 0, "");
							}
							Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wTile Merging``|left|10034||\nadd_label_with_icon|sml|Select the item which you want to merge!|left|2|\nadd_spacer|small|\nadd_item_picker|mergepicker_" + number + "|Select from inventory|Select your item|\nend_dialog|merge|Close||");

						}
						if (btn.substr(0, 18) == "putHisSellingItem_")
						{
							if (world == nullptr || world->name == "EXIT" || serverIsFrozen) continue;
							string number = btn.substr(btn.find("_") + 1);
							bool contains_non_int3 = !std::regex_match(number, std::regex("^[0-9]+$"));
							if (contains_non_int3 == true)
							{
								autoBan(peer, false, 24 * 7, "Proxy detect! putHisSellingItem_ number was: " + number);
								break;
							}
							if (number.size() != 1)
							{
								autoBan(peer, false, 24 * 7, "Proxy detect! putHisSellingItem_ number was: " + number);
								break;
							}
							if (number != "1" && number != "2" && number != "3" && number != "4")
							{
								autoBan(peer, false, 24 * 7, "Proxy detect! putHisSellingItem_ number was: " + number);
								break;
							}

							GTDialog picker;
							if (number == "1")
							{
								if (static_cast<PlayerInfo*>(peer->data)->hisSellingItem1 == "3308")
								{
									picker.addLabelWithIcon("`wSelect which item you want to get.", 1434, LABEL_SMALL);
									picker.addSpacer(SPACER_SMALL);
									picker.addButton("choosehisitem_" + number, "Find the item in his inventory!");
									picker.addSpacer(SPACER_SMALL);
									picker.addButton("trademypickerback", "Back to main.");
									picker.addQuickExit();
									picker.endDialog("", "", "");
									Player::OnDialogRequest(peer, picker.finishDialog());
								}
								else
								{
									picker.addLabelWithIcon("`wSelect the item that you want to get and how much.", 1434, LABEL_SMALL);
									picker.addSpacer(SPACER_SMALL);
									picker.addButton("choosehisitem_" + number, "Change the item!");
									picker.addSpacer(SPACER_SMALL);
									picker.addSmallText("`$You have Selected: `2" + getItemDef(atoi(static_cast<PlayerInfo*>(peer->data)->hisSellingItem1.c_str())).name);
									picker.addInputBox("tradehisitemcount_" + number, "Select how much you want to get", "", 5);
									picker.addSpacer(SPACER_SMALL);
									picker.addButton("tradehisitemconfirm", "Confirm");
									picker.addSpacer(SPACER_SMALL);
									picker.addButton("trademypickerback", "Back to main.");
									picker.addQuickExit();
									picker.endDialog("", "", "");
									Player::OnDialogRequest(peer, picker.finishDialog());
								}
							}

							if (number == "2")
							{
								if (static_cast<PlayerInfo*>(peer->data)->hisSellingItem2 == "3308")
								{
									picker.addLabelWithIcon("`wSelect which item you want to get.", 1434, LABEL_SMALL);
									picker.addSpacer(SPACER_SMALL);
									picker.addButton("choosehisitem_" + number, "Find the item in his inventory!");
									picker.addSpacer(SPACER_SMALL);
									picker.addButton("trademypickerback", "Back to main.");
									picker.addQuickExit();
									picker.endDialog("", "", "");
									Player::OnDialogRequest(peer, picker.finishDialog());
								}
								else
								{
									picker.addLabelWithIcon("`wSelect the item that you want to get and how much.", 1434, LABEL_SMALL);
									picker.addSpacer(SPACER_SMALL);
									picker.addButton("choosehisitem_" + number, "Change the item!");
									picker.addSpacer(SPACER_SMALL);
									picker.addSmallText("`$You have Selected: `2" + getItemDef(atoi(static_cast<PlayerInfo*>(peer->data)->hisSellingItem2.c_str())).name);
									picker.addInputBox("tradehisitemcount_" + number, "Select how much you want to get", "", 5);
									picker.addSpacer(SPACER_SMALL);
									picker.addButton("tradehisitemconfirm", "Confirm");
									picker.addSpacer(SPACER_SMALL);
									picker.addButton("trademypickerback", "Back to main.");
									picker.addQuickExit();
									picker.endDialog("", "", "");
									Player::OnDialogRequest(peer, picker.finishDialog());
								}
							}

							if (number == "3")
							{
								if (static_cast<PlayerInfo*>(peer->data)->hisSellingItem3 == "3308")
								{
									picker.addLabelWithIcon("`wSelect which item you want to get.", 1434, LABEL_SMALL);
									picker.addSpacer(SPACER_SMALL);
									picker.addButton("choosehisitem_" + number, "Find the item in his inventory!");
									picker.addSpacer(SPACER_SMALL);
									picker.addButton("trademypickerback", "Back to main.");
									picker.addQuickExit();
									picker.endDialog("", "", "");
									Player::OnDialogRequest(peer, picker.finishDialog());
								}
								else
								{
									picker.addLabelWithIcon("`wSelect the item that you want to get and how much.", 1434, LABEL_SMALL);
									picker.addSpacer(SPACER_SMALL);
									picker.addButton("choosehisitem_" + number, "Change the item!");
									picker.addSpacer(SPACER_SMALL);
									picker.addSmallText("`$You have Selected: `2" + getItemDef(atoi(static_cast<PlayerInfo*>(peer->data)->hisSellingItem3.c_str())).name);
									picker.addInputBox("tradehisitemcount_" + number, "Select how much you want to get", "", 5);
									picker.addSpacer(SPACER_SMALL);
									picker.addButton("tradehisitemconfirm", "Confirm");
									picker.addSpacer(SPACER_SMALL);
									picker.addButton("trademypickerback", "Back to main.");
									picker.addQuickExit();
									picker.endDialog("", "", "");
									Player::OnDialogRequest(peer, picker.finishDialog());
								}
							}

							if (number == "4")
							{
								if (static_cast<PlayerInfo*>(peer->data)->hisSellingItem4 == "3308")
								{
									picker.addLabelWithIcon("`wSelect which item you want to get.", 1434, LABEL_SMALL);
									picker.addSpacer(SPACER_SMALL);
									picker.addButton("choosehisitem_" + number, "Find the item in his inventory!");
									picker.addSpacer(SPACER_SMALL);
									picker.addButton("trademypickerback", "Back to main.");
									picker.addQuickExit();
									picker.endDialog("", "", "");
									Player::OnDialogRequest(peer, picker.finishDialog());
								}
								else
								{
									picker.addLabelWithIcon("`wSelect the item that you want to get and how much.", 1434, LABEL_SMALL);
									picker.addSpacer(SPACER_SMALL);
									picker.addButton("choosehisitem_" + number, "Change the item!");
									picker.addSpacer(SPACER_SMALL);
									picker.addSmallText("`$You have Selected: `2" + getItemDef(atoi(static_cast<PlayerInfo*>(peer->data)->hisSellingItem4.c_str())).name);
									picker.addInputBox("tradehisitemcount_" + number, "Select how much you want to get", "", 5);
									picker.addSpacer(SPACER_SMALL);
									picker.addButton("tradehisitemconfirm", "Confirm");
									picker.addSpacer(SPACER_SMALL);
									picker.addButton("trademypickerback", "Back to main.");
									picker.addQuickExit();
									picker.endDialog("", "", "");
									Player::OnDialogRequest(peer, picker.finishDialog());
								}
							}

						}
						if (btn.substr(0, 23) == "removeselectedbulletin_")
						{
							if (world == nullptr || world->name == "EXIT" || serverIsFrozen) continue;
							if (static_cast<PlayerInfo*>(peer->data)->rawName == world->owner || world->owner == "" || isMod(peer))
							{
								string coord, apos;
								string coord_and_apos = btn.erase(0, 23);
								string::size_type pos = coord_and_apos.find('_');
								if (pos != std::string::npos)
								{
									coord = coord_and_apos.substr(0, pos);
									coord_and_apos.erase(0, pos + 1);
									apos = coord_and_apos;
								}
								else
								{
									autoBan(peer, false, 24 * 7, "Incorrect parameters removeselectedbulletin_. Coord and id were: " + coord_and_apos);
									break;
								}
								auto isdbox = std::experimental::filesystem::exists("bulletinboard/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
								if (!isdbox)
								{
									Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4An error occured while getting safe bulletin board.", 0, true);
									break;
								}

								bool contains_non_int3 = !std::regex_match(apos, std::regex("^[0-9]+$"));
								if (contains_non_int3 == true)
								{
									autoBan(peer, false, 24 * 7, "Proxy detect! removeselectedbulletin_ apos was: " + apos);
									break;
								}
								int apos_int = atoi(apos.c_str());
								if (apos_int < 1 || apos_int > 90)
								{
									autoBan(peer, false, 24 * 7, "Proxy detect! removeselectedbulletin_ apos was: " + apos);
									break;
								}
								try
								{
									ifstream ifff("bulletinboard/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
									json j;
									ifff >> j;
									ifff.close();
									string tekstas = j["mails"][apos_int - 1]["text"];
									GTDialog myLetterBox;
									myLetterBox.addLabelWithIcon("`oRemove \"" + tekstas + "\" from your board?", 658, LABEL_BIG);
									myLetterBox.addButton("Confirmremoveselectedbulletin_" + coord + "_" + apos, "`wOK");
									myLetterBox.addSpacer(SPACER_SMALL);
									myLetterBox.addQuickExit();
									myLetterBox.endDialog("Close", "", "Cancel");
									Player::OnDialogRequest(peer, myLetterBox.finishDialog());
								}
								catch (std::exception&)
								{
									cout << "bulletin kodas failed" << endl;
									break; /*tipo jeigu nera*/
								}
							}
						}
						if (btn.substr(0, 30) == "Confirmremoveselectedbulletin_")
						{
							if (world == nullptr || world->name == "EXIT" || serverIsFrozen) continue;
							if (static_cast<PlayerInfo*>(peer->data)->rawName == world->owner || world->owner == "" || isMod(peer))
							{
								string coord, apos;
								string coord_and_apos = btn.erase(0, 30);
								string::size_type pos = coord_and_apos.find('_');
								if (pos != std::string::npos)
								{
									coord = coord_and_apos.substr(0, pos);
									coord_and_apos.erase(0, pos + 1);
									apos = coord_and_apos;
								}
								else
								{
									autoBan(peer, false, 24 * 7, "Incorrect parameters Confirmremoveselectedbulletin_. Coord and id were: " + coord_and_apos);
									break;
								}
								auto isdbox = std::experimental::filesystem::exists("bulletinboard/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
								if (!isdbox)
								{
									Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4An error occured while getting safe bulletin board.", 0, true);
									break;
								}

								bool contains_non_int3 = !std::regex_match(apos, std::regex("^[0-9]+$"));
								if (contains_non_int3 == true)
								{
									autoBan(peer, false, 24 * 7, "Proxy detect! Confirmremoveselectedbulletin_ apos was: " + apos);
									break;
								}
								int apos_int = atoi(apos.c_str());
								if (apos_int < 1 || apos_int > 90)
								{
									autoBan(peer, false, 24 * 7, "Proxy detect! Confirmremoveselectedbulletin_ apos was: " + apos);
									break;
								}
								try
								{
									ifstream ifff("bulletinboard/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
									json j;
									ifff >> j;
									ifff.close();
									int inmail = j["inmail"];
									j["inmail"] = inmail - 1;
									j["mails"][apos_int - 1]["text"] = "";
									j["mails"][apos_int - 1]["growid"] = "";
									Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`2Bulletin removed.", 0, true);
									ofstream of("bulletinboard/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
									of << j << std::endl;
									of.close();
								}
								catch (std::exception&)
								{
									cout << "bulletin kodas failed" << endl;
									break; /*tipo jeigu nera*/
								}
							}
						}
						if (btn.substr(0, 18) == "addbulletinletter_")
						{
							if (world == nullptr || world->name == "EXIT" || serverIsFrozen) continue;
							string coord = btn.substr(btn.find("_") + 1);
							auto isdbox = std::experimental::filesystem::exists("bulletinboard/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
							if (!isdbox)
							{
								Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4An error occured while getting bulletin board info.", 0, true);
								continue;
							}

							std::stringstream bss(cch);
							std::string bto;

							string addtext = "";

							while (std::getline(bss, bto, '\n'))
							{
								vector<string> infoDat = explode("|", bto);
								if (infoDat[0] == "addbulletinletterinput")
								{
									addtext = infoDat[1];
								}
							}
							if (addtext.length() < 3)
							{
								Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wThat's not interesting enough to post.", 0, true);
								continue;
							}

							try
							{
								ifstream ifff("bulletinboard/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
								json j;
								ifff >> j;
								ifff.close();
								if (j["inmail"] >= 90)
								{
									Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4Bulletin Board is full!", 0, true);
									continue;
								}
								for (int i = 0; i < 90; i++)
								{
									if (j["mails"][i]["growid"] == "")
									{
										j["mails"][i]["growid"] = static_cast<PlayerInfo*>(peer->data)->displayName;
										j["mails"][i]["text"] = addtext;
										int inmail = j["inmail"];
										j["inmail"] = inmail + 1;
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`2Bulletin posted.", 0, true);

										ofstream of("bulletinboard/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
										of << j << std::endl;
										of.close();

										break;
									}
								}
							}
							catch (std::exception&)
							{
								cout << "bulletin kodas failed" << endl;
								break; /*tipo jeigu nera*/
							}
						}
						if (btn.substr(0, 17) == "bulletinletterok_")
						{
							if (world == nullptr || world->name == "EXIT" || serverIsFrozen) continue;
							string coord = btn.substr(btn.find("_") + 1);
							auto isdbox = std::experimental::filesystem::exists("bulletinboard/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
							if (!isdbox)
							{
								Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4An error occured while getting bulletin board info.", 0, true);
								continue;
							}
							if (static_cast<PlayerInfo*>(peer->data)->rawName == world->owner || world->owner == "" || isMod(peer))
							{
								std::stringstream bss(cch);
								std::string bto;

								string publiccanadd = "";
								string hidenames = "";

								while (std::getline(bss, bto, '\n'))
								{
									vector<string> infoDat = explode("|", bto);
									if (infoDat[0] == "publiccanaddbulletinboard")
									{
										publiccanadd = infoDat[1];
									}
									if (infoDat[0] == "hidenamesbulletinboard")
									{
										hidenames = infoDat[1];
									}
								}
								if (publiccanadd != "" && hidenames != "")
								{
									int does_pubiccanadd = atoi(publiccanadd.c_str());
									int are_hidenames = atoi(hidenames.c_str());
									if ((does_pubiccanadd != 0 && does_pubiccanadd != 1) || (are_hidenames != 0 && are_hidenames != 1))
									{
										autoBan(peer, false, 24 * 7, "Incorrect parameters bulletinletterok_. publiccanadd was " + publiccanadd + ",hidenames was " + hidenames + "");
										break;
									}
									try
									{
										ifstream ifff("bulletinboard/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
										json j;
										ifff >> j;
										ifff.close();

										j["hidenames"] = are_hidenames;
										j["publiccanadd"] = does_pubiccanadd;

										ofstream of("bulletinboard/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
										of << j << std::endl;
										of.close();
									}
									catch (std::exception&)
									{
										SendConsole("bulletinboardclear_ Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_now(peer, 0);
									}
									catch (std::runtime_error&)
									{
										SendConsole("bulletinboardclear_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_now(peer, 0);
									}
									catch (...)
									{
										SendConsole("bulletinboardclear_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_now(peer, 0);
									}
								}
							}
						}
						if (btn.substr(0, 19) == "bulletinboardclear_")
						{
							if (world == nullptr || world->name == "EXIT" || serverIsFrozen) continue;
							string coord = btn.substr(btn.find("_") + 1);
							auto isdbox = std::experimental::filesystem::exists("bulletinboard/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
							if (!isdbox)
							{
								Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4An error occured while getting bulletin board info.", 0, true);
								continue;
							}
							if (static_cast<PlayerInfo*>(peer->data)->rawName == world->owner || world->owner == "" || isMod(peer))
							{
								try
								{
									ifstream ifff("bulletinboard/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
									json j;
									ifff >> j;
									ifff.close();
									if (j["inmail"] < 1)
									{
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4There is no any mails!", 0, true);
										continue;
									}
									for (int i = 0; i < 90; i++)
									{
										j["mails"][i]["growid"] = "";
										j["mails"][i]["text"] = "";
									}
									j["inmail"] = 0;
									Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`2Bulletin Board emptied.", 0, true);

									ofstream of("bulletinboard/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
									of << j << std::endl;
									of.close();
								}
								catch (std::exception&)
								{
									SendConsole("bulletinboardclear_ Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
									enet_peer_disconnect_now(peer, 0);
								}
								catch (std::runtime_error&)
								{
									SendConsole("bulletinboardclear_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
									enet_peer_disconnect_now(peer, 0);
								}
								catch (...)
								{
									SendConsole("bulletinboardclear_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
									enet_peer_disconnect_now(peer, 0);
								}
							}
						}
						if (btn.substr(0, 10) == "mailempty_")
						{
							if (world == nullptr || world->name == "EXIT" || serverIsFrozen) continue;
							string coord = btn.substr(btn.find("_") + 1);
							auto isdbox = std::experimental::filesystem::exists("mailbox/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
							if (!isdbox)
							{
								Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4An error occured while getting mailbox info.", 0, true);
								continue;
							}
							if (static_cast<PlayerInfo*>(peer->data)->rawName == world->owner || world->owner == "" || isMod(peer))
							{
								try
								{
									ifstream ifff("mailbox/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
									json j;
									ifff >> j;
									ifff.close();
									if (j["inmail"] < 1)
									{
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4There is no any mails!", 0, true);
										continue;
									}
									for (int i = 0; i < 20; i++)
									{
										j["mails"][i]["growid"] = "";
										j["mails"][i]["text"] = "";
									}
									j["inmail"] = 0;
									Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`2Mailbox emptied.", 0, true);

									int x = j["x"];
									int y = j["y"];
									ENetPeer* currentPeer;
									for (currentPeer = server->peers;
										currentPeer < &server->peers[server->peerCount];
										++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
										if (isHere(peer, currentPeer))
										{
											RemoveItemPacket(currentPeer, 656, 0, x, y, 1);
										}
									}
									ofstream of("mailbox/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
									of << j << std::endl;
									of.close();
								}
								catch (std::exception&)
								{
									SendConsole("mailempty_ Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
									enet_peer_disconnect_now(peer, 0);
								}
								catch (std::runtime_error&)
								{
									SendConsole("mailempty_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
									enet_peer_disconnect_now(peer, 0);
								}
								catch (...)
								{
									SendConsole("mailempty_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
									enet_peer_disconnect_now(peer, 0);
								}
							}
						}
						if (btn.substr(0, 14) == "bluemailempty_")
						{
							if (world == nullptr || world->name == "EXIT" || serverIsFrozen) continue;
							string coord = btn.substr(btn.find("_") + 1);
							auto isdbox = std::experimental::filesystem::exists("bluemailbox/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
							if (!isdbox)
							{
								Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4An error occured while getting blue mailbox info.", 0, true);
								continue;
							}
							if (static_cast<PlayerInfo*>(peer->data)->rawName == world->owner || world->owner == "" || isMod(peer))
							{
								try
								{
									ifstream ifff("bluemailbox/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
									json j;
									ifff >> j;
									ifff.close();
									if (j["inmail"] < 1)
									{
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4There is no any mails!", 0, true);
										continue;
									}
									for (int i = 0; i < 20; i++)
									{
										j["mails"][i]["growid"] = "";
										j["mails"][i]["text"] = "";
									}
									j["inmail"] = 0;
									Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`2Mailbox emptied.", 0, true);

									int x = j["x"];
									int y = j["y"];
									ENetPeer* currentPeer;
									for (currentPeer = server->peers;
										currentPeer < &server->peers[server->peerCount];
										++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
										if (isHere(peer, currentPeer))
										{
											RemoveItemPacket(currentPeer, 1006, 0, x, y, 1);
										}
									}
									ofstream of("bluemailbox/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
									of << j << std::endl;
									of.close();
								}
								catch (std::exception&)
								{
									SendConsole("bluemailempty_ Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
									enet_peer_disconnect_now(peer, 0);
								}
								catch (std::runtime_error&)
								{
									SendConsole("bluemailempty_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
									enet_peer_disconnect_now(peer, 0);
								}
								catch (...)
								{
									SendConsole("bluemailempty_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
									enet_peer_disconnect_now(peer, 0);
								}
							}
						}
						if (btn.substr(0, 14) == "retrieveGifts_")
						{
							if (world == nullptr || world->name == "EXIT" || serverIsFrozen) continue;
							string coord = btn.substr(btn.find("_") + 1);
							auto isdbox = std::experimental::filesystem::exists("donationboxes/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
							if (!isdbox)
							{
								Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4An error occured while getting donation box info.", 0, true);
								continue;
							}
							if (static_cast<PlayerInfo*>(peer->data)->rawName == world->owner || world->owner == "" || isMod(peer))
							{
								try
								{
									ifstream ifff("donationboxes/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
									json j;
									ifff >> j;
									ifff.close();
									if (j["donated"] < 1)
									{
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4There is no any donations!", 0, true);
										continue;
									}
									bool success = true;
									for (int i = 0; i < 20; i++)
									{
										if (j["donatedItems"][i]["itemid"] != 0)
										{
											int howManyEarnings = j["donatedItems"][i]["itemcount"];
											int itemid = j["donatedItems"][i]["itemid"];
											string whoSent = j["donatedItems"][i]["sentBy"];
											if (j["donatedItems"][i]["itemcount"] > 200)
											{
												Player::OnTextOverlay(peer, "You cant receive that!");
												break;
											}
											if (CheckItemExists(peer, j["donatedItems"][i]["itemid"]))
											{
												int currentlyHave = GetQuantityOfItem(peer, j["donatedItems"][i]["itemid"]);
												if (j["donatedItems"][i]["itemcount"].get<double>() + currentlyHave < 201)
												{
													SaveItemMoreTimes(j["donatedItems"][i]["itemid"], j["donatedItems"][i]["itemcount"], peer, success);
													j["donatedItems"][i]["itemid"] = 0;
													j["donatedItems"][i]["itemcount"] = 0;
													j["donatedItems"][i]["sentBy"] = "";
													j["donatedItems"][i]["note"] = "";
													j["donated"] = j["donated"].get<double>() - 1;
													ENetPeer* currentPeer;
													for (currentPeer = server->peers;
														currentPeer < &server->peers[server->peerCount];
														++currentPeer)
													{
														if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
														if (isHere(peer, currentPeer))
														{
															Player::OnConsoleMessage(currentPeer, "`w[`o" + static_cast<PlayerInfo*>(peer->data)->displayName + " `oreceives `5" + to_string(howManyEarnings) + " `w" + itemDefs[itemid].name + " `ofrom `w" + whoSent + "`o, how nice!`w]");
														}
													}
													Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`2Box emptied.", 0, true);
												}
												else
												{
													int kiekTrukstaIki200 = 200 - currentlyHave;
													SaveItemMoreTimes(j["donatedItems"][i]["itemid"], kiekTrukstaIki200, peer, success);
													j["donatedItems"][i]["itemcount"] = j["donatedItems"][i]["itemcount"].get<double>() - kiekTrukstaIki200;
													howManyEarnings -= kiekTrukstaIki200;
													ENetPeer* currentPeer;
													for (currentPeer = server->peers;
														currentPeer < &server->peers[server->peerCount];
														++currentPeer)
													{
														if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
														if (isHere(peer, currentPeer))
														{
															Player::OnConsoleMessage(currentPeer, "`w[`o" + static_cast<PlayerInfo*>(peer->data)->rawName + " receives `5" + to_string(kiekTrukstaIki200) + " (`w" + to_string(howManyEarnings) + " `5left) `w" + itemDefs[itemid].name + " `ofrom `w" + whoSent + "`o, how nice!`w]");
														}
													}
													Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`2Box emptied.", 0, true);
												}
											}
											else
											{
												if (static_cast<PlayerInfo*>(peer->data)->inventory.items.size() == static_cast<PlayerInfo*>(peer->data)->currentInventorySize)
												{
													Player::OnTextOverlay(peer, "`4Your inventory is full! You can purchase an inventory upgrade in the shop.");
													break;
												}

												SaveItemMoreTimes(j["donatedItems"][i]["itemid"], j["donatedItems"][i]["itemcount"], peer, success);
												j["donatedItems"][i]["itemid"] = 0;
												j["donatedItems"][i]["itemcount"] = 0;
												j["donatedItems"][i]["sentBy"] = "";
												j["donatedItems"][i]["note"] = "";
												j["donated"] = j["donated"].get<double>() - 1;
												ENetPeer* currentPeer;
												for (currentPeer = server->peers;
													currentPeer < &server->peers[server->peerCount];
													++currentPeer)
												{
													if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
													if (isHere(peer, currentPeer))
													{
														Player::OnConsoleMessage(currentPeer, "`w[`o" + static_cast<PlayerInfo*>(peer->data)->rawName + " receives `5" + to_string(howManyEarnings) + " `w" + itemDefs[itemid].name + " `ofrom `w" + whoSent + "`o, how nice!`w]");
													}
												}
												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`2Box emptied.", 0, true);
											}
										}
									}

									if (j["donated"] <= 0)
									{
										ENetPeer* currentPeer;
										for (currentPeer = server->peers;
											currentPeer < &server->peers[server->peerCount];
											++currentPeer)
										{
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
											if (isHere(peer, currentPeer))
											{
												if (static_cast<PlayerInfo*>(peer->data)->lastPunchX >= 0 && static_cast<PlayerInfo*>(peer->data)->lastPunchY >= 0)
												{
													RemoveItemPacket(currentPeer, 1452, 0, static_cast<PlayerInfo*>(peer->data)->lastPunchX, static_cast<PlayerInfo*>(peer->data)->lastPunchY, 1);
												}
											}
										}
									}
									ofstream of("donationboxes/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
									of << j << std::endl;
									of.close();
								}
								catch (std::exception&)
								{
									SendConsole("retrieveGifts_ Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
									enet_peer_disconnect_now(peer, 0);
								}
								catch (std::runtime_error&)
								{
									SendConsole("retrieveGifts_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
									enet_peer_disconnect_now(peer, 0);
								}
								catch (...)
								{
									SendConsole("retrieveGifts_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
									enet_peer_disconnect_now(peer, 0);
								}
							}
						}
						if (btn.substr(0, 15) == "safeupdatepass_")
						{
							if (world == nullptr || world->name == "EXIT" || serverIsFrozen) continue;
							string coord = btn.substr(btn.find("_") + 1);
							auto isdbox = std::experimental::filesystem::exists("safevault/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
							if (!isdbox)
							{
								Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4An error occured. Break the safe.", 0, true);
							}
							else
							{
								if (static_cast<PlayerInfo*>(peer->data)->rawName == PlayerDB::getProperName(world->owner) || world->owner == "" || isMod(peer))
								{
									try
									{
										GTDialog mySafe;
										mySafe.addLabelWithIcon("`wSafe Vault", 8878, LABEL_BIG);
										ifstream ifff("safevault/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
										json j;
										ifff >> j;
										if (j["password"] == "")
										{
											mySafe.addSmallText("The ingenious minds at GrowTech bring you the `2Safe Vault`` - a place to store your items safely with its integrated password option!");
											mySafe.addSmallText("How the password works:");
											mySafe.addSmallText("The Safe Vault requires both a `2password`` and a `2recovery answer`` to be entered to use a password.");
											mySafe.addSmallText("Enter your `2password`` and `2recovery answer`` below - keep them safe and `4DO NOT`` share them with anyone you do not trust!");
											mySafe.addSmallText("The password and recovery answer can be no longer than 12 characters in length - number and alphabet only please, no special characters are allowed!");
											mySafe.addSmallText("If you forget your password, enter your recovery answer to access the Safe Vault - The Safe Vault will `4NOT be password protected now``. You will need to enter a new password.");
											mySafe.addSmallText("You can change your password, however you will need to enter the old password before a new one can be used.");
											mySafe.addSmallText("`4WARNING``: DO NOT forget your password and recovery answer or you will not be able to access the Safe Vault!");
											mySafe.addSmallText("`4There is no password currently set on this Safe Vault.``");
											mySafe.addSmallText("Enter a new password.");
											mySafe.addInputBox("safenewpass_" + coord, "", "", 18);
											mySafe.addSmallText("Enter a recovery answer.");
											mySafe.addInputBox("safe_recoverypass", "", "", 12);
											mySafe.addButton("safe_setpassword", "Update Password");
											mySafe.addSpacer(SPACER_SMALL);
											mySafe.addQuickExit();
											mySafe.endDialog("Close", "", "Exit");
											Player::OnDialogRequest(peer, mySafe.finishDialog());
										}
										else
										{
											mySafe.addSmallText("The ingenious minds at GrowTech bring you the `2Safe Vault`` - a place to store your items safely with its integrated password option!");
											mySafe.addSmallText("How the password works:");
											mySafe.addSmallText("The Safe Vault requires both a `2password`` and a `2recovery answer`` to be entered to use a password.");
											mySafe.addSmallText("Enter your `2password`` and `2recovery answer`` below - keep them safe and `4DO NOT`` share them with anyone you do not trust!");
											mySafe.addSmallText("The password and recovery answer can be no longer than 12 characters in length - number and alphabet only please, no special characters are allowed!");
											mySafe.addSmallText("If you forget your password, enter your recovery answer to access the Safe Vault - The Safe Vault will `4NOT be password protected now``. You will need to enter a new password.");
											mySafe.addSmallText("You can change your password, however you will need to enter the old password before a new one can be used.");
											mySafe.addSmallText("`4WARNING``: DO NOT forget your password and recovery answer or you will not be able to access the Safe Vault!");
											mySafe.addSmallText("Enter your old password.");
											mySafe.addInputBox("safeoldpassword_" + coord, "", "", 18);
											mySafe.addSmallText("Enter a new password.");
											mySafe.addInputBox("safe_newpassword", "", "", 18);
											mySafe.addSmallText("Enter a recovery answer.");
											mySafe.addInputBox("storage_recoveryanswer", "", "", 12);
											mySafe.addButton("safe_updatepassword", "Update Password");
											mySafe.addSmallText("Remove the password protection from the `5Safe Vault``.");
											mySafe.addSmallText("You will need to enter the old password to remove the password protection.");
											mySafe.addButton("safe_removepassword", "Remove Password");
											mySafe.addSpacer(SPACER_SMALL);
											mySafe.addQuickExit();
											mySafe.endDialog("Close", "", "Exit");
											Player::OnDialogRequest(peer, mySafe.finishDialog());
										}
									}
									catch (std::exception&)
									{
										SendConsole("safeupdatepass_ Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_now(peer, 0);
									}
									catch (std::runtime_error&)
									{
										SendConsole("safeupdatepass_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_now(peer, 0);
									}
									catch (...)
									{
										SendConsole("safeupdatepass_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_now(peer, 0);
									}
								}
							}
						}

						if (btn == "starttrade")
						{
							bool found = false;

							if (((PlayerInfo*)(peer->data))->rawName == ((PlayerInfo*)(peer->data))->lastInfo)
							{
								Player::OnConsoleMessage(peer, "`4You cant trade your self.");
								continue;
							}
							else if (((PlayerInfo*)(peer->data))->istrading == true)
							{
								Player::OnConsoleMessage(peer, "`4cancel the current trade first.");
								continue;
							}
							if (((PlayerInfo*)(peer->data))->tradingme == ((PlayerInfo*)(peer->data))->lastInfo)
							{
								ENetPeer* currentPeer;
								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									if (isHere(peer, currentPeer))
									{
										if (((PlayerInfo*)(peer->data))->tradingme == ((PlayerInfo*)(currentPeer->data))->rawName) {
											((PlayerInfo*)(peer->data))->istrading = true;
											((PlayerInfo*)(currentPeer->data))->istrading = true;

											GamePacket pt1 = packetEnd(appendInt(appendString(appendString(createPacket(), "OnStartTrade"), ((PlayerInfo*)(currentPeer->data))->rawName), ((PlayerInfo*)(currentPeer->data))->netID));
											ENetPacket* packetw = enet_packet_create(pt1.data,
												pt1.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(peer, 0, packetw);
											delete pt1.data;

											GamePacket pty = packetEnd(appendInt(appendString(appendString(createPacket(), "OnStartTrade"), ((PlayerInfo*)(peer->data))->rawName), ((PlayerInfo*)(peer->data))->netID));
											ENetPacket* packety = enet_packet_create(pty.data,
												pty.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(currentPeer, 0, packety);
											delete pty.data;
										}
									}
								}
							}
							else
							{
								ENetPeer* currentPeer;
								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									if (isHere(peer, currentPeer))
									{
										if (((PlayerInfo*)(currentPeer->data))->rawName == ((PlayerInfo*)(peer->data))->lastInfo)
										{
											found = true;

											if (((PlayerInfo*)(currentPeer->data))->istrading == true)
											{
												Player::OnConsoleMessage(peer, "this player is trading someone else");
												continue;
											}
											else
											{
												((PlayerInfo*)(peer->data))->tradingme = ((PlayerInfo*)(peer->data))->lastInfo;
												((PlayerInfo*)(currentPeer->data))->tradingme = ((PlayerInfo*)(peer->data))->rawName;
												((PlayerInfo*)(peer->data))->istrading = true;
												GamePacket p1 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "You started trading with " + ((PlayerInfo*)(currentPeer->data))->rawName));
												ENetPacket* packet = enet_packet_create(p1.data,
													p1.len,
													ENET_PACKET_FLAG_RELIABLE);
												enet_peer_send(peer, 0, packet);
												delete p1.data;
												GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`#TRADE ALERT: `w" + ((PlayerInfo*)(peer->data))->rawName + " `owants to trade with you! To start, use the `wWrench `oon that person's wrench icon,or type `w/trade " + ((PlayerInfo*)(peer->data))->rawName));
												ENetPacket* packet2 = enet_packet_create(p.data,
													p.len,
													ENET_PACKET_FLAG_RELIABLE);
												enet_peer_send(currentPeer, 0, packet2);
												delete p.data;
												GamePacket pt1 = packetEnd(appendInt(appendString(appendString(createPacket(), "OnStartTrade"), ((PlayerInfo*)(currentPeer->data))->rawName), ((PlayerInfo*)(currentPeer->data))->netID));
												ENetPacket* packet3 = enet_packet_create(pt1.data,
													pt1.len,
													ENET_PACKET_FLAG_RELIABLE);
												enet_peer_send(peer, 0, packet3);
												delete pt1.data;
											}
										}
									}
								}
								if (!found) {
									Player::OnConsoleMessage(peer, "The player no found ");
								}
							}
						}

						if (btn == "notrade")
						{
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`wYou canceled the trade."));
							ENetPacket* packet1 = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet1);
							delete p.data;

							((PlayerInfo*)(peer->data))->item1 = 0;
							((PlayerInfo*)(peer->data))->item1count = 0;
							((PlayerInfo*)(peer->data))->item2 = 0;
							((PlayerInfo*)(peer->data))->item2count = 0;
							((PlayerInfo*)(peer->data))->item3 = 0;
							((PlayerInfo*)(peer->data))->item3count = 0;
							((PlayerInfo*)(peer->data))->item4 = 0;
							((PlayerInfo*)(peer->data))->item4count = 0;
							((PlayerInfo*)(peer->data))->istrading = false;
							((PlayerInfo*)(peer->data))->accepted = false;
							((PlayerInfo*)(peer->data))->dotrade = false;

							ENetPeer* currentPeer;
							for (currentPeer = server->peers;
								currentPeer < &server->peers[server->peerCount];
								++currentPeer)
							{
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
									continue;
								if (((PlayerInfo*)(currentPeer->data))->rawName == ((PlayerInfo*)(peer->data))->tradingme)
								{
									GamePacket p24 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), ((PlayerInfo*)(peer->data))->displayName + " `wcanceled the trade."));

									ENetPacket* packet2 = enet_packet_create(p24.data,
										p24.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(currentPeer, 0, packet2);

									GamePacket p2 = packetEnd(appendString(createPacket(), "OnForceTradeEnd"));

									ENetPacket* packet3 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(currentPeer, 0, packet3);

									ENetPacket* packet4 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet4);

									delete p24.data;
									delete p2.data;

									((PlayerInfo*)(currentPeer->data))->item1 = 0;
									((PlayerInfo*)(currentPeer->data))->item1count = 0;
									((PlayerInfo*)(currentPeer->data))->item2 = 0;
									((PlayerInfo*)(currentPeer->data))->item2count = 0;
									((PlayerInfo*)(currentPeer->data))->item3 = 0;
									((PlayerInfo*)(currentPeer->data))->item3count = 0;
									((PlayerInfo*)(currentPeer->data))->item4 = 0;
									((PlayerInfo*)(currentPeer->data))->item4count = 0;
									((PlayerInfo*)(currentPeer->data))->tradingme = "";
									((PlayerInfo*)(currentPeer->data))->istrading = false;
									((PlayerInfo*)(currentPeer->data))->accepted = false;
									((PlayerInfo*)(currentPeer->data))->dotrade = false;
								}
							}
							((PlayerInfo*)(peer->data))->tradingme = "";
						}

						if (btn == "dothetrade")
						{

							string traderName = ((PlayerInfo*)(peer->data))->displayName;
							string tradingWithName = ((PlayerInfo*)(peer->data))->tradingme;

							string toLogs = "";
							string toLogs2 = "";
							bool toLogsItem1 = false;
							bool toLogsItem2 = false;
							bool toLogsItem3 = false;
							bool toLogsItem4 = false;

							ENetPeer* currentPeer;
							for (currentPeer = server->peers;
								currentPeer < &server->peers[server->peerCount];
								++currentPeer)
							{
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
									continue;

								if (((PlayerInfo*)(currentPeer->data))->rawName == tradingWithName)
								{

									if (((PlayerInfo*)(currentPeer->data))->isDoTheTrade == false)
									{
										((PlayerInfo*)(peer->data))->isDoTheTrade = true;
										Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`4Waiting for another player...", 0, true);
										break;
									}
									bool success = false;

									//Peer

									if (((PlayerInfo*)(peer->data))->item1count != 0 && ((PlayerInfo*)(peer->data))->item1 != 0)
									{
										RemoveInventoryItems(((PlayerInfo*)(peer->data))->item1, ((PlayerInfo*)(peer->data))->item1count, peer);
										SaveItemMoreTimess(((PlayerInfo*)(peer->data))->item1, ((PlayerInfo*)(peer->data))->item1count, currentPeer, success);
										toLogs += ((PlayerInfo*)(peer->data))->displayName + " `1traded " + to_string(((PlayerInfo*)(peer->data))->item1count) + " " + itemDefs[((PlayerInfo*)(peer->data))->item1].name + " to " + ((PlayerInfo*)(currentPeer->data))->displayName + "; ";
									}
									if (((PlayerInfo*)(peer->data))->item2count != 0 && ((PlayerInfo*)(peer->data))->item2 != 0)
									{
										RemoveInventoryItems(((PlayerInfo*)(peer->data))->item2, ((PlayerInfo*)(peer->data))->item2count, peer);
										SaveItemMoreTimess(((PlayerInfo*)(peer->data))->item2, ((PlayerInfo*)(peer->data))->item2count, currentPeer, success);
										toLogs += ((PlayerInfo*)(peer->data))->displayName + " `1traded " + to_string(((PlayerInfo*)(peer->data))->item2count) + " " + itemDefs[((PlayerInfo*)(peer->data))->item2].name + " to " + ((PlayerInfo*)(currentPeer->data))->displayName + "; ";
									}
									if (((PlayerInfo*)(peer->data))->item3count != 0 && ((PlayerInfo*)(peer->data))->item3 != 0)
									{
										RemoveInventoryItems(((PlayerInfo*)(peer->data))->item3, ((PlayerInfo*)(peer->data))->item3count, peer);
										SaveItemMoreTimess(((PlayerInfo*)(peer->data))->item3, ((PlayerInfo*)(peer->data))->item3count, currentPeer, success);
										toLogs += ((PlayerInfo*)(peer->data))->displayName + " `1traded " + to_string(((PlayerInfo*)(peer->data))->item3count) + " " + itemDefs[((PlayerInfo*)(peer->data))->item3].name + " to " + ((PlayerInfo*)(currentPeer->data))->displayName + "; ";
									}
									if (((PlayerInfo*)(peer->data))->item4count != 0 && ((PlayerInfo*)(peer->data))->item4 != 0)
									{
										RemoveInventoryItems(((PlayerInfo*)(peer->data))->item4, ((PlayerInfo*)(peer->data))->item4count, peer);
										SaveItemMoreTimess(((PlayerInfo*)(peer->data))->item4, ((PlayerInfo*)(peer->data))->item4count, currentPeer, success);
										toLogs += ((PlayerInfo*)(peer->data))->displayName + " `1traded " + to_string(((PlayerInfo*)(peer->data))->item4count) + " " + itemDefs[((PlayerInfo*)(peer->data))->item4].name + " to " + ((PlayerInfo*)(currentPeer->data))->displayName + "; ";
									}

									//currentPeer

									if (((PlayerInfo*)(currentPeer->data))->item1count != 0 && ((PlayerInfo*)(currentPeer->data))->item1 != 0)
									{
										RemoveInventoryItems(((PlayerInfo*)(currentPeer->data))->item1, ((PlayerInfo*)(currentPeer->data))->item1count, currentPeer);
										SaveItemMoreTimess(((PlayerInfo*)(currentPeer->data))->item1, ((PlayerInfo*)(currentPeer->data))->item1count, peer, success);
										toLogs2 += ((PlayerInfo*)(currentPeer->data))->displayName + " `1traded " + to_string(((PlayerInfo*)(currentPeer->data))->item1count) + " " + itemDefs[((PlayerInfo*)(currentPeer->data))->item1].name + " to " + ((PlayerInfo*)(peer->data))->displayName + "; ";
									}
									if (((PlayerInfo*)(currentPeer->data))->item2count != 0 && ((PlayerInfo*)(currentPeer->data))->item2 != 0)
									{
										RemoveInventoryItems(((PlayerInfo*)(currentPeer->data))->item2, ((PlayerInfo*)(currentPeer->data))->item2count, currentPeer);
										SaveItemMoreTimess(((PlayerInfo*)(currentPeer->data))->item2, ((PlayerInfo*)(currentPeer->data))->item2count, peer, success);
										toLogs2 += ((PlayerInfo*)(currentPeer->data))->displayName + " `1traded " + to_string(((PlayerInfo*)(currentPeer->data))->item2count) + " " + itemDefs[((PlayerInfo*)(currentPeer->data))->item2].name + " to " + ((PlayerInfo*)(peer->data))->displayName + "; ";
									}
									if (((PlayerInfo*)(currentPeer->data))->item3count != 0 && ((PlayerInfo*)(currentPeer->data))->item3 != 0)
									{
										RemoveInventoryItems(((PlayerInfo*)(currentPeer->data))->item3, ((PlayerInfo*)(currentPeer->data))->item3count, currentPeer);
										SaveItemMoreTimess(((PlayerInfo*)(currentPeer->data))->item3, ((PlayerInfo*)(currentPeer->data))->item3count, peer, success);
										toLogs2 += ((PlayerInfo*)(currentPeer->data))->displayName + " `1traded " + to_string(((PlayerInfo*)(currentPeer->data))->item3count) + " " + itemDefs[((PlayerInfo*)(currentPeer->data))->item3].name + " to " + ((PlayerInfo*)(peer->data))->displayName + "; ";
									}
									if (((PlayerInfo*)(currentPeer->data))->item4count != 0 && ((PlayerInfo*)(currentPeer->data))->item4 != 0)
									{
										RemoveInventoryItems(((PlayerInfo*)(currentPeer->data))->item4, ((PlayerInfo*)(currentPeer->data))->item4count, currentPeer);
										SaveItemMoreTimess(((PlayerInfo*)(currentPeer->data))->item4, ((PlayerInfo*)(currentPeer->data))->item4count, peer, success);
										toLogs2 += ((PlayerInfo*)(currentPeer->data))->displayName + " `1traded " + to_string(((PlayerInfo*)(currentPeer->data))->item4count) + " " + itemDefs[((PlayerInfo*)(currentPeer->data))->item4].name + " to " + ((PlayerInfo*)(peer->data))->displayName + "; ";
									}

									//logs

									if (toLogs == "")
									{
										toLogs = ((PlayerInfo*)(peer->data))->displayName + " `1traded `4nothing `1to `4" + ((PlayerInfo*)(currentPeer->data))->displayName;
									}
									if (toLogs2 == "")
									{
										toLogs = ((PlayerInfo*)(currentPeer->data))->displayName + " `1traded `4nothing `1to `4" + ((PlayerInfo*)(peer->data))->displayName;
									}
									ofstream tradelogs("logs/trade.txt", ios::app);
									tradelogs << toLogs << endl;
									tradelogs << toLogs2 << endl;
									tradelogs.close();

									//return values

									((PlayerInfo*)(peer->data))->dotrade = false;
									((PlayerInfo*)(peer->data))->istrading = false;
									((PlayerInfo*)(peer->data))->accepted = false;

									((PlayerInfo*)(currentPeer->data))->dotrade = false;
									((PlayerInfo*)(currentPeer->data))->istrading = false;
									((PlayerInfo*)(currentPeer->data))->accepted = false;

									Player::OnForceTradeEnd(peer);
									Player::OnForceTradeEnd(currentPeer);

									updateplayerset(peer, ((PlayerInfo*)(peer->data))->item1);
									updateplayerset(currentPeer, ((PlayerInfo*)(currentPeer->data))->item1);

									updateplayerset(peer, ((PlayerInfo*)(peer->data))->item2);
									updateplayerset(currentPeer, ((PlayerInfo*)(currentPeer->data))->item2);

									updateplayerset(peer, ((PlayerInfo*)(peer->data))->item3);
									updateplayerset(currentPeer, ((PlayerInfo*)(currentPeer->data))->item3);

									updateplayerset(peer, ((PlayerInfo*)(peer->data))->item4);
									updateplayerset(currentPeer, ((PlayerInfo*)(currentPeer->data))->item4);

									//notice players

									ENetPeer* currentPeer2;
									for (currentPeer2 = server->peers;
										currentPeer2 < &server->peers[server->peerCount];
										++currentPeer2)
									{
										if (currentPeer2->state != ENET_PEER_STATE_CONNECTED)
											continue;
										if (isHere(peer, currentPeer2))
										{
											Player::OnConsoleMessage(currentPeer2, toLogs);
											Player::OnConsoleMessage(currentPeer2, toLogs2);
										}
									}

								}

							}

						}
						if (btn == "buylitems")
						{
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|\nadd_label_with_icon|small|`8Legendary Items``|left|1790|\nadd_button_with_icon|ldrag||staticBlueFrame|1782|15000000||\nadd_button_with_icon|lwings||staticBlueFrame|1784|18000000||\nadd_button_with_icon|lwiz||staticBlueFrame|1790|20000000|\nadd_button_with_icon|lbot||staticBlueFrame|1780|19000000|\nadd_quick_exit|"));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						if (btn == "buyrare")
						{
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|\nadd_label_with_icon|small|`9Rare Wings``|left|1782|\nadd_button_with_icon|phoenix||staticBlueFrame|1674|2000000||\nadd_button_with_icon|nwings||staticBlueFrame|1970|6000000||\nadd_button_with_icon|gteeny||staticBlueFrame|2392|8000000|\nadd_quick_exit|"));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						if (btn == "gteeny")
						{
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|\nadd_label_with_icon|big|`6Buy `6Teeny Golden Angel Wings``|left|2392|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`^Teeny Angel Wings In Gold!|\nadd_spacer|small|\nadd_button|buygtwing|`9Buy `6Teeny Golden Angel Wings!|0|0|\nadd_spacer|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|"));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}



						if (btn == "nwings")
						{
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|\nadd_label_with_icon|big|`6Buy `7Nightmare Devil Wings``|left|1970|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`^A Wings That Sparkles Purple In Colour When You Jump & It has A Sick Respawn Effect!|\nadd_spacer|small|\nadd_button|buynwing|`9Buy `7Nightmare Devil Wings!|0|0|\nadd_spacer|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|"));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						if (btn == "phoenix")
						{
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|\nadd_label_with_icon|big|`6Buy `9Phoenix Wings``|left|1674|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`^A Wings That Are On Fire!! How Cool Is That!|\nadd_spacer|small|\nadd_button|buypwing|`9Buy `9Phoenix Wings!|0|0|\nadd_spacer|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|"));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						if (btn == "ldrag")
						{
							std::ifstream ifsz("gemdb/" + ((PlayerInfo*)(peer->data))->rawName + ".txt");
							std::string content((std::istreambuf_iterator<char>(ifsz)),
								(std::istreambuf_iterator<char>()));

							int b = atoi(content.c_str());

							if (b > 15000000)
							{

								bool success = true;
								SaveShopsItemMoreTimes(1782, 1, peer, success);

								if (!success)continue;
								GamePacket ps2 = packetEnd(appendInt(appendString(appendString(appendString(appendString(createPacket(), "OnAddNotification"), "interface/science_button.rttex"), "`0You have bought `1Legendary Dragon!"), "audio/hub_open.wav"), 0));
								ENetPacket* packet2 = enet_packet_create(ps2.data,
									ps2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);

								string text = "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0\n";
								BYTE* data = new BYTE[5 + text.length()];
								BYTE zero = 0;
								int type = 3;
								memcpy(data, &type, 4);
								memcpy(data + 4, text.c_str(), text.length()); // change memcpy here
								memcpy(data + 4 + text.length(), &zero, 1); // change memcpy here, revert to 4

								ENetPacket* packetsou = enet_packet_create(data,
									5 + text.length(),
									ENET_PACKET_FLAG_RELIABLE);

								enet_peer_send(peer, 0, packetsou);

								int gemcalc10k = b - 15000000;


								ofstream myfile2;
								myfile2.open("gemdb/" + ((PlayerInfo*)(peer->data))->rawName + ".txt");
								myfile2 << std::to_string(gemcalc10k);
								myfile2.close();

								std::ifstream ifszi("gemdb/" + ((PlayerInfo*)(peer->data))->rawName + ".txt");
								std::string contentx((std::istreambuf_iterator<char>(ifszi)),
									(std::istreambuf_iterator<char>()));


								int updgem = atoi(contentx.c_str());
								GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), updgem));
								ENetPacket* packetpp = enet_packet_create(pp.data,
									pp.len,
									ENET_PACKET_FLAG_RELIABLE);

								enet_peer_send(peer, 0, packetpp);
								delete pp.data;


							}
							else
							{
								GamePacket ps2 = packetEnd(appendInt(appendString(appendString(appendString(appendString(createPacket(), "OnAddNotification"), "interface/science_button.rttex"), "`0You don't have enough gems."), "audio/hub_open.wav"), 0));
								ENetPacket* packet2 = enet_packet_create(ps2.data,
									ps2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);
								delete ps2.data;
							}

						}
						if (btn == "achi")
						{
							string buffs;
							bool achi1 = std::experimental::filesystem::exists("achievements/wl/" + ((PlayerInfo*)(peer->data))->rawName + ".txt");
							if (achi1 == true)
							{
								buffs += "\nadd_achieve|Creating An GrowID (Classic) |Earned for making an account|left|26|\nadd_achieve|This is my land (Classic) |Earned for using for a World lock|left|26|";
							}
							else
							{
								buffs += "\nadd_achieve|Creating An GrowID (Classic) |Earned for making an account|left|26|\nadd_achieve|This is my land (Classic) |Not achieved!|left|125|";
							}

							Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|small|`o" + ((PlayerInfo*)(peer->data))->rawName + " Achievements|left|982|\nadd_spacer|small|\nadd_textbox|" + buffs + "|\nadd_spacer|small|\nadd_button|gayno|`wContinue|noflags|0|0|\nend_dialog|gayno||");
						}
						if (btn == "lwings")
						{
							std::ifstream ifsz("gemdb/" + ((PlayerInfo*)(peer->data))->rawName + ".txt");
							std::string content((std::istreambuf_iterator<char>(ifsz)),
								(std::istreambuf_iterator<char>()));

							int b = atoi(content.c_str());

							if (b > 18000000)
							{

								bool success = true;
								SaveShopsItemMoreTimes(1784, 1, peer, success);

								if (!success)continue;
								GamePacket ps2 = packetEnd(appendInt(appendString(appendString(appendString(appendString(createPacket(), "OnAddNotification"), "interface/science_button.rttex"), "`0You have bought `4Legendary Wings!"), "audio/hub_open.wav"), 0));
								ENetPacket* packet2 = enet_packet_create(ps2.data,
									ps2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);

								string text = "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0\n";
								BYTE* data = new BYTE[5 + text.length()];
								BYTE zero = 0;
								int type = 3;
								memcpy(data, &type, 4);
								memcpy(data + 4, text.c_str(), text.length()); // change memcpy here
								memcpy(data + 4 + text.length(), &zero, 1); // change memcpy here, revert to 4

								ENetPacket* packetsou = enet_packet_create(data,
									5 + text.length(),
									ENET_PACKET_FLAG_RELIABLE);

								enet_peer_send(peer, 0, packetsou);

								int gemcalc10k = b - 18000000;


								ofstream myfile2;
								myfile2.open("gemdb/" + ((PlayerInfo*)(peer->data))->rawName + ".txt");
								myfile2 << std::to_string(gemcalc10k);
								myfile2.close();

								std::ifstream ifszi("gemdb/" + ((PlayerInfo*)(peer->data))->rawName + ".txt");
								std::string contentx((std::istreambuf_iterator<char>(ifszi)),
									(std::istreambuf_iterator<char>()));


								int updgem = atoi(contentx.c_str());
								GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), updgem));
								ENetPacket* packetpp = enet_packet_create(pp.data,
									pp.len,
									ENET_PACKET_FLAG_RELIABLE);

								enet_peer_send(peer, 0, packetpp);
								delete pp.data;


							}
							else
							{
								GamePacket ps2 = packetEnd(appendInt(appendString(appendString(appendString(appendString(createPacket(), "OnAddNotification"), "interface/science_button.rttex"), "`0You don't have enough gems."), "audio/hub_open.wav"), 0));
								ENetPacket* packet2 = enet_packet_create(ps2.data,
									ps2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);
								delete ps2.data;
							}

						}
						if (btn == "lwiz")
						{
							std::ifstream ifsz("gemdb/" + ((PlayerInfo*)(peer->data))->rawName + ".txt");
							std::string content((std::istreambuf_iterator<char>(ifsz)),
								(std::istreambuf_iterator<char>()));

							int b = atoi(content.c_str());

							if (b > 20000000)
							{

								bool success = true;
								SaveShopsItemMoreTimes(1790, 1, peer, success);

								if (!success)continue;
								GamePacket ps2 = packetEnd(appendInt(appendString(appendString(appendString(appendString(createPacket(), "OnAddNotification"), "interface/science_button.rttex"), "`0You have bought `eLegendary Wizard!"), "audio/hub_open.wav"), 0));
								ENetPacket* packet2 = enet_packet_create(ps2.data,
									ps2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);

								string text = "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0\n";
								BYTE* data = new BYTE[5 + text.length()];
								BYTE zero = 0;
								int type = 3;
								memcpy(data, &type, 4);
								memcpy(data + 4, text.c_str(), text.length()); // change memcpy here
								memcpy(data + 4 + text.length(), &zero, 1); // change memcpy here, revert to 4

								ENetPacket* packetsou = enet_packet_create(data,
									5 + text.length(),
									ENET_PACKET_FLAG_RELIABLE);

								enet_peer_send(peer, 0, packetsou);

								int gemcalc10k = b - 20000000;


								ofstream myfile2;
								myfile2.open("gemdb/" + ((PlayerInfo*)(peer->data))->rawName + ".txt");
								myfile2 << std::to_string(gemcalc10k);
								myfile2.close();

								std::ifstream ifszi("gemdb/" + ((PlayerInfo*)(peer->data))->rawName + ".txt");
								std::string contentx((std::istreambuf_iterator<char>(ifszi)),
									(std::istreambuf_iterator<char>()));


								int updgem = atoi(contentx.c_str());
								GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), updgem));
								ENetPacket* packetpp = enet_packet_create(pp.data,
									pp.len,
									ENET_PACKET_FLAG_RELIABLE);

								enet_peer_send(peer, 0, packetpp);
								delete pp.data;


							}
							else
							{
								GamePacket ps2 = packetEnd(appendInt(appendString(appendString(appendString(appendString(createPacket(), "OnAddNotification"), "interface/science_button.rttex"), "`0You don't have enough gems."), "audio/hub_open.wav"), 0));
								ENetPacket* packet2 = enet_packet_create(ps2.data,
									ps2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);
								delete ps2.data;
							}

						}
						if (btn == "lbot")
						{
							std::ifstream ifsz("gemdb/" + ((PlayerInfo*)(peer->data))->rawName + ".txt");
							std::string content((std::istreambuf_iterator<char>(ifsz)),
								(std::istreambuf_iterator<char>()));

							int b = atoi(content.c_str());

							if (b > 19000000)
							{

								bool success = true;
								SaveShopsItemMoreTimes(1780, 1, peer, success);

								if (!success)continue;
								GamePacket ps2 = packetEnd(appendInt(appendString(appendString(appendString(appendString(createPacket(), "OnAddNotification"), "interface/science_button.rttex"), "`0You have bought `bLegendary Bot!"), "audio/hub_open.wav"), 0));
								ENetPacket* packet2 = enet_packet_create(ps2.data,
									ps2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);

								string text = "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0\n";
								BYTE* data = new BYTE[5 + text.length()];
								BYTE zero = 0;
								int type = 3;
								memcpy(data, &type, 4);
								memcpy(data + 4, text.c_str(), text.length()); // change memcpy here
								memcpy(data + 4 + text.length(), &zero, 1); // change memcpy here, revert to 4

								ENetPacket* packetsou = enet_packet_create(data,
									5 + text.length(),
									ENET_PACKET_FLAG_RELIABLE);

								enet_peer_send(peer, 0, packetsou);

								int gemcalc10k = b - 19000000;


								ofstream myfile2;
								myfile2.open("gemdb/" + ((PlayerInfo*)(peer->data))->rawName + ".txt");
								myfile2 << std::to_string(gemcalc10k);
								myfile2.close();

								std::ifstream ifszi("gemdb/" + ((PlayerInfo*)(peer->data))->rawName + ".txt");
								std::string contentx((std::istreambuf_iterator<char>(ifszi)),
									(std::istreambuf_iterator<char>()));


								int updgem = atoi(contentx.c_str());
								GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), updgem));
								ENetPacket* packetpp = enet_packet_create(pp.data,
									pp.len,
									ENET_PACKET_FLAG_RELIABLE);

								enet_peer_send(peer, 0, packetpp);
								delete pp.data;


							}
							else
							{
								GamePacket ps2 = packetEnd(appendInt(appendString(appendString(appendString(appendString(createPacket(), "OnAddNotification"), "interface/science_button.rttex"), "`0You don't have enough gems."), "audio/hub_open.wav"), 0));
								ENetPacket* packet2 = enet_packet_create(ps2.data,
									ps2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);
								delete ps2.data;
							}

						}
						if (btn == "buygtwing")
						{
							std::ifstream ifsz("gemdb/" + ((PlayerInfo*)(peer->data))->rawName + ".txt");
							std::string content((std::istreambuf_iterator<char>(ifsz)),
								(std::istreambuf_iterator<char>()));

							int b = atoi(content.c_str());

							if (b > 8000000)
							{

								bool success = true;
								SaveShopsItemMoreTimes(2392, 1, peer, success);

								if (!success)continue;
								GamePacket ps2 = packetEnd(appendInt(appendString(appendString(appendString(appendString(createPacket(), "OnAddNotification"), "interface/science_button.rttex"), "`0You have bought `6Teeny Golden Angel Wings!"), "audio/hub_open.wav"), 0));
								ENetPacket* packet2 = enet_packet_create(ps2.data,
									ps2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);

								string text = "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0\n";
								BYTE* data = new BYTE[5 + text.length()];
								BYTE zero = 0;
								int type = 3;
								memcpy(data, &type, 4);
								memcpy(data + 4, text.c_str(), text.length()); // change memcpy here
								memcpy(data + 4 + text.length(), &zero, 1); // change memcpy here, revert to 4

								ENetPacket* packetsou = enet_packet_create(data,
									5 + text.length(),
									ENET_PACKET_FLAG_RELIABLE);

								enet_peer_send(peer, 0, packetsou);

								int gemcalc10k = b - 8000000;


								ofstream myfile2;
								myfile2.open("gemdb/" + ((PlayerInfo*)(peer->data))->rawName + ".txt");
								myfile2 << std::to_string(gemcalc10k);
								myfile2.close();

								std::ifstream ifszi("gemdb/" + ((PlayerInfo*)(peer->data))->rawName + ".txt");
								std::string contentx((std::istreambuf_iterator<char>(ifszi)),
									(std::istreambuf_iterator<char>()));


								int updgem = atoi(contentx.c_str());
								GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), updgem));
								ENetPacket* packetpp = enet_packet_create(pp.data,
									pp.len,
									ENET_PACKET_FLAG_RELIABLE);

								enet_peer_send(peer, 0, packetpp);
								delete pp.data;


							}
							else
							{
								GamePacket ps2 = packetEnd(appendInt(appendString(appendString(appendString(appendString(createPacket(), "OnAddNotification"), "interface/science_button.rttex"), "`0You don't have enough gems."), "audio/hub_open.wav"), 0));
								ENetPacket* packet2 = enet_packet_create(ps2.data,
									ps2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);
								delete ps2.data;
							}

						}
						if (btn == "buypwing")
						{
							std::ifstream ifsz("gemdb/" + ((PlayerInfo*)(peer->data))->rawName + ".txt");
							std::string content((std::istreambuf_iterator<char>(ifsz)),
								(std::istreambuf_iterator<char>()));

							int b = atoi(content.c_str());

							if (b > 2000000)
							{

								bool success = true;
								SaveShopsItemMoreTimes(1674, 1, peer, success);

								if (!success)continue;
								GamePacket ps2 = packetEnd(appendInt(appendString(appendString(appendString(appendString(createPacket(), "OnAddNotification"), "interface/science_button.rttex"), "`0You have bought `9Phoenix Wing!"), "audio/hub_open.wav"), 0));
								ENetPacket* packet2 = enet_packet_create(ps2.data,
									ps2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);

								string text = "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0\n";
								BYTE* data = new BYTE[5 + text.length()];
								BYTE zero = 0;
								int type = 3;
								memcpy(data, &type, 4);
								memcpy(data + 4, text.c_str(), text.length()); // change memcpy here
								memcpy(data + 4 + text.length(), &zero, 1); // change memcpy here, revert to 4

								ENetPacket* packetsou = enet_packet_create(data,
									5 + text.length(),
									ENET_PACKET_FLAG_RELIABLE);

								enet_peer_send(peer, 0, packetsou);

								int gemcalc10k = b - 2000000;


								ofstream myfile2;
								myfile2.open("gemdb/" + ((PlayerInfo*)(peer->data))->rawName + ".txt");
								myfile2 << std::to_string(gemcalc10k);
								myfile2.close();

								std::ifstream ifszi("gemdb/" + ((PlayerInfo*)(peer->data))->rawName + ".txt");
								std::string contentx((std::istreambuf_iterator<char>(ifszi)),
									(std::istreambuf_iterator<char>()));


								int updgem = atoi(contentx.c_str());
								GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), updgem));
								ENetPacket* packetpp = enet_packet_create(pp.data,
									pp.len,
									ENET_PACKET_FLAG_RELIABLE);

								enet_peer_send(peer, 0, packetpp);
								delete pp.data;


							}
							else
							{
								GamePacket ps2 = packetEnd(appendInt(appendString(appendString(appendString(appendString(createPacket(), "OnAddNotification"), "interface/science_button.rttex"), "`0You don't have enough gems."), "audio/hub_open.wav"), 0));
								ENetPacket* packet2 = enet_packet_create(ps2.data,
									ps2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);
								delete ps2.data;
							}

						}
						if (btn == "buynwing")
						{
							std::ifstream ifsz("gemdb/" + ((PlayerInfo*)(peer->data))->rawName + ".txt");
							std::string content((std::istreambuf_iterator<char>(ifsz)),
								(std::istreambuf_iterator<char>()));

							int b = atoi(content.c_str());

							if (b > 6000000)
							{

								bool success = true;
								SaveShopsItemMoreTimes(1970, 1, peer, success);

								if (!success)continue;
								GamePacket ps2 = packetEnd(appendInt(appendString(appendString(appendString(appendString(createPacket(), "OnAddNotification"), "interface/science_button.rttex"), "`0You have bought `7Nightmare Devil Wings!"), "audio/hub_open.wav"), 0));
								ENetPacket* packet2 = enet_packet_create(ps2.data,
									ps2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);

								string text = "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0\n";
								BYTE* data = new BYTE[5 + text.length()];
								BYTE zero = 0;
								int type = 3;
								memcpy(data, &type, 4);
								memcpy(data + 4, text.c_str(), text.length()); // change memcpy here
								memcpy(data + 4 + text.length(), &zero, 1); // change memcpy here, revert to 4

								ENetPacket* packetsou = enet_packet_create(data,
									5 + text.length(),
									ENET_PACKET_FLAG_RELIABLE);

								enet_peer_send(peer, 0, packetsou);

								int gemcalc10k = b - 6000000;


								ofstream myfile2;
								myfile2.open("gemdb/" + ((PlayerInfo*)(peer->data))->rawName + ".txt");
								myfile2 << std::to_string(gemcalc10k);
								myfile2.close();

								std::ifstream ifszi("gemdb/" + ((PlayerInfo*)(peer->data))->rawName + ".txt");
								std::string contentx((std::istreambuf_iterator<char>(ifszi)),
									(std::istreambuf_iterator<char>()));


								int updgem = atoi(contentx.c_str());
								GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), updgem));
								ENetPacket* packetpp = enet_packet_create(pp.data,
									pp.len,
									ENET_PACKET_FLAG_RELIABLE);

								enet_peer_send(peer, 0, packetpp);
								delete pp.data;


							}
							else
							{
								GamePacket ps2 = packetEnd(appendInt(appendString(appendString(appendString(appendString(createPacket(), "OnAddNotification"), "interface/science_button.rttex"), "`0You don't have enough gems."), "audio/hub_open.wav"), 0));
								ENetPacket* packet2 = enet_packet_create(ps2.data,
									ps2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);
								delete ps2.data;
							}

						}

						if (btn == "buyzeus")
						{
							Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`6Buy `!Zeus Lightning Bolt``|left|1804|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`9This Item is Special Item That Have Same Effect Like `bFocus Eyes!|\nadd_spacer|small|\nadd_button|buyzeus1|`7Buy `!Zeus Lighting Bolt `7[`450`e DLS`7]!|0|0|\nadd_spacer|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|");
							continue;
						}
						if (btn == "buyances")
						{
							Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`6Buy `3Ancestral Items``|left|1100|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`9There Are 3 Type Of Ances Working Right Now. `4Ancestral Of Riches `0= More Gems, `9Ancestral Totem Of Wisdom `0= Double Chance XP & `1Ancestral Of Dimensions `0= Drops More Blocks From Break Blocks! (`2Upgrading Ancestral Item Coming Soon`0!).. Each Ancestral Item Costs (`625DLS`0!)|\nadd_spacer|small|\nadd_button|buyriches|`7Buy `4Ancestral Of Riches!|0|0|\nadd_button|buywis|`7Buy `9Ancestral Totem Of Wisdom!|0|0|\nadd_button|buydim|`7Buy `3Ancestral Of Dimensions!|0|0|\nadd_spacer|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|");
							continue;
						}
						if (btn == "bgl")
						{
							Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`6Buy `!Blue Gem Lock``|left|7188|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`9This Item is like world lock, allows you to lock any world, you can convert this item back to `@100 `1Diamond Locks `9At any time!|\nadd_spacer|small|\nadd_button|buybgl|`7Buy `!BGL `7[`4100`e DLS`7]!|0|0|\nadd_spacer|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|");
							continue;
						}

						if (btn == "magplant")
						{
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|\nadd_label_with_icon|big|`6Buy `^Magplant``|left|5638|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`5Magplant Collects Items That Are Dropped & Keeps It For You Till You Retrieve It!|\nadd_spacer|small|\nadd_button|buymg|`9Buy `^Magplant For 4.5M Gems!|0|0|\nadd_spacer|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|"));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						if (btn == "buymg")
						{
							std::ifstream ifsz("gemdb/" + ((PlayerInfo*)(peer->data))->rawName + ".txt");
							std::string content((std::istreambuf_iterator<char>(ifsz)),
								(std::istreambuf_iterator<char>()));

							int b = atoi(content.c_str());

							if (b > 4500000)
							{

								bool success = true;
								SaveShopsItemMoreTimes(5638, 1, peer, success);

								if (!success)continue;
								GamePacket ps2 = packetEnd(appendInt(appendString(appendString(appendString(appendString(createPacket(), "OnAddNotification"), "interface/science_button.rttex"), "`0You have bought `^Magplant!"), "audio/hub_open.wav"), 0));
								ENetPacket* packet2 = enet_packet_create(ps2.data,
									ps2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);

								string text = "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0\n";
								BYTE* data = new BYTE[5 + text.length()];
								BYTE zero = 0;
								int type = 3;
								memcpy(data, &type, 4);
								memcpy(data + 4, text.c_str(), text.length()); // change memcpy here
								memcpy(data + 4 + text.length(), &zero, 1); // change memcpy here, revert to 4

								ENetPacket* packetsou = enet_packet_create(data,
									5 + text.length(),
									ENET_PACKET_FLAG_RELIABLE);

								enet_peer_send(peer, 0, packetsou);

								int gemcalc10k = b - 45000000;


								ofstream myfile2;
								myfile2.open("gemdb/" + ((PlayerInfo*)(peer->data))->rawName + ".txt");
								myfile2 << std::to_string(gemcalc10k);
								myfile2.close();

								std::ifstream ifszi("gemdb/" + ((PlayerInfo*)(peer->data))->rawName + ".txt");
								std::string contentx((std::istreambuf_iterator<char>(ifszi)),
									(std::istreambuf_iterator<char>()));


								int updgem = atoi(contentx.c_str());
								GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), updgem));
								ENetPacket* packetpp = enet_packet_create(pp.data,
									pp.len,
									ENET_PACKET_FLAG_RELIABLE);

								enet_peer_send(peer, 0, packetpp);
								delete pp.data;


							}
							else
							{
								GamePacket ps2 = packetEnd(appendInt(appendString(appendString(appendString(appendString(createPacket(), "OnAddNotification"), "interface/science_button.rttex"), "`0You don't have enough gems."), "audio/hub_open.wav"), 0));
								ENetPacket* packet2 = enet_packet_create(ps2.data,
									ps2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);
								delete ps2.data;
							}

						}
						if (btn.substr(0, 21) == "boxlvl2DepositedItem_")
						{
							if (world == nullptr || world->name == "EXIT" || serverIsFrozen) continue;
							if (static_cast<PlayerInfo*>(peer->data)->rawName == PlayerDB::getProperName(world->owner) || world->owner == "" || isMod(peer))
							{
								string apos_and_coord = btn.erase(0, 21);
								string::size_type pos = apos_and_coord.find('_');
								string apos = "";
								string coord = "";

								if (pos != std::string::npos)
								{
									apos = apos_and_coord.substr(0, pos);
									apos_and_coord.erase(0, pos + 1);
									coord = apos_and_coord;
								}
								else
								{
									autoBan(peer, false, 24 * 7, "Incorrect parameters boxlvl2DepositedItem_. apos and coord were: " + apos_and_coord);
									break;
								}
								auto isdbox = std::experimental::filesystem::exists("storageboxlvl2/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
								if (!isdbox)
								{
									Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4An error occured while getting box info.", 0, true);
									break;
								}

								bool contains_non_int3 = !std::regex_match(apos, std::regex("^[0-9]+$"));
								if (contains_non_int3 == true)
								{
									autoBan(peer, false, 24 * 7, "Proxy detect! boxlvl2DepositedItem_ apos was: " + apos);
									break;
								}

								try
								{
									ifstream ifff("storageboxlvl2/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
									json j;
									ifff >> j;
									ifff.close();

									int itemid = 0;
									int count = 0;
									for (int i = 0; i < 40; i++)
									{
										if (j["storage"][i]["aposition"] == atoi(apos.c_str()))
										{
											itemid = j["storage"][i]["itemid"];
											count = j["storage"][i]["itemcount"];
											GTDialog storagelvl1;
											storagelvl1.addLabelWithIcon("`wStorage Box Xtreme - Level 2", 6288, LABEL_BIG);
											storagelvl1.addSmallText("`oYou have `w" + to_string(count) + " " + itemDefs[itemid].name + " `ostored.");
											storagelvl1.addSmallText("`oWithdraw how many?");
											storagelvl1.addInputBox("boxlvl2withdraw_" + coord + "_" + apos, "", to_string(count), 5);
											storagelvl1.addSpacer(SPACER_SMALL);
											storagelvl1.addButton("boxlvl2_withdrawConfirm", "Remove items");
											storagelvl1.addSpacer(SPACER_SMALL);
											storagelvl1.addQuickExit();
											storagelvl1.endDialog("Close", "", "Exit");
											Player::OnDialogRequest(peer, storagelvl1.finishDialog());
											break;
										}
									}
								}
								catch (std::exception&)
								{
									SendConsole("boxlvl2DepositedItem_ Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
									enet_peer_disconnect_now(peer, 0);
								}
								catch (std::runtime_error&)
								{
									SendConsole("boxlvl2DepositedItem_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
									enet_peer_disconnect_now(peer, 0);
								}
								catch (...)
								{
									SendConsole("boxlvl2DepositedItem_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
									enet_peer_disconnect_now(peer, 0);
								}
							}
						}
						if (btn.substr(0, 21) == "boxlvl3DepositedItem_")
						{
							if (world == nullptr || world->name == "EXIT" || serverIsFrozen) continue;
							if (static_cast<PlayerInfo*>(peer->data)->rawName == PlayerDB::getProperName(world->owner) || world->owner == "" || isMod(peer))
							{
								string apos_and_coord = btn.erase(0, 21);
								string::size_type pos = apos_and_coord.find('_');
								string apos = "";
								string coord = "";

								if (pos != std::string::npos)
								{
									apos = apos_and_coord.substr(0, pos);
									apos_and_coord.erase(0, pos + 1);
									coord = apos_and_coord;
								}
								else
								{
									autoBan(peer, false, 24 * 7, "Incorrect parameters boxlvl3DepositedItem_. apos and coord were: " + apos_and_coord);
									break;
								}
								auto isdbox = std::experimental::filesystem::exists("storageboxlvl3/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
								if (!isdbox)
								{
									Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4An error occured while getting box info.", 0, true);
									break;
								}

								bool contains_non_int3 = !std::regex_match(apos, std::regex("^[0-9]+$"));
								if (contains_non_int3 == true)
								{
									autoBan(peer, false, 24 * 7, "Proxy detect! boxlvl3DepositedItem_ apos was: " + apos);
									break;
								}

								try
								{
									ifstream ifff("storageboxlvl3/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
									json j;
									ifff >> j;
									ifff.close();

									int itemid = 0;
									int count = 0;
									for (int i = 0; i < 90; i++)
									{
										if (j["storage"][i]["aposition"] == atoi(apos.c_str()))
										{
											itemid = j["storage"][i]["itemid"];
											count = j["storage"][i]["itemcount"];
											GTDialog storagelvl1;
											storagelvl1.addLabelWithIcon("`wStorage Box Xtreme - Level 3", 6290, LABEL_BIG);
											storagelvl1.addSmallText("`oYou have `w" + to_string(count) + " " + itemDefs[itemid].name + " `ostored.");
											storagelvl1.addSmallText("`oWithdraw how many?");
											storagelvl1.addInputBox("boxlvl3withdraw_" + coord + "_" + apos, "", to_string(count), 5);
											storagelvl1.addSpacer(SPACER_SMALL);
											storagelvl1.addButton("boxlvl3_withdrawConfirm", "Remove items");
											storagelvl1.addSpacer(SPACER_SMALL);
											storagelvl1.addQuickExit();
											storagelvl1.endDialog("Close", "", "Exit");
											Player::OnDialogRequest(peer, storagelvl1.finishDialog());
											break;
										}
									}
								}
								catch (std::exception&)
								{
									SendConsole("boxlvl3DepositedItem_ Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
									enet_peer_disconnect_now(peer, 0);
								}
								catch (std::runtime_error&)
								{
									SendConsole("boxlvl3DepositedItem_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
									enet_peer_disconnect_now(peer, 0);
								}
								catch (...)
								{
									SendConsole("boxlvl3DepositedItem_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
									enet_peer_disconnect_now(peer, 0);
								}
							}
						}
						if (btn.substr(0, 21) == "boxlvl1DepositedItem_")
						{
							if (world == nullptr || world->name == "EXIT" || serverIsFrozen) continue;
							if (static_cast<PlayerInfo*>(peer->data)->rawName == PlayerDB::getProperName(world->owner) || world->owner == "" || isMod(peer))
							{
								string apos_and_coord = btn.erase(0, 21);
								string::size_type pos = apos_and_coord.find('_');
								string apos = "";
								string coord = "";

								if (pos != std::string::npos)
								{
									apos = apos_and_coord.substr(0, pos);
									apos_and_coord.erase(0, pos + 1);
									coord = apos_and_coord;
								}
								else
								{
									autoBan(peer, false, 24 * 7, "Incorrect parameters boxlvl1DepositedItem_. apos and coord were: " + apos_and_coord);
									break;
								}
								auto isdbox = std::experimental::filesystem::exists("storageboxlvl1/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
								if (!isdbox)
								{
									Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4An error occured while getting box info.", 0, true);
									break;
								}

								bool contains_non_int3 = !std::regex_match(apos, std::regex("^[0-9]+$"));
								if (contains_non_int3 == true)
								{
									autoBan(peer, false, 24 * 7, "Proxy detect! boxlvl1DepositedItem_ apos was: " + apos);
									break;
								}

								try
								{
									ifstream ifff("storageboxlvl1/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
									json j;
									ifff >> j;
									ifff.close();

									int itemid = 0;
									int count = 0;
									for (int i = 0; i < 20; i++)
									{
										if (j["storage"][i]["aposition"] == atoi(apos.c_str()))
										{
											itemid = j["storage"][i]["itemid"];
											count = j["storage"][i]["itemcount"];
											GTDialog storagelvl1;
											storagelvl1.addLabelWithIcon("`wStorage Box Xtreme - Level 1", 6286, LABEL_BIG);
											storagelvl1.addSmallText("`oYou have `w" + to_string(count) + " " + itemDefs[itemid].name + " `ostored.");
											storagelvl1.addSmallText("`oWithdraw how many?");
											storagelvl1.addInputBox("boxlvl1withdraw_" + coord + "_" + apos, "", to_string(count), 5);
											storagelvl1.addSpacer(SPACER_SMALL);
											storagelvl1.addButton("boxlvl1_withdrawConfirm", "Remove items");
											storagelvl1.addSpacer(SPACER_SMALL);
											storagelvl1.addQuickExit();
											storagelvl1.endDialog("Close", "", "Exit");
											Player::OnDialogRequest(peer, storagelvl1.finishDialog());
											break;
										}
									}
								}
								catch (std::exception&)
								{
									SendConsole("boxlvl1DepositedItem_ Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
									enet_peer_disconnect_now(peer, 0);
								}
								catch (std::runtime_error&)
								{
									SendConsole("boxlvl1DepositedItem_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
									enet_peer_disconnect_now(peer, 0);
								}
								catch (...)
								{
									SendConsole("boxlvl1DepositedItem_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
									enet_peer_disconnect_now(peer, 0);
								}
							}
						}
						if (btn.substr(0, 14) == "choosehisitem_")
						{
							string number = btn.substr(btn.find("_") + 1);

							if (number != "1" && number != "2" && number != "3" && number != "4")
							{
								autoBan(peer, false, 24 * 7, "Proxy detect! choosehisitem_ number was: " + number);
								break;
							}

							string name = static_cast<PlayerInfo*>(peer->data)->lastTradeGrowid;
							ENetPeer* currentPeer;
							bool found = false;
							for (currentPeer = server->peers;
								currentPeer < &server->peers[server->peerCount];
								++currentPeer)
							{
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
									continue;
								if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == PlayerDB::getProperName(name))
								{
									string appendItems = "";
									found = true;
									for (int i = 0; i < static_cast<PlayerInfo*>(currentPeer->data)->inventory.items.size(); i++)
									{
										if (i % 6 == 0 && i != 0)
										{
											appendItems += "\nadd_button_with_icon||END_LIST|noflags|0|0|\nadd_button_with_icon|choosehisitemadd_" + number + "_" + to_string(static_cast<PlayerInfo*>(currentPeer->data)->inventory.items.at(i).itemID) + "||staticBlueFrame|" + to_string(static_cast<PlayerInfo*>(currentPeer->data)->inventory.items.at(i).itemID) + "|" + to_string(static_cast<PlayerInfo*>(currentPeer->data)->inventory.items.at(i).itemCount) + "|";
										}
										else
										{
											appendItems += "\nadd_button_with_icon|choosehisitemadd_" + number + "_" + to_string(static_cast<PlayerInfo*>(currentPeer->data)->inventory.items.at(i).itemID) + "||staticBlueFrame|" + to_string(static_cast<PlayerInfo*>(currentPeer->data)->inventory.items.at(i).itemID) + "|" + to_string(static_cast<PlayerInfo*>(currentPeer->data)->inventory.items.at(i).itemCount) + "|";
										}
									}
									Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|small|`2" + name + " inventory``|left|826|" + appendItems + "\nadd_quick_exit|");
								}
							}
							if (!found)
							{
								Player::OnConsoleMessage(peer, "`@Player Not `4Found!");
							}
						}
						if (btn == "goals")
						{
							Player::OnTextOverlay(peer, "`4Nothing is developed here...");
							Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|small|" + static_cast<PlayerInfo*>(peer->data)->displayName + "'s Goals|left|982|\nadd_spacer|small|\nadd_textbox|`9Life Goals``|left|\nadd_smalltext|`9Awesomeness: " + to_string(static_cast<PlayerInfo*>(peer->data)->Awesomeness) + "%``|left|\nadd_label_with_icon|small|`3Seed Goal:`` Deliver 20 Gems (0/20)``|left|3|\\nadd_label_with_icon|small|`3Experience Goal:`` Plant 200 rarity of trees (45/200)``|left|1488|\nadd_smalltext|Completed Life Goals will reset in 20 hours, 22 mins|left|\nadd_spacer|small|\nadd_textbox|`9Daily Quest``|left|\nadd_label_with_icon|small|Deliver `2200 " + getItemDef(DailyItem).name + "`` to Crazy Jim|left|1486|\nadd_spacer|small|\nadd_textbox|`9Biweekly Quest``|left|\nadd_label_with_icon|small|`2Quest progress``|left|5202|\nadd_textbox|- Harvest 4800 rarity from trees (0/4800)|left|\nadd_textbox|- Collect 100 items from Providers (0/100)|left|\nadd_textbox|- Cook 5 meals (0/5)|left|\nadd_spacer|small|\nadd_textbox|`9Role Quests|left|\nadd_button|rolesmenu|View Role Quests|noflags|0|0|\nadd_spacer|small|\nadd_textbox|`9Epic Quests``|left|\nadd_label_with_icon|small|`3Catch a Perfect Stonefish``|left|482|\nadd_label_with_icon|small|`3Sew a Wool Scarf``|left|482|\\nadd_label_with_icon|small|`3Discover the Truth``|left|482|\nadd_label_with_icon|small|`3Plant a Wizard's Staff Tree``|left|482|\nadd_label_with_icon|small|`3Forge an Iron Buckle``|left|482|\nadd_label_with_icon|small|`3Dress up as Locke``|left|482|\nadd_label_with_icon|small|`3Own a Top-10 Rated world``|left|482|\nadd_label_with_icon|small|`3Achieve 100% Awesomeness``|left|482|\nadd_label_with_icon|small|`3Complete a Massive Trauma surgery``|left|482|\nadd_label_with_icon|small|`3Craft a Xenonite Crystal``|left|482|\nadd_label_with_icon|small|`3Hatch a Black Crystal Dragon``|left|482|\nadd_label_with_icon|small|`3Beat a Blanket Cape out of a Supervillain``|left|482|\nadd_label_with_icon|small|`3Find a Topaz Block in a Golden Treasure Hoard``|left|482|\nadd_label_with_icon|small|`3Buy a Riding Bumblebee or Riding Raven in the Gem Shop``|left|482|\nadd_label_with_icon|small|`3Buy a Golden Pickaxe for Growtokens``|left|482|\nadd_label_with_icon|small|`3Buy the Phlogiston for Pet Trainer Medals``|left|482|\nadd_label_with_icon|small|`3Collect all 4 treasures in Valhowla``|left|482|\nadd_label_with_icon|small|`3Get a Ghost Charm from a Spirit Storage explosion``|left|482|\nadd_label_with_icon|small|`3Get a Teddy Bear from an Awkward Friendly Unicorn``|left|482|\nadd_label_with_icon|small|`3Compact a dress into a Mystery Dress``|left|482|\nadd_label_with_icon|small|`3In a world you own, combust a stack of 200 Highly Combustible Boxes you earned``|left|482|\nadd_label_with_icon|small|`3Catch an Octopus Head``|left|482|\nadd_label_with_icon|small|`3Complete the Growtopian Of The Year achievement``|left|482|\nadd_label_with_icon|small|`3Splice a Weather Machine - Comet``|left|482|\nadd_label_with_icon|small|`3Win 200 Carnival Games``|left|482|\nadd_label_with_icon|small|`3Buy a Diamond Dragon from Locke``|left|482|\nadd_label_with_icon|small|`3Win World Of The Day or Video Of The Week``|left|482|\nadd_label_with_icon|small|`3Have all Ringmaster Rings in your inventory``|left|482|\nadd_label_with_icon|small|`3Level up to level 100``|left|482|\nadd_label_with_icon|small|`3Hold 3 different Legendary items in your inventory``|left|482|\nadd_label_with_icon|small|`3Complete all 100 classic achievements``|left|482|\nadd_spacer|small|\nend_dialog|goalslist||Back|\nadd_quick_exit|");
						}
						if (btn == "rankup")
						{
							GTDialog myRankUp;
							myRankUp.addLabelWithIcon("`wRankup", 9228, LABEL_BIG);
							myRankUp.addSpacer(SPACER_SMALL);
							if (isMod(peer))
							{
								myRankUp.addTextBox("`4Warning: `1You have the highest rank in rankup and you are not allowed to rankup higher.");
								myRankUp.addSpacer(SPACER_SMALL);
								myRankUp.addTextBox("`oIf you want to get dev rank, you must purchase it for real gt dls or buy via paypal. You need to contact server's owner.");
							}
							else
							{
								myRankUp.addTextBox("`oFor rankup to `1" + getRankName(static_cast<PlayerInfo*>(peer->data)->adminLevel + 1) + " rank,`o you need to complete these quests: ");
								myRankUp.addButton("rankupnow", "`wRankup Now");
							}

							myRankUp.endDialog("Close", "", "Close");
							Player::OnDialogRequest(peer, myRankUp.finishDialog());
						}
						if (btn == "clearworldyes")
						{
							auto iscontainsss = false;
							SearchInventoryItem(peer, 5524, 1, iscontainsss);
							if (!iscontainsss)
							{
								autoBan(peer, true, 1, "he tried to punch 5524 item, but did not has it.");
								continue;
							}

							if (!isWorldOwner(peer, world))
							{
								Player::OnTextOverlay(peer, "`@You can use Detonator only in your owned worlds!");
								continue;
							}

							if (world->width != 100 && world->height != 60)
							{
								Player::OnTextOverlay(peer, "`@Detonator Cannot Be Used In Mutated Worlds!");
								continue;
							}

							if (static_cast<PlayerInfo*>(peer->data)->level < 30)
							{
								Player::OnTextOverlay(peer, "`@You can use Detonator only in you have level 30 or higher!");
								continue;
							}

							if (!isVip(peer))
							{
								Player::OnTextOverlay(peer, "`@You can use Detonator only in you have vip or higher rank!");
								continue;
							}

							RemoveInventoryItem(5524, 1, peer, true);

							for (auto i = 0; i < world->width * world->height; i++)
							{
								if (world->items[i].foreground == 6 || world->items[i].foreground == 8 || world->items[i].foreground == 242 || world->items[i].foreground == 2408 || world->items[i].foreground == 1796 || world->items[i].foreground == 4428 || world->items[i].foreground == 7188 || world->items[i].foreground == 8470 || world->items[i].foreground == 9290 || world->items[i].foreground == 9308 || world->items[i].foreground == 9504 || world->items[i].foreground == 2950 || world->items[i].foreground == 4802 || world->items[i].foreground == 5260 || world->items[i].foreground == 5814 || world->items[i].foreground == 5980 || world->items[i].foreground == 9640) continue;
								if (world->items[i].foreground != 0 || world->items[i].background != 0)
								{
									world->items[i].foreground = 0;
									world->items[i].background = 0;
									PlayerMoving data3;
									data3.packetType = 0x3;
									data3.characterState = 0x0;
									data3.x = i % world->width;
									data3.y = i / world->height;
									data3.punchX = i % world->width;
									data3.punchY = i / world->width;
									data3.XSpeed = 0;
									data3.YSpeed = 0;
									data3.netID = -1;
									data3.plantingTree = 0;
									for (ENetPeer* currentPeer6 = server->peers; currentPeer6 < &server->peers[server->peerCount]; ++currentPeer6)
									{
										if (currentPeer6->state != ENET_PEER_STATE_CONNECTED) continue;
										if (isHere(peer, currentPeer6))
										{
											auto raw = packPlayerMoving(&data3);
											raw[2] = 0;
											raw[3] = 0;
											SendPacketRaw(4, raw, 56, nullptr, currentPeer6, ENET_PACKET_FLAG_RELIABLE);
										}
									}

								}
							}
						}
						if (btn == "rolesmenu")
						{
							Player::OnDialogRequest(peer, "add_label_with_icon|big|`wRole Quests``|left|982|\nadd_spacer|small|\nadd_textbox|`9What's your specialty? Punch, Build, Grow, and more to earn points and unlock Role Rewards and Powers!``|left|\nadd_spacer|small|\nadd_smalltext|- You have embarked on 0 Role Quests today!|left|\nadd_smalltext|- Your quests will reset in: 20 hours, 22 mins and any progress on the current quest will be lost.|left|\nadd_spacer|small|\nadd_smalltext|- You haven't started any Role Quests today!|left|\nadd_smalltext|- Your first quest for the day is `2FREE`` to start!|left|\nadd_button|questselect|Quest Select|noflags|0|0|\nadd_button|viewrolestats|View Role Stats|noflags|0|0|\nend_dialog|rolequestspage||Back|\nadd_quick_exit|");
						}
						if (btn == "rolequestspage")
						{
							Player::OnDialogRequest(peer, "add_label_with_icon|big|`wRole Quests``|left|982|\nadd_spacer|small|\nadd_textbox|`9Select a Role Quest to advance your speciality!``|left|\nadd_spacer|small|\nadd_smalltext|- You have embarked on 0 Role Quests today!|left|\nadd_smalltext|- Your quests will reset in: 20 hours, 22 mins and any progress on the current quest will be lost.|left|\nadd_smalltext|- You haven't started any Role Quests today!|left|\nadd_smalltext|- Your first quest for the day is `2FREE`` to start!|left|\nadd_spacer|small|\nadd_player_info|Farmer|0|0|1300|\nadd_spacer|small|\nadd_button|startFarmerquest|Start Farmer Quest|noflags|0|0|\nadd_label_with_icon|sml|Today is `2Farming Day``!|left|1486|\nadd_smalltext|- Your first Farming quest will earn `21 Growtoken``. Every Farming quest will also earn 25% extra points.|left|\nadd_smalltext|- Completing this Quest will earn you: 337 `9Farming Points!``|left|\nadd_spacer|small|\nadd_player_info|Builder|0|0|1500|\nadd_spacer|small|\nadd_button|startBuilderquest|Start Builder Quest|noflags|0|0|\nadd_smalltext|- Completing this Quest will earn you: `2230`` `9Building Points!``|left|\nadd_spacer|small|\nadd_player_info|Surgeon|0|0|1300|\nadd_spacer|small|\nadd_button|startSurgeonquest|Start Surgeon Quest|noflags|0|0|\nadd_smalltext|- Completing this Quest will earn you: `2270`` `9Surgery Points!``|left|\nadd_spacer|small|\nadd_player_info|Fishing|0|0|1300|\nadd_spacer|small|\nadd_button|startFishingquest|Start Fishing Quest|noflags|0|0|\nadd_smalltext|- Completing this Quest will earn you: `2270`` `9Fishing Points!``|left|\nadd_spacer|small|\nadd_player_info|Chef|0|0|1500|\nadd_spacer|small|\nadd_button|startChefquest|Start Chef Quest|noflags|0|0|\nadd_smalltext|- Completing this Quest will earn you: `2230`` `9Cooking Points!``|left|\nadd_spacer|small|\nadd_player_info|Star Captain|0|0|1300|\nadd_spacer|small|\nadd_button|startStar Captainquest|Start Star Captain Quest|noflags|0|0|\nadd_smalltext|- Completing this Quest will earn you: `2270`` `9Startopia Points!``|left|\nadd_spacer|small|\nadd_button|back|Back|noflags|0|0|\nend_dialog|rolequestselectpage|||\nadd_quick_exit|");
						}
						if (btn == "viewrolestats")
						{
							Player::OnDialogRequest(peer, "add_label_with_icon|big|`wRole Stats``|left|982|\nadd_spacer|small|\nadd_textbox|`9What prizes and powers have you unlocked in your Roles and what's left to discover? Find out here!``|left|\nadd_spacer|small|\nadd_player_info|Farmer|0|0|1300|\nadd_spacer|small|\nadd_button|viewFarmer|`0View Farmer Rewards``|noflags|0|0|\nadd_spacer|small|\nadd_player_info|Builder|0|0|1500|\nadd_spacer|small|\nadd_button|viewBuilder|`0View Builder Rewards``|noflags|0|0|\nadd_spacer|small|\nadd_player_info|Surgeon|0|0|1300|\nadd_spacer|small|\nadd_button|viewSurgeon|`0View Surgeon Rewards``|noflags|0|0|\nadd_spacer|small|\nadd_player_info|Fishing|0|0|1300|\nadd_spacer|small|\nadd_button|viewFishing|`0View Fishing Rewards``|noflags|0|0|\nadd_spacer|small|\nadd_player_info|Chef|0|0|1500|\nadd_spacer|small|\nadd_button|viewChef|`0View Chef Rewards``|noflags|0|0|\nadd_spacer|small|\nadd_player_info|Star Captain|0|0|1300|\nadd_spacer|small|\nadd_button|viewStar Captain|`0View Star Captain Rewards``|noflags|0|0|\nadd_spacer|small|\nadd_button|back|Back|noflags|0|0|\nend_dialog|rolestatspage|||\nadd_quick_exit|");
						}
						if (btn == "completemerge")
						{
							if (world == nullptr || world->name == "EXIT" || serverIsFrozen) continue;
							int item1 = atoi(static_cast<PlayerInfo*>(peer->data)->MergeItem1.c_str());
							int item2 = atoi(static_cast<PlayerInfo*>(peer->data)->MergeItem2.c_str());
							int item3 = atoi(static_cast<PlayerInfo*>(peer->data)->MergeItem3.c_str());
							if (item1 == 0 || item2 == 0 || item3 == 0)
							{
								static_cast<PlayerInfo*>(peer->data)->MergeItem1 = "0";
								static_cast<PlayerInfo*>(peer->data)->MergeItem2 = "0";
								static_cast<PlayerInfo*>(peer->data)->MergeItem3 = "0";
								SendMergeEnd(peer, "|\nadd_label_with_icon|small|Something went wrong! Please try again...|left|1432|");
								continue;
							}
							bool isContains = false;
							SearchInventoryItem(peer, item1, 1, isContains);
							if (!isContains)
							{
								static_cast<PlayerInfo*>(peer->data)->MergeItem1 = "0";
								static_cast<PlayerInfo*>(peer->data)->MergeItem2 = "0";
								static_cast<PlayerInfo*>(peer->data)->MergeItem3 = "0";
								SendMergeEnd(peer, "|\nadd_label_with_icon|small|Something went wrong! Please try again...|left|1432|");
								continue;
							}
							bool isContains2 = false;
							SearchInventoryItem(peer, item2, 1, isContains2);
							if (!isContains2)
							{
								static_cast<PlayerInfo*>(peer->data)->MergeItem1 = "0";
								static_cast<PlayerInfo*>(peer->data)->MergeItem2 = "0";
								static_cast<PlayerInfo*>(peer->data)->MergeItem3 = "0";
								SendMergeEnd(peer, "|\nadd_label_with_icon|small|Something went wrong! Please try again...|left|1432|");
								continue;
							}
							if (CheckItemMaxed(peer, item3, 1))
							{
								SendMergeEnd(peer, "|\nadd_label_with_icon|small|Whoops, Its seems like " + getItemDef(item3).name + " Wont fit into my backpack!|left|1432|");
								continue;
							}
							RemoveInventoryItem(item1, 1, peer, true);
							RemoveInventoryItem(item2, 1, peer, true);
							SendMergeEnd(peer, "|\nadd_label_with_icon|small|You have merged " + getItemDef(item1).name + " with " + getItemDef(item2).name + " And obtained " + getItemDef(item3).name + "!|left|" + to_string(item3) + "|");
							bool success = true;
							SaveItemMoreTimes(item3, 1, peer, success);
							Player::PlayAudio(peer, "audio/harp.wav", 0);
							ENetPeer* currentPeer;
							for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer)
							{
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
								if (isHere(peer, currentPeer))
								{
									SendTradeEffect(currentPeer, item3, static_cast<PlayerInfo*>(peer->data)->netID, static_cast<PlayerInfo*>(peer->data)->netID, 150);
								}
							}
							static_cast<PlayerInfo*>(peer->data)->MergeItem1 = "0";
							static_cast<PlayerInfo*>(peer->data)->MergeItem2 = "0";
							static_cast<PlayerInfo*>(peer->data)->MergeItem3 = "0";
						}
						if (btn == "sendMergeBook")
						{
							SendMergeDialog(peer, atoi(static_cast<PlayerInfo*>(peer->data)->MergeItem1.c_str()), atoi(static_cast<PlayerInfo*>(peer->data)->MergeItem2.c_str()), 0, "");
						}
						if (btn == "dothetrade")
						{
							if (static_cast<PlayerInfo*>(peer->data)->receivedFrom == "")
							{
								//Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4You don't have any trade offers!``", 0, false);
								continue;
							}

							ENetPeer* currentPeer;
							bool found = false;
							bool doesHave = false;
							for (currentPeer = server->peers;
								currentPeer < &server->peers[server->peerCount];
								++currentPeer)
							{
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
									continue;
								if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == PlayerDB::getProperName(static_cast<PlayerInfo*>(peer->data)->receivedFrom))
								{
									found = true;
									if (static_cast<PlayerInfo*>(currentPeer->data)->lastTradeGrowid != static_cast<PlayerInfo*>(peer->data)->rawName) break;


									//anti dupe

									if (static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem1Count != "0" && static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem1 != "3308")
									{
										if (static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem1 == static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem2 || static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem1 == static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem3 || static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem1 == static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem4)
										{
											Player::OnConsoleMessage(peer, "`4Something went wrong! Trade was aborted.");
											Player::OnConsoleMessage(currentPeer, "`4Something went wrong! Trade was aborted.");
											static_cast<PlayerInfo*>(peer->data)->receivedFrom = "";
											break;
										}
									}
									if (static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem2Count != "0" && static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem2 != "3308")
									{
										if (static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem2 == static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem1 || static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem2 == static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem3 || static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem2 == static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem4)
										{
											Player::OnConsoleMessage(peer, "`4Something went wrong! Trade was aborted.");
											Player::OnConsoleMessage(currentPeer, "`4Something went wrong! Trade was aborted.");
											static_cast<PlayerInfo*>(peer->data)->receivedFrom = "";
											break;
										}
									}
									if (static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem3Count != "0" && static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem3 != "3308")
									{
										if (static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem3 == static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem1 || static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem3 == static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem2 || static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem3 == static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem4)
										{
											Player::OnConsoleMessage(peer, "`4Something went wrong! Trade was aborted.");
											Player::OnConsoleMessage(currentPeer, "`4Something went wrong! Trade was aborted.");
											static_cast<PlayerInfo*>(peer->data)->receivedFrom = "";
											break;
										}
									}
									if (static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem4Count != "0" && static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem4 != "3308")
									{
										if (static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem4 == static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem1 || static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem4 == static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem2 || static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem4 == static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem3)
										{
											Player::OnConsoleMessage(peer, "`4Something went wrong! Trade was aborted.");
											Player::OnConsoleMessage(currentPeer, "`4Something went wrong! Trade was aborted.");
											static_cast<PlayerInfo*>(peer->data)->receivedFrom = "";
											break;
										}
									}

									if (static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem1Count != "0" && static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem1 != "3308")
									{
										if (static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem1 == static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem2 || static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem1 == static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem3 || static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem1 == static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem4)
										{
											Player::OnConsoleMessage(peer, "`4Something went wrong! Trade was aborted.");
											Player::OnConsoleMessage(currentPeer, "`4Something went wrong! Trade was aborted.");
											static_cast<PlayerInfo*>(peer->data)->receivedFrom = "";
											break;
										}
									}
									if (static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem2Count != "0" && static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem2 != "3308")
									{
										if (static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem2 == static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem1 || static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem2 == static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem3 || static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem2 == static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem4)
										{
											Player::OnConsoleMessage(peer, "`4Something went wrong! Trade was aborted.");
											Player::OnConsoleMessage(currentPeer, "`4Something went wrong! Trade was aborted.");
											static_cast<PlayerInfo*>(peer->data)->receivedFrom = "";
											break;
										}
									}
									if (static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem3Count != "0" && static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem3 != "3308")
									{
										if (static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem3 == static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem1 || static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem3 == static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem2 || static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem3 == static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem4)
										{
											Player::OnConsoleMessage(peer, "`4Something went wrong! Trade was aborted.");
											Player::OnConsoleMessage(currentPeer, "`4Something went wrong! Trade was aborted.");
											static_cast<PlayerInfo*>(peer->data)->receivedFrom = "";
											break;
										}
									}
									if (static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem4Count != "0" && static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem4 != "3308")
									{
										if (static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem4 == static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem1 || static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem4 == static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem2 || static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem4 == static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem3)
										{
											Player::OnConsoleMessage(peer, "`4Something went wrong! Trade was aborted.");
											Player::OnConsoleMessage(currentPeer, "`4Something went wrong! Trade was aborted.");
											static_cast<PlayerInfo*>(peer->data)->receivedFrom = "";
											break;
										}
									}

									//check items

									if (static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem1Count != "0" && static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem1 != "3308")
									{
										SearchInventoryItem(peer, stoi(static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem1), stoi(static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem1Count), doesHave);
										if (doesHave == false)
										{
											Player::OnConsoleMessage(peer, "`4You dont have `o" + static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem1Count + " " + getItemDef(atoi(static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem1.c_str())).name + "`4. Trade was aborted!");
											Player::OnConsoleMessage(currentPeer, "`o" + static_cast<PlayerInfo*>(peer->data)->rawName + " `4does not have `o" + static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem1Count + " " + getItemDef(atoi(static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem1.c_str())).name + "`4. Trade was aborted!");
											static_cast<PlayerInfo*>(peer->data)->receivedFrom = "";
											break;
										}
										if (CheckItemExists(currentPeer, stoi(static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem1)))
										{
											int currentlyHave = GetQuantityOfItem(currentPeer, stoi(static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem1));
											if (stoi(static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem1Count) + currentlyHave < 201)
											{

											}
											else
											{
												Player::OnConsoleMessage(peer, "`o" + static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem1Count + " " + getItemDef(atoi(static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem1.c_str())).name + " `4won't fit in `o" + static_cast<PlayerInfo*>(currentPeer->data)->rawName + "'s `4inventory. Trade was aborted!");
												Player::OnConsoleMessage(currentPeer, "`o" + static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem1Count + " " + getItemDef(atoi(static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem1.c_str())).name + " `4won't fit in your inventory. Trade was aborted!");
												static_cast<PlayerInfo*>(peer->data)->receivedFrom = "";
												break;
											}
										}
									}
									if (static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem2Count != "0" && static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem2 != "3308")
									{
										SearchInventoryItem(peer, stoi(static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem2), stoi(static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem2Count), doesHave);
										if (doesHave == false)
										{
											Player::OnConsoleMessage(peer, "`4You dont have `o" + static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem2Count + " " + getItemDef(atoi(static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem2.c_str())).name + "`4. Trade was aborted!");
											Player::OnConsoleMessage(currentPeer, "`o" + static_cast<PlayerInfo*>(peer->data)->rawName + " `4does not have `o" + static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem2Count + " " + getItemDef(atoi(static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem2.c_str())).name + "`4. Trade was aborted!");
											static_cast<PlayerInfo*>(peer->data)->receivedFrom = "";
											break;
										}
										if (CheckItemExists(currentPeer, stoi(static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem2)))
										{
											int currentlyHave = GetQuantityOfItem(currentPeer, stoi(static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem2));
											if (stoi(static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem2Count) + currentlyHave < 201)
											{

											}
											else
											{
												Player::OnConsoleMessage(peer, "`o" + static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem2Count + " " + getItemDef(atoi(static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem2.c_str())).name + " `4won't fit in `o" + static_cast<PlayerInfo*>(currentPeer->data)->rawName + "'s `4inventory. Trade was aborted!");
												Player::OnConsoleMessage(currentPeer, "`o" + static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem2Count + " " + getItemDef(atoi(static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem2.c_str())).name + " `4won't fit in your inventory. Trade was aborted!");
												static_cast<PlayerInfo*>(peer->data)->receivedFrom = "";
												break;
											}
										}
									}
									if (static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem3Count != "0" && static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem3 != "3308")
									{
										SearchInventoryItem(peer, stoi(static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem3), stoi(static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem3Count), doesHave);
										if (doesHave == false)
										{
											Player::OnConsoleMessage(peer, "`4You dont have `o" + static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem3Count + " " + getItemDef(atoi(static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem3.c_str())).name + "`4. Trade was aborted!");
											Player::OnConsoleMessage(currentPeer, "`o" + static_cast<PlayerInfo*>(peer->data)->rawName + " `4does not have `o" + static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem3Count + " " + getItemDef(atoi(static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem3.c_str())).name + "`4. Trade was aborted!");
											static_cast<PlayerInfo*>(peer->data)->receivedFrom = "";
											break;
										}
										if (CheckItemExists(currentPeer, stoi(static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem3)))
										{
											int currentlyHave = GetQuantityOfItem(currentPeer, stoi(static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem3));
											if (stoi(static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem3Count) + currentlyHave < 201)
											{

											}
											else
											{
												Player::OnConsoleMessage(peer, "`o" + static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem3Count + " " + getItemDef(atoi(static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem3.c_str())).name + " `4won't fit in `o" + static_cast<PlayerInfo*>(currentPeer->data)->rawName + "'s `4inventory. Trade was aborted!");
												Player::OnConsoleMessage(currentPeer, "`o" + static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem3Count + " " + getItemDef(atoi(static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem3.c_str())).name + " `4won't fit in your inventory. Trade was aborted!");
												static_cast<PlayerInfo*>(peer->data)->receivedFrom = "";
												break;
											}
										}
									}
									if (static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem4Count != "0" && static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem4 != "3308")
									{
										SearchInventoryItem(peer, stoi(static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem4), stoi(static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem4Count), doesHave);
										if (doesHave == false)
										{
											Player::OnConsoleMessage(peer, "`4You dont have `o" + static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem4Count + " " + getItemDef(atoi(static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem4.c_str())).name + "`4. Trade was aborted!");
											Player::OnConsoleMessage(currentPeer, "`o" + static_cast<PlayerInfo*>(peer->data)->rawName + " `4does not have `o" + static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem4Count + " " + getItemDef(atoi(static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem4.c_str())).name + "`4. Trade was aborted!");
											static_cast<PlayerInfo*>(peer->data)->receivedFrom = "";
											break;
										}
										if (CheckItemExists(currentPeer, stoi(static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem4)))
										{
											int currentlyHave = GetQuantityOfItem(currentPeer, stoi(static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem4));
											if (stoi(static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem4Count) + currentlyHave < 201)
											{

											}
											else
											{
												Player::OnConsoleMessage(peer, "`o" + static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem4Count + " " + getItemDef(atoi(static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem4.c_str())).name + " `4won't fit in `o" + static_cast<PlayerInfo*>(currentPeer->data)->rawName + "'s `4inventory. Trade was aborted!");
												Player::OnConsoleMessage(currentPeer, "`o" + static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem4Count + " " + getItemDef(atoi(static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem4.c_str())).name + " `4won't fit in your inventory. Trade was aborted!");
												static_cast<PlayerInfo*>(peer->data)->receivedFrom = "";
												break;
											}
										}
									}

									if (static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem1Count != "0" && static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem1 != "3308")
									{
										SearchInventoryItem(currentPeer, stoi(static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem1), stoi(static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem1Count), doesHave);
										if (doesHave == false)
										{
											Player::OnConsoleMessage(currentPeer, "`4You dont have `o" + static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem1Count + " " + getItemDef(atoi(static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem1.c_str())).name + "`4. Trade was aborted!");
											Player::OnConsoleMessage(peer, "`o" + static_cast<PlayerInfo*>(currentPeer->data)->rawName + " `4does not have `o" + static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem1Count + " " + getItemDef(atoi(static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem1.c_str())).name + "`4. Trade was aborted!");
											static_cast<PlayerInfo*>(peer->data)->receivedFrom = "";
											break;
										}
										if (CheckItemExists(peer, stoi(static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem1)))
										{
											int currentlyHave = GetQuantityOfItem(peer, stoi(static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem1));
											if (stoi(static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem1Count) + currentlyHave < 201)
											{

											}
											else
											{
												Player::OnConsoleMessage(currentPeer, "`o" + static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem1Count + " " + getItemDef(atoi(static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem1.c_str())).name + " `4won't fit in `o" + static_cast<PlayerInfo*>(peer->data)->rawName + "'s `4inventory. Trade was aborted!");
												Player::OnConsoleMessage(peer, "`o" + static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem1Count + " " + getItemDef(atoi(static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem1.c_str())).name + " `4won't fit in your inventory. Trade was aborted!");
												static_cast<PlayerInfo*>(peer->data)->receivedFrom = "";
												break;
											}
										}
									}
									if (static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem2Count != "0" && static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem2 != "3308")
									{
										SearchInventoryItem(currentPeer, stoi(static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem2), stoi(static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem2Count), doesHave);
										if (doesHave == false)
										{
											Player::OnConsoleMessage(currentPeer, "`4You dont have `o" + static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem2Count + " " + getItemDef(atoi(static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem2.c_str())).name + "`4. Trade was aborted!");
											Player::OnConsoleMessage(peer, "`o" + static_cast<PlayerInfo*>(currentPeer->data)->rawName + " `4does not have `o" + static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem2Count + " " + getItemDef(atoi(static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem2.c_str())).name + "`4. Trade was aborted!");
											static_cast<PlayerInfo*>(peer->data)->receivedFrom = "";
											break;
										}
										if (CheckItemExists(peer, stoi(static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem2)))
										{
											int currentlyHave = GetQuantityOfItem(peer, stoi(static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem2));
											if (stoi(static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem2Count) + currentlyHave < 201)
											{

											}
											else
											{
												Player::OnConsoleMessage(currentPeer, "`o" + static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem2Count + " " + getItemDef(atoi(static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem2.c_str())).name + " `4won't fit in `o" + static_cast<PlayerInfo*>(peer->data)->rawName + "'s `4inventory. Trade was aborted!");
												Player::OnConsoleMessage(peer, "`o" + static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem2Count + " " + getItemDef(atoi(static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem2.c_str())).name + " `4won't fit in your inventory. Trade was aborted!");
												static_cast<PlayerInfo*>(peer->data)->receivedFrom = "";
												break;
											}
										}
									}
									if (static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem3Count != "0" && static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem3 != "3308")
									{
										SearchInventoryItem(currentPeer, stoi(static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem3), stoi(static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem3Count), doesHave);
										if (doesHave == false)
										{
											Player::OnConsoleMessage(currentPeer, "`4You dont have `o" + static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem3Count + " " + getItemDef(atoi(static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem3.c_str())).name + "`4. Trade was aborted!");
											Player::OnConsoleMessage(peer, "`o" + static_cast<PlayerInfo*>(currentPeer->data)->rawName + " `4does not have `o" + static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem3Count + " " + getItemDef(atoi(static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem3.c_str())).name + "`4. Trade was aborted!");
											static_cast<PlayerInfo*>(peer->data)->receivedFrom = "";
											break;
										}
										if (CheckItemExists(peer, stoi(static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem3)))
										{
											int currentlyHave = GetQuantityOfItem(peer, stoi(static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem3));
											if (stoi(static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem3Count) + currentlyHave < 201)
											{

											}
											else
											{
												Player::OnConsoleMessage(currentPeer, "`o" + static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem3Count + " " + getItemDef(atoi(static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem3.c_str())).name + " `4won't fit in `o" + static_cast<PlayerInfo*>(peer->data)->rawName + "'s `4inventory. Trade was aborted!");
												Player::OnConsoleMessage(peer, "`o" + static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem3Count + " " + getItemDef(atoi(static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem3.c_str())).name + " `4won't fit in your inventory. Trade was aborted!");
												static_cast<PlayerInfo*>(peer->data)->receivedFrom = "";
												break;
											}
										}
									}
									if (static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem4Count != "0" && static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem4 != "3308")
									{
										SearchInventoryItem(currentPeer, stoi(static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem4), stoi(static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem4Count), doesHave);
										if (doesHave == false)
										{
											Player::OnConsoleMessage(currentPeer, "`4You dont have `o" + static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem4Count + " " + getItemDef(atoi(static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem4.c_str())).name + "`4. Trade was aborted!");
											Player::OnConsoleMessage(peer, "`o" + static_cast<PlayerInfo*>(currentPeer->data)->rawName + " `4does not have `o" + static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem4Count + " " + getItemDef(atoi(static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem4.c_str())).name + "`4. Trade was aborted!");
											static_cast<PlayerInfo*>(peer->data)->receivedFrom = "";
											break;
										}
										if (CheckItemExists(peer, stoi(static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem4)))
										{
											int currentlyHave = GetQuantityOfItem(peer, stoi(static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem4));
											if (stoi(static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem4Count) + currentlyHave < 201)
											{

											}
											else
											{
												Player::OnConsoleMessage(currentPeer, "`o" + static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem4Count + " " + getItemDef(atoi(static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem4.c_str())).name + " `4won't fit in `o" + static_cast<PlayerInfo*>(peer->data)->rawName + "'s `4inventory. Trade was aborted!");
												Player::OnConsoleMessage(peer, "`o" + static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem4Count + " " + getItemDef(atoi(static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem4.c_str())).name + " `4won't fit in your inventory. Trade was aborted!");
												static_cast<PlayerInfo*>(peer->data)->receivedFrom = "";
												break;
											}
										}
									}

									//remove items

									if (static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem1Count != "0" && static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem1 != "3308")
									{
										updateplayerset(peer, atoi(static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem1.c_str()));
										RemoveInventoryItem(stoi(static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem1), stoi(static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem1Count), peer, true);
									}
									if (static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem2Count != "0" && static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem2 != "3308")
									{
										updateplayerset(peer, atoi(static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem2.c_str()));
										RemoveInventoryItem(stoi(static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem2), stoi(static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem2Count), peer, true);
									}
									if (static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem3Count != "0" && static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem3 != "3308")
									{
										updateplayerset(peer, atoi(static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem3.c_str()));
										RemoveInventoryItem(stoi(static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem3), stoi(static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem3Count), peer, true);
									}
									if (static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem4Count != "0" && static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem4 != "3308")
									{
										updateplayerset(peer, atoi(static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem4.c_str()));
										RemoveInventoryItem(stoi(static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem4), stoi(static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem4Count), peer, true);
									}

									if (static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem1Count != "0" && static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem1 != "3308")
									{
										updateplayerset(currentPeer, atoi(static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem1.c_str()));
										RemoveInventoryItem(stoi(static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem1), stoi(static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem1Count), currentPeer, true);
									}
									if (static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem2Count != "0" && static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem2 != "3308")
									{
										updateplayerset(currentPeer, atoi(static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem2.c_str()));
										RemoveInventoryItem(stoi(static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem2), stoi(static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem2Count), currentPeer, true);
									}
									if (static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem3Count != "0" && static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem3 != "3308")
									{
										updateplayerset(currentPeer, atoi(static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem3.c_str()));
										RemoveInventoryItem(stoi(static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem3), stoi(static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem3Count), currentPeer, true);
									}
									if (static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem4Count != "0" && static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem4 != "3308")
									{
										updateplayerset(currentPeer, atoi(static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem4.c_str()));
										RemoveInventoryItem(stoi(static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem4), stoi(static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem4Count), currentPeer, true);
									}

									//give items
									bool success = false;

									if (static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem1Count != "0" && static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem1 != "3308")
									{
										SaveItemMoreTimes(stoi(static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem1), stoi(static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem1Count), currentPeer, success);
									}
									if (static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem2Count != "0" && static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem2 != "3308")
									{
										SaveItemMoreTimes(stoi(static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem2), stoi(static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem2Count), currentPeer, success);
									}
									if (static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem3Count != "0" && static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem3 != "3308")
									{
										SaveItemMoreTimes(stoi(static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem3), stoi(static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem3Count), currentPeer, success);
									}
									if (static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem4Count != "0" && static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem4 != "3308")
									{
										SaveItemMoreTimes(stoi(static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem4), stoi(static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem4Count), currentPeer, success);
									}

									if (static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem1Count != "0" && static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem1 != "3308")
									{
										SaveItemMoreTimes(stoi(static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem1), stoi(static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem1Count), peer, success);
									}
									if (static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem2Count != "0" && static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem2 != "3308")
									{
										SaveItemMoreTimes(stoi(static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem2), stoi(static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem2Count), peer, success);
									}
									if (static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem3Count != "0" && static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem3 != "3308")
									{
										SaveItemMoreTimes(stoi(static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem3), stoi(static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem3Count), peer, success);
									}
									if (static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem4Count != "0" && static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem4 != "3308")
									{
										SaveItemMoreTimes(stoi(static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem4), stoi(static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem4Count), peer, success);
									}
									static_cast<PlayerInfo*>(peer->data)->receivedFrom = "";
									ENetPeer* currentPeer2;
									for (currentPeer2 = server->peers;
										currentPeer2 < &server->peers[server->peerCount];
										++currentPeer2)
									{
										if (currentPeer2->state != ENET_PEER_STATE_CONNECTED) continue;
										if (isHere(peer, currentPeer2))
										{
											if (static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem1Count != "0" && static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem1 != "3308")
											{
												Player::OnConsoleMessage(currentPeer2, "`w" + static_cast<PlayerInfo*>(peer->data)->displayName + " `1traded " + static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem1Count + " " + getItemDef(atoi(static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem1.c_str())).name + " `1to " + static_cast<PlayerInfo*>(currentPeer->data)->displayName + "");
											}
											if (static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem2Count != "0" && static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem2 != "3308")
											{
												Player::OnConsoleMessage(currentPeer2, "`w" + static_cast<PlayerInfo*>(peer->data)->displayName + " `1traded " + static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem2Count + " " + getItemDef(atoi(static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem2.c_str())).name + " `1to " + static_cast<PlayerInfo*>(currentPeer->data)->displayName + "");
											}
											if (static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem3Count != "0" && static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem3 != "3308")
											{
												Player::OnConsoleMessage(currentPeer2, "`w" + static_cast<PlayerInfo*>(peer->data)->displayName + " `1traded " + static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem3Count + " " + getItemDef(atoi(static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem3.c_str())).name + " `1to " + static_cast<PlayerInfo*>(currentPeer->data)->displayName + "");
											}
											if (static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem4Count != "0" && static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem4 != "3308")
											{
												Player::OnConsoleMessage(currentPeer2, "`w" + static_cast<PlayerInfo*>(peer->data)->displayName + " `1traded " + static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem4Count + " " + getItemDef(atoi(static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem4.c_str())).name + " `1to " + static_cast<PlayerInfo*>(currentPeer->data)->displayName + "");
											}

											if (static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem1Count != "0" && static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem1 != "3308")
											{
												Player::OnConsoleMessage(currentPeer2, "`w" + static_cast<PlayerInfo*>(currentPeer->data)->displayName + " `1traded " + static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem1Count + " " + getItemDef(atoi(static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem1.c_str())).name + " `1to " + static_cast<PlayerInfo*>(peer->data)->displayName + "");
											}
											if (static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem2Count != "0" && static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem2 != "3308")
											{
												Player::OnConsoleMessage(currentPeer2, "`w" + static_cast<PlayerInfo*>(currentPeer->data)->displayName + " `1traded " + static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem2Count + " " + getItemDef(atoi(static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem2.c_str())).name + " `1to " + static_cast<PlayerInfo*>(peer->data)->displayName + "");
											}
											if (static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem3Count != "0" && static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem3 != "3308")
											{
												Player::OnConsoleMessage(currentPeer2, "`w" + static_cast<PlayerInfo*>(currentPeer->data)->displayName + " `1traded " + static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem3Count + " " + getItemDef(atoi(static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem3.c_str())).name + " `1to " + static_cast<PlayerInfo*>(peer->data)->displayName + "");
											}
											if (static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem4Count != "0" && static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem4 != "3308")
											{
												Player::OnConsoleMessage(currentPeer2, "`w" + static_cast<PlayerInfo*>(currentPeer->data)->displayName + " `1traded " + static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem4Count + " " + getItemDef(atoi(static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem4.c_str())).name + " `1to " + static_cast<PlayerInfo*>(peer->data)->displayName + "");
											}
										}
									}

									break;
								}
							}
							if (!found)
							{
								static_cast<PlayerInfo*>(peer->data)->receivedFrom = "";
								Player::OnConsoleMessage(peer, "`@Player is not `4Online! `@Trade was `4aborted`@!");
								break;
							}
						}
						if (btn == "sendtrade")
						{
							if (static_cast<PlayerInfo*>(peer->data)->mySellingItem1Count == "0" && static_cast<PlayerInfo*>(peer->data)->mySellingItem2Count == "0" && static_cast<PlayerInfo*>(peer->data)->mySellingItem3Count == "0" && static_cast<PlayerInfo*>(peer->data)->mySellingItem4Count == "0")
							{
								Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4Please select items for trade first!", 0, true);
								break;
							}
							if (static_cast<PlayerInfo*>(peer->data)->hisSellingItem1Count == "0" && static_cast<PlayerInfo*>(peer->data)->hisSellingItem2Count == "0" && static_cast<PlayerInfo*>(peer->data)->hisSellingItem3Count == "0" && static_cast<PlayerInfo*>(peer->data)->hisSellingItem4Count == "0")
							{
								Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4Please select items for trade first!", 0, true);
								break;
							}

							if (static_cast<PlayerInfo*>(peer->data)->lastTradeGrowid == "")
							{
								autoBan(peer, false, 24 * 7, "Proxy detect! In btn sendtrade, tradeGrowid was empty");
								break;
							}

							string name = static_cast<PlayerInfo*>(peer->data)->lastTradeGrowid;
							ENetPeer* currentPeer;
							bool found = false;
							for (currentPeer = server->peers;
								currentPeer < &server->peers[server->peerCount];
								++currentPeer)
							{
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
									continue;
								if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == PlayerDB::getProperName(name))
								{
									found = true;
									static_cast<PlayerInfo*>(currentPeer->data)->receivedFrom = static_cast<PlayerInfo*>(peer->data)->displayName;
									Player::OnConsoleMessage(peer, "`@You have successfully sent a trade offer. Wait for him to accept or reject it.");
									Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`@You have successfully sent a trade offer. Wait for him to accept or reject it.", 0, true);
									Player::OnConsoleMessage(currentPeer, "`@You have received a new trade offer from `$" + static_cast<PlayerInfo*>(peer->data)->displayName + " `@. Type /tradeinfo to check this offer.");
									Player::OnTalkBubble(currentPeer, static_cast<PlayerInfo*>(peer->data)->netID, "`@You have received a new trade offer from `$" + static_cast<PlayerInfo*>(peer->data)->displayName + " `@. Type /tradeinfo to check this offer.", 0, true);
								}
							}
							if (!found)
							{
								Player::OnConsoleMessage(peer, "`@Player Not `4Found!");
								break;
							}
						}

						if (btn == "closetrade")
						{
							static_cast<PlayerInfo*>(peer->data)->mySellingItem1 = "3308";
							static_cast<PlayerInfo*>(peer->data)->mySellingItem2 = "3308";
							static_cast<PlayerInfo*>(peer->data)->mySellingItem3 = "3308";
							static_cast<PlayerInfo*>(peer->data)->mySellingItem4 = "3308";
							static_cast<PlayerInfo*>(peer->data)->mySellingItem1Count = "0";
							static_cast<PlayerInfo*>(peer->data)->mySellingItem2Count = "0";
							static_cast<PlayerInfo*>(peer->data)->mySellingItem3Count = "0";
							static_cast<PlayerInfo*>(peer->data)->mySellingItem4Count = "0";
							static_cast<PlayerInfo*>(peer->data)->hisSellingItem1 = "3308";
							static_cast<PlayerInfo*>(peer->data)->hisSellingItem2 = "3308";
							static_cast<PlayerInfo*>(peer->data)->hisSellingItem3 = "3308";
							static_cast<PlayerInfo*>(peer->data)->hisSellingItem4 = "3308";
							static_cast<PlayerInfo*>(peer->data)->hisSellingItem1Count = "0";
							static_cast<PlayerInfo*>(peer->data)->hisSellingItem2Count = "0";
							static_cast<PlayerInfo*>(peer->data)->hisSellingItem3Count = "0";
							static_cast<PlayerInfo*>(peer->data)->hisSellingItem4Count = "0";
							Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`2You have canceled the trade!", 0, true);
						}
						if (btn == "trademypickerback")
						{
							TradeMainMenu(peer);
						}
						if (btn == "pullstock")
						{
							if (world->owner != "" && !isWorldOwner(peer, world)) continue;
							int xxx = static_cast<PlayerInfo*>(peer->data)->lastPunchX;
							int yyy = static_cast<PlayerInfo*>(peer->data)->lastPunchY;
							if (xxx < 0 && yyy < 0) continue;
							int squaresign = xxx + (yyy * 100);
							string currentworld = static_cast<PlayerInfo*>(peer->data)->currentWorld + "X" + std::to_string(squaresign);
							string itemid = "";
							ifstream fdss3("vend/id/" + currentworld + ".txt");
							fdss3 >> itemid;
							fdss3.close();
							string itemcount = "";
							ifstream fdsss("vend/count/" + currentworld + ".txt");
							fdsss >> itemcount;
							fdsss.close();
							string withdraw = "";
							ifstream fdssss("vend/withdraw/" + currentworld + ".txt");
							fdssss >> withdraw;
							fdssss.close();
							int withdrawcpy = atoi(withdraw.c_str());
							if (withdrawcpy != 0)
							{
								Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wWithdraw the world locks first!", 0, true);
								continue;
							}
							int realid = atoi(itemid.c_str());
							int countid = atoi(itemcount.c_str());
							if (CheckItemMaxed(peer, realid, countid))
							{
								Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wYou can't carry any of those!", 0, true);
								Player::OnConsoleMessage(peer, "`oYou can't carry any of those!");
								continue;
							}
							if (countid > 200)
							{
								string pricekiek = "";
								ifstream fdssasd("vend/price/" + currentworld + ".txt");
								fdssasd >> pricekiek;
								fdssasd.close();
								bool success = true;
								SaveItemMoreTimes(realid, 200, peer, success);
								int atgal = atoi(itemcount.c_str());
								atgal -= 200;
								ofstream fdss6("vend/count/" + currentworld + ".txt");
								fdss6 << to_string(atgal);
								fdss6.close();
								Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wYou picked up 200 " + getItemDef(realid).name + "`w, leaving " + to_string(atgal) + " in the machine.", 0, true);
								Player::OnConsoleMessage(peer, "`oYou picked up 200 " + getItemDef(realid).name + "`o, leaving " + to_string(atgal) + " in the machine.");
								ENetPeer* currentPeer;
								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
									if (isHere(peer, currentPeer))
									{
										UpdateVend(currentPeer, xxx, yyy, atoi(itemid.c_str()), false, atoi(pricekiek.c_str()), world->items[xxx + (yyy * world->width)].background);
									}
								}
							}
							else
							{
								ofstream fdss("vend/price/" + currentworld + ".txt");
								fdss << 0;
								fdss.close();
								bool success = true;
								SaveItemMoreTimes(realid, countid, peer, success);
								ofstream fdss333("vend/id/" + currentworld + ".txt");
								fdss333 << 0;
								fdss333.close();
								ofstream fdss6("vend/count/" + currentworld + ".txt");
								fdss6 << 0;
								fdss6.close();
								Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wYou picked up " + to_string(countid) + " " + getItemDef(realid).name + "`w.", 0, true);
								Player::OnConsoleMessage(peer, "`oYou picked up " + to_string(countid) + " " + getItemDef(realid).name + "`o.");
								ENetPeer* currentPeer;
								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
									if (isHere(peer, currentPeer))
									{
										UpdateVend(currentPeer, xxx, yyy, 0, false, 0, world->items[xxx + (yyy * world->width)].background);
									}
								}
							}
						}
						if (btn == "withdraw")
						{
							if (world->owner != "" && !isWorldOwner(peer, world)) continue;
							int xxx = static_cast<PlayerInfo*>(peer->data)->lastPunchX;
							int yyy = static_cast<PlayerInfo*>(peer->data)->lastPunchY;
							if (xxx < 0 && yyy < 0) continue;
							int squaresign = xxx + (yyy * 100);
							string currentworld = static_cast<PlayerInfo*>(peer->data)->currentWorld + "X" + std::to_string(squaresign);
							string withdraw = "";
							ifstream fdssss("vend/withdraw/" + currentworld + ".txt");
							fdssss >> withdraw;
							fdssss.close();
							string itemid = "";
							ifstream fdss3("vend/id/" + currentworld + ".txt");
							fdss3 >> itemid;
							fdss3.close();
							string price = "";
							ifstream fdsss("vend/price/" + currentworld + ".txt");
							fdsss >> price;
							fdsss.close();
							string count = "";
							ifstream fdsss2("vend/count/" + currentworld + ".txt");
							fdsss2 >> count;
							fdsss2.close();
							int withdrawcpy = atoi(withdraw.c_str());
							if (withdrawcpy != 0)
							{
								if (withdrawcpy <= 200)
								{
									if (CheckItemMaxed(peer, 242, withdrawcpy))
									{
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wI dont have free space to collect " + to_string(withdrawcpy) + " World Locks!", 0, true);
										continue;
									}
									ofstream fdssss("vend/withdraw/" + currentworld + ".txt");
									fdssss << "";
									fdssss.close();
									int realid = atoi(itemid.c_str());
									int priceid = atoi(price.c_str());
									bool success = true;
									SaveItemMoreTimes(242, withdrawcpy, peer, success);
									Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wYou collected " + to_string(withdrawcpy) + " World Locks.", 0, true);
									if (count == "0")
									{
										priceid = 0;
										realid = 0;
									}
									ENetPeer* currentPeer;
									for (currentPeer = server->peers;
										currentPeer < &server->peers[server->peerCount];
										++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
										if (isHere(peer, currentPeer))
										{
											UpdateVend(currentPeer, xxx, yyy, realid, false, priceid, world->items[xxx + (yyy * world->width)].background);
										}
									}
								}
								else if (withdrawcpy > 200)
								{
									if (CheckItemMaxed(peer, 242, withdrawcpy))
									{
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wI dont have free space to collect 200 World Locks!", 0, true);
										continue;
									}

									int grazinti = withdrawcpy - 200;
									ofstream fdssss("vend/withdraw/" + currentworld + ".txt");
									fdssss << grazinti;
									fdssss.close();
									int realid = atoi(itemid.c_str());
									int priceid = atoi(price.c_str());
									bool success = true;
									SaveItemMoreTimes(242, 200, peer, success);
									Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wYou collected 200 World Locks, leaving " + to_string(grazinti) + " in the machine!", 0, true);
									if (count == "0")
									{
										priceid = 0;
										realid = 0;
									}
									ENetPeer* currentPeer;
									for (currentPeer = server->peers;
										currentPeer < &server->peers[server->peerCount];
										++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
										if (isHere(peer, currentPeer))
										{
											UpdateVend(currentPeer, xxx, yyy, realid, true, priceid, world->items[xxx + (yyy * world->width)].background);
										}
									}
								}
								else
								{
									Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wHuh?", 0, true);
								}
							}
						}
						if (btn == "addvend")
						{
							if (world->owner != "" && !isWorldOwner(peer, world)) continue;
							int xxx = static_cast<PlayerInfo*>(peer->data)->lastPunchX;
							int yyy = static_cast<PlayerInfo*>(peer->data)->lastPunchY;
							if (xxx < 0 && yyy < 0) continue;
							int squaresign = xxx + (yyy * 100);
							string currentworld = static_cast<PlayerInfo*>(peer->data)->currentWorld + "X" + std::to_string(squaresign);
							string itemid = "";
							ifstream fdss3("vend/id/" + currentworld + ".txt");
							fdss3 >> itemid;
							fdss3.close();
							string count = "";
							ifstream fdsss2("vend/count/" + currentworld + ".txt");
							fdsss2 >> count;
							fdsss2.close();
							int iditem = atoi(itemid.c_str());
							int countitem = atoi(count.c_str());
							auto mtitems = 0;
							for (auto i = 0; i < static_cast<PlayerInfo*>(peer->data)->inventory.items.size(); i++)
							{
								if (static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemID == iditem)
								{
									mtitems = static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount;
									break;
								}
							}
							auto iscontainseas = false;
							SearchInventoryItem(peer, iditem, mtitems, iscontainseas);
							if (!iscontainseas)
							{
								Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "Huh?", 0, true);
								continue;
							}
							else
							{
								RemoveInventoryItem(iditem, mtitems, peer, true);
								updateplayerset(peer, iditem);
								countitem += mtitems;
								ofstream save("vend/count/" + currentworld + ".txt");
								save << countitem;
								save.close();
								Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wAdded " + to_string(mtitems) + " to the machine.", 0, true);
							}
						}
						if (btn == "banslogs")
						{
							if (!isMod(peer)) continue;
							GTDialog allLog;
							string line;

							ifstream banlog("logs/pban.txt");
							allLog.addLabelWithIcon("`wTemp ban logs", 1434, LABEL_SMALL);
							allLog.addSpacer(SPACER_SMALL);
							while (getline(banlog, line))
							{
								allLog.addSmallText(line);
							}
							banlog.close();

							allLog.addSpacer(SPACER_SMALL);
							ifstream baniplog("logs/banip.txt");
							allLog.addLabelWithIcon("`wBan IP logs", 1434, LABEL_SMALL);
							allLog.addSpacer(SPACER_SMALL);
							while (getline(baniplog, line))
							{
								allLog.addSmallText(line);
							}
							baniplog.close();

							allLog.addSpacer(SPACER_SMALL);
							ifstream suspendlog("logs/suspend.txt");
							allLog.addLabelWithIcon("`wSuspend logs", 1434, LABEL_SMALL);
							allLog.addSpacer(SPACER_SMALL);
							while (getline(suspendlog, line))
							{
								allLog.addSmallText(line);
							}
							suspendlog.close();

							allLog.addSpacer(SPACER_SMALL);
							ifstream unbanlog("logs/unban.txt");
							allLog.addLabelWithIcon("`wUnban logs", 1434, LABEL_SMALL);
							allLog.addSpacer(SPACER_SMALL);
							while (getline(unbanlog, line))
							{
								allLog.addSmallText(line);
							}
							unbanlog.close();

							allLog.addSpacer(SPACER_SMALL);
							ifstream unsuspendlog("logs/unsuspend.txt");
							allLog.addLabelWithIcon("`wUnSuspend logs", 1434, LABEL_SMALL);
							allLog.addSpacer(SPACER_SMALL);
							while (getline(unsuspendlog, line))
							{
								allLog.addSmallText(line);
							}
							unsuspendlog.close();

							allLog.addSpacer(SPACER_SMALL);
							ifstream unbanip("logs/unbanip.txt");
							allLog.addLabelWithIcon("`wUn-ban IP logs", 1434, LABEL_SMALL);
							allLog.addSpacer(SPACER_SMALL);
							while (getline(unbanip, line))
							{
								allLog.addSmallText(line);
							}
							unbanip.close();

							allLog.addSpacer(SPACER_SMALL);
							allLog.addQuickExit();
							allLog.endDialog("Close", "", "Close it");
							Player::OnDialogRequest(peer, allLog.finishDialog());
						}
						if (btn == "autodemoteautobanlogs")
						{
							if (!isMod(peer)) continue;
							GTDialog allLog;
							string line;

							ifstream autoDemotelog("logs/autodemote.txt");
							allLog.addLabelWithIcon("`wAuto-Demoted logs", 1434, LABEL_SMALL);
							allLog.addSpacer(SPACER_SMALL);
							while (getline(autoDemotelog, line))
							{
								allLog.addSmallText(line);
							}
							autoDemotelog.close();

							allLog.addSpacer(SPACER_SMALL);
							ifstream autobanlog("logs/autoban.txt");
							allLog.addLabelWithIcon("`wAuto-Ban logs", 1434, LABEL_SMALL);
							allLog.addSpacer(SPACER_SMALL);
							while (getline(autobanlog, line))
							{
								allLog.addSmallText(line);
							}
							autobanlog.close();

							allLog.addSpacer(SPACER_SMALL);
							allLog.addQuickExit();
							allLog.endDialog("Close", "", "Close it");
							Player::OnDialogRequest(peer, allLog.finishDialog());
						}
						if (btn == "mutecursewarnlogs")
						{
							if (!isMod(peer)) continue;
							GTDialog allLog;
							string line;

							ifstream curselog("logs/curse.txt");
							allLog.addLabelWithIcon("`wCurse logs", 1434, LABEL_SMALL);
							allLog.addSpacer(SPACER_SMALL);
							while (getline(curselog, line))
							{
								allLog.addSmallText(line);
							}
							curselog.close();
							allLog.addSpacer(SPACER_SMALL);

							ifstream mutelog("logs/mute.txt");
							allLog.addLabelWithIcon("`wMute logs", 1434, LABEL_SMALL);
							allLog.addSpacer(SPACER_SMALL);
							while (getline(mutelog, line))
							{
								allLog.addSmallText(line);
							}
							mutelog.close();
							allLog.addSpacer(SPACER_SMALL);

							ifstream warnlog("logs/warns.txt");
							allLog.addLabelWithIcon("`wWarn logs", 1434, LABEL_SMALL);
							allLog.addSpacer(SPACER_SMALL);
							while (getline(warnlog, line))
							{
								allLog.addSmallText(line);
							}
							warnlog.close();
							allLog.addSpacer(SPACER_SMALL);

							ifstream uncurselog("logs/uncurse.txt");
							allLog.addLabelWithIcon("`wUn-Curse logs", 1434, LABEL_SMALL);
							allLog.addSpacer(SPACER_SMALL);
							while (getline(uncurselog, line))
							{
								allLog.addSmallText(line);
							}
							uncurselog.close();
							allLog.addSpacer(SPACER_SMALL);

							ifstream unmuteLog("logs/unmute.txt");
							allLog.addLabelWithIcon("`wUn-Mute logs", 1434, LABEL_SMALL);
							allLog.addSpacer(SPACER_SMALL);
							while (getline(unmuteLog, line))
							{
								allLog.addSmallText(line);
							}
							unmuteLog.close();
							allLog.addSpacer(SPACER_SMALL);

							ifstream unwarnlog("logs/unwarns.txt");
							allLog.addLabelWithIcon("`wUnwarn logs", 1434, LABEL_SMALL);
							allLog.addSpacer(SPACER_SMALL);
							while (getline(unwarnlog, line))
							{
								allLog.addSmallText(line);
							}
							unwarnlog.close();

							allLog.addSpacer(SPACER_SMALL);
							allLog.addQuickExit();
							allLog.endDialog("Close", "", "Close it");
							Player::OnDialogRequest(peer, allLog.finishDialog());
						}
						if (btn == "wrenchlogs")
						{
							if (!isMod(peer)) continue;
							GTDialog allLog;
							string line;

							ifstream wrench2week("logs/wrench/2weeksban.txt");
							allLog.addLabelWithIcon("`wWrench 2 weeks ban logs", 1434, LABEL_SMALL);
							allLog.addSpacer(SPACER_SMALL);
							while (getline(wrench2week, line))
							{
								allLog.addSmallText(line);
							}
							wrench2week.close();
							allLog.addSpacer(SPACER_SMALL);

							ifstream wrench4week("logs/wrench/4weeksban.txt");
							allLog.addLabelWithIcon("`wWrench 4 weeks ban logs", 1434, LABEL_SMALL);
							allLog.addSpacer(SPACER_SMALL);
							while (getline(wrench4week, line))
							{
								allLog.addSmallText(line);
							}
							wrench4week.close();
							allLog.addSpacer(SPACER_SMALL);

							ifstream wrench8week("logs/wrench/8weeksban.txt");
							allLog.addLabelWithIcon("`wWrench 8 weeks ban logs", 1434, LABEL_SMALL);
							allLog.addSpacer(SPACER_SMALL);
							while (getline(wrench8week, line))
							{
								allLog.addSmallText(line);
							}
							wrench8week.close();
							allLog.addSpacer(SPACER_SMALL);

							ifstream wrenchipban("logs/wrench/ipban.txt");
							allLog.addLabelWithIcon("`wWrench ip-ban logs", 1434, LABEL_SMALL);
							allLog.addSpacer(SPACER_SMALL);
							while (getline(wrenchipban, line))
							{
								allLog.addSmallText(line);
							}
							wrenchipban.close();

							allLog.addSpacer(SPACER_SMALL);
							allLog.addQuickExit();
							allLog.endDialog("Close", "", "Close it");
							Player::OnDialogRequest(peer, allLog.finishDialog());
						}
						if (btn == "popup")
						{
							if (((PlayerInfo*)(peer->data))->haveSuperSupporterName == false)
							{
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|Growmojis|left|1366|\nadd_spacer|small|\nadd_smalltext_forced| (sigh) |left|\nadd_spacer|small||left|\nadd_smalltext_forced| (no) |\nadd_spacer|small||left|\nadd_smalltext_forced| (wow) |\nadd_spacer|small||left|\nadd_smalltext_forced| (yes) |0.5|left|\nadd_button|chc0|Cancel|noflags|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|"));
								ENetPacket* packet = enet_packet_create(p.data,
									p.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|Growmojis (BETA)|left|1366|\nadd_spacer|small|\nadd_smalltext_forced| (sigh) |left|\nadd_spacer|small|\nadd_smalltext|`$You unlocked growmoji (`2Super supporter`$)``|left|\nadd_smalltext_forced| (no) |left|\nadd_button|chc0|Cancel|noflags|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|"));
								ENetPacket* packet = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p2.data;

							}
						}
						if (btn == "passbutton") {
							GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "add_label_with_icon|big|`wChange Password|left|1280|\nadd_spacer|small|\nadd_text_input|oldpass|`2Current Password``||18|\nadd_text_input|newpass|`2New Password``||18|\nadd_text_input|verifypass|`2Verify Password``||18|\nend_dialog|pssdia|`wCancel``|`wConfirm!``|"));
							ENetPacket* packet = enet_packet_create(ps.data,
								ps.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete ps.data;
							continue;
						}
						if (btn == "marketplace")
						{
							string name = "" + ((PlayerInfo*)(peer->data))->displayName + "";
							Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`w" + name + " Market Place``|left|6138|\nadd_textbox|Change your information about your market place here!!|left|\nadd_spacer|small|\nadd_text_input|username|About Market Place||100|\nadd_spacer|small|\nadd_smalltext|If You did edit Your Market Place, click this button to see Preview|left|\nadd_button|marketreview|Review Market|\nadd_spacer|small|\nadd_smalltext|Store Description : `4Market Place is Under Progress!|left|\nadd_smalltext|");
						}
						if (btn == "worldlogs")
						{
							if (!isMod(peer)) continue;
							GTDialog allLog;
							string line;

							allLog.addSpacer(SPACER_SMALL);

							ifstream nukeLog("logs/nuke.txt");
							allLog.addLabelWithIcon("`wNuke logs", 1434, LABEL_SMALL);
							allLog.addSpacer(SPACER_SMALL);
							while (getline(nukeLog, line))
							{
								allLog.addSmallText(line);
							}
							nukeLog.close();
							allLog.addSpacer(SPACER_SMALL);

							ifstream unnukeLog("logs/unnuke.txt");
							allLog.addLabelWithIcon("`wUn-Nuke logs", 1434, LABEL_SMALL);
							allLog.addSpacer(SPACER_SMALL);
							while (getline(unnukeLog, line))
							{
								allLog.addSmallText(line);
							}
							unnukeLog.close();

							allLog.addSpacer(SPACER_SMALL);
							allLog.addQuickExit();
							allLog.endDialog("Close", "", "Close it");
							Player::OnDialogRequest(peer, allLog.finishDialog());
						}
						if (btn == "otherlogs")
						{
							if (!isMod(peer)) continue;
							GTDialog allLog;
							string line;

							ifstream giveranklog("logs/giverank.txt");
							allLog.addLabelWithIcon("`wGive rank logs", 1434, LABEL_SMALL);
							allLog.addSpacer(SPACER_SMALL);
							while (getline(giveranklog, line))
							{
								allLog.addSmallText(line);
							}
							giveranklog.close();
							allLog.addSpacer(SPACER_SMALL);

							ifstream givelevellog("logs/givelevel.txt");
							allLog.addLabelWithIcon("`wGive level logs", 1434, LABEL_SMALL);
							allLog.addSpacer(SPACER_SMALL);
							while (getline(givelevellog, line))
							{
								allLog.addSmallText(line);
							}
							givelevellog.close();
							allLog.addSpacer(SPACER_SMALL);

							ifstream itemlog("logs/item.txt");
							allLog.addLabelWithIcon("`w/item logs", 1434, LABEL_SMALL);
							allLog.addSpacer(SPACER_SMALL);
							while (getline(itemlog, line))
							{
								allLog.addSmallText(line);
							}
							itemlog.close();
							allLog.addSpacer(SPACER_SMALL);



							ifstream removeinventoryitemlog("logs/removeinventoryitem.txt");
							allLog.addLabelWithIcon("`wRemove items from inventory logs", 1434, LABEL_SMALL);
							allLog.addSpacer(SPACER_SMALL);
							while (getline(removeinventoryitemlog, line))
							{
								allLog.addSmallText(line);
							}
							removeinventoryitemlog.close();
							allLog.addSpacer(SPACER_SMALL);

							allLog.addSpacer(SPACER_SMALL);
							allLog.addQuickExit();
							allLog.endDialog("Close", "", "Close it");
							Player::OnDialogRequest(peer, allLog.finishDialog());
						}
						if (btn == "stafftestok")
						{
							if (world == nullptr || world->name == "EXIT" || serverIsFrozen) continue;

							string timedid = OutputBanTime(GetCurrentTimeInternalSeconds() - static_cast<PlayerInfo*>(peer->data)->startedTest);

							std::stringstream bss(cch);
							std::string bto;

							int all[10] = {};
							int doescheat[10] = {};
							int correct = 0;

							while (std::getline(bss, bto, '\n'))
							{
								vector<string> infoDat = explode("|", bto);

								if (infoDat[0] == "question1a")
								{
									all[0] = atoi(infoDat[1].c_str());
									if (atoi(infoDat[1].c_str()) == 1) doescheat[0]++;
								}
								if (infoDat[0] == "question1b")
								{
									if (atoi(infoDat[1].c_str()) == 1) doescheat[0]++;
								}
								if (infoDat[0] == "question1c")
								{
									if (atoi(infoDat[1].c_str()) == 1) doescheat[0]++;
								}
								if (infoDat[0] == "question1d")
								{
									if (atoi(infoDat[1].c_str()) == 1) doescheat[0]++;
								}


								if (infoDat[0] == "question2a")
								{
									if (atoi(infoDat[1].c_str()) == 1) doescheat[1]++;
								}
								if (infoDat[0] == "question2b")
								{
									if (atoi(infoDat[1].c_str()) == 1) doescheat[1]++;
								}
								if (infoDat[0] == "question2c")
								{
									if (atoi(infoDat[1].c_str()) == 1) doescheat[1]++;
								}
								if (infoDat[0] == "question2d")
								{
									all[1] = atoi(infoDat[1].c_str());
									if (atoi(infoDat[1].c_str()) == 1) doescheat[1]++;
								}


								if (infoDat[0] == "question3a")
								{
									if (atoi(infoDat[1].c_str()) == 1) doescheat[2]++;
								}
								if (infoDat[0] == "question3b")
								{
									if (atoi(infoDat[1].c_str()) == 1) doescheat[2]++;
								}
								if (infoDat[0] == "question3c")
								{
									all[2] = atoi(infoDat[1].c_str());
									if (atoi(infoDat[1].c_str()) == 1) doescheat[2]++;
								}
								if (infoDat[0] == "question3d")
								{
									if (atoi(infoDat[1].c_str()) == 1) doescheat[2]++;
								}


								if (infoDat[0] == "question4a")
								{
									all[3] = atoi(infoDat[1].c_str());
									if (atoi(infoDat[1].c_str()) == 1) doescheat[3]++;
								}
								if (infoDat[0] == "question4b")
								{
									if (atoi(infoDat[1].c_str()) == 1) doescheat[3]++;
								}
								if (infoDat[0] == "question4c")
								{
									if (atoi(infoDat[1].c_str()) == 1) doescheat[3]++;
								}
								if (infoDat[0] == "question4d")
								{
									if (atoi(infoDat[1].c_str()) == 1) doescheat[3]++;
								}


								if (infoDat[0] == "question5a")
								{
									if (atoi(infoDat[1].c_str()) == 1) doescheat[4]++;
								}
								if (infoDat[0] == "question5b")
								{
									if (atoi(infoDat[1].c_str()) == 1) doescheat[4]++;
								}
								if (infoDat[0] == "question5c")
								{
									if (atoi(infoDat[1].c_str()) == 1) doescheat[4]++;
								}
								if (infoDat[0] == "question5d")
								{
									all[4] = atoi(infoDat[1].c_str());
									if (atoi(infoDat[1].c_str()) == 1) doescheat[4]++;
								}

								if (infoDat[0] == "question6a")
								{
									if (atoi(infoDat[1].c_str()) == 1) doescheat[5]++;
								}
								if (infoDat[0] == "question6b")
								{
									if (atoi(infoDat[1].c_str()) == 1) doescheat[5]++;
								}
								if (infoDat[0] == "question6c")
								{
									all[5] = atoi(infoDat[1].c_str());
									if (atoi(infoDat[1].c_str()) == 1) doescheat[5]++;
								}
								if (infoDat[0] == "question6d")
								{
									if (atoi(infoDat[1].c_str()) == 1) doescheat[5]++;
								}


								if (infoDat[0] == "question7a")
								{
									all[6] = atoi(infoDat[1].c_str());
									if (atoi(infoDat[1].c_str()) == 1) doescheat[6]++;
								}
								if (infoDat[0] == "question7b")
								{
									if (atoi(infoDat[1].c_str()) == 1) doescheat[6]++;
								}
								if (infoDat[0] == "question7c")
								{
									if (atoi(infoDat[1].c_str()) == 1) doescheat[6]++;
								}
								if (infoDat[0] == "question7d")
								{
									if (atoi(infoDat[1].c_str()) == 1) doescheat[6]++;
								}


								if (infoDat[0] == "question8a")
								{
									if (atoi(infoDat[1].c_str()) == 1) doescheat[7]++;
								}
								if (infoDat[0] == "question8b")
								{
									all[7] = atoi(infoDat[1].c_str());
									if (atoi(infoDat[1].c_str()) == 1) doescheat[7]++;
								}
								if (infoDat[0] == "question8c")
								{
									if (atoi(infoDat[1].c_str()) == 1) doescheat[7]++;
								}
								if (infoDat[0] == "question8d")
								{
									if (atoi(infoDat[1].c_str()) == 1) doescheat[7]++;
								}


								if (infoDat[0] == "question9a")
								{
									if (atoi(infoDat[1].c_str()) == 1) doescheat[8]++;
								}
								if (infoDat[0] == "question9b")
								{
									all[8] = atoi(infoDat[1].c_str());
									if (atoi(infoDat[1].c_str()) == 1) doescheat[8]++;
								}
								if (infoDat[0] == "question9c")
								{
									if (atoi(infoDat[1].c_str()) == 1) doescheat[8]++;
								}
								if (infoDat[0] == "question9d")
								{
									if (atoi(infoDat[1].c_str()) == 1) doescheat[8]++;
								}


								if (infoDat[0] == "question10a")
								{
									if (atoi(infoDat[1].c_str()) == 1) doescheat[9]++;
								}
								if (infoDat[0] == "question10b")
								{
									all[9] = atoi(infoDat[1].c_str());
									if (atoi(infoDat[1].c_str()) == 1) doescheat[9]++;
								}
								if (infoDat[0] == "question10c")
								{
									if (atoi(infoDat[1].c_str()) == 1) doescheat[9]++;
								}
								if (infoDat[0] == "question10d")
								{
									if (atoi(infoDat[1].c_str()) == 1) doescheat[9]++;
								}
							}

							string wrongAnswers = "Wrong answers in questions`o: ", correctAnswers = "Correct answers in questions`o: ";
							for (int i = 0; i < 10; i++)
							{
								if (all[i] == 0 || doescheat[i] > 1)
								{
									wrongAnswers += to_string(i + 1) + ", ";
								}
								else
								{
									correctAnswers += to_string(i + 1) + ", ";
									correct++;
								}
							}
							if (correct >= 8)
							{
								showModLogs("`o[test]: `$" + static_cast<PlayerInfo*>(peer->data)->rawName + " `2passed the test. `4" + wrongAnswers + ". `2" + correctAnswers + ". `oScore: `2" + to_string(correct) + "/10. `oCompleted in " + timedid);
							}
							else
							{
								showModLogs("`o[test]: `$" + static_cast<PlayerInfo*>(peer->data)->rawName + " `4failed the test. `4" + wrongAnswers + ". `2" + correctAnswers + ". `oScore: `4" + to_string(correct) + "/10. `oCompleted in " + timedid);
							}
						}
						if (btn == "addletter")
						{
							if (world == nullptr || world->name == "EXIT" || serverIsFrozen) continue;
							std::stringstream bss(cch);
							std::string bto;

							string text = "";
							string coord = "";

							while (std::getline(bss, bto, '\n'))
							{
								vector<string> infoDat = explode("|", bto);
								if (infoDat[0].substr(0, 15) == "addletterinput_")
								{
									text = infoDat[1];
									string coord = infoDat[0].substr(infoDat[0].find("_") + 1);
									auto isdbox = std::experimental::filesystem::exists("mailbox/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
									if (!isdbox)
									{
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4An error occured. Break the mailbox.", 0, true);
										break;
									}

									if (text.size() < 3)
									{
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wThats not interesting enough to mail.", 0, true);
										break;
									}

									try
									{
										ifstream ifff("mailbox/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
										json j;
										ifff >> j;
										ifff.close();

										if (j["inmail"] > 19)
										{
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`oThis mailbox already has `w20 `oletters in it. Try again later.", 0, true);
										}
										for (int i = 0; i < 20; i++)
										{
											if (j["mails"][i]["growid"] == "")
											{
												j["mails"][i]["growid"] = static_cast<PlayerInfo*>(peer->data)->displayName;
												j["mails"][i]["text"] = text;
												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`2You place your letter in the mailbox.", 0, true);
												int x = j["x"];
												int y = j["y"];
												if (j["inmail"] < 1)
												{
													ENetPeer* currentPeer;
													for (currentPeer = server->peers;
														currentPeer < &server->peers[server->peerCount];
														++currentPeer)
													{
														if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
														if (isHere(peer, currentPeer))
														{
															SendItemPacket(currentPeer, 656, 0, x, y, 1);
														}
													}
												}
												j["inmail"] = j["inmail"].get<double>() + 1;
												ofstream of("mailbox/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
												of << j << std::endl;
												of.close();
												break;
											}
										}
									}
									catch (std::exception&)
									{
										SendConsole("addletter Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_now(peer, 0);
									}
									catch (std::runtime_error&)
									{
										SendConsole("addletter Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_now(peer, 0);
									}
									catch (...)
									{
										SendConsole("addletter Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_now(peer, 0);
									}
								}
							}
						}
						if (btn == "addblueletter")
						{
							if (world == nullptr || world->name == "EXIT" || serverIsFrozen) continue;
							std::stringstream bss(cch);
							std::string bto;

							string text = "";
							string coord = "";

							while (std::getline(bss, bto, '\n'))
							{
								vector<string> infoDat = explode("|", bto);
								if (infoDat[0].substr(0, 19) == "addblueletterinput_")
								{
									text = infoDat[1];
									string coord = infoDat[0].substr(infoDat[0].find("_") + 1);
									auto isdbox = std::experimental::filesystem::exists("bluemailbox/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
									if (!isdbox)
									{
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4An error occured. Break the blue mailbox.", 0, true);
										break;
									}

									if (text.size() < 3)
									{
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wThats not interesting enough to mail.", 0, true);
										break;
									}

									try
									{
										ifstream ifff("bluemailbox/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
										json j;
										ifff >> j;
										ifff.close();

										if (j["inmail"] > 19)
										{
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`oThis mailbox already has `w20 `oletters in it. Try again later.", 0, true);
										}
										for (int i = 0; i < 20; i++)
										{
											if (j["mails"][i]["growid"] == "")
											{
												j["mails"][i]["growid"] = static_cast<PlayerInfo*>(peer->data)->displayName;
												j["mails"][i]["text"] = text;
												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`2You place your letter in the mailbox.", 0, true);
												int x = j["x"];
												int y = j["y"];
												if (j["inmail"] < 1)
												{
													ENetPeer* currentPeer;
													for (currentPeer = server->peers;
														currentPeer < &server->peers[server->peerCount];
														++currentPeer)
													{
														if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
														if (isHere(peer, currentPeer))
														{
															SendItemPacket(currentPeer, 1006, 0, x, y, 1);
														}
													}
												}
												j["inmail"] = j["inmail"].get<double>() + 1;
												ofstream of("bluemailbox/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
												of << j << std::endl;
												of.close();
												break;
											}
										}
									}
									catch (std::exception&)
									{
										SendConsole("addblueletter Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_now(peer, 0);
									}
									catch (std::runtime_error&)
									{
										SendConsole("addblueletter Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_now(peer, 0);
									}
									catch (...)
									{
										SendConsole("addblueletter Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_now(peer, 0);
									}
								}
							}
						}
						if (btn == "boxlvl2depositconfirm")
						{
							if (world == nullptr || world->name == "EXIT" || serverIsFrozen) continue;
							std::stringstream bss(cch);
							std::string bto;

							string count = "";
							int countint = 0;
							string coord = "";
							string id = "";
							int idint = 0;

							while (std::getline(bss, bto, '\n'))
							{
								vector<string> infoDat = explode("|", bto);
								if (infoDat[0].substr(0, 20) == "boxlvl2depositcount_")
								{
									count = infoDat[1];

									string coord_and_id = infoDat[0].erase(0, 20);
									string::size_type pos = coord_and_id.find('_');
									if (pos != std::string::npos)
									{
										coord = coord_and_id.substr(0, pos);
										coord_and_id.erase(0, pos + 1);
										id = coord_and_id;
									}
									else
									{
										autoBan(peer, false, 24 * 7, "Incorrect parameters boxlvl2depositconfirm. Coord and id were: " + coord_and_id);
										break;
									}
									auto isdbox = std::experimental::filesystem::exists("storageboxlvl2/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
									if (!isdbox)
									{
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4An error occured while getting box info.", 0, true);
										break;
									}

									bool contains_non_int3 = !std::regex_match(id, std::regex("^[0-9]+$"));
									if (contains_non_int3 == true)
									{
										autoBan(peer, false, 24 * 7, "Proxy detect! boxlvl2depositconfirm item id was: " + id);
										break;
									}

									bool contains_non_int4 = !std::regex_match(count, std::regex("^[0-9]+$"));
									if (contains_non_int4 == true)
									{
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4Count should be only 1-200", 0, true);
										break;
									}
									countint = atoi(count.c_str());

									idint = atoi(id.c_str());
									if (idint < 1 || idint > maxItems)
									{
										autoBan(peer, false, 24 * 7, "Proxy detect! In boxlvl2depositconfirm, id was: " + to_string(idint) + "");
										break;
									}

									if (countint < 1 || countint > 200)
									{
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4Count should be only 1-200", 0, true);
										break;
									}

									try
									{
										ifstream ifff("storageboxlvl2/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
										json j;
										ifff >> j;
										ifff.close();

										if (j["instorage"] > 19)
										{
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4Storage Box Xtreme - Level 2 is full!", 0, true);
											break;
										}
										bool isContains = false;
										SearchInventoryItem(peer, idint, countint, isContains);
										if (isContains == false)
										{
											Player::OnTextOverlay(peer, "`4You don't have enough " + itemDefs[idint].name + " in your inventory.");
											break;
										}
										j["instorage"] = j["instorage"].get<double>() + 1;

										for (int i = 0; i < 20; i++)
										{
											if (j["storage"][i]["itemid"] == 0)
											{
												j["storage"][i]["itemid"] = idint;
												j["storage"][i]["placedby"] = static_cast<PlayerInfo*>(peer->data)->rawName;
												j["storage"][i]["itemcount"] = countint;

												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wStored " + to_string(countint) + " " + itemDefs[idint].name + " in the Storage Box Xtreme - Level 2", 0, true);
												break;
											}
										}

										ofstream of("storageboxlvl2/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
										of << j << std::endl;
										of.close();
										RemoveInventoryItem(idint, countint, peer, true);
										updateplayerset(peer, idint);
									}
									catch (std::exception&)
									{
										SendConsole("boxlvl2depositcount_ Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_now(peer, 0);
									}
									catch (std::runtime_error&)
									{
										SendConsole("boxlvl2depositcount_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_now(peer, 0);
									}
									catch (...)
									{
										SendConsole("boxlvl2depositcount_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_now(peer, 0);
									}
								}
							}
						}
						if (btn == "boxlvl3depositconfirm")
						{
							if (world == nullptr || world->name == "EXIT" || serverIsFrozen) continue;
							std::stringstream bss(cch);
							std::string bto;

							string count = "";
							int countint = 0;
							string coord = "";
							string id = "";
							int idint = 0;

							while (std::getline(bss, bto, '\n'))
							{
								vector<string> infoDat = explode("|", bto);
								if (infoDat[0].substr(0, 20) == "boxlvl3depositcount_")
								{
									count = infoDat[1];

									string coord_and_id = infoDat[0].erase(0, 20);
									string::size_type pos = coord_and_id.find('_');
									if (pos != std::string::npos)
									{
										coord = coord_and_id.substr(0, pos);
										coord_and_id.erase(0, pos + 1);
										id = coord_and_id;
									}
									else
									{
										autoBan(peer, false, 24 * 7, "Incorrect parameters boxlvl3depositconfirm. Coord and id were: " + coord_and_id);
										break;
									}
									auto isdbox = std::experimental::filesystem::exists("storageboxlvl3/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
									if (!isdbox)
									{
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4An error occured while getting box info.", 0, true);
										break;
									}

									bool contains_non_int3 = !std::regex_match(id, std::regex("^[0-9]+$"));
									if (contains_non_int3 == true)
									{
										autoBan(peer, false, 24 * 7, "Proxy detect! boxlvl3depositconfirm item id was: " + id);
										break;
									}

									bool contains_non_int4 = !std::regex_match(count, std::regex("^[0-9]+$"));
									if (contains_non_int4 == true)
									{
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4Count should be only 1-200", 0, true);
										break;
									}
									countint = atoi(count.c_str());

									idint = atoi(id.c_str());
									if (idint < 1 || idint > maxItems)
									{
										autoBan(peer, false, 24 * 7, "Proxy detect! In boxlvl3depositconfirm, id was: " + to_string(idint) + "");
										break;
									}

									if (countint < 1 || countint > 200)
									{
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4Count should be only 1-200", 0, true);
										break;
									}

									try
									{
										ifstream ifff("storageboxlvl3/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
										json j;
										ifff >> j;
										ifff.close();

										if (j["instorage"] > 19)
										{
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4Storage Box Xtreme - Level 3 is full!", 0, true);
											break;
										}
										bool isContains = false;
										SearchInventoryItem(peer, idint, countint, isContains);
										if (isContains == false)
										{
											Player::OnTextOverlay(peer, "`4You don't have enough " + itemDefs[idint].name + " in your inventory.");
											break;
										}
										j["instorage"] = j["instorage"].get<double>() + 1;

										for (int i = 0; i < 20; i++)
										{
											if (j["storage"][i]["itemid"] == 0)
											{
												j["storage"][i]["itemid"] = idint;
												j["storage"][i]["placedby"] = static_cast<PlayerInfo*>(peer->data)->rawName;
												j["storage"][i]["itemcount"] = countint;

												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wStored " + to_string(countint) + " " + itemDefs[idint].name + " in the Storage Box Xtreme - Level 3", 0, true);
												break;
											}
										}

										ofstream of("storageboxlvl3/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
										of << j << std::endl;
										of.close();
										RemoveInventoryItem(idint, countint, peer, true);
										updateplayerset(peer, idint);
									}
									catch (std::exception&)
									{
										SendConsole("boxlvl3depositconfirm Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_now(peer, 0);
									}
									catch (std::runtime_error&)
									{
										SendConsole("boxlvl3depositconfirm Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_now(peer, 0);
									}
									catch (...)
									{
										SendConsole("boxlvl3depositconfirm Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_now(peer, 0);
									}
								}
							}
						}
						if (btn == "boxlvl1depositconfirm")
						{
							if (world == nullptr || world->name == "EXIT" || serverIsFrozen) continue;
							std::stringstream bss(cch);
							std::string bto;

							string count = "";
							int countint = 0;
							string coord = "";
							string id = "";
							int idint = 0;

							while (std::getline(bss, bto, '\n'))
							{
								vector<string> infoDat = explode("|", bto);
								if (infoDat[0].substr(0, 20) == "boxlvl1depositcount_")
								{
									count = infoDat[1];

									string coord_and_id = infoDat[0].erase(0, 20);
									string::size_type pos = coord_and_id.find('_');
									if (pos != std::string::npos)
									{
										coord = coord_and_id.substr(0, pos);
										coord_and_id.erase(0, pos + 1);
										id = coord_and_id;
									}
									else
									{
										autoBan(peer, false, 24 * 7, "Incorrect parameters boxlvl1depositconfirm. Coord and id were: " + coord_and_id);
										break;
									}
									auto isdbox = std::experimental::filesystem::exists("storageboxlvl1/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
									if (!isdbox)
									{
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4An error occured while getting box info.", 0, true);
										break;
									}

									bool contains_non_int3 = !std::regex_match(id, std::regex("^[0-9]+$"));
									if (contains_non_int3 == true)
									{
										autoBan(peer, false, 24 * 7, "Proxy detect! boxlvl1depositconfirm item id was: " + id);
										break;
									}

									bool contains_non_int4 = !std::regex_match(count, std::regex("^[0-9]+$"));
									if (contains_non_int4 == true)
									{
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4Count should be only 1-200", 0, true);
										break;
									}
									countint = atoi(count.c_str());

									idint = atoi(id.c_str());
									if (idint < 1 || idint > maxItems)
									{
										autoBan(peer, false, 24 * 7, "Proxy detect! In boxlvl1depositconfirm, id was: " + to_string(idint) + "");
										break;
									}

									if (countint < 1 || countint > 200)
									{
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4Count should be only 1-200", 0, true);
										break;
									}

									try
									{
										ifstream ifff("storageboxlvl1/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
										json j;
										ifff >> j;
										ifff.close();

										if (j["instorage"] > 19)
										{
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4Storage Box Xtreme - Level 1 is full!", 0, true);
											break;
										}
										bool isContains = false;
										SearchInventoryItem(peer, idint, countint, isContains);
										if (isContains == false)
										{
											Player::OnTextOverlay(peer, "`4You don't have enough " + itemDefs[idint].name + " in your inventory.");
											break;
										}
										j["instorage"] = j["instorage"].get<double>() + 1;

										for (int i = 0; i < 20; i++)
										{
											if (j["storage"][i]["itemid"] == 0)
											{
												j["storage"][i]["itemid"] = idint;
												j["storage"][i]["placedby"] = static_cast<PlayerInfo*>(peer->data)->rawName;
												j["storage"][i]["itemcount"] = countint;

												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wStored " + to_string(countint) + " " + itemDefs[idint].name + " in the Storage Box Xtreme - Level 1", 0, true);
												break;
											}
										}

										ofstream of("storageboxlvl1/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
										of << j << std::endl;
										of.close();
										RemoveInventoryItem(idint, countint, peer, true);
										updateplayerset(peer, idint);
									}
									catch (std::exception&)
									{
										SendConsole("boxlvl1depositconfirm Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_now(peer, 0);
									}
									catch (std::runtime_error&)
									{
										SendConsole("boxlvl1depositconfirm Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_now(peer, 0);
									}
									catch (...)
									{
										SendConsole("boxlvl1depositconfirm Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_now(peer, 0);
									}
								}
							}
						}
						if (btn == "boxlvl2_withdrawConfirm")
						{
							if (world == nullptr || world->name == "EXIT" || serverIsFrozen) continue;
							std::stringstream bss(cch);
							std::string bto;

							string howMany = "";
							string apos = "";
							string coord = "";
							int aposInt = 0;
							int howManyInt = 0;

							while (std::getline(bss, bto, '\n'))
							{
								vector<string> infoDat = explode("|", bto);
								if (infoDat[0].substr(0, 16) == "boxlvl2withdraw_")
								{
									howMany = infoDat[1];
									if (howMany.size() > 5) break;

									string coord_and_apos = infoDat[0].erase(0, 16);
									string::size_type pos = coord_and_apos.find('_');
									if (pos != std::string::npos)
									{
										coord = coord_and_apos.substr(0, pos);
										coord_and_apos.erase(0, pos + 1);
										apos = coord_and_apos;
									}
									else
									{
										autoBan(peer, false, 24 * 7, "Incorrect parameters boxlvl2_withdrawConfirm. Coord and id were: " + coord_and_apos);
										break;
									}
									auto isdbox = std::experimental::filesystem::exists("storageboxlvl2/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
									if (!isdbox)
									{
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4An error occured while getting safe vault info.", 0, true);
										break;
									}

									bool contains_non_int3 = !std::regex_match(apos, std::regex("^[0-9]+$"));
									if (contains_non_int3 == true)
									{
										autoBan(peer, false, 24 * 7, "Proxy detect! boxlvl2_withdrawConfirm apos was: " + apos);
										break;
									}

									bool contains_non_int4 = !std::regex_match(howMany, std::regex("^[0-9]+$"));
									if (contains_non_int4 == true)
									{
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4Count should be only 1-200", 0, true);
										break;
									}
									howManyInt = atoi(howMany.c_str());

									aposInt = atoi(apos.c_str());

									if (howManyInt < 1 || howManyInt > 200)
									{
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4Count should be only 1-200", 0, true);
										break;
									}

									try
									{
										ifstream ifff("storageboxlvl2/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
										json j;
										ifff >> j;
										ifff.close();

										int itemid = 0;
										bool success = true;

										for (int i = 0; i < 20; i++)
										{
											if (j["storage"][i]["aposition"] == aposInt)
											{
												itemid = j["storage"][i]["itemid"];

												if (itemid == 0) break;

												if (howManyInt > j["storage"][i]["itemcount"])
												{
													Player::OnTextOverlay(peer, "`4Your Storage Box Xtreme - Level 2 does not contains such many.");
													break;
												}

												if (CheckItemExists(peer, j["storage"][i]["itemid"]))
												{
													int currentlyHave = GetQuantityOfItem(peer, j["storage"][i]["itemid"]);
													if (howManyInt + currentlyHave < 201)
													{
														SaveItemMoreTimes(j["storage"][i]["itemid"], howManyInt, peer, success);
													}
													else
													{
														Player::OnTextOverlay(peer, "`4You don't have enough space.");
														break;
													}
												}
												else
												{
													if (static_cast<PlayerInfo*>(peer->data)->inventory.items.size() == static_cast<PlayerInfo*>(peer->data)->currentInventorySize)
													{
														Player::OnTextOverlay(peer, "`4Your inventory is full! You can purchase an inventory upgrade in the shop.");
														break;
													}

													SaveItemMoreTimes(j["storage"][i]["itemid"], howManyInt, peer, success);
												}

												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wRemoved " + to_string(howManyInt) + " " + itemDefs[itemid].name + " from the Storage Box Xtreme - Level 2", 0, true);


												if (j["storage"][i]["itemcount"] == howManyInt)
												{
													j["storage"][i]["itemid"] = 0;
													j["storage"][i]["placedby"] = "There was " + to_string(howManyInt) + " of " + to_string(itemid) + " item, and " + static_cast<PlayerInfo*>(peer->data)->rawName + " withdrawed them.";
													j["storage"][i]["itemcount"] = 0;
													j["instorage"] = j["instorage"].get<double>() - 1;
												}
												else
												{
													j["storage"][i]["itemcount"] = j["storage"][i]["itemcount"].get<double>() - howManyInt;
												}

												ofstream of("storageboxlvl2/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
												of << j << std::endl;
												of.close();
												break;
											}
										}
									}
									catch (std::exception&)
									{
										SendConsole("boxlvl2_withdrawConfirm Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_now(peer, 0);
									}
									catch (std::runtime_error&)
									{
										SendConsole("boxlvl2_withdrawConfirm Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_now(peer, 0);
									}
									catch (...)
									{
										SendConsole("boxlvl2_withdrawConfirm Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_now(peer, 0);
									}
								}
							}
						}
						if (btn == "boxlvl3_withdrawConfirm")
						{
							if (world == nullptr || world->name == "EXIT" || serverIsFrozen) continue;
							std::stringstream bss(cch);
							std::string bto;

							string howMany = "";
							string apos = "";
							string coord = "";
							int aposInt = 0;
							int howManyInt = 0;

							while (std::getline(bss, bto, '\n'))
							{
								vector<string> infoDat = explode("|", bto);
								if (infoDat[0].substr(0, 16) == "boxlvl3withdraw_")
								{
									howMany = infoDat[1];
									if (howMany.size() > 5) break;

									string coord_and_apos = infoDat[0].erase(0, 16);
									string::size_type pos = coord_and_apos.find('_');
									if (pos != std::string::npos)
									{
										coord = coord_and_apos.substr(0, pos);
										coord_and_apos.erase(0, pos + 1);
										apos = coord_and_apos;
									}
									else
									{
										autoBan(peer, false, 24 * 7, "Incorrect parameters boxlvl3_withdrawConfirm. Coord and id were: " + coord_and_apos);
										break;
									}
									auto isdbox = std::experimental::filesystem::exists("storageboxlvl3/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
									if (!isdbox)
									{
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4An error occured while getting safe vault info.", 0, true);
										break;
									}

									bool contains_non_int3 = !std::regex_match(apos, std::regex("^[0-9]+$"));
									if (contains_non_int3 == true)
									{
										autoBan(peer, false, 24 * 7, "Proxy detect! boxlvl3_withdrawConfirm apos was: " + apos);
										break;
									}

									bool contains_non_int4 = !std::regex_match(howMany, std::regex("^[0-9]+$"));
									if (contains_non_int4 == true)
									{
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4Count should be only 1-200", 0, true);
										break;
									}
									howManyInt = atoi(howMany.c_str());

									aposInt = atoi(apos.c_str());

									if (howManyInt < 1 || howManyInt > 200)
									{
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4Count should be only 1-200", 0, true);
										break;
									}

									try
									{
										ifstream ifff("storageboxlvl3/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
										json j;
										ifff >> j;
										ifff.close();

										int itemid = 0;
										bool success = true;

										for (int i = 0; i < 20; i++)
										{
											if (j["storage"][i]["aposition"] == aposInt)
											{
												itemid = j["storage"][i]["itemid"];

												if (itemid == 0) break;

												if (howManyInt > j["storage"][i]["itemcount"])
												{
													Player::OnTextOverlay(peer, "`4Your Storage Box Xtreme - Level 3 does not contains such many.");
													break;
												}

												if (CheckItemExists(peer, j["storage"][i]["itemid"]))
												{
													int currentlyHave = GetQuantityOfItem(peer, j["storage"][i]["itemid"]);
													if (howManyInt + currentlyHave < 201)
													{
														SaveItemMoreTimes(j["storage"][i]["itemid"], howManyInt, peer, success);
													}
													else
													{
														Player::OnTextOverlay(peer, "`4You don't have enough space.");
														break;
													}
												}
												else
												{
													if (static_cast<PlayerInfo*>(peer->data)->inventory.items.size() == static_cast<PlayerInfo*>(peer->data)->currentInventorySize)
													{
														Player::OnTextOverlay(peer, "`4Your inventory is full! You can purchase an inventory upgrade in the shop.");
														break;
													}

													SaveItemMoreTimes(j["storage"][i]["itemid"], howManyInt, peer, success);
												}

												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wRemoved " + to_string(howManyInt) + " " + itemDefs[itemid].name + " from the Storage Box Xtreme - Level 3", 0, true);


												if (j["storage"][i]["itemcount"] == howManyInt)
												{
													j["storage"][i]["itemid"] = 0;
													j["storage"][i]["placedby"] = "There was " + to_string(howManyInt) + " of " + to_string(itemid) + " item, and " + static_cast<PlayerInfo*>(peer->data)->rawName + " withdrawed them.";
													j["storage"][i]["itemcount"] = 0;
													j["instorage"] = j["instorage"].get<double>() - 1;
												}
												else
												{
													j["storage"][i]["itemcount"] = j["storage"][i]["itemcount"].get<double>() - howManyInt;
												}

												ofstream of("storageboxlvl3/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
												of << j << std::endl;
												of.close();
												break;
											}
										}
									}
									catch (std::exception&)
									{
										SendConsole("boxlvl3_withdrawConfirm Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_now(peer, 0);
									}
									catch (std::runtime_error&)
									{
										SendConsole("boxlvl3_withdrawConfirm Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_now(peer, 0);
									}
									catch (...)
									{
										SendConsole("boxlvl3_withdrawConfirm Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_now(peer, 0);
									}
								}
							}
						}
						if (btn == "trademypickerconfirm")
						{
							if (world == nullptr || world->name == "EXIT" || serverIsFrozen) continue;
							std::stringstream bss(cch);
							std::string bto;

							string howMany = "";
							string number = "";
							int howManyInt = 0;
							while (std::getline(bss, bto, '\n'))
							{
								vector<string> infoDat = explode("|", bto);
								if (infoDat[0].substr(0, 19) == "trademypickercount_")
								{
									howMany = infoDat[1];
									if (howMany.size() > 5) break;
									number = infoDat[0].substr(19, infoDat[0].length() - 1).c_str();

									bool contains_non_int4 = !std::regex_match(number, std::regex("^[0-9]+$"));
									if (contains_non_int4 == true)
									{
										autoBan(peer, false, 24 * 7, "Incorrect parameters trademypickercount_. number was " + number);
										break;
									}
									bool contains_non_int5 = !std::regex_match(howMany, std::regex("^[0-9]+$"));
									if (contains_non_int5 == true)
									{
										Player::OnConsoleMessage(peer, "`4Count should be only 1-200");
										TradeMainMenu(peer);
										break;
									}
									howManyInt = atoi(howMany.c_str());

									if (howManyInt < 1 || howManyInt > 200)
									{
										Player::OnConsoleMessage(peer, "`4Count should be only 1-200");
										TradeMainMenu(peer);
										break;
									}
									if (number == "1")
									{
										if (static_cast<PlayerInfo*>(peer->data)->mySellingItem1 == "3308")
										{
											autoBan(peer, false, 24 * 7, "Proxy detect! In btn trademypickerconfirm, item1 was 3308");
											break;
										}
										bool doesHave = false;
										SearchInventoryItem(peer, stoi(static_cast<PlayerInfo*>(peer->data)->mySellingItem1), howManyInt, doesHave);
										if (doesHave == false)
										{
											Player::OnConsoleMessage(peer, "`4You don't have that much.");
											TradeMainMenu(peer);
											break;
										}
										static_cast<PlayerInfo*>(peer->data)->mySellingItem1Count = howMany;
										Player::OnConsoleMessage(peer, "`8" + howMany + " `2of `8" + getItemDef(atoi(static_cast<PlayerInfo*>(peer->data)->mySellingItem1.c_str())).name + " `2were added to the first box.");
										TradeMainMenu(peer);
									}
									if (number == "2")
									{
										if (static_cast<PlayerInfo*>(peer->data)->mySellingItem2 == "3308")
										{
											autoBan(peer, false, 24 * 7, "Proxy detect! In btn trademypickerconfirm, item2 was 3308");
											break;
										}
										bool doesHave = false;
										SearchInventoryItem(peer, stoi(static_cast<PlayerInfo*>(peer->data)->mySellingItem2), howManyInt, doesHave);
										if (doesHave == false)
										{
											Player::OnConsoleMessage(peer, "`4You don't have that much.");
											TradeMainMenu(peer);
											break;
										}
										static_cast<PlayerInfo*>(peer->data)->mySellingItem2Count = howMany;
										Player::OnConsoleMessage(peer, "`8" + howMany + " `2of `8" + getItemDef(atoi(static_cast<PlayerInfo*>(peer->data)->mySellingItem2.c_str())).name + " `2were added to the second box.");
										TradeMainMenu(peer);
									}
									if (number == "3")
									{
										if (static_cast<PlayerInfo*>(peer->data)->mySellingItem3 == "3308")
										{
											autoBan(peer, false, 24 * 7, "Proxy detect! In btn trademypickerconfirm, item3 was 3308");
											break;
										}
										bool doesHave = false;
										SearchInventoryItem(peer, stoi(static_cast<PlayerInfo*>(peer->data)->mySellingItem3), howManyInt, doesHave);
										if (doesHave == false)
										{
											Player::OnConsoleMessage(peer, "`4You don't have that much.");
											TradeMainMenu(peer);
											break;
										}
										static_cast<PlayerInfo*>(peer->data)->mySellingItem3Count = howMany;
										Player::OnConsoleMessage(peer, "`8" + howMany + " `2of `8" + getItemDef(atoi(static_cast<PlayerInfo*>(peer->data)->mySellingItem3.c_str())).name + " `2were added to the third box.");
										TradeMainMenu(peer);
									}
									if (number == "4")
									{
										if (static_cast<PlayerInfo*>(peer->data)->mySellingItem4 == "3308")
										{
											autoBan(peer, false, 24 * 7, "Proxy detect! In btn trademypickerconfirm, item4 was 3308");
											break;
										}
										bool doesHave = false;
										SearchInventoryItem(peer, stoi(static_cast<PlayerInfo*>(peer->data)->mySellingItem4), howManyInt, doesHave);
										if (doesHave == false)
										{
											Player::OnConsoleMessage(peer, "`4You don't have that much.");
											TradeMainMenu(peer);
											break;
										}
										static_cast<PlayerInfo*>(peer->data)->mySellingItem4Count = howMany;
										Player::OnConsoleMessage(peer, "`8" + howMany + " `2of `8" + getItemDef(atoi(static_cast<PlayerInfo*>(peer->data)->mySellingItem4.c_str())).name + " `2were added to the fourth box.");
										TradeMainMenu(peer);
									}
								}

							}
						}
						if (btn == "tradehisitemconfirm")
						{
							if (world == nullptr || world->name == "EXIT" || serverIsFrozen) continue;
							std::stringstream bss(cch);
							std::string bto;

							string howMany = "";
							string number = "";
							int howManyInt = 0;
							while (std::getline(bss, bto, '\n'))
							{
								vector<string> infoDat = explode("|", bto);
								if (infoDat[0].substr(0, 18) == "tradehisitemcount_")
								{
									howMany = infoDat[1];
									if (howMany.size() > 5) break;
									number = infoDat[0].substr(18, infoDat[0].length() - 1).c_str();

									if (number != "1" && number != "2" && number != "3" && number != "4")
									{
										autoBan(peer, false, 24 * 7, "Proxy detect! tradehisitemcount_ number was: " + number);
										break;
									}
									bool contains_non_int5 = !std::regex_match(howMany, std::regex("^[0-9]+$"));
									if (contains_non_int5 == true)
									{
										Player::OnConsoleMessage(peer, "`4Count should be only 1-200");
										TradeMainMenu(peer);
										break;
									}
									howManyInt = atoi(howMany.c_str());

									if (howManyInt < 1 || howManyInt > 200)
									{
										Player::OnConsoleMessage(peer, "`4Count should be only 1-200");
										TradeMainMenu(peer);
										break;
									}

									if (number == "1")
									{
										if (static_cast<PlayerInfo*>(peer->data)->hisSellingItem1 == "3308")
										{
											autoBan(peer, false, 24 * 7, "Proxy detect! In btn tradehisitemconfirm, item1 was 3308");
											break;
										}

										string name = static_cast<PlayerInfo*>(peer->data)->lastTradeGrowid;
										ENetPeer* currentPeer;
										bool found = false;
										bool doesHave = false;
										for (currentPeer = server->peers;
											currentPeer < &server->peers[server->peerCount];
											++currentPeer)
										{
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
												continue;
											if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == PlayerDB::getProperName(name))
											{
												found = true;
												SearchInventoryItem(currentPeer, stoi(static_cast<PlayerInfo*>(peer->data)->hisSellingItem1), howManyInt, doesHave);
												if (doesHave == false)
												{
													Player::OnConsoleMessage(peer, "`4He doesn't have that much.");
													TradeMainMenu(peer);
													break;
												}
											}
										}
										if (!found)
										{
											Player::OnConsoleMessage(peer, "`@Player Not `4Found!");
											break;
										}
										if (!doesHave)
										{
											break;
										}

										static_cast<PlayerInfo*>(peer->data)->hisSellingItem1Count = howMany;
										Player::OnConsoleMessage(peer, "`8" + howMany + " `2of `8" + getItemDef(atoi(static_cast<PlayerInfo*>(peer->data)->hisSellingItem1.c_str())).name + " `2were added to the first box.");
										TradeMainMenu(peer);
									}
									if (number == "2")
									{
										if (static_cast<PlayerInfo*>(peer->data)->hisSellingItem2 == "3308")
										{
											autoBan(peer, false, 24 * 7, "Proxy detect! In btn tradehisitemconfirm, item2 was 3308");
											break;
										}

										string name = static_cast<PlayerInfo*>(peer->data)->lastTradeGrowid;
										ENetPeer* currentPeer;
										bool found = false;
										bool doesHave = false;
										for (currentPeer = server->peers;
											currentPeer < &server->peers[server->peerCount];
											++currentPeer)
										{
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
												continue;
											if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == PlayerDB::getProperName(name))
											{
												found = true;
												SearchInventoryItem(currentPeer, stoi(static_cast<PlayerInfo*>(peer->data)->hisSellingItem2), howManyInt, doesHave);
												if (doesHave == false)
												{
													Player::OnConsoleMessage(peer, "`4He doesn't have that much.");
													TradeMainMenu(peer);
													break;
												}
											}
										}
										if (!found)
										{
											Player::OnConsoleMessage(peer, "`@Player Not `4Found!");
											break;
										}
										if (!doesHave)
										{
											break;
										}

										static_cast<PlayerInfo*>(peer->data)->hisSellingItem2Count = howMany;
										Player::OnConsoleMessage(peer, "`8" + howMany + " `2of `8" + getItemDef(atoi(static_cast<PlayerInfo*>(peer->data)->hisSellingItem2.c_str())).name + " `2were added to the second box.");
										TradeMainMenu(peer);
									}
									if (number == "3")
									{
										if (static_cast<PlayerInfo*>(peer->data)->hisSellingItem3 == "3308")
										{
											autoBan(peer, false, 24 * 7, "Proxy detect! In btn tradehisitemconfirm, item3 was 3308");
											break;
										}

										string name = static_cast<PlayerInfo*>(peer->data)->lastTradeGrowid;
										ENetPeer* currentPeer;
										bool found = false;
										bool doesHave = false;
										for (currentPeer = server->peers;
											currentPeer < &server->peers[server->peerCount];
											++currentPeer)
										{
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
												continue;
											if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == PlayerDB::getProperName(name))
											{
												found = true;
												SearchInventoryItem(currentPeer, stoi(static_cast<PlayerInfo*>(peer->data)->hisSellingItem3), howManyInt, doesHave);
												if (doesHave == false)
												{
													Player::OnConsoleMessage(peer, "`4He doesn't have that much.");
													TradeMainMenu(peer);
													break;
												}
											}
										}
										if (!found)
										{
											Player::OnConsoleMessage(peer, "`@Player Not `4Found!");
											break;
										}
										if (!doesHave)
										{
											break;
										}

										static_cast<PlayerInfo*>(peer->data)->hisSellingItem3Count = howMany;
										Player::OnConsoleMessage(peer, "`8" + howMany + " `2of `8" + getItemDef(atoi(static_cast<PlayerInfo*>(peer->data)->hisSellingItem3.c_str())).name + " `2were added to the third box.");
										TradeMainMenu(peer);
									}
									if (number == "4")
									{
										if (static_cast<PlayerInfo*>(peer->data)->hisSellingItem4 == "3308")
										{
											autoBan(peer, false, 24 * 7, "Proxy detect! In btn tradehisitemconfirm, item4 was 3308");
											break;
										}

										string name = static_cast<PlayerInfo*>(peer->data)->lastTradeGrowid;
										ENetPeer* currentPeer;
										bool found = false;
										bool doesHave = false;
										for (currentPeer = server->peers;
											currentPeer < &server->peers[server->peerCount];
											++currentPeer)
										{
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
												continue;
											if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == PlayerDB::getProperName(name))
											{
												found = true;
												SearchInventoryItem(currentPeer, stoi(static_cast<PlayerInfo*>(peer->data)->hisSellingItem4), howManyInt, doesHave);
												if (doesHave == false)
												{
													Player::OnConsoleMessage(peer, "`4He doesn't have that much.");
													TradeMainMenu(peer);
													break;
												}
											}
										}
										if (!found)
										{
											Player::OnConsoleMessage(peer, "`@Player Not `4Found!");
											break;
										}
										if (!doesHave)
										{
											break;
										}

										static_cast<PlayerInfo*>(peer->data)->hisSellingItem4Count = howMany;
										Player::OnConsoleMessage(peer, "`8" + howMany + " `2of `8" + getItemDef(atoi(static_cast<PlayerInfo*>(peer->data)->hisSellingItem4.c_str())).name + " `2were added to the fourth box.");
										TradeMainMenu(peer);
									}
								}

							}
						}
						if (btn == "boxlvl1_withdrawConfirm")
						{
							if (world == nullptr || world->name == "EXIT" || serverIsFrozen) continue;
							std::stringstream bss(cch);
							std::string bto;

							string howMany = "";
							string apos = "";
							string coord = "";
							int aposInt = 0;
							int howManyInt = 0;

							while (std::getline(bss, bto, '\n'))
							{
								vector<string> infoDat = explode("|", bto);
								if (infoDat[0].substr(0, 16) == "boxlvl1withdraw_")
								{
									howMany = infoDat[1];
									if (howMany.size() > 5) break;

									string coord_and_apos = infoDat[0].erase(0, 16);
									string::size_type pos = coord_and_apos.find('_');
									if (pos != std::string::npos)
									{
										coord = coord_and_apos.substr(0, pos);
										coord_and_apos.erase(0, pos + 1);
										apos = coord_and_apos;
									}
									else
									{
										autoBan(peer, false, 24 * 7, "Incorrect parameters boxlvl1_withdrawConfirm. Coord and id were: " + coord_and_apos);
										break;
									}
									auto isdbox = std::experimental::filesystem::exists("storageboxlvl1/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
									if (!isdbox)
									{
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4An error occured while getting safe vault info.", 0, true);
										break;
									}

									bool contains_non_int3 = !std::regex_match(apos, std::regex("^[0-9]+$"));
									if (contains_non_int3 == true)
									{
										autoBan(peer, false, 24 * 7, "Proxy detect! boxlvl1_withdrawConfirm apos was: " + apos);
										break;
									}

									bool contains_non_int4 = !std::regex_match(howMany, std::regex("^[0-9]+$"));
									if (contains_non_int4 == true)
									{
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4Count should be only 1-200", 0, true);
										break;
									}
									howManyInt = atoi(howMany.c_str());

									aposInt = atoi(apos.c_str());

									if (howManyInt < 1 || howManyInt > 200)
									{
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4Count should be only 1-200", 0, true);
										break;
									}

									try
									{
										ifstream ifff("storageboxlvl1/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
										json j;
										ifff >> j;
										ifff.close();

										int itemid = 0;
										bool success = true;

										for (int i = 0; i < 20; i++)
										{
											if (j["storage"][i]["aposition"] == aposInt)
											{
												itemid = j["storage"][i]["itemid"];

												if (itemid == 0) break;

												if (howManyInt > j["storage"][i]["itemcount"])
												{
													Player::OnTextOverlay(peer, "`4Your Storage Box Xtreme - Level 1 does not contains such many.");
													break;
												}

												if (CheckItemExists(peer, j["storage"][i]["itemid"]))
												{
													int currentlyHave = GetQuantityOfItem(peer, j["storage"][i]["itemid"]);
													if (howManyInt + currentlyHave < 201)
													{
														SaveItemMoreTimes(j["storage"][i]["itemid"], howManyInt, peer, success);
													}
													else
													{
														Player::OnTextOverlay(peer, "`4You don't have enough space.");
														break;
													}
												}
												else
												{
													if (static_cast<PlayerInfo*>(peer->data)->inventory.items.size() == static_cast<PlayerInfo*>(peer->data)->currentInventorySize)
													{
														Player::OnTextOverlay(peer, "`4Your inventory is full! You can purchase an inventory upgrade in the shop.");
														break;
													}

													SaveItemMoreTimes(j["storage"][i]["itemid"], howManyInt, peer, success);
												}

												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wRemoved " + to_string(howManyInt) + " " + itemDefs[itemid].name + " from the Storage Box Xtreme - Level 1", 0, true);


												if (j["storage"][i]["itemcount"] == howManyInt)
												{
													j["storage"][i]["itemid"] = 0;
													j["storage"][i]["placedby"] = "There was " + to_string(howManyInt) + " of " + to_string(itemid) + " item, and " + static_cast<PlayerInfo*>(peer->data)->rawName + " withdrawed them.";
													j["storage"][i]["itemcount"] = 0;
													j["instorage"] = j["instorage"].get<double>() - 1;
												}
												else
												{
													j["storage"][i]["itemcount"] = j["storage"][i]["itemcount"].get<double>() - howManyInt;
												}

												ofstream of("storageboxlvl1/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
												of << j << std::endl;
												of.close();
												break;
											}
										}
									}
									catch (std::exception&)
									{
										SendConsole("boxlvl1_withdrawConfirm Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_now(peer, 0);
									}
									catch (std::runtime_error&)
									{
										SendConsole("boxlvl1_withdrawConfirm Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_now(peer, 0);
									}
									catch (...)
									{
										SendConsole("boxlvl1_withdrawConfirm Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_now(peer, 0);
									}
								}
							}
						}
						if (btn.substr(0, 24) == "removeplayerofflineitem_")
						{
							if (!isDev(peer))
							{
								//sendwrongcmd(peer);
								continue;
							}
							if (world == nullptr || world->name == "EXIT" || serverIsFrozen) continue;
							string growid_and_itemid = btn.erase(0, 24);
							string::size_type pos = growid_and_itemid.find('_');
							string growid = "";
							string itemid = "";

							if (pos != std::string::npos)
							{
								growid = growid_and_itemid.substr(0, pos);
								growid_and_itemid.erase(0, pos + 1);
								itemid = growid_and_itemid;
							}
							else
							{
								autoBan(peer, false, 24 * 7, "Incorrect parameters removeplayerofflineitem_. growid and itemid were: " + growid_and_itemid);
								break;
							}
							growid = PlayerDB::getProperName(growid);


							bool contains_non_int3 = !std::regex_match(itemid, std::regex("^[0-9]+$"));
							if (contains_non_int3 == true)
							{
								autoBan(peer, false, 24 * 7, "Proxy detect! removeplayerofflineitem_ itemid was: " + itemid);
								break;
							}
							if (itemid.size() > 5)
							{
								autoBan(peer, false, 24 * 7, "Proxy detect! removeplayerofflineitem_ itemid was: " + itemid);
								break;
							}
							int intitemid = atoi(itemid.c_str());

							if (!std::experimental::filesystem::exists("inventory/" + growid + ".json"))
							{
								autoBan(peer, false, 24 * 7, "Proxy detect! removeplayerofflineitem_ - user's '" + growid + "' inventory does not exists");
								break;
							}

							GTDialog remove;
							remove.addLabelWithIcon("`wRemove " + growid + "'s items.", intitemid, LABEL_BIG);
							remove.addSmallText("How much remove " + itemDefs[intitemid].name + "");
							remove.addInputBox("removeofflineplayeritemConfirmInput", "", "", 4);
							remove.addButton("removeofflineplayeritemConfirm_" + growid + "_" + itemid, "Remove Items");
							remove.addSpacer(SPACER_SMALL);
							remove.addQuickExit();
							remove.endDialog("Close", "", "Exit");
							Player::OnDialogRequest(peer, remove.finishDialog());
						}
						if (btn.substr(0, 17) == "removeplayeritem_")
						{
							if (!isDev(peer))
							{
								//sendwrongcmd(peer);
								continue;
							}
							if (world == nullptr || world->name == "EXIT" || serverIsFrozen) continue;
							string growid_and_itemid = btn.erase(0, 17);
							string::size_type pos = growid_and_itemid.find('_');
							string growid = "";
							string itemid = "";

							if (pos != std::string::npos)
							{
								growid = growid_and_itemid.substr(0, pos);
								growid_and_itemid.erase(0, pos + 1);
								itemid = growid_and_itemid;
							}
							else
							{
								autoBan(peer, false, 24 * 7, "Incorrect parameters removeplayeritem_. growid and itemid were: " + growid_and_itemid);
								break;
							}
							growid = PlayerDB::getProperName(growid);


							bool contains_non_int3 = !std::regex_match(itemid, std::regex("^[0-9]+$"));
							if (contains_non_int3 == true)
							{
								autoBan(peer, false, 24 * 7, "Proxy detect! removeplayeritem_ itemid was: " + itemid);
								break;
							}
							if (itemid.size() > 5)
							{
								autoBan(peer, false, 24 * 7, "Proxy detect! removeplayeritem_ itemid was: " + itemid);
								break;
							}
							int intitemid = atoi(itemid.c_str());

							ENetPeer* currentPeer;
							for (currentPeer = server->peers;
								currentPeer < &server->peers[server->peerCount];
								++currentPeer)
							{
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
									continue;
								if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == growid)
								{
									GTDialog remove;
									remove.addLabelWithIcon("`wRemove " + growid + "'s items.", intitemid, LABEL_BIG);
									remove.addSmallText("How much remove " + itemDefs[intitemid].name + "");
									remove.addInputBox("removeplayeritemConfirmInput", "", "", 4);
									remove.addButton("removeplayeritemConfirm_" + growid + "_" + itemid, "Remove Items");
									remove.addSpacer(SPACER_SMALL);
									remove.addQuickExit();
									remove.endDialog("Close", "", "Exit");
									Player::OnDialogRequest(peer, remove.finishDialog());
								}
							}
						}
						if (btn.substr(0, 17) == "choosehisitemadd_")
						{
							string number_and_itemid = btn.erase(0, 17);
							string::size_type pos = number_and_itemid.find('_');
							string number = "";
							string itemid = "";

							if (pos != std::string::npos)
							{
								number = number_and_itemid.substr(0, pos);
								number_and_itemid.erase(0, pos + 1);
								itemid = number_and_itemid;
							}
							else
							{
								autoBan(peer, false, 24 * 7, "Incorrect parameters choosehisitemadd_. number and itemid were: " + number_and_itemid);
								break;
							}

							bool contains_non_int3 = !std::regex_match(itemid, std::regex("^[0-9]+$"));
							if (contains_non_int3 == true)
							{
								autoBan(peer, false, 24 * 7, "Proxy detect! choosehisitemadd_ itemid was: " + itemid);
								break;
							}
							if (itemid.size() > 5)
							{
								autoBan(peer, false, 24 * 7, "Proxy detect! choosehisitemadd_ itemid was: " + itemid);
								break;
							}
							int itemidint = atoi(itemid.c_str());
							if (itemidint < 1 || itemidint > maxItems)
							{
								autoBan(peer, false, 24 * 7, "Proxy detect! In choosehisitemadd_, item was: " + itemid + "");
								break;
							}
							if (itemidint == 18 || itemidint == 3308 || itemidint == 32 || itemidint == 6336 || getItemDef(itemidint).properties & Property_Untradable || getItemDef(itemidint).blockType == BlockTypes::FISH || itemidint == 8552 || itemidint == 9472 || itemidint == 9482 || itemidint == 9356 || itemidint == 9492 || itemidint == 9498 || itemidint == 8774 || itemidint == 1790 || itemidint == 2592 || itemidint == 1784 || itemidint == 1792 || itemidint == 1794 || itemidint == 7734 || itemidint == 8306 || itemidint == 9458)
							{
								Player::OnConsoleMessage(peer, "`4You can't place " + getItemDef(itemidint).name + ".");
								TradeMainMenu(peer);
								break;
							}

							bool contains_non_int4 = !std::regex_match(number, std::regex("^[0-9]+$"));
							if (contains_non_int4 == true)
							{
								autoBan(peer, false, 24 * 7, "Incorrect parameters choosehisitemadd_ number was " + number);
								break;
							}
							if (number != "1" && number != "2" && number != "3" && number != "4")
							{
								autoBan(peer, false, 24 * 7, "Proxy detect! choosehisitemadd_ number was: " + number);
								break;
							}

							if (number == "1")
							{
								static_cast<PlayerInfo*>(peer->data)->hisSellingItem1 = itemid;
							}
							if (number == "2")
							{
								static_cast<PlayerInfo*>(peer->data)->hisSellingItem2 = itemid;
							}
							if (number == "3")
							{
								static_cast<PlayerInfo*>(peer->data)->hisSellingItem3 = itemid;
							}
							if (number == "4")
							{
								static_cast<PlayerInfo*>(peer->data)->hisSellingItem4 = itemid;
							}

							GTDialog picker;
							if (number == "1")
							{
								if (static_cast<PlayerInfo*>(peer->data)->hisSellingItem1 == "3308")
								{
									picker.addLabelWithIcon("`wSelect which item you want to get.", 1434, LABEL_SMALL);
									picker.addSpacer(SPACER_SMALL);
									picker.addButton("choosehisitem_" + number, "Find the item in his inventory!");
									picker.addSpacer(SPACER_SMALL);
									picker.addButton("trademypickerback", "Back to main.");
									picker.addQuickExit();
									picker.endDialog("", "", "");
									Player::OnDialogRequest(peer, picker.finishDialog());
								}
								else
								{
									picker.addLabelWithIcon("`wSelect the item that you want to get and how much.", 1434, LABEL_SMALL);
									picker.addSpacer(SPACER_SMALL);
									picker.addButton("choosehisitem_" + number, "Change the item!");
									picker.addSpacer(SPACER_SMALL);
									picker.addSmallText("`$You have Selected: `2" + getItemDef(atoi(static_cast<PlayerInfo*>(peer->data)->hisSellingItem1.c_str())).name);
									picker.addInputBox("tradehisitemcount_" + number, "Select how much you want to get", "", 5);
									picker.addSpacer(SPACER_SMALL);
									picker.addButton("tradehisitemconfirm", "Confirm");
									picker.addSpacer(SPACER_SMALL);
									picker.addButton("trademypickerback", "Back to main.");
									picker.addQuickExit();
									picker.endDialog("", "", "");
									Player::OnDialogRequest(peer, picker.finishDialog());
								}
							}

							if (number == "2")
							{
								if (static_cast<PlayerInfo*>(peer->data)->hisSellingItem2 == "3308")
								{
									picker.addLabelWithIcon("`wSelect which item you want to get.", 1434, LABEL_SMALL);
									picker.addSpacer(SPACER_SMALL);
									picker.addButton("choosehisitem_" + number, "Find the item in his inventory!");
									picker.addSpacer(SPACER_SMALL);
									picker.addButton("trademypickerback", "Back to main.");
									picker.addQuickExit();
									picker.endDialog("", "", "");
									Player::OnDialogRequest(peer, picker.finishDialog());
								}
								else
								{
									picker.addLabelWithIcon("`wSelect the item that you want to get and how much.", 1434, LABEL_SMALL);
									picker.addSpacer(SPACER_SMALL);
									picker.addButton("choosehisitem_" + number, "Change the item!");
									picker.addSpacer(SPACER_SMALL);
									picker.addSmallText("`$You have Selected: `2" + getItemDef(atoi(static_cast<PlayerInfo*>(peer->data)->hisSellingItem2.c_str())).name);
									picker.addInputBox("tradehisitemcount_" + number, "Select how much you want to get", "", 5);
									picker.addSpacer(SPACER_SMALL);
									picker.addButton("tradehisitemconfirm", "Confirm");
									picker.addSpacer(SPACER_SMALL);
									picker.addButton("trademypickerback", "Back to main.");
									picker.addQuickExit();
									picker.endDialog("", "", "");
									Player::OnDialogRequest(peer, picker.finishDialog());
								}
							}

							if (number == "3")
							{
								if (static_cast<PlayerInfo*>(peer->data)->hisSellingItem3 == "3308")
								{
									picker.addLabelWithIcon("`wSelect which item you want to get.", 1434, LABEL_SMALL);
									picker.addSpacer(SPACER_SMALL);
									picker.addButton("choosehisitem_" + number, "Find the item in his inventory!");
									picker.addSpacer(SPACER_SMALL);
									picker.addButton("trademypickerback", "Back to main.");
									picker.addQuickExit();
									picker.endDialog("", "", "");
									Player::OnDialogRequest(peer, picker.finishDialog());
								}
								else
								{
									picker.addLabelWithIcon("`wSelect the item that you want to get and how much.", 1434, LABEL_SMALL);
									picker.addSpacer(SPACER_SMALL);
									picker.addButton("choosehisitem_" + number, "Change the item!");
									picker.addSpacer(SPACER_SMALL);
									picker.addSmallText("`$You have Selected: `2" + getItemDef(atoi(static_cast<PlayerInfo*>(peer->data)->hisSellingItem3.c_str())).name);
									picker.addInputBox("tradehisitemcount_" + number, "Select how much you want to get", "", 5);
									picker.addSpacer(SPACER_SMALL);
									picker.addButton("tradehisitemconfirm", "Confirm");
									picker.addSpacer(SPACER_SMALL);
									picker.addButton("trademypickerback", "Back to main.");
									picker.addQuickExit();
									picker.endDialog("", "", "");
									Player::OnDialogRequest(peer, picker.finishDialog());
								}
							}

							if (number == "4")
							{
								if (static_cast<PlayerInfo*>(peer->data)->hisSellingItem4 == "3308")
								{
									picker.addLabelWithIcon("`wSelect which item you want to get.", 1434, LABEL_SMALL);
									picker.addSpacer(SPACER_SMALL);
									picker.addButton("choosehisitem_" + number, "Find the item in his inventory!");
									picker.addSpacer(SPACER_SMALL);
									picker.addButton("trademypickerback", "Back to main.");
									picker.addQuickExit();
									picker.endDialog("", "", "");
									Player::OnDialogRequest(peer, picker.finishDialog());
								}
								else
								{
									picker.addLabelWithIcon("`wSelect the item that you want to get and how much.", 1434, LABEL_SMALL);
									picker.addSpacer(SPACER_SMALL);
									picker.addButton("choosehisitem_" + number, "Change the item!");
									picker.addSpacer(SPACER_SMALL);
									picker.addSmallText("`$You have Selected: `2" + getItemDef(atoi(static_cast<PlayerInfo*>(peer->data)->hisSellingItem4.c_str())).name);
									picker.addInputBox("tradehisitemcount_" + number, "Select how much you want to get", "", 5);
									picker.addSpacer(SPACER_SMALL);
									picker.addButton("tradehisitemconfirm", "Confirm");
									picker.addSpacer(SPACER_SMALL);
									picker.addButton("trademypickerback", "Back to main.");
									picker.addQuickExit();
									picker.endDialog("", "", "");
									Player::OnDialogRequest(peer, picker.finishDialog());
								}
							}
						}
						if (btn.substr(0, 24) == "removeplayeritemConfirm_")
						{
							if (!isDev(peer))
							{
								//sendwrongcmd(peer);
								continue;
							}
							if (world == nullptr || world->name == "EXIT" || serverIsFrozen) continue;
							string growid_and_itemid = btn.erase(0, 24);
							string::size_type pos = growid_and_itemid.find('_');
							string growid = "";
							string itemid = "";

							if (pos != std::string::npos)
							{
								growid = growid_and_itemid.substr(0, pos);
								growid_and_itemid.erase(0, pos + 1);
								itemid = growid_and_itemid;
							}
							else
							{
								autoBan(peer, false, 24 * 7, "Incorrect parameters removeplayeritemConfirm_. growid and itemid were: " + growid_and_itemid);
								break;
							}
							growid = PlayerDB::getProperName(growid);


							bool contains_non_int3 = !std::regex_match(itemid, std::regex("^[0-9]+$"));
							if (contains_non_int3 == true)
							{
								autoBan(peer, false, 24 * 7, "Proxy detect! removeplayeritemConfirm_ itemid was: " + itemid);
								break;
							}
							if (itemid.size() > 5)
							{
								autoBan(peer, false, 24 * 7, "Proxy detect! removeplayeritemConfirm_ itemid was: " + itemid);
								break;
							}
							int intitemid = atoi(itemid.c_str());
							string inputhowmuch;
							int inputhowmuchint;
							std::stringstream bss(cch);
							std::string bto;

							while (std::getline(bss, bto, '\n'))
							{
								vector<string> infoDat = explode("|", bto);
								if (infoDat[0].substr(0, 28) == "removeplayeritemConfirmInput")
								{
									inputhowmuch = infoDat[1];
									bool int3 = !std::regex_match(inputhowmuch, std::regex("^[0-9]+$"));
									if (int3 == true)
									{
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4Input should be 1-200.", 0, true);
										break;
									}
									if (inputhowmuch.size() > 5)
									{
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4Input should be 1-200.", 0, true);
										break;
									}

									inputhowmuchint = atoi(inputhowmuch.c_str());
									if (inputhowmuchint < 1 || inputhowmuchint > 200)
									{
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4Input should be 1-200.", 0, true);
										break;
									}
									ENetPeer* currentPeer;
									for (currentPeer = server->peers;
										currentPeer < &server->peers[server->peerCount];
										++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
											continue;
										if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == growid)
										{
											bool doesHave = false;
											SearchInventoryItem(currentPeer, intitemid, inputhowmuchint, doesHave);
											if (doesHave == false)
											{
												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4the player doesn't have that much.", 0, true);
												break;
											}
											RemoveInventoryItem(intitemid, inputhowmuchint, currentPeer, true);
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`2" + to_string(inputhowmuchint) + " " + itemDefs[intitemid].name + " were removed for the " + growid + ".", 0, true);
											Player::OnConsoleMessage(currentPeer, "`4Administrator " + static_cast<PlayerInfo*>(peer->data)->rawName + " has removed " + to_string(inputhowmuchint) + " " + itemDefs[intitemid].name + " from your inventory.");
											ofstream warnslog("logs/removeinventoryitem.txt", ios::app);
											warnslog << "administrator " << static_cast<PlayerInfo*>(peer->data)->rawName << " has removed " << to_string(inputhowmuchint) << " " << itemDefs[intitemid].name << " from " << static_cast<PlayerInfo*>(currentPeer->data)->rawName << " inventory." << endl;
											warnslog.close();
											break;
										}
									}
								}
							}
						}
						if (btn.substr(0, 31) == "removeofflineplayeritemConfirm_")
						{
							if (!isDev(peer))
							{
								//sendwrongcmd(peer);
								continue;
							}
							if (world == nullptr || world->name == "EXIT" || serverIsFrozen) continue;
							string growid_and_itemid = btn.erase(0, 31);
							string::size_type pos = growid_and_itemid.find('_');
							string growid = "";
							string itemid = "";

							if (pos != std::string::npos)
							{
								growid = growid_and_itemid.substr(0, pos);
								growid_and_itemid.erase(0, pos + 1);
								itemid = growid_and_itemid;
							}
							else
							{
								autoBan(peer, false, 24 * 7, "Incorrect parameters removeofflineplayeritemConfirm_. growid and itemid were: " + growid_and_itemid);
								break;
							}
							growid = PlayerDB::getProperName(growid);


							bool contains_non_int3 = !std::regex_match(itemid, std::regex("^[0-9]+$"));
							if (contains_non_int3 == true)
							{
								autoBan(peer, false, 24 * 7, "Proxy detect! removeofflineplayeritemConfirm_ itemid was: " + itemid);
								break;
							}
							if (itemid.size() > 5)
							{
								autoBan(peer, false, 24 * 7, "Proxy detect! removeofflineplayeritemConfirm_ itemid was: " + itemid);
								break;
							}
							int intitemid = atoi(itemid.c_str());
							string inputhowmuch;
							int inputhowmuchint;
							std::stringstream bss(cch);
							std::string bto;

							while (std::getline(bss, bto, '\n'))
							{
								vector<string> infoDat = explode("|", bto);
								if (infoDat[0].substr(0, 35) == "removeofflineplayeritemConfirmInput")
								{
									inputhowmuch = infoDat[1];
									bool int3 = !std::regex_match(inputhowmuch, std::regex("^[0-9]+$"));
									if (int3 == true)
									{
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4Input should be 1-200.", 0, true);
										break;
									}
									if (inputhowmuch.size() > 5)
									{
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4Input should be 1-200.", 0, true);
										break;
									}

									inputhowmuchint = atoi(inputhowmuch.c_str());
									if (inputhowmuchint < 1 || inputhowmuchint > 200)
									{
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4Input should be 1-200.", 0, true);
										break;
									}

									if (std::experimental::filesystem::exists("inventory/" + growid + ".json"))
									{
										try
										{
											std::ifstream ifff("inventory/" + growid + ".json");
											if (ifff.fail())
											{
												ifff.close();
												Player::OnTextOverlay(peer, "`4Error getting inventory info!");
												continue;
											}
											json j;
											ifff >> j;
											ifff.close();

											int inventorySize = 200;
											if (std::experimental::filesystem::exists("usersinventorysize/" + growid + ".txt"))
											{
												std::ifstream iffff("usersinventorysize/" + growid + ".txt");
												iffff >> inventorySize;
												iffff.close();
											}
											int item_id = 0;
											int item_Count = 0;
											for (int i = 0; i < inventorySize; i++)
											{
												item_id = j["items"][i]["itemid"];
												item_Count = j["items"][i]["quantity"];
												if (item_id == intitemid)
												{
													if (inputhowmuchint > item_Count)
													{
														Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4the player doesn't have that much.", 0, true);
														break;
													}
													if (item_Count == inputhowmuchint)
													{
														j["items"][i]["itemid"] = 0;
														j["items"][i]["quantity"] = 0;
													}
													else
													{
														j["items"][i]["quantity"] = j["items"][i]["quantity"].get<double>() - inputhowmuchint;
													}

													Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`2" + to_string(inputhowmuchint) + " " + itemDefs[intitemid].name + " were removed for the " + growid + ".", 0, true);
													ofstream warnslog("logs/removeinventoryitem.txt", ios::app);
													warnslog << "administrator " << static_cast<PlayerInfo*>(peer->data)->rawName << " has removed in offline " << to_string(inputhowmuchint) << " " << itemDefs[intitemid].name << " from " << growid << " inventory." << endl;
													warnslog.close();
													std::ofstream ofs("inventory/" + growid + ".json");
													ofs << j;
													ofs.close();
													break;
												}
											}
										}
										catch (std::exception&)
										{
											SendConsole("removeofflineplayeritemConfirmInput Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
											enet_peer_disconnect_now(peer, 0);
										}
										catch (std::runtime_error&)
										{
											SendConsole("removeofflineplayeritemConfirmInput Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
											enet_peer_disconnect_now(peer, 0);
										}
										catch (...)
										{
											SendConsole("removeofflineplayeritemConfirmInput Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
											enet_peer_disconnect_now(peer, 0);
										}
									}
									else
									{
										Player::OnTextOverlay(peer, "`#This user does not have inventory!");
									}
								}
							}
						}
						if (btn.substr(0, 21) == "safeBoxDepositedItem_")
						{
							if (world == nullptr || world->name == "EXIT" || serverIsFrozen) continue;
							if (static_cast<PlayerInfo*>(peer->data)->rawName == PlayerDB::getProperName(world->owner) || world->owner == "" || isMod(peer))
							{
								string apos_and_coord = btn.erase(0, 21);
								string::size_type pos = apos_and_coord.find('_');
								string apos = "";
								string coord = "";

								if (pos != std::string::npos)
								{
									apos = apos_and_coord.substr(0, pos);
									apos_and_coord.erase(0, pos + 1);
									coord = apos_and_coord;
								}
								else
								{
									autoBan(peer, false, 24 * 7, "Incorrect parameters safeBoxDepositedItem_. apos and coord were: " + apos_and_coord);
									break;
								}
								auto isdbox = std::experimental::filesystem::exists("safevault/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
								if (!isdbox)
								{
									Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4An error occured while getting safe vault info.", 0, true);
									break;
								}

								bool contains_non_int3 = !std::regex_match(apos, std::regex("^[0-9]+$"));
								if (contains_non_int3 == true)
								{
									autoBan(peer, false, 24 * 7, "Proxy detect! safeBoxDepositedItem_ apos was: " + apos);
									break;
								}

								try
								{
									ifstream ifff("safevault/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
									json j;
									ifff >> j;
									ifff.close();

									int itemid = 0;
									int count = 0;
									for (int i = 0; i < 20; i++)
									{
										if (j["safe"][i]["aposition"] == atoi(apos.c_str()))
										{
											itemid = j["safe"][i]["itemid"];
											count = j["safe"][i]["itemcount"];
											GTDialog mySafe;
											mySafe.addLabelWithIcon("`wSafe Vault", 8878, LABEL_BIG);
											mySafe.addSmallText("`oYou have `w" + to_string(count) + " " + itemDefs[itemid].name + " `ostored.");
											mySafe.addSmallText("`oWithdraw how many?");
											mySafe.addInputBox("safewithdraw_" + coord + "_" + apos, "", to_string(count), 5);
											mySafe.addSpacer(SPACER_SMALL);
											mySafe.addQuickExit();
											mySafe.endDialog("safe_withdrawConfirm", "Remove items", "Exit");
											Player::OnDialogRequest(peer, mySafe.finishDialog());
											break;
										}
									}
								}
								catch (std::exception&)
								{
									SendConsole("safeBoxDepositedItem_ Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
									enet_peer_disconnect_now(peer, 0);
								}
								catch (std::runtime_error&)
								{
									SendConsole("safeBoxDepositedItem_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
									enet_peer_disconnect_now(peer, 0);
								}
								catch (...)
								{
									SendConsole("safeBoxDepositedItem_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
									enet_peer_disconnect_now(peer, 0);
								}
							}
						}
						if (btn.substr(0, 29) == "saferecoverPasswordInConfirm_")
						{
							if (static_cast<PlayerInfo*>(peer->data)->rawName == PlayerDB::getProperName(world->owner) || world->owner == "" || isMod(peer))
							{
								if (world == nullptr || world->name == "EXIT" || serverIsFrozen) continue;
								string coord = btn.substr(btn.find("_") + 1);
								auto isdbox = std::experimental::filesystem::exists("safevault/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
								if (!isdbox)
								{
									Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4An error occured. Break the safe.", 0, true);
									break;
								}
								GTDialog recover;
								recover.addLabelWithIcon("`wSafe Vault", 8878, LABEL_BIG);
								recover.addSmallText("Please enter recovery answer.");
								recover.addInputBox("saferecoveryanswer_" + coord, "", "", 12);
								recover.addButton("saferecoveryanswerconfirm", "Enter Recovery Answer");
								recover.addSpacer(SPACER_SMALL);
								recover.addQuickExit();
								recover.endDialog("Close", "", "Exit");
								Player::OnDialogRequest(peer, recover.finishDialog());
							}
						}
						if (btn == "saferecoveryanswerconfirm")
						{
							if (world == nullptr || world->name == "EXIT" || serverIsFrozen) continue;
							std::stringstream bss(cch);
							std::string bto;

							string recoveryanswer = "";
							string coord = "";

							while (std::getline(bss, bto, '\n'))
							{
								vector<string> infoDat = explode("|", bto);
								if (infoDat[0].substr(0, 19) == "saferecoveryanswer_")
								{
									if (static_cast<PlayerInfo*>(peer->data)->rawName == PlayerDB::getProperName(world->owner) || world->owner == "" || isMod(peer))
									{
										recoveryanswer = infoDat[1];
										coord = infoDat[0].substr(19, infoDat[0].length() - 1).c_str();
										auto isdbox = std::experimental::filesystem::exists("safevault/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
										if (!isdbox)
										{
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4An error occured. Break the safe.", 0, true);
											break;
										}
										try
										{
											ifstream ifff("safevault/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
											json j;
											ifff >> j;
											ifff.close();

											if (recoveryanswer != j["recovery"])
											{
												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4Recovery answer did not match!", 0, true);
												break;
											}

											j["password"] = "";
											j["recovery"] = "";
											ofstream of("safevault/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
											of << j << std::endl;
											of.close();

											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "Your safe vault was `2Updated!", 0, true);
										}
										catch (std::exception&)
										{
											SendConsole("saferecoveryanswer_ Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
											enet_peer_disconnect_now(peer, 0);
										}
										catch (std::runtime_error&)
										{
											SendConsole("saferecoveryanswer_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
											enet_peer_disconnect_now(peer, 0);
										}
										catch (...)
										{
											SendConsole("saferecoveryanswer_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
											enet_peer_disconnect_now(peer, 0);
										}
									}
								}
							}
						}
						if (btn == "safe_updatepassword")
						{
							if (world == nullptr || world->name == "EXIT" || serverIsFrozen) continue;
							std::stringstream bss(cch);
							std::string bto;

							string inputoldpass = "";
							string coord = "";
							string newpass = "";
							string recans = "";

							while (std::getline(bss, bto, '\n'))
							{
								vector<string> infoDat = explode("|", bto);
								if (infoDat[0].substr(0, 16) == "safeoldpassword_")
								{
									if (static_cast<PlayerInfo*>(peer->data)->rawName == PlayerDB::getProperName(world->owner) || world->owner == "" || isMod(peer))
									{
										inputoldpass = infoDat[1];
										coord = infoDat[0].substr(16, infoDat[0].length() - 1).c_str();
										auto isdbox = std::experimental::filesystem::exists("safevault/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
										if (!isdbox)
										{
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4An error occured. Break the safe.", 0, true);
											break;
										}
										try
										{
											ifstream ifff("safevault/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
											json j;
											ifff >> j;
											ifff.close();

											if (j["password"] != inputoldpass)
											{
												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4Old password did not match", 0, true);
												break;
											}
										}
										catch (std::exception&)
										{
											SendConsole("safeoldpassword_ Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
											enet_peer_disconnect_now(peer, 0);
										}
										catch (std::runtime_error&)
										{
											SendConsole("safeoldpassword_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
											enet_peer_disconnect_now(peer, 0);
										}
										catch (...)
										{
											SendConsole("safeoldpassword_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
											enet_peer_disconnect_now(peer, 0);
										}
									}
								}
								if (infoDat[0] == "safe_newpassword")
								{
									if (static_cast<PlayerInfo*>(peer->data)->rawName == PlayerDB::getProperName(world->owner) || world->owner == "" || isMod(peer))
									{
										newpass = infoDat[1];
									}
								}
								if (infoDat[0] == "storage_recoveryanswer")
								{
									if (static_cast<PlayerInfo*>(peer->data)->rawName == PlayerDB::getProperName(world->owner) || world->owner == "" || isMod(peer))
									{
										recans = infoDat[1];

										try
										{
											ifstream ifff("safevault/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
											json j;
											ifff >> j;
											ifff.close();

											j["password"] = newpass;
											j["recovery"] = recans;
											ofstream of("safevault/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
											of << j << std::endl;
											of.close();

											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "Your safe vault was `2Updated!", 0, true);
										}
										catch (std::exception&)
										{
											SendConsole("storage_recoveryanswer Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
											enet_peer_disconnect_now(peer, 0);
										}
										catch (std::runtime_error&)
										{
											SendConsole("storage_recoveryanswer Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
											enet_peer_disconnect_now(peer, 0);
										}
										catch (...)
										{
											SendConsole("storage_recoveryanswer Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
											enet_peer_disconnect_now(peer, 0);
										}
									}
								}
							}
						}
						if (btn == "safe_removepassword")
						{
							if (world == nullptr || world->name == "EXIT" || serverIsFrozen) continue;
							std::stringstream bss(cch);
							std::string bto;

							string inputoldpass = "";
							string coord = "";

							while (std::getline(bss, bto, '\n'))
							{
								vector<string> infoDat = explode("|", bto);
								if (infoDat[0].substr(0, 16) == "safeoldpassword_")
								{
									if (static_cast<PlayerInfo*>(peer->data)->rawName == PlayerDB::getProperName(world->owner) || world->owner == "" || isMod(peer))
									{
										inputoldpass = infoDat[1];
										coord = infoDat[0].substr(16, infoDat[0].length() - 1).c_str();
										auto isdbox = std::experimental::filesystem::exists("safevault/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
										if (!isdbox)
										{
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4An error occured. Break the safe.", 0, true);
											break;
										}
										try
										{
											ifstream ifff("safevault/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
											json j;
											ifff >> j;
											ifff.close();

											if (j["password"] != inputoldpass)
											{
												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4Old password did not match", 0, true);
												break;
											}

											j["password"] = "";
											j["recovery"] = "";
											ofstream of("safevault/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
											of << j << std::endl;
											of.close();

											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "Your safe vault is no longer `4Password Protected`o!", 0, true);
										}
										catch (std::exception&)
										{
											SendConsole("safeoldpassword_ Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
											enet_peer_disconnect_now(peer, 0);
										}
										catch (std::runtime_error&)
										{
											SendConsole("safeoldpassword_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
											enet_peer_disconnect_now(peer, 0);
										}
										catch (...)
										{
											SendConsole("safeoldpassword_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
											enet_peer_disconnect_now(peer, 0);
										}
									}
								}
							}
						}
						if (btn == "safe_setpassword")
						{
							if (world == nullptr || world->name == "EXIT" || serverIsFrozen) continue;
							std::stringstream bss(cch);
							std::string bto;

							string inputnewpass = "";
							string coord = "";
							string inputnewrecoveryans = "";

							while (std::getline(bss, bto, '\n'))
							{
								vector<string> infoDat = explode("|", bto);
								if (infoDat[0].substr(0, 12) == "safenewpass_")
								{
									if (static_cast<PlayerInfo*>(peer->data)->rawName == PlayerDB::getProperName(world->owner) || world->owner == "" || isMod(peer))
									{
										inputnewpass = infoDat[1];
										coord = infoDat[0].substr(12, infoDat[0].length() - 1).c_str();
										auto isdbox = std::experimental::filesystem::exists("safevault/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
										if (!isdbox)
										{
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4An error occured. Break the safe.", 0, true);
											break;
										}

										if (inputnewpass.size() < 2)
										{
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4Your password is too easy.", 0, true);
											break;
										}
									}
								}
								if (infoDat[0] == "safe_recoverypass")
								{
									if (static_cast<PlayerInfo*>(peer->data)->rawName == PlayerDB::getProperName(world->owner) || world->owner == "" || isMod(peer))
									{
										inputnewrecoveryans = infoDat[1];

										if (inputnewpass.size() < 2)
										{
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4Your recovery answer is too easy.", 0, true);
											break;
										}

										try
										{
											ifstream ifff("safevault/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
											json j;
											ifff >> j;
											ifff.close();
											j["password"] = inputnewpass;
											j["recovery"] = inputnewrecoveryans;

											ofstream of("safevault/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
											of << j << std::endl;
											of.close();

											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "Your safe vault is now `2Password Protected`o!", 0, true);
										}
										catch (std::exception&)
										{
											SendConsole("safe_recoverypass Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
											enet_peer_disconnect_now(peer, 0);
										}
										catch (std::runtime_error&)
										{
											SendConsole("safe_recoverypass Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
											enet_peer_disconnect_now(peer, 0);
										}
										catch (...)
										{
											SendConsole("safe_recoverypass Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
											enet_peer_disconnect_now(peer, 0);
										}
									}
								}
							}
						}

						if (btn == "safe_confirmpass")
						{
							if (world == nullptr || world->name == "EXIT" || serverIsFrozen) continue;
							std::stringstream bss(cch);
							std::string bto;

							string inputpass = "";

							while (std::getline(bss, bto, '\n'))
							{
								vector<string> infoDat = explode("|", bto);
								if (infoDat[0].substr(0, 21) == "safeconfirmpassInput_")
								{
									inputpass = infoDat[1];
									if (static_cast<PlayerInfo*>(peer->data)->rawName == PlayerDB::getProperName(world->owner) || world->owner == "" || isMod(peer))
									{
										string coord = infoDat[0].substr(21, infoDat[0].length() - 1).c_str();
										auto isdbox = std::experimental::filesystem::exists("safevault/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
										if (!isdbox)
										{
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4An error occured. Break the safe.", 0, true);
											break;
										}
										try
										{
											ifstream ifff("safevault/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
											json j;
											ifff >> j;
											ifff.close();
											string basic_string = j["password"];
											if (inputpass != basic_string)
											{
												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4Password did not match", 0, true);
												break;
											}
											int stored = j["insafe"];

											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`2Password matched", 0, true);

											GTDialog mySafe;
											mySafe.addLabelWithIcon("`wSafe Vault", 8878, LABEL_BIG);

											if (stored > 0)
											{
												mySafe.addSpacer(SPACER_SMALL);
											}

											int count = 0;
											int id = 0;
											int aposition = 0;
											for (int i = 0; i < 20; i++)
											{
												if (j["safe"][i]["itemid"] != 0)
												{
													count = j["safe"][i]["itemcount"];
													id = j["safe"][i]["itemid"];
													aposition = j["safe"][i]["aposition"];

													if (i % 6 == 0 && i != 0)
													{
														mySafe.addStaticBlueFrameWithIdCountText(to_string(id), to_string(count), getItemDef(id).name, "safeBoxDepositedItem_" + to_string(aposition) + "_" + coord, true);
													}
													else
													{
														mySafe.addStaticBlueFrameWithIdCountText(to_string(id), to_string(count), getItemDef(id).name, "safeBoxDepositedItem_" + to_string(aposition) + "_" + coord, false);
													}
												}
											}

											if (stored > 0)
											{
												mySafe.addNewLineAfterFrame();
											}

											mySafe.addSmallText("`w" + to_string(stored) + "/20 `$items stored.");
											mySafe.addSpacer(SPACER_SMALL);
											mySafe.addPicker("safedeposit_" + coord, "Deposit item", "Select an item");
											if (j["password"] == "")
											{
												mySafe.addSmallText("`$This Safe Vault is not `4password protected`$!");
											}
											else
											{
												mySafe.addSmallText("`$This Safe Vault is `2password protected`$!");
											}
											mySafe.addSpacer(SPACER_SMALL);
											mySafe.addSmallText("`$Change your password.");
											mySafe.addButton("safeupdatepass_" + coord, "Update Password");

											mySafe.addSpacer(SPACER_SMALL);
											mySafe.addQuickExit();
											mySafe.endDialog("Close", "", "Exit");
											Player::OnDialogRequest(peer, mySafe.finishDialog());
										}
										catch (std::exception&)
										{
											SendConsole("safeconfirmpassInput_ Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
											enet_peer_disconnect_now(peer, 0);
										}
										catch (std::runtime_error&)
										{
											SendConsole("safeconfirmpassInput_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
											enet_peer_disconnect_now(peer, 0);
										}
										catch (...)
										{
											SendConsole("safeconfirmpassInput_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
											enet_peer_disconnect_now(peer, 0);
										}
										break;
									}
								}
							}
						}
						if (btn == "entermystore")
						{
							if (world == nullptr || world->name == "EXIT" || serverIsFrozen) continue;
							GTDialog myStore;
							myStore.addLabelWithIcon("`wMy store", 1430, LABEL_BIG);
							myStore.addSpacer(SPACER_SMALL);
							bool existx = std::experimental::filesystem::exists("store/" + PlayerDB::getProperName(static_cast<PlayerInfo*>(peer->data)->rawName) + ".json");
							if (!existx)
							{
								myStore.addSmallText("`wYou don't have store right now. You can create it for 150.000 gems.");
								myStore.addSpacer(SPACER_SMALL);
								myStore.addButton("createstore", "Create my store.");
							}
							else
							{
								try
								{
									ifstream ifff("store/" + PlayerDB::getProperName(static_cast<PlayerInfo*>(peer->data)->rawName) + ".json");
									json j;
									ifff >> j;
									ifff.close();
									string ownedFgItemID = "2";
									string ownedStoreName = "0";
									int currentSpaceInStore = 0;
									ownedFgItemID = j["fg"].get<string>();
									ownedStoreName = j["name"].get<string>();
									currentSpaceInStore = j["currentSpaceInStore"];
									int upgradeFor = 0;
									if (currentSpaceInStore < 20)
									{
										if (currentSpaceInStore == 5) upgradeFor = 150000 * 2;
										else if (currentSpaceInStore == 10) upgradeFor = (150000 * 2) * 2;
										else if (currentSpaceInStore == 15) upgradeFor = ((150000 * 2) * 2) * 2;
										myStore.addSmallText("`wYou can upgrade your current space from " + to_string(currentSpaceInStore) + " to " + to_string(currentSpaceInStore + 5) + " in your store to place more items for " + to_string(upgradeFor));
										myStore.addButton("upgradeCurrentSpace", "Upgrade for " + to_string(upgradeFor));
									}
									else
									{
										myStore.addSmallText("`wYour store items space is maxed(20)!");
									}
									myStore.addSpacer(SPACER_SMALL);
									if (j["newLogs"] > 0)
									{
										myStore.addSmallText("`2There are new notifications in your store.");
										myStore.addButton("readStoreNotifications", "Read them.");
									}
									else
									{
										myStore.addSmallText("`4There are no new notifications in your store.");
									}
									myStore.addSpacer(SPACER_SMALL);
									myStore.addSmallText("`$Placed items in your store:");
									myStore.addPicker("addItemToStore", "Add item for sale", "Which item you wanna place on sale?");
									int kiekItemuBus = 0;
									int id;
									int kiekis;
									int aPosition;
									for (int i = 0; i < j["itemsInStore"].size(); i++)
									{
										if (j["itemsInStore"][i]["itemid"] != 0)
										{
											kiekItemuBus++;
											aPosition = j["itemsInStore"][i]["aposition"];
											id = j["itemsInStore"][i]["itemid"];
											kiekis = j["itemsInStore"][i]["quantityOfItems"];

											if (i % 6 == 0 && i != 0)
											{
												myStore.addStaticBlueFrame(to_string(id), to_string(kiekis), "myStoreItemEnter_" + to_string(aPosition), true);
											}
											else
											{
												myStore.addStaticBlueFrame(to_string(id), to_string(kiekis), "myStoreItemEnter_" + to_string(aPosition), false);
											}
										}
									}
									if (kiekItemuBus == 0)
									{
										myStore.addSmallText("`4There are no items placed in your store! `$You can add for sale some.");
									}
									else
									{
										myStore.addNewLineAfterFrame();
									}
									myStore.addSpacer(SPACER_SMALL);
									myStore.addSmallText("`2Tired of selling items? `4You can Abandon from your store.");
									myStore.addButton("abandonStore", "Abandon");
									myStore.addSpacer(SPACER_SMALL);
								}
								catch (std::exception&)
								{
									SendConsole("entermystore Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
									enet_peer_disconnect_now(peer, 0);
								}
								catch (std::runtime_error&)
								{
									SendConsole("entermystore Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
									enet_peer_disconnect_now(peer, 0);
								}
								catch (...)
								{
									SendConsole("entermystore Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
									enet_peer_disconnect_now(peer, 0);
								}
							}
							myStore.addSpacer(SPACER_SMALL);
							myStore.addQuickExit();
							myStore.endDialog("Close", "", "Close my store");
							Player::OnDialogRequest(peer, myStore.finishDialog());
						}
						if (btn == "pickupdisplayitem")
						{
							if (world == nullptr || world->name == "EXIT" || serverIsFrozen) continue;
							if (static_cast<PlayerInfo*>(peer->data)->rawName == world->owner || world->owner == "")
							{
								WorldInfo* targetworld = getPlyersWorld(peer);
								string world = static_cast<PlayerInfo*>(peer->data)->currentWorld;
								short dfg = static_cast<PlayerInfo*>(peer->data)->displayfg;
								short dbg = static_cast<PlayerInfo*>(peer->data)->displaybg;
								int x = static_cast<PlayerInfo*>(peer->data)->displaypunchx;
								int y = static_cast<PlayerInfo*>(peer->data)->displaypunchy;
								static_cast<PlayerInfo*>(peer->data)->displayfg = 0;
								static_cast<PlayerInfo*>(peer->data)->displaybg = 0;
								static_cast<PlayerInfo*>(peer->data)->displaypunchx = 0;
								static_cast<PlayerInfo*>(peer->data)->displaypunchy = 0;
								if (targetworld->items[x + (y * targetworld->width)].intdata != 0)
								{
									Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wYou removed `5" + getItemDef(targetworld->items[x + (y * targetworld->width)].intdata).name + " `wfrom the Display Block.", 0, true);
									bool success = true;
									SaveItemMoreTimes(targetworld->items[x + (y * targetworld->width)].intdata, 1, peer, success);
									targetworld->items[x + (y * targetworld->width)].intdata = 0;
									ENetPeer* currentPeer;
									for (currentPeer = server->peers;
										currentPeer < &server->peers[server->peerCount];
										++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
											continue;
										if (isHere(peer, currentPeer))
										{
											UpdateVisualsForBlock(currentPeer, true, x, y, targetworld);
										}
									}
								}
								else
								{
									Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "Error occured while trying to remove item!", 0, true);
									continue;
								}
							}
							else
							{
								autoBan(peer, true, 24, "yes");
							}
						}
						if (btn == "createstore")
						{
							if (world == nullptr || world->name == "EXIT" || serverIsFrozen) continue;
							bool existx = std::experimental::filesystem::exists("store/" + PlayerDB::getProperName(static_cast<PlayerInfo*>(peer->data)->rawName) + ".json");
							if (existx)
							{
								continue;
							}
							GTDialog store;
							store.addLabelWithIcon("`wCreate your store!", 1430, LABEL_SMALL);
							store.addSpacer(SPACER_SMALL);
							store.addLabelWithIcon("`wWarning: to create your own store you need 40000 gems. You will be able to sell all items from your inventory.", 1434, LABEL_SMALL);
							store.addSpacer(SPACER_SMALL);
							store.addInputBox("createstorefg", "Enter foreground id", "", 4);
							store.addInputBox("createstorename", "Enter store name", "", 20);
							store.addInputBox("createstoredesc", "Enter description", "", 50);
							store.addSpacer(SPACER_SMALL);
							store.addQuickExit();
							store.endDialog("createstoreconfirm", "Create store", "Cancel");
							Player::OnDialogRequest(peer, store.finishDialog());
						}
						if (btn == "upgradeCurrentSpace")
						{
							if (world == nullptr || world->name == "EXIT" || serverIsFrozen) continue;
							bool existx = std::experimental::filesystem::exists("store/" + PlayerDB::getProperName(static_cast<PlayerInfo*>(peer->data)->rawName) + ".json");
							if (!existx)
							{
								continue;
							}

							try
							{
								ifstream ifff("store/" + PlayerDB::getProperName(static_cast<PlayerInfo*>(peer->data)->rawName) + ".json");
								json j;
								ifff >> j;
								ifff.close();

								int currentSpaceInStore = j["currentSpaceInStore"];

								int upgradeFor = 0;

								if (currentSpaceInStore < 20)
								{
									if (currentSpaceInStore == 5) upgradeFor = 150000 * 2;
									else if (currentSpaceInStore == 10) upgradeFor = (150000 * 2) * 2;
									else if (currentSpaceInStore == 15) upgradeFor = ((150000 * 2) * 2) * 2;
									std::ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									std::string content((std::istreambuf_iterator<char>(ifsz)),
										(std::istreambuf_iterator<char>()));
									int b = atoi(content.c_str());
									if (b >= upgradeFor)
									{
										int gemcalc10k = b - upgradeFor;
										ofstream myfile2;
										myfile2.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										myfile2 << std::to_string(gemcalc10k);
										myfile2.close();
										std::ifstream ifszi("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										std::string contentx((std::istreambuf_iterator<char>(ifszi)),
											(std::istreambuf_iterator<char>()));
										int updgem = atoi(contentx.c_str());
										GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), updgem));
										ENetPacket* packetpp = enet_packet_create(pp.data,
											pp.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetpp);
										delete pp.data;

										j["currentSpaceInStore"] = currentSpaceInStore + 5;

										std::ofstream oo("store/" + PlayerDB::getProperName(static_cast<PlayerInfo*>(peer->data)->rawName) + ".json");
										if (!oo.is_open()) continue;
										oo << j << std::endl;

										Player::OnConsoleMessage(peer, "`2You have succeessfully increased your store items space to `$" + to_string(currentSpaceInStore + 5) + " `2for " + to_string(upgradeFor));
									}
									else
									{
										GamePacket pto = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`4You don't have enough gems."));
										ENetPacket* packetto = enet_packet_create(pto.data,
											pto.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetto);
										delete pto.data;
										continue;
									}
								}
								else
								{
									Player::OnTextOverlay(peer, "`#Current Space in store is already full!");
								}
							}
							catch (std::exception&)
							{
								SendConsole("upgradeCurrentSpace Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
								enet_peer_disconnect_now(peer, 0);
							}
							catch (std::runtime_error&)
							{
								SendConsole("upgradeCurrentSpace Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
								enet_peer_disconnect_now(peer, 0);
							}
							catch (...)
							{
								SendConsole("upgradeCurrentSpace Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
								enet_peer_disconnect_now(peer, 0);
							}
						}
						if (btn == "readStoreNotifications")
						{
							if (world == nullptr || world->name == "EXIT" || serverIsFrozen) continue;
							bool existx = std::experimental::filesystem::exists("store/" + PlayerDB::getProperName(static_cast<PlayerInfo*>(peer->data)->rawName) + ".json");
							if (!existx)
							{
								continue;
							}

							try
							{
								ifstream ifff("store/" + PlayerDB::getProperName(static_cast<PlayerInfo*>(peer->data)->rawName) + ".json");
								json j;
								ifff >> j;
								ifff.close();

								GTDialog notifications;
								notifications.addLabelWithIcon("`wNotifications!", 1430, LABEL_SMALL);

								string log;
								for (int i = 0; i < j["logs"].size(); i++)
								{
									notifications.addSpacer(SPACER_SMALL);
									log = j["logs"][i].get<string>();
									log.erase(std::remove(log.begin(), log.end(), '\n'), log.end());
									notifications.addSmallText("`$" + to_string(i + 1) + ") `#" + log);
								}
								notifications.addSpacer(SPACER_SMALL);
								notifications.addQuickExit();
								notifications.endDialog("Close", "", "Close notifications");
								Player::OnDialogRequest(peer, notifications.finishDialog());

								j["newLogs"] = 0;

								std::ofstream oo("store/" + PlayerDB::getProperName(static_cast<PlayerInfo*>(peer->data)->rawName) + ".json");
								if (!oo.is_open()) continue;
								oo << j << std::endl;
							}
							catch (std::exception&)
							{
								SendConsole("readStoreNotifications Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
								enet_peer_disconnect_now(peer, 0);
							}
							catch (std::runtime_error&)
							{
								SendConsole("readStoreNotifications Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
								enet_peer_disconnect_now(peer, 0);
							}
							catch (...)
							{
								SendConsole("readStoreNotifications Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
								enet_peer_disconnect_now(peer, 0);
							}
						}
						if (btn == "abandonStore")
						{
							if (world == nullptr || world->name == "EXIT" || serverIsFrozen) continue;
							GTDialog abandon;
							abandon.addLabelWithIcon("`wAre you sure?", 1430, LABEL_SMALL);
							abandon.addSmallText("`$Are you sure that you want to abandon from your store?");
							abandon.addSmallText("`#Note: make sure that you have withdrawn all earnings and removed all items from your store, otherwise, they will be removed.");
							abandon.addSpacer(SPACER_SMALL);
							abandon.addButton("confirmabandonStore", "Yes, abandon.");

							abandon.addQuickExit();
							abandon.endDialog("Close", "", "No, Close it.");
							Player::OnDialogRequest(peer, abandon.finishDialog());
						}
						if (btn == "confirmabandonStore")
						{
							if (world == nullptr || world->name == "EXIT" || serverIsFrozen) continue;
							bool existx = std::experimental::filesystem::exists("store/" + PlayerDB::getProperName(static_cast<PlayerInfo*>(peer->data)->rawName) + ".json");
							if (!existx)
							{
								continue;
							}

							remove(("store/" + PlayerDB::getProperName(static_cast<PlayerInfo*>(peer->data)->rawName) + ".json").c_str());

							try
							{
								ifstream iffff("storeinfo/stores.json");
								json j2;
								iffff >> j2;
								iffff.close();
								vector<string> allStores;
								for (int i = 0; i < j2["owners"].size(); i++)
								{
									allStores.push_back(j2["owners"][i]);
								}

								for (int i = 0; i < allStores.size(); i++)
								{
									if (allStores[i] == static_cast<PlayerInfo*>(peer->data)->rawName)
									{
										allStores.erase(std::remove(allStores.begin(), allStores.end(), static_cast<PlayerInfo*>(peer->data)->rawName), allStores.end());
									}
								}

								j2["owners"] = allStores;

								std::ofstream oo2("storeinfo/stores.json");
								if (!oo2.is_open()) continue;
								oo2 << j2 << std::endl;

								Player::OnTextOverlay(peer, "`bSuccessfully abandoned from the store!");
							}
							catch (std::exception&)
							{
								SendConsole("confirmabandonStore Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
								enet_peer_disconnect_now(peer, 0);
							}
							catch (std::runtime_error&)
							{
								SendConsole("confirmabandonStore Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
								enet_peer_disconnect_now(peer, 0);
							}
							catch (...)
							{
								SendConsole("confirmabandonStore Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
								enet_peer_disconnect_now(peer, 0);
							}
						}
						if (btn.substr(0, 10) == "storeitem_")
						{
							if (world == nullptr || world->name == "EXIT" || serverIsFrozen) continue;
							string whoseStore = btn.substr(btn.find("_") + 1);

							bool existx = std::experimental::filesystem::exists("store/" + PlayerDB::getProperName(whoseStore) + ".json");
							if (!existx)
							{
								Player::OnTextOverlay(peer, "`4 Store does not exist");
								continue;
							}

							try
							{
								ifstream ifff("store/" + PlayerDB::getProperName(whoseStore) + ".json");
								json j;
								ifff >> j;
								ifff.close();

								GTDialog playerStore;

								playerStore.addLabelWithIcon("`w" + whoseStore + "'s store.", 1434, LABEL_SMALL);
								playerStore.addSpacer(SPACER_SMALL);
								playerStore.addButton("storeReview_" + whoseStore + "", "Wanna write a review about this store?");
								playerStore.addSpacer(SPACER_SMALL);
								playerStore.addButton("storeReviewCheck_" + whoseStore + "", "Wanna check this store's reviews?");
								playerStore.addSpacer(SPACER_SMALL);
								playerStore.addSmallText("`$Store description: `#" + j["desc"].get<string>() + "");
								playerStore.addSpacer(SPACER_SMALL);
								playerStore.addSmallText("`$" + whoseStore + "'s selling items:");


								int kiekItemuBus = 0;
								int id;
								int kiekis;
								int aPosition;
								for (int i = 0; i < j["itemsInStore"].size(); i++)
								{
									if (j["itemsInStore"][i]["itemid"] != 0)
									{
										kiekItemuBus++;
										aPosition = j["itemsInStore"][i]["aposition"];
										id = j["itemsInStore"][i]["itemid"];
										kiekis = j["itemsInStore"][i]["quantityOfItems"];

										if (i % 6 == 0 && i != 0)
										{
											playerStore.addStaticBlueFrame(to_string(id), to_string(kiekis), "playerStoreItemEnter_" + to_string(aPosition) + "_" + whoseStore, true);
										}
										else
										{
											playerStore.addStaticBlueFrame(to_string(id), to_string(kiekis), "playerStoreItemEnter_" + to_string(aPosition) + "_" + whoseStore, false);
										}
									}
								}
								if (kiekItemuBus == 0)
								{
									playerStore.addSmallText("`4There are no items placed in this store!");
								}
								else
								{
									playerStore.addNewLineAfterFrame();
								}

								playerStore.addSpacer(SPACER_SMALL);

								playerStore.addQuickExit();
								playerStore.endDialog("Close", "", "Close " + whoseStore + "'s store.");
								Player::OnDialogRequest(peer, playerStore.finishDialog());
							}
							catch (std::exception&)
							{
								SendConsole("storeitem_ Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
								enet_peer_disconnect_now(peer, 0);
							}
							catch (std::runtime_error&)
							{
								SendConsole("storeitem_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
								enet_peer_disconnect_now(peer, 0);
							}
							catch (...)
							{
								SendConsole("storeitem_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
								enet_peer_disconnect_now(peer, 0);
							}
						}
						if (btn.substr(0, 12) == "storeReview_")
						{
							if (world == nullptr || world->name == "EXIT" || serverIsFrozen) continue;
							string whoseStore = btn.substr(btn.find("_") + 1);
							bool existx = std::experimental::filesystem::exists("store/" + PlayerDB::getProperName(whoseStore) + ".json");
							if (!existx)
							{
								Player::OnTextOverlay(peer, "`4Store does not exist");
								continue;
							}

							GTDialog playerReviewStore;

							playerReviewStore.addLabelWithIcon("`wApply a review for " + whoseStore + "'s store.", 1434, LABEL_SMALL);
							playerReviewStore.addInputBox("storeWriteReview_" + whoseStore + "", "Write a review:", "", 200);
							playerReviewStore.addInputBox("storeWriteReviewStar", "Rate store 0-5:", "", 2);
							playerReviewStore.addSpacer(SPACER_SMALL);

							playerReviewStore.addQuickExit();
							playerReviewStore.endDialog("storeReviewConfirm", "Apply a review", "Cancel");
							Player::OnDialogRequest(peer, playerReviewStore.finishDialog());
						}
						if (btn.substr(0, 17) == "storeReviewCheck_")
						{
							if (world == nullptr || world->name == "EXIT" || serverIsFrozen) continue;
							string whoseStore = btn.substr(btn.find("_") + 1);
							bool existx = std::experimental::filesystem::exists("store/" + PlayerDB::getProperName(whoseStore) + ".json");
							if (!existx)
							{
								Player::OnTextOverlay(peer, "`4Store does not exist");
								continue;
							}

							try
							{
								ifstream ifff("store/" + PlayerDB::getProperName(whoseStore) + ".json");
								json j;
								ifff >> j;
								ifff.close();

								GTDialog allReviews;
								allReviews.addLabelWithIcon("`wAll " + whoseStore + "'s reviews:", 1434, LABEL_SMALL);

								bool noReviews = true;
								for (int i = 0; i < 50; i++)
								{
									if (j["storeReview"][i]["sentBy"].get<string>() != "")
									{
										noReviews = false;

										string review = j["storeReview"][i]["review"].get<string>();
										string sendBy = j["storeReview"][i]["sentBy"].get<string>();
										int stars = j["storeReview"][i]["stars"];

										allReviews.addSmallText("`$" + sendBy + "`#(`$" + to_string(stars) + "/5`#): " + review + "");
										allReviews.addSpacer(SPACER_SMALL);
									}
								}

								if (noReviews == true)
								{
									allReviews.addSpacer(SPACER_SMALL);
									allReviews.addSmallText("`$There is no any reviews in this store.");
									allReviews.addSpacer(SPACER_SMALL);
								}

								allReviews.addQuickExit();
								allReviews.endDialog("Close", "", "Close " + whoseStore + "'s reviews.");
								Player::OnDialogRequest(peer, allReviews.finishDialog());
							}
							catch (std::exception&)
							{
								SendConsole("storeReviewCheck_ Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
								enet_peer_disconnect_now(peer, 0);
							}
							catch (std::runtime_error&)
							{
								SendConsole("storeReviewCheck_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
								enet_peer_disconnect_now(peer, 0);
							}
							catch (...)
							{
								SendConsole("storeReviewCheck_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
								enet_peer_disconnect_now(peer, 0);
							}
						}
						if (btn.substr(0, 17) == "myStoreItemEnter_")
						{
							if (world == nullptr || world->name == "EXIT" || serverIsFrozen) continue;
							string aposition = btn.substr(btn.find("_") + 1);
							if (aposition.size() > 9) continue;
							int ap = stoi(aposition);

							bool existx = std::experimental::filesystem::exists("store/" + PlayerDB::getProperName(static_cast<PlayerInfo*>(peer->data)->rawName) + ".json");
							if (!existx)
							{
								Player::OnTextOverlay(peer, "`4Store does not exist");
								continue;
							}

							try
							{
								ifstream ifff("store/" + PlayerDB::getProperName(static_cast<PlayerInfo*>(peer->data)->rawName) + ".json");
								json j;
								ifff >> j;
								ifff.close();

								bool found = false;

								for (int i = 0; i < j["itemsInStore"].size(); i++)
								{
									if (j["itemsInStore"][i]["aposition"] == ap)
									{
										int earned = j["itemsInStore"][i]["boughtItems"];
										GTDialog myStoreItem;
										myStoreItem.addLabelWithIcon("`w" + itemDefs[j["itemsInStore"][i]["itemid"]].name + " item's properties:", 1434, LABEL_SMALL);
										myStoreItem.addSpacer(SPACER_SMALL);
										myStoreItem.addButton("myStoreItemAddAll_" + aposition + "", "Add more " + itemDefs[j["itemsInStore"][i]["itemid"]].name + ".");
										myStoreItem.addButton("myStoreItemRemove_" + aposition + "", "Remove that item from selling.");
										myStoreItem.addButton("myStoreTakeBackItems_" + aposition + "", "Take them back to your inventory.");
										myStoreItem.addButton("myStoreWithdrawEarnings_" + aposition + "", "Withdraw earnings (" + to_string(earned) + ").");

										myStoreItem.addQuickExit();
										myStoreItem.endDialog("Close", "", "Cancel.");
										Player::OnDialogRequest(peer, myStoreItem.finishDialog());

										found = true;
										break;
									}
								}

								if (!found)
								{
									Player::OnTextOverlay(peer, "`4Item does not exist in your store");
									continue;
								}
							}
							catch (std::exception&)
							{
								SendConsole("myStoreItemEnter_ Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
								enet_peer_disconnect_now(peer, 0);
							}
							catch (std::runtime_error&)
							{
								SendConsole("myStoreItemEnter_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
								enet_peer_disconnect_now(peer, 0);
							}
							catch (...)
							{
								SendConsole("myStoreItemEnter_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
								enet_peer_disconnect_now(peer, 0);
							}
						}
						if (btn.substr(0, 18) == "myStoreItemAddAll_")
						{
							if (world == nullptr || world->name == "EXIT" || serverIsFrozen) continue;
							string aposition = btn.substr(btn.find("_") + 1);
							if (aposition.size() > 9) continue;
							int ap = stoi(aposition);

							bool existx = std::experimental::filesystem::exists("store/" + PlayerDB::getProperName(static_cast<PlayerInfo*>(peer->data)->rawName) + ".json");
							if (!existx)
							{
								Player::OnTextOverlay(peer, "`4Store does not exist");
								continue;
							}

							try
							{
								ifstream ifff("store/" + PlayerDB::getProperName(static_cast<PlayerInfo*>(peer->data)->rawName) + ".json");
								json j;
								ifff >> j;
								ifff.close();

								bool found = false;
								bool doesHave = false;
								int howManyHave = 0;

								for (int i = 0; i < j["itemsInStore"].size(); i++)
								{
									if (j["itemsInStore"][i]["aposition"] == ap)
									{
										SearchInventoryItem(peer, j["itemsInStore"][i]["itemid"], 1, doesHave);
										if (doesHave == false)
										{
											break;
										}

										howManyHave = GetQuantityOfItem(peer, j["itemsInStore"][i]["itemid"]);
										j["itemsInStore"][i]["quantityOfItems"] = j["itemsInStore"][i]["quantityOfItems"].get<double>() + howManyHave;
										RemoveInventoryItem(j["itemsInStore"][i]["itemid"], howManyHave, peer, true);

										std::ofstream oo("store/" + PlayerDB::getProperName(static_cast<PlayerInfo*>(peer->data)->rawName) + ".json");
										if (!oo.is_open()) break;
										oo << j << std::endl;

										Player::OnConsoleMessage(peer, "`2Successfully added all`1(`2" + to_string(howManyHave) + "`1)`2 " + itemDefs[j["itemsInStore"][i]["itemid"]].name + " from your inventory to your shop.");

										doesHave = true;
										found = true;
										break;
									}
								}

								if (!doesHave)
								{
									Player::OnTextOverlay(peer, "`4You don't have that item in your inventory.");
									continue;
								}

								if (!found)
								{
									Player::OnTextOverlay(peer, "`4Item does not exist in your store");
									continue;
								}
							}
							catch (std::exception&)
							{
								SendConsole("myStoreItemAddAll_ Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
								enet_peer_disconnect_now(peer, 0);
							}
							catch (std::runtime_error&)
							{
								SendConsole("myStoreItemAddAll_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
								enet_peer_disconnect_now(peer, 0);
							}
							catch (...)
							{
								SendConsole("myStoreItemAddAll_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
								enet_peer_disconnect_now(peer, 0);
							}
						}
						if (btn.substr(0, 18) == "myStoreItemRemove_")
						{
							if (world == nullptr || world->name == "EXIT" || serverIsFrozen) continue;
							string aposition = btn.substr(btn.find("_") + 1);
							if (aposition.size() > 9) continue;
							int ap = stoi(aposition);

							bool existx = std::experimental::filesystem::exists("store/" + PlayerDB::getProperName(static_cast<PlayerInfo*>(peer->data)->rawName) + ".json");
							if (!existx)
							{
								Player::OnTextOverlay(peer, "`4Store does not exist");
								continue;
							}

							try
							{
								ifstream ifff("store/" + PlayerDB::getProperName(static_cast<PlayerInfo*>(peer->data)->rawName) + ".json");
								json j;
								ifff >> j;
								ifff.close();

								bool found = false;
								bool earned = false;
								bool quantityOfItems = false;
								int quantityOfItemsHowMany = 0;

								for (int i = 0; i < j["itemsInStore"].size(); i++)
								{
									if (j["itemsInStore"][i]["aposition"] == ap)
									{
										found = true;
										if (j["itemsInStore"][i]["boughtItems"] > 0)
										{
											earned = true;
											break;
										}

										if (j["itemsInStore"][i]["quantityOfItems"] > 0)
										{
											quantityOfItems = true;
											quantityOfItemsHowMany = j["itemsInStore"][i]["quantityOfItems"];
											break;
										}

										j["itemsInStore"][i]["itemDesc"] = "";
										j["itemsInStore"][i]["itemid"] = 0;
										j["itemsInStore"][i]["sellForItem"] = 0;
										j["itemsInStore"][i]["sellPer"] = 0;

										std::ofstream oo("store/" + PlayerDB::getProperName(static_cast<PlayerInfo*>(peer->data)->rawName) + ".json");
										if (!oo.is_open()) break;
										oo << j << std::endl;

										Player::OnTextOverlay(peer, "`2Successfully removed from selling that item.");

										break;
									}
								}

								if (earned)
								{
									Player::OnTextOverlay(peer, "`4You have earned items here. Withdraw them first.");
									continue;
								}

								if (quantityOfItems)
								{
									Player::OnConsoleMessage(peer, "`4There are " + to_string(quantityOfItemsHowMany) + " items placed on your store. Take them back to your inventory.");
									continue;
								}

								if (!found)
								{
									Player::OnTextOverlay(peer, "`4Item does not exist in your store");
									continue;
								}
							}
							catch (std::exception&)
							{
								SendConsole("myStoreItemRemove_ Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
								enet_peer_disconnect_now(peer, 0);
							}
							catch (std::runtime_error&)
							{
								SendConsole("myStoreItemRemove_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
								enet_peer_disconnect_now(peer, 0);
							}
							catch (...)
							{
								SendConsole("myStoreItemRemove_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
								enet_peer_disconnect_now(peer, 0);
							}
						}

						if (btn.substr(0, 21) == "myStoreTakeBackItems_")
						{
							if (world == nullptr || world->name == "EXIT" || serverIsFrozen) continue;
							string aposition = btn.substr(btn.find("_") + 1);
							if (aposition.size() > 9) continue;
							int ap = stoi(aposition);

							bool existx = std::experimental::filesystem::exists("store/" + PlayerDB::getProperName(static_cast<PlayerInfo*>(peer->data)->rawName) + ".json");
							if (!existx)
							{
								Player::OnTextOverlay(peer, "`4Store does not exist");
								continue;
							}

							try
							{
								ifstream ifff("store/" + PlayerDB::getProperName(static_cast<PlayerInfo*>(peer->data)->rawName) + ".json");
								json j;
								ifff >> j;
								ifff.close();

								bool found = false;
								bool noHas = false;

								for (int i = 0; i < j["itemsInStore"].size(); i++)
								{
									if (j["itemsInStore"][i]["aposition"] == ap)
									{
										bool success = false;
										found = true;
										if (j["itemsInStore"][i]["quantityOfItems"] < 1)
										{
											noHas = true;
											break;
										}
										int howManyHas = j["itemsInStore"][i]["quantityOfItems"];

										if (CheckItemExists(peer, j["itemsInStore"][i]["itemid"]))
										{
											int currentlyHave = GetQuantityOfItem(peer, j["itemsInStore"][i]["itemid"]);
											if (j["itemsInStore"][i]["quantityOfItems"].get<double>() + currentlyHave < 201)
											{
												SaveItemMoreTimes(j["itemsInStore"][i]["itemid"], j["itemsInStore"][i]["quantityOfItems"], peer, success);
												j["itemsInStore"][i]["quantityOfItems"] = 0;
												Player::OnConsoleMessage(peer, "`2Successfully returned " + to_string(howManyHas) + " items of " + itemDefs[j["itemsInStore"][i]["itemid"]].name + ".\n0 items left.");
											}
											else
											{
												int kiekTrukstaIki200 = 200 - currentlyHave;
												SaveItemMoreTimes(j["itemsInStore"][i]["itemid"], kiekTrukstaIki200, peer, success);
												j["itemsInStore"][i]["quantityOfItems"] = j["itemsInStore"][i]["quantityOfItems"].get<double>() - kiekTrukstaIki200;
												howManyHas -= kiekTrukstaIki200;
												Player::OnConsoleMessage(peer, "`2Successfully returned " + to_string(kiekTrukstaIki200) + " items of " + itemDefs[j["itemsInStore"][i]["itemid"]].name + ".\n" + to_string(howManyHas) + " items left.");
											}
										}
										else
										{
											if (static_cast<PlayerInfo*>(peer->data)->inventory.items.size() == static_cast<PlayerInfo*>(peer->data)->currentInventorySize)
											{
												Player::OnTextOverlay(peer, "`4Your inventory is full! You can purchase an inventory upgrade in the shop.");
												break;
											}
											if (j["itemsInStore"][i]["quantityOfItems"] > 200)
											{
												SaveItemMoreTimes(j["itemsInStore"][i]["itemid"], 200, peer, success);
												j["itemsInStore"][i]["quantityOfItems"] = j["itemsInStore"][i]["quantityOfItems"].get<double>() - 200;
												howManyHas -= 200;
												Player::OnConsoleMessage(peer, "`2Successfully returned 200 items of " + itemDefs[j["itemsInStore"][i]["itemid"]].name + ".\n" + to_string(howManyHas) + " items left.");
											}
											else
											{
												SaveItemMoreTimes(j["itemsInStore"][i]["itemid"], j["itemsInStore"][i]["quantityOfItems"], peer, success);
												j["itemsInStore"][i]["quantityOfItems"] = 0;
												Player::OnConsoleMessage(peer, "`2Successfully returned " + to_string(howManyHas) + " items of " + itemDefs[j["itemsInStore"][i]["itemid"]].name + ".\n0 items left.");
											}
										}


										std::ofstream oo("store/" + PlayerDB::getProperName(static_cast<PlayerInfo*>(peer->data)->rawName) + ".json");
										if (!oo.is_open()) break;
										oo << j << std::endl;

										break;
									}
								}

								if (noHas)
								{
									Player::OnTextOverlay(peer, "`4You don't have more than 0 placed items.");
									continue;
								}

								if (!found)
								{
									Player::OnTextOverlay(peer, "`4Item does not exist in your store");
									continue;
								}
							}
							catch (std::exception&)
							{
								SendConsole("myStoreTakeBackItems_ Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
								enet_peer_disconnect_now(peer, 0);
							}
							catch (std::runtime_error&)
							{
								SendConsole("myStoreTakeBackItems_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
								enet_peer_disconnect_now(peer, 0);
							}
							catch (...)
							{
								SendConsole("myStoreTakeBackItems_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
								enet_peer_disconnect_now(peer, 0);
							}
						}
						if (btn.substr(0, 24) == "myStoreWithdrawEarnings_")
						{
							if (world == nullptr || world->name == "EXIT" || serverIsFrozen) continue;
							string aposition = btn.substr(btn.find("_") + 1);
							if (aposition.size() > 9) continue;
							int ap = stoi(aposition);

							bool existx = std::experimental::filesystem::exists("store/" + PlayerDB::getProperName(static_cast<PlayerInfo*>(peer->data)->rawName) + ".json");
							if (!existx)
							{
								Player::OnTextOverlay(peer, "`4Store does not exist");
								continue;
							}

							try
							{
								ifstream ifff("store/" + PlayerDB::getProperName(static_cast<PlayerInfo*>(peer->data)->rawName) + ".json");
								json j;
								ifff >> j;
								ifff.close();

								bool found = false;
								bool noearned = false;

								for (int i = 0; i < j["itemsInStore"].size(); i++)
								{
									if (j["itemsInStore"][i]["aposition"] == ap)
									{
										bool success = false;
										found = true;
										if (j["itemsInStore"][i]["boughtItems"] < 1)
										{
											noearned = true;
											break;
										}
										int howManyEarnings = j["itemsInStore"][i]["boughtItems"];

										if (CheckItemExists(peer, j["itemsInStore"][i]["sellForItem"]))
										{
											int currentlyHave = GetQuantityOfItem(peer, j["itemsInStore"][i]["sellForItem"]);
											if (j["itemsInStore"][i]["boughtItems"].get<double>() + currentlyHave < 201)
											{
												SaveItemMoreTimes(j["itemsInStore"][i]["sellForItem"], j["itemsInStore"][i]["boughtItems"], peer, success);
												j["itemsInStore"][i]["boughtItems"] = 0;
												Player::OnConsoleMessage(peer, "`2Successfully withdrawn " + to_string(howManyEarnings) + " earnings of " + itemDefs[j["itemsInStore"][i]["sellForItem"]].name + ".\n0 earnings left.");
											}
											else
											{
												int kiekTrukstaIki200 = 200 - currentlyHave;
												SaveItemMoreTimes(j["itemsInStore"][i]["sellForItem"], kiekTrukstaIki200, peer, success);
												j["itemsInStore"][i]["boughtItems"] = j["itemsInStore"][i]["boughtItems"].get<double>() - kiekTrukstaIki200;
												howManyEarnings -= kiekTrukstaIki200;
												Player::OnConsoleMessage(peer, "`2Successfully withdrawn " + to_string(kiekTrukstaIki200) + " earnings of " + itemDefs[j["itemsInStore"][i]["sellForItem"]].name + ".\n" + to_string(howManyEarnings) + " earnings left.");
											}
										}
										else
										{
											if (static_cast<PlayerInfo*>(peer->data)->inventory.items.size() == static_cast<PlayerInfo*>(peer->data)->currentInventorySize)
											{
												Player::OnTextOverlay(peer, "`4Your inventory is full! You can purchase an inventory upgrade in the shop.");
												break;
											}
											if (j["itemsInStore"][i]["boughtItems"] > 200)
											{
												SaveItemMoreTimes(j["itemsInStore"][i]["sellForItem"], 200, peer, success);
												j["itemsInStore"][i]["boughtItems"] = j["itemsInStore"][i]["boughtItems"].get<double>() - 200;
												howManyEarnings -= 200;
												Player::OnConsoleMessage(peer, "`2Successfully withdrawn 200 earnings of " + itemDefs[j["itemsInStore"][i]["sellForItem"]].name + ".\n" + to_string(howManyEarnings) + " earnings left.");
											}
											else
											{
												SaveItemMoreTimes(j["itemsInStore"][i]["sellForItem"], j["itemsInStore"][i]["boughtItems"], peer, success);
												j["itemsInStore"][i]["boughtItems"] = 0;
												Player::OnConsoleMessage(peer, "`2Successfully withdrawn " + to_string(howManyEarnings) + " earnings of " + itemDefs[j["itemsInStore"][i]["sellForItem"]].name + ".\n0 earnings left.");
											}
										}


										std::ofstream oo("store/" + PlayerDB::getProperName(static_cast<PlayerInfo*>(peer->data)->rawName) + ".json");
										if (!oo.is_open()) break;
										oo << j << std::endl;

										break;
									}
								}

								if (noearned)
								{
									Player::OnTextOverlay(peer, "`4You don't have earned items.");
									continue;
								}

								if (!found)
								{
									Player::OnTextOverlay(peer, "`4Item does not exist in your store");
									continue;
								}
							}
							catch (std::exception&)
							{
								SendConsole("myStoreWithdrawEarnings_ Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
								enet_peer_disconnect_now(peer, 0);
							}
							catch (std::runtime_error&)
							{
								SendConsole("myStoreWithdrawEarnings_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
								enet_peer_disconnect_now(peer, 0);
							}
							catch (...)
							{
								SendConsole("myStoreWithdrawEarnings_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
								enet_peer_disconnect_now(peer, 0);
							}
						}
						if (btn.substr(0, 21) == "playerStoreItemEnter_")
						{
							if (world == nullptr || world->name == "EXIT" || serverIsFrozen) continue;
							string pos_and_whoseStore = btn.erase(0, 21);
							string::size_type pos = pos_and_whoseStore.find('_');
							string apos = "";
							string whosStore = "";
							if (pos != std::string::npos)
							{
								apos = pos_and_whoseStore.substr(0, pos);
								pos_and_whoseStore.erase(0, pos + 1);
								whosStore = pos_and_whoseStore;
							}
							else
							{
								autoBan(peer, false, 24 * 7, "Incorrect parameters in btn playerStoreItemEnter_ . Was:" + pos_and_whoseStore);
								continue;
							}
							bool contains_non_int2 = !std::regex_match(apos, std::regex("^[0-9]+$"));
							if (contains_non_int2 == true)
							{
								autoBan(peer, false, 24 * 7, "Incorrect aPos in btn playerStoreItemEnter_ .Was: " + apos);
								continue;
							}
							bool existx = std::experimental::filesystem::exists("store/" + PlayerDB::getProperName(whosStore) + ".json");
							if (!existx)
							{
								Player::OnTextOverlay(peer, "`4Store does not exist");
								continue;
							}
							if (apos.size() > 9) continue;
							int a_pos = stoi(apos);
							try
							{
								ifstream ifff("store/" + PlayerDB::getProperName(whosStore) + ".json");
								json j;
								ifff >> j;
								ifff.close();
								GTDialog playerStore;
								bool found = false;
								bool error = false;
								bool error2 = false;
								for (int i = 0; i < j["itemsInStore"].size(); i++)
								{
									if (j["itemsInStore"][i]["aposition"] == a_pos)
									{
										found = true;
										if (j["itemsInStore"][i]["itemid"] == 0)
										{
											error = true;
											break;
										}
										if (j["itemsInStore"][i]["quantityOfItems"] == 0)
										{
											error2 = true;
											break;
										}
										int itemprice = j["itemsInStore"][i]["sellForItem"];
										int itempricePer = j["itemsInStore"][i]["sellPer"];
										int itemId = j["itemsInStore"][i]["itemid"];
										int quantity = j["itemsInStore"][i]["quantityOfItems"];
										playerStore.addLabelWithIcon("`w" + PlayerDB::getProperName(whosStore) + "'s store.", 1430, LABEL_BIG);
										playerStore.addSpacer(SPACER_SMALL);
										playerStore.addSmallText("`$Item's description: `#" + j["itemsInStore"][i]["itemDesc"].get<string>() + "");
										playerStore.addSpacer(SPACER_SMALL);
										playerStore.addSmallText("`$Selling item:");
										playerStore.addStaticBlueFrame(to_string(itemId), to_string(quantity), "askdganslda", false);
										playerStore.addNewLineAfterFrame();
										playerStore.addSpacer(SPACER_SMALL);
										playerStore.addSmallText("`$Price:");
										playerStore.addStaticBlueFrame(to_string(itemprice), to_string(itempricePer), "askdganslda", false);
										playerStore.addNewLineAfterFrame();
										playerStore.addSpacer(SPACER_SMALL);
										playerStore.addSpacer(SPACER_SMALL);
										playerStore.addInputBox("buyPlayerStoreQuantity_" + apos + "_" + whosStore, "How many buy? Price (1/" + to_string(itempricePer) + ")", "", 3);
										break;
									}
								}
								if (error)
								{
									Player::OnTextOverlay(peer, "`4Item does not exist in this store.");
									continue;
								}
								if (error2)
								{
									Player::OnTextOverlay(peer, "`4Item sold out.");
									continue;
								}
								if (!found)
								{
									Player::OnTextOverlay(peer, "`4Item does not exist in this store.");
									continue;
								}
								playerStore.addSpacer(SPACER_SMALL);
								playerStore.addQuickExit();
								playerStore.endDialog("buyPlayerStoreItem", "Buy item", "Cancel");
								Player::OnDialogRequest(peer, playerStore.finishDialog());
							}
							catch (std::exception&)
							{
								SendConsole("playerStoreItemEnter_ Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
								enet_peer_disconnect_now(peer, 0);
							}
							catch (std::runtime_error&)
							{
								SendConsole("playerStoreItemEnter_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
								enet_peer_disconnect_now(peer, 0);
							}
							catch (...)
							{
								SendConsole("playerStoreItemEnter_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
								enet_peer_disconnect_now(peer, 0);
							}
						}
						if (btn == "questkatana")
						{
							if (static_cast<PlayerInfo*>(peer->data)->rawName == world->owner || isMod(peer))
							{
								Player::OnDialogRequest(peer, "set_default_color|`o\n\nadd_label_with_icon|big|`#Quest For The Katana``|left|2592|0|0|\n\nadd_spacer|small|\nadd_textbox|`5Are you sure you want to start a `^Quest `5For the `cLegendary Katana`5? Theres no way to `@Undone `5That, Even if you will cancel `^Current Quest `5The `#Legendary Wizard `5Will be consumed!|\n\nadd_spacer|small|\nadd_button|startquestkatana|`9Start Quest For Legendary Katana|\nadd_button|chc0|`9Close|0|0|\nadd_quick_exit|");
							}
						}
						if (btn == "startquestkatana")
						{
							//if (static_cast<PlayerInfo*>(peer->data)->rawName == world->owner || isMod(peer))
							{
								ofstream fd("quests/currentquest/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
								fd << "Katana";
								fd.close();
								Player::OnTextOverlay(peer, "`#You have started `^Quest `#For the `cLegendary Katana`#!");
								int sQuest = 1;
								ifstream fileStream216("quests/currentqueststep/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
								fileStream216 >> sQuest;
								fileStream216.close();
								int s1Quest = 0;
								ifstream fileStream219("quests/katana/step1/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
								fileStream219 >> s1Quest;
								fileStream219.close();
								std::ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
								std::string content((std::istreambuf_iterator<char>(ifsz)),
									(std::istreambuf_iterator<char>()));
								int b = atoi(content.c_str());
								int togive = 3000000 - s1Quest;
								int cangive = b - togive;
								if (cangive >= 0)
								{
									cangive = 3000000 - s1Quest;
								}
								else
								{
									cangive = b;
								}
								Player::OnDialogRequest(peer, "set_default_color|`o\n\nadd_label_with_icon|big|`#Quest For The Katana``|left|2592|0|0|\n\nadd_spacer|small|\nadd_textbox|`5Your current step: `^" + to_string(sQuest) + "/5|\nadd_textbox|`5Step 1: Welcome adventurer, your first `^Quest `5Will be to bring me `43m `9Gems`5, Hope that not too much for you`5!|\nadd_textbox|`5Progress: `^" + to_string(s1Quest) + "/3000000 `5Gems|\nadd_button|s1sgemsgive|`9Give `^" + to_string(cangive) + " `9Gems|\nadd_button|chc0|`9Close|0|0|\nadd_quick_exit|");
							}
						}
						if (btn == "floatingitems")
						{
							if (world == nullptr || world->name == "EXIT" || serverIsFrozen) continue;
							string additems = "";
							int totalfloatinggems = 0;
							for (int i = 0; i < world->droppedItems.size(); i++)
							{
								//if (world->droppedItems.at(i).uid)
								int id = world->droppedItems.at(i).id;
								if (id == 112)
								{
									totalfloatinggems += world->droppedItems.at(i).count;
									continue;
								}
								additems += "\nadd_label_with_icon_button||`w" + getItemDef(id).name + ": " + to_string(world->droppedItems.at(i).count) + "|left|" + to_string(world->droppedItems.at(i).id) + "|item" + to_string(id) + "|";
							}
							Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wWorld Items``|left|6016|\nadd_spacer|small|\nadd_textbox|`oPress on the icon to be directed to the location of the item.|\nadd_label_with_icon|small|`$Gems `ofloating in world: " + to_string(totalfloatinggems) + "|left|112||\nadd_spacer|small|" + additems + "\nadd_spacer|small|\nadd_button|goback|Back|\nend_dialog|growscan_float|||\n");
						}
						if (btn == "allowMod")
						{
							if (world == nullptr || world->name == "EXIT" || serverIsFrozen) continue;
							if (static_cast<PlayerInfo*>(peer->data)->rawName == getPlyersWorld(peer)->owner)
							{
								getPlyersWorld(peer)->allowMod = true;
								Player::OnConsoleMessage(peer, "`wWorld properties changed. World flags modified -> ALLOW-MOD = TRUE!");
								ENetPeer* currentPeer;
								for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									if (static_cast<PlayerInfo*>(peer->data)->currentWorld != "EXIT")
									{
										if (static_cast<PlayerInfo*>(peer->data)->currentWorld == static_cast<PlayerInfo*>(currentPeer->data)->currentWorld)
										{
											Player::OnConsoleMessage(currentPeer, "`2Owner `ohas `2enabled `5Mod-Noclip `oin this world.");
											if (isPlayer(currentPeer))
											{
												static_cast<PlayerInfo*>(currentPeer->data)->canWalkInBlocks = true;
												send_state(currentPeer);
											}
										}
									}
								}
							}
						}
						if (btn == "allowMod1")
						{
							if (world == nullptr || world->name == "EXIT" || serverIsFrozen) continue;
							if (static_cast<PlayerInfo*>(peer->data)->rawName == getPlyersWorld(peer)->owner)
							{
								getPlyersWorld(peer)->allowMod = false;
								Player::OnConsoleMessage(peer, "`wWorld properties changed. World flags modified -> ALLOW-MOD = FALSE!");
								ENetPeer* currentPeer;
								for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									if (static_cast<PlayerInfo*>(peer->data)->currentWorld != "EXIT")
									{
										if (static_cast<PlayerInfo*>(peer->data)->currentWorld == static_cast<PlayerInfo*>(currentPeer->data)->currentWorld)
										{
											Player::OnConsoleMessage(currentPeer, "`2Owner `ohas `4disabled `5Mod-Noclip `oin this world.");
											if (isPlayer(currentPeer))
											{
												static_cast<PlayerInfo*>(currentPeer->data)->canWalkInBlocks = false;
												static_cast<PlayerInfo*>(currentPeer->data)->skinColor = 0x8295C3FF;
												sendClothes(currentPeer);
												send_state(currentPeer);
											}
										}
									}
								}
							}
						}
						if (btn == "WorldDropPickup")
						{
							if (world == nullptr || world->name == "EXIT" || serverIsFrozen) continue;
							if (static_cast<PlayerInfo*>(peer->data)->rawName == getPlyersWorld(peer)->owner)
							{
								if (!getPlyersWorld(peer)->DisableDrop)
								{
									getPlyersWorld(peer)->DisableDrop = true;
									ofstream WorldSettings("misc/disabledrop/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + ".txt");
									WorldSettings << "true";
									WorldSettings.close();
									Player::OnConsoleMessage(peer, "`oVisitors can no longer collect dropped items!");
									ENetPeer* currentPeer;
									for (currentPeer = server->peers;
										currentPeer < &server->peers[server->peerCount];
										++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
										if (static_cast<PlayerInfo*>(peer->data)->rawName == getPlyersWorld(peer)->owner) continue;
										if (static_cast<PlayerInfo*>(peer->data)->currentWorld != "EXIT")
										{
											if (static_cast<PlayerInfo*>(peer->data)->currentWorld == static_cast<PlayerInfo*>(currentPeer->data)->currentWorld)
											{
												Player::OnConsoleMessage(currentPeer, "`oOwner has disabled ability to collect dropped items!");
											}
										}
									}
								}
								else
								{
									getPlyersWorld(peer)->DisableDrop = false;
									ofstream WorldSettings("misc/disabledrop/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + ".txt");
									WorldSettings << "false";
									WorldSettings.close();
									Player::OnConsoleMessage(peer, "`oVisitors can again collect dropped items!");
									ENetPeer* currentPeer;
									for (currentPeer = server->peers;
										currentPeer < &server->peers[server->peerCount];
										++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
										if (static_cast<PlayerInfo*>(peer->data)->rawName == getPlyersWorld(peer)->owner) continue;
										if (static_cast<PlayerInfo*>(peer->data)->currentWorld != "EXIT")
										{
											if (static_cast<PlayerInfo*>(peer->data)->currentWorld == static_cast<PlayerInfo*>(currentPeer->data)->currentWorld)
											{
												Player::OnConsoleMessage(currentPeer, "`oOwner has enabled ability to collect dropped items!");
											}
										}
									}
								}
							}
						}
						if (btn == "clearworldlogs")
						{
							if (world == nullptr || world->name == "EXIT" || serverIsFrozen) continue;
							if (static_cast<PlayerInfo*>(peer->data)->rawName == world->owner || isDev(peer))
							{
								ofstream fd("securitycam/logs/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + ".txt");
								fd << "";
								fd.close();
								Player::OnTextOverlay(peer, "world logs cleared!");
							}
						}
						if (btn == "s1sgemsgive")
						{
							//if (static_cast<PlayerInfo*>(peer->data)->rawName == world->owner)
							{
								std::ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
								std::string content((std::istreambuf_iterator<char>(ifsz)),
									(std::istreambuf_iterator<char>()));
								int b = atoi(content.c_str());
								int s1Quest = 0;
								ifstream fileStream216("quests/katana/step1/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
								fileStream216 >> s1Quest;
								fileStream216.close();
								int bendras = 3000000 - s1Quest;
								int cangive = b - bendras;
								int willgive = 0;
								if (cangive >= 0)
								{
									willgive = b - bendras;
									ofstream myfile2;
									myfile2.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									myfile2 << std::to_string(willgive);
									myfile2.close();
									std::ifstream ifszi("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									std::string contentx((std::istreambuf_iterator<char>(ifszi)),
										(std::istreambuf_iterator<char>()));
									int updgem = atoi(contentx.c_str());
									GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), updgem));
									ENetPacket* packetpp = enet_packet_create(pp.data,
										pp.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packetpp);
									delete pp.data;
									ofstream fd("quests/currentqueststep/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									fd << 2;
									fd.close();
									Player::OnTextOverlay(peer, "`#You have completed Step 1 For the `cLegendary Katana`#!");
								}
								else
								{
									willgive = 0;
									int alrdadded = 0;
									ifstream fileStream316("quests/katana/step1/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									fileStream316 >> alrdadded;
									fileStream316.close();
									int willaddnow = b + alrdadded;
									ofstream fileStream216("quests/katana/step1/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									fileStream216 << willaddnow;
									fileStream216.close();
									ofstream myfile2;
									myfile2.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									myfile2 << std::to_string(willgive);
									myfile2.close();
									std::ifstream ifszi("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									std::string contentx((std::istreambuf_iterator<char>(ifszi)),
										(std::istreambuf_iterator<char>()));
									int updgem = atoi(contentx.c_str());
									GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), updgem));
									ENetPacket* packetpp = enet_packet_create(pp.data,
										pp.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packetpp);
									delete pp.data;
									Player::OnTextOverlay(peer, "`#Thank you, keep it going`#!");
								}
							}
						}
						if (btn == "getremote")
						{
							if (world == nullptr || world->name == "EXIT" || serverIsFrozen) continue;
							int x = static_cast<PlayerInfo*>(peer->data)->lastPunchX;
							int y = static_cast<PlayerInfo*>(peer->data)->lastPunchY;
							int squaresign = x + (y * 100);
							string currentworld = static_cast<PlayerInfo*>(peer->data)->currentWorld + "X" + std::to_string(squaresign);
							int itemid = 0;
							ifstream fdss("magplant/storeditem/" + currentworld + ".txt");
							fdss >> itemid;
							fdss.close();
							int count = 0;
							ifstream fdss3("magplant/count/" + currentworld + ".txt");
							fdss3 >> count;
							fdss3.close();
							bool canuseremote = false;
							if (!isWorldOwner(peer, world) && !isMod(peer))
							{
								for (int i = 0; i < world->width * world->height; i++)
								{
									if (world->items[i].foreground == 2408)
									{
										int bfgitem = 0;
										ifstream fdss("bfg/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "X" + to_string(i) + ".txt");
										fdss >> bfgitem;
										fdss.close();
										if (itemid == bfgitem) canuseremote = true;
										break;
									}
								}
							}
							else
							{
								canuseremote = true;
							}
							if (!canuseremote)
							{
								Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wRemote cannot be taken because the block isnt a bfg", 0, true);
							}
							if (canuseremote)
							{
								if (static_cast<PlayerInfo*>(peer->data)->inventory.items.size() == static_cast<PlayerInfo*>(peer->data)->currentInventorySize)
								{
									Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wInventory is full!", 0, true);
									continue;
								}
								bool iscontainss = false;
								SearchInventoryItem(peer, 5640, 1, iscontainss);
								if (!iscontainss)
								{
									if (itemid != 0 && count != 0)
									{
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wYou received a MAGPLANT 5000 Remote.", 0, true);
										bool success = true;
										SaveItemMoreTimes(5640, 1, peer, success);
										static_cast<PlayerInfo*>(peer->data)->magplantitemid = itemid;
										static_cast<PlayerInfo*>(peer->data)->magplantx = x;
										static_cast<PlayerInfo*>(peer->data)->magplanty = y;
									}
								}
								else
								{
									static_cast<PlayerInfo*>(peer->data)->magplantitemid = itemid;
									static_cast<PlayerInfo*>(peer->data)->magplantx = x;
									static_cast<PlayerInfo*>(peer->data)->magplanty = y;
									Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wYou received a MAGPLANT 5000 Remote.", 0, true);
								}
							}
						}
						if (btn == "retrieveitem")
						{
							if (world == nullptr || world->name == "EXIT" || serverIsFrozen) continue;
							int x = static_cast<PlayerInfo*>(peer->data)->lastPunchX;
							int y = static_cast<PlayerInfo*>(peer->data)->lastPunchY;
							int suckerid = static_cast<PlayerInfo*>(peer->data)->suckerid;
							string suckername = static_cast<PlayerInfo*>(peer->data)->suckername;
							int squaresign = x + (y * 100);
							string currentworld = static_cast<PlayerInfo*>(peer->data)->currentWorld + "X" + std::to_string(squaresign);
							int itemid = 0;
							ifstream fdss(suckername + "/storeditem/" + currentworld + ".txt");
							fdss >> itemid;
							fdss.close();
							int count = 0;
							ifstream fdss3(suckername + "/count/" + currentworld + ".txt");
							if (fdss3.fail())
							{
								Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4An error occured, while trying to get information from " + currentworld + ".txt file.\nPlease report it to developers.", 0, true);
								break;
							}
							fdss3 >> count;
							fdss3.close();
							if (itemid == 112)
							{
								fstream fdss6(suckername + "/count/" + currentworld + ".txt");
								if (fdss6.fail())
								{
									if (remove((suckername + "/count/" + currentworld + ".txt").c_str()) != 0)
									{
										Player::OnConsoleMessage(peer, "An error occured, when tryed to remove a txt file.");
										break;
									}
									else
									{
										ofstream againsave(suckername + "/count/" + currentworld + ".txt");
										if (againsave.fail())
										{
											Player::OnConsoleMessage(peer, "An error occured, when tryed to save information, even after remove a txt file.");
											break;
										}
										againsave << 0;
										againsave.close();
									}
								}
								else
								{
									fdss6 << 0;
									fdss6.close();
								}

								bool iscontainss = false;
								SearchInventoryItem(peer, 5640, 1, iscontainss);
								if (iscontainss)
								{
									static_cast<PlayerInfo*>(peer->data)->magplantitemid = 0;
									RemoveInventoryItem(5640, 1, peer, true);
								}
								int currentgems = 0;
								ifstream fs("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
								fs >> currentgems;
								fs.close();
								currentgems += count;
								GamePacket psa = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), currentgems));
								ENetPacket* packetsa = enet_packet_create(psa.data, psa.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packetsa);
								ofstream of("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
								of << currentgems;
								of.close();
								Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`oCollected `2" + to_string(count) + " `5" + getItemDef(itemid).name + " `oFrom the " + getItemDef(suckerid).name + "!", 0, true);
								ENetPeer* currentPeer;
								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
									if (isHere(peer, currentPeer))
									{
										SendItemSucker(currentPeer, suckerid, x, y, itemid, 0, true, true);
									}
								}
								continue;
							}
							if (count > 200)
							{
								if (CheckItemMaxed(peer, itemid, 200))
								{
									Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wI dont have a free space to pickup `2200 `$" + getItemDef(itemid).name + "`w!", 0, true);
									continue;
								}
								else
								{
									count -= 200;
									ofstream fdss6(suckername + "/count/" + currentworld + ".txt");
									if (fdss6.fail())
									{
										if (remove((suckername + "/count/" + currentworld + ".txt").c_str()) != 0)
										{
											Player::OnConsoleMessage(peer, "An error occured, when tryed to remove a txt file.");
											break;
										}
										else
										{
											ofstream againsave(suckername + "/count/" + currentworld + ".txt");
											if (againsave.fail())
											{
												Player::OnConsoleMessage(peer, "An error occured, when tryed to save information, even after remove a txt file.");
												break;
											}
											againsave << count;
											againsave.close();
										}
									}
									else
									{
										fdss6 << count;
										fdss6.close();
									}
									bool success = true;
									SaveItemMoreTimes(itemid, 200, peer, success);
									Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`oCollected `2200 `5" + getItemDef(itemid).name + " `oFrom the " + getItemDef(suckerid).name + "!", 0, true);
									ENetPeer* currentPeer;
									for (currentPeer = server->peers;
										currentPeer < &server->peers[server->peerCount];
										++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
										if (isHere(peer, currentPeer))
										{
											SendItemSucker(currentPeer, suckerid, x, y, itemid, 1, true, true);
										}
									}
								}
							}
							else
							{
								if (CheckItemMaxed(peer, itemid, count))
								{
									Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wI dont have a free space to pickup `2" + to_string(count) + " `$" + getItemDef(itemid).name + "`w!", 0, true);
									continue;
								}
								else
								{
									ofstream fdss6(suckername + "/count/" + currentworld + ".txt");
									if (fdss6.fail())
									{
										if (remove((suckername + "/count/" + currentworld + ".txt").c_str()) != 0)
										{
											Player::OnConsoleMessage(peer, "An error occured, when tryed to remove a txt file.");
											break;
										}
										else
										{
											ofstream againsave(suckername + "/count/" + currentworld + ".txt");
											if (againsave.fail())
											{
												Player::OnConsoleMessage(peer, "An error occured, when tryed to save information, even after remove a txt file.");
												break;
											}
											againsave << 0;
											againsave.close();
										}
									}
									else
									{
										fdss6 << 0;
										fdss6.close();
									}

									bool iscontainss = false;
									SearchInventoryItem(peer, 5640, 1, iscontainss);
									if (iscontainss)
									{
										static_cast<PlayerInfo*>(peer->data)->magplantitemid = 0;
										RemoveInventoryItem(5640, 1, peer, true);
									}
									bool success = true;
									SaveItemMoreTimes(itemid, count, peer, success);
									Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`oCollected `2" + to_string(count) + " `5" + getItemDef(itemid).name + " `oFrom the " + getItemDef(suckerid).name + "!", 0, true);
									ENetPeer* currentPeer;
									for (currentPeer = server->peers;
										currentPeer < &server->peers[server->peerCount];
										++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
										if (isHere(peer, currentPeer))
										{
											SendItemSucker(currentPeer, suckerid, x, y, itemid, 0, true, true);
										}
									}
								}
							}
						}
						if (btn == "s2scomplete")
						{

							{
								ofstream fd("quests/currentqueststep/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
								fd << 3;
								fd.close();
								Player::OnTextOverlay(peer, "`#You have completed Step 2 For the `cLegendary Katana`#!");
							}

						}
						if (btn == "s3scomplete")
						{

							{
								ofstream fd("quests/currentqueststep/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
								fd << 4;
								fd.close();
								RemoveInventoryItem(1486, 5, peer, true);
								Player::OnTextOverlay(peer, "`#You have completed Step 4 For the `cLegendary Katana`#!");
							}
							/*else
							{
								autoBan(peer, true, 24, "btn s3scomplete -> is not owner");
							}*/
						}
						if (btn == "s4scomplete")
						{

							{
								ofstream fd("quests/currentqueststep/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
								fd << 5;
								fd.close();
								RemoveInventoryItem(2952, 1, peer, true);
								Player::OnTextOverlay(peer, "`#You have completed Step 4 For the `cLegendary Katana`#!");
							}

						}
						if (btn == "s5scomplete")
						{
							//if (static_cast<PlayerInfo*>(peer->data)->rawName == world->owner)
							{
								ofstream fd("quests/currentqueststep/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
								fd << 5;
								fd.close();
								RemoveInventoryItem(1794, 1, peer, true);
								bool success = true;
								SaveItemMoreTimes(2592, 1, peer, success);
								Player::OnTextOverlay(peer, "`#You have received the `cLegendary Katana`#!");
								remove(("quests/currentquest/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt").c_str());
								remove(("quests/currentqueststep/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt").c_str());
								remove(("quests/katana/step1/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt").c_str());
								remove(("quests/katana/step2/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt").c_str());
								remove(("quests/katana/step3/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt").c_str());
								remove(("quests/katana/step4/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt").c_str());
								remove(("quests/katana/step5/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt").c_str());
								for (int i = 0; i < world->width * world->height; i++)
								{
									if (world->items[i].foreground == 1790)
									{
										world->items[i].foreground = 0;
									}
								}
								int effect = 90;
								int x = static_cast<PlayerInfo*>(peer->data)->x;
								int y = static_cast<PlayerInfo*>(peer->data)->y;
								ENetPeer* currentPeer;
								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									Player::OnConsoleMessage(currentPeer, "`c>> Player `w" + static_cast<PlayerInfo*>(peer->data)->rawName + " `cReceived The Legendary Katana!");
									if (isHere(peer, currentPeer))
									{
										Player::OnParticleEffect(currentPeer, effect, x, y, 0);
										string act = static_cast<PlayerInfo*>(peer->data)->currentWorld;
										sendPlayerLeave(currentPeer, static_cast<PlayerInfo*>(currentPeer->data));
										joinWorld(currentPeer, act, 0, 0);
									}
								}
							}

						}
						//End					
						if (btn == "showuserinventory")
						{
							ENetPeer* currentPeer;
							for (currentPeer = server->peers;
								currentPeer < &server->peers[server->peerCount];
								++currentPeer)
							{
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
									continue;
								if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == static_cast<PlayerInfo*>(peer->data)->lastInfoAboutPlayer)
								{
									string appendItems = "";
									for (int i = 0; i < static_cast<PlayerInfo*>(currentPeer->data)->inventory.items.size(); i++)
									{
										if (i % 6 == 0 && i != 0)
										{
											appendItems += "\nadd_button_with_icon||END_LIST|noflags|0|0|\nadd_button_with_icon|removeplayeritem_" + static_cast<PlayerInfo*>(currentPeer->data)->rawName + "_" + to_string(static_cast<PlayerInfo*>(currentPeer->data)->inventory.items.at(i).itemID) + "||staticBlueFrame|" + to_string(static_cast<PlayerInfo*>(currentPeer->data)->inventory.items.at(i).itemID) + "|" + to_string(static_cast<PlayerInfo*>(currentPeer->data)->inventory.items.at(i).itemCount) + "|";
										}
										else
										{
											appendItems += "\nadd_button_with_icon|removeplayeritem_" + static_cast<PlayerInfo*>(currentPeer->data)->rawName + "_" + to_string(static_cast<PlayerInfo*>(currentPeer->data)->inventory.items.at(i).itemID) + "||staticBlueFrame|" + to_string(static_cast<PlayerInfo*>(currentPeer->data)->inventory.items.at(i).itemID) + "|" + to_string(static_cast<PlayerInfo*>(currentPeer->data)->inventory.items.at(i).itemCount) + "|";
										}
									}
									GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|\nadd_label_with_icon|small|`2" + static_cast<PlayerInfo*>(currentPeer->data)->rawName + " inventory``|left|826|" + appendItems + "\nadd_quick_exit|"));
									ENetPacket* packet = enet_packet_create(ps.data,
										ps.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete ps.data;
								}
							}
						}
						if (btn.substr(0, 25) == "showuserinventoryoffline_")
						{
							string user = btn.substr(25, cch.length() - 25 - 1);
							if (std::experimental::filesystem::exists("inventory/" + user + ".json"))
							{
								try
								{
									std::ifstream ifff("inventory/" + user + ".json");
									if (ifff.fail())
									{
										ifff.close();
										Player::OnTextOverlay(peer, "`4Error getting inventory info!");
										continue;
									}
									json j;
									ifff >> j;
									ifff.close();

									int inventorySize = 200;
									if (std::experimental::filesystem::exists("usersinventorysize/" + user + ".txt"))
									{
										std::ifstream iffff("usersinventorysize/" + user + ".txt");
										iffff >> inventorySize;
										iffff.close();
									}
									string appendItems = "";
									int itemid = 0;
									int itemCount = 0;
									for (int i = 0; i < inventorySize; i++)
									{
										itemid = j["items"][i]["itemid"];
										itemCount = j["items"][i]["quantity"];
										if (itemid == 0) continue;
										if (i % 6 == 0 && i != 0)
										{
											appendItems += "\nadd_button_with_icon||END_LIST|noflags|0|0|\nadd_button_with_icon|removeplayerofflineitem_" + user + "_" + to_string(itemid) + "||staticBlueFrame|" + to_string(itemid) + "|" + to_string(itemCount) + "|";
										}
										else
										{
											appendItems += "\nadd_button_with_icon|removeplayerofflineitem_" + user + "_" + to_string(itemid) + "||staticBlueFrame|" + to_string(itemid) + "|" + to_string(itemCount) + "|";
										}
									}
									GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|\nadd_label_with_icon|small|`2" + user + " `boffline `2inventory``|left|826|" + appendItems + "\nadd_quick_exit|"));
									ENetPacket* packet = enet_packet_create(ps.data,
										ps.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete ps.data;
								}
								catch (std::exception&)
								{
									SendConsole("showuserinventoryoffline_ Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
									enet_peer_disconnect_now(peer, 0);
								}
								catch (std::runtime_error&)
								{
									SendConsole("showuserinventoryoffline_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
									enet_peer_disconnect_now(peer, 0);
								}
								catch (...)
								{
									SendConsole("showuserinventoryoffline_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
									enet_peer_disconnect_now(peer, 0);
								}
							}
							else
							{
								Player::OnTextOverlay(peer, "`#This user does not have inventory!");
							}
						}
						if (btn == "changeskillgroup")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							Player::OnDialogRequest(peer, "set_default_color|`o\n\nadd_label_with_icon|big|`wChoose Skill Group``|left|18|0|0|\n\nadd_spacer|small|\nadd_button|changetofarmer|`9Farmer [`415 `@Store Tokens`9]|0|0|\nadd_textbox|`oFarmer Skill Buffs all gem drops by `430% `oAnd gives you exlusive looking flag`o!|\nadd_button|changetominer|`9Miner [`430 `@Store Tokens`9]|0|0|\nadd_textbox|`oMiner Skill Buffs all crystal drops by `430% `oAnd gives you exlusive looking flag`o!|\nadd_button|changetonone|`9Leave Skill Group|0|0|\nadd_textbox|`@Warning! `oIf you will leave your current skill group you will lose all buffs`o!|\n\nadd_spacer|small|\nadd_button||`9Continue|0|0|\nadd_quick_exit|");
						}
						if (btn == "killrewards")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							Player::OnDialogRequest(peer, "set_default_color|`o\n\nadd_label_with_icon|big|`wKill Rewards``|left|18|0|0|\n\nadd_spacer|small|\nadd_textbox|`oYou Currently Have: " + std::to_string(static_cast<PlayerInfo*>(peer->data)->TotalKills) + " Kills`o!|\nadd_button|10wlskills|`9Purchase 10 World Locks For 180 Kills|0|0|\nadd_button|storetokenkills|`9Purchase Store Token For 330 Kills|0|0|\n\nadd_spacer|small|\nadd_button||`9Continue|0|0|\nadd_quick_exit|");
						}
						if (btn == "10wlskills")
						{
							if (static_cast<PlayerInfo*>(peer->data)->TotalKills >= 180)
							{
								int killminus = static_cast<PlayerInfo*>(peer->data)->TotalKills -= 180;

								ifstream fg("players/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".json");
								json j;
								fg >> j;
								fg.close();

								j["kills"] = killminus;

								ofstream fs("players/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".json");
								fs << j;
								fs.close();
								static_cast<PlayerInfo*>(peer->data)->TotalKills -= 180;
								bool success = true;
								SaveItemMoreTimes(242, 10, peer, success);
								Player::OnTextOverlay(peer, "`^You Have `9Purchased `@10 `2World Locks`^!");
							}
							else
							{
								Player::OnTextOverlay(peer, "`@You Dont Have Enough Kills!");
							}
						}
						if (btn == "storetokenkills")
						{
							if (static_cast<PlayerInfo*>(peer->data)->TotalKills >= 330)
							{
								int killminus = static_cast<PlayerInfo*>(peer->data)->TotalKills -= 330;
								ifstream fg("players/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".json");
								json j;
								fg >> j;
								fg.close();

								j["kills"] = killminus;

								ofstream fs("players/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".json");
								fs << j;
								fs.close();
								static_cast<PlayerInfo*>(peer->data)->TotalKills -= 330;
								bool success = true;
								SaveItemMoreTimes(1486, 1, peer, success);
								Player::OnTextOverlay(peer, "`^You Have `9Purchased `@Store Token`^!");
							}
							else
							{
								Player::OnTextOverlay(peer, "`@You Dont Have Enough Kills!");
							}
						}
						if (btn == "lvluprewards")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							Player::OnDialogRequest(peer,
								"set_default_color|`o\n\nadd_label_with_icon|big|`wLevelup Rewards``|left|18|0|0|\n\nadd_spacer|small|\nadd_button|claimmercywings|`9Claim Mercy Wings `w[`4100 `!LVL`w]|0|0|\nadd_textbox|`oMercy wings will give you `4Dr. `oTitle and `9Exclusive Movement Effects`o, Also a `9Flag`o!|0|0|\n\nadd_spacer|small|\nadd_button||`9Continue|0|0|\nadd_quick_exit|");
						}
						if (btn == "claimroyallock")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							bool iscontainss = false;
							SearchInventoryItem(peer, 4802, 1, iscontainss);
							if (iscontainss)
							{
								Player::OnTextOverlay(peer, "`^You Already Have `4Royal `^Lock!");
							}
							else
							{
								if (static_cast<PlayerInfo*>(peer->data)->level >= 125)
								{
									bool success = true;
									SaveItemMoreTimes(4802, 1, peer, success);
									Player::OnTextOverlay(peer, "`^You Have `9Obtained `^The `4Royal `^Lock!");
									Player::OnParticleEffect(peer, 356, static_cast<PlayerInfo*>(peer->data)->x, static_cast<PlayerInfo*>(peer->data)->y, 0);
								}
								else
								{
									Player::OnTextOverlay(peer, "`@You Need To Be `1Level `@100!");
								}
							}
						}
						if (btn == "claimmercywings")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							bool iscontainss = false;
							SearchInventoryItem(peer, 8552, 1, iscontainss);
							if (iscontainss)
							{
								Player::OnTextOverlay(peer, "`^You Already Have `4Mercy `^Wings!");
							}
							else
							{
								if (static_cast<PlayerInfo*>(peer->data)->level >= 100)
								{
									bool success = true;
									SaveItemMoreTimes(8552, 1, peer, success);
									Player::OnTextOverlay(peer, "`^You Have `9Obtained `^The `4Mercy `^Wings!");
									Player::OnParticleEffect(peer, 356, static_cast<PlayerInfo*>(peer->data)->x, static_cast<PlayerInfo*>(peer->data)->y, 0);
								}
								else
								{
									Player::OnTextOverlay(peer, "`@You Need To Be `1Level `@100!");
								}
							}
						}
						if (btn == "changetonone")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							if (static_cast<PlayerInfo*>(peer->data)->skill == "None")
							{
								Player::OnTextOverlay(peer, "`@You Don't Have Any `#Skill Groups `@To Leave!");
								continue;
							}
							else
							{
								Player::OnTextOverlay(peer, "`^Succesfully Left `5" + static_cast<PlayerInfo*>(peer->data)->skill + " `#Skill Group`^!");
								static_cast<PlayerInfo*>(peer->data)->skill = "None";
								send_state(peer);

								ifstream fg("players/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".json");
								json j;
								fg >> j;
								fg.close();

								j["skill"] = "None";

								ofstream fs("players/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".json");
								fs << j;
								fs.close();
								GamePacket p2 = packetEnd(appendIntx(appendIntx(appendIntx(appendIntx(appendString(createPacket(), "OnGuildDataChanged"), 1), 2), 0), 0));
								memcpy(p2.data + 8, &(static_cast<PlayerInfo*>(peer->data)->netID), 4);
								ENetPacket* packet3 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);
								ENetPeer* currentPeer;
								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									if (isHere(peer, currentPeer))
									{
										enet_peer_send(currentPeer, 0, packet3);
									}
								}
								delete p2.data;
							}
						}
						if (btn == "changetominer")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							if (static_cast<PlayerInfo*>(peer->data)->skill == "Miner")
							{
								Player::OnTextOverlay(peer, "`@You Are `4Already `@In The `^Miner's `@Group!");
								continue;
							}
							else
							{
								bool iscontainss = false;
								SearchInventoryItem(peer, 1486, 30, iscontainss);
								if (!iscontainss)
								{
									Player::OnTextOverlay(peer, "`@You `4Don't `@Have Enough Store Tokens!");
								}
								else
								{
									RemoveInventoryItem(1486, 30, peer, true);
									static_cast<PlayerInfo*>(peer->data)->skill = "Miner";
									Player::OnTextOverlay(peer, "`^Succesfully Joined `2Miner's `^Skill Group!");
									send_state(peer);
									Player::OnParticleEffect(peer, 354, static_cast<PlayerInfo*>(peer->data)->x, static_cast<PlayerInfo*>(peer->data)->y, 0);
									ifstream fg("players/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".json");
									json j;
									fg >> j;
									fg.close();

									j["skill"] = "Miner";

									ofstream fs("players/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".json");
									fs << j;
									fs.close();
								}
							}
						}
						if (btn == "changetofarmer")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							if (static_cast<PlayerInfo*>(peer->data)->skill == "Farmer")
							{
								Player::OnTextOverlay(peer, "`@You Are `4Already `@In The `^Farmer's `@Group!");
								continue;
							}
							else
							{
								bool iscontainss = false;
								SearchInventoryItem(peer, 1486, 15, iscontainss);
								if (!iscontainss)
								{
									Player::OnTextOverlay(peer, "`@You `4Don't `@Have Enough Store Tokens!");
								}
								else
								{
									RemoveInventoryItem(1486, 15, peer, true);
									static_cast<PlayerInfo*>(peer->data)->skill = "Farmer";
									Player::OnTextOverlay(peer, "`^Succesfully Joined `2Farmer's `^Skill Group!");
									send_state(peer);
									Player::OnParticleEffect(peer, 354, static_cast<PlayerInfo*>(peer->data)->x, static_cast<PlayerInfo*>(peer->data)->y, 0);
									ifstream fg("players/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".json");
									json j;
									fg >> j;
									fg.close();

									j["skill"] = "Farmer";

									ofstream fs("players/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".json");
									fs << j;
									fs.close();
								}
							}
						}
						if (btn == "magicmachine")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							if (static_cast<PlayerInfo*>(peer->data)->haveGrowId == false) continue;
							Player::OnDialogRequest(peer, "set_default_color|`o\n\nadd_label_with_icon|big|`wMagic Machine``|left|9170|0|0|\n\nadd_spacer|small|\nadd_textbox|`oChoose block which you want to shatter!|\nadd_button_with_icon|iamethyst||staticBlueFrame|4762|\nadd_button_with_icon|ionyx||staticBlueFrame|7382|\nadd_button_with_icon|ismaraged||staticBlueFrame|9460|\nadd_button_with_icon|idiamondstone||staticBlueFrame|9468|\nadd_button_with_icon|ipinkdiamond||staticBlueFrame|10024|\nadd_button_with_icon||END_LIST|noflags|0|0|\nadd_button_with_icon|icitrine||staticBlueFrame|10028|\n\nadd_spacer||0|0|\nadd_quick_exit|");
						}
						if (btn == "iamethyst")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							if (static_cast<PlayerInfo*>(peer->data)->haveGrowId == false) continue;
							bool iscontains = false;
							SearchInventoryItem(peer, 4762, 100, iscontains);
							if (iscontains)
							{
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`wMagic Machine``|left|9170|0|0|\n\nadd_spacer|small|\nadd_textbox|`oAre you sure you want to convert `9100 `#Amethyst Blocks `oInto `9crystals`o? [`4This cannot be undone after clicking convert!`o]|\n\nadd_spacer|small|\nadd_button|yesconvertamethyst|`9Convert!|0|0|\nadd_quick_exit|"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);
								delete p2.data;
							}
							else
							{
								Player::OnTextOverlay(peer, "`@You dont have `#Amethyst Block's`@!");
							}
						}
						if (btn == "ionyx")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							if (static_cast<PlayerInfo*>(peer->data)->haveGrowId == false) continue;
							bool iscontains = false;
							SearchInventoryItem(peer, 7382, 100, iscontains);
							if (iscontains)
							{
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`wMagic Machine``|left|9170|0|0|\n\nadd_spacer|small|\nadd_textbox|`oAre you sure you want to convert `9100 `bOnyx Blocks `oInto `9crystals`o? [`4This cannot be undone after clicking convert!`o]|\n\nadd_spacer|small|\nadd_button|yesconvertonyx|`9Convert!|0|0|\nadd_quick_exit|"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);
								delete p2.data;
							}
							else
							{
								Player::OnTextOverlay(peer, "`@You dont have `bOnyx Block's`@!");
							}
						}
						if (btn == "ismaraged")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							if (static_cast<PlayerInfo*>(peer->data)->haveGrowId == false) continue;
							bool iscontains = false;
							SearchInventoryItem(peer, 9460, 100, iscontains);
							if (iscontains)
							{
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`wMagic Machine``|left|9170|0|0|\n\nadd_spacer|small|\nadd_textbox|`oAre you sure you want to convert `9100 `2Smaraged Blocks `oInto `9crystals`o? [`4This cannot be undone after clicking convert!`o]|\n\nadd_spacer|small|\nadd_button|yesconvertsmaraged|`9Convert!|0|0|\nadd_quick_exit|"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);
								delete p2.data;
							}
							else
							{
								Player::OnTextOverlay(peer, "`@You dont have `2Smaraged Block's`@!");
							}
						}
						if (btn == "idiamondstone")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							if (static_cast<PlayerInfo*>(peer->data)->haveGrowId == false) continue;
							bool iscontains = false;
							SearchInventoryItem(peer, 9468, 100, iscontains);
							if (iscontains)
							{
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`wMagic Machine``|left|9170|0|0|\n\nadd_spacer|small|\nadd_textbox|`oAre you sure you want to convert `9100 `1Diamond Stones `oInto `9crystals`o? [`4This cannot be undone after clicking convert!`o]|\n\nadd_spacer|small|\nadd_button|yesconvertdiamondstone|`9Convert!|0|0|\nadd_quick_exit|"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);
								delete p2.data;
							}
							else
							{
								Player::OnTextOverlay(peer, "`@You dont have `1Diamond Stone's`@!");
							}
						}
						if (btn == "ipinkdiamond")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							if (static_cast<PlayerInfo*>(peer->data)->haveGrowId == false) continue;
							bool iscontains = false;
							SearchInventoryItem(peer, 10024, 100, iscontains);
							if (iscontains)
							{
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`wMagic Machine``|left|9170|0|0|\n\nadd_spacer|small|\nadd_textbox|`oAre you sure you want to convert `9100 `#Pink Diamonds `oInto `9crystals`o? [`4This cannot be undone after clicking convert!`o]|\n\nadd_spacer|small|\nadd_button|yesconvertpinkdiamond|`9Convert!|0|0|\nadd_quick_exit|"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);
								delete p2.data;
							}
							else
							{
								Player::OnTextOverlay(peer, "`@You dont have `#Pink Diamond's`@!");
							}
						}
						if (btn == "icitrine")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT") continue;
							if (static_cast<PlayerInfo*>(peer->data)->haveGrowId == false) continue;
							bool iscontains = false;
							SearchInventoryItem(peer, 10028, 100, iscontains);
							if (iscontains)
							{
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`wMagic Machine``|left|9170|0|0|\n\nadd_spacer|small|\nadd_textbox|`oAre you sure you want to convert `9100 `6Citrine Blocks `oInto `9crystals`o? [`4This cannot be undone after clicking convert!`o]|\n\nadd_spacer|small|\nadd_button|yesconvertcitrine|`9Convert!|0|0|\nadd_quick_exit|"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);
								delete p2.data;
							}
							else
							{
								Player::OnTextOverlay(peer, "`@You dont have `6Citrine Block's`@!");
							}
						}
						if (btn == "yesconvertamethyst")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							if (static_cast<PlayerInfo*>(peer->data)->haveGrowId == false) continue;
							bool iscontainsss = false;
							SearchInventoryItem(peer, 4762, 100, iscontainsss);
							if (!iscontainsss)
							{
								Player::OnConsoleMessage(peer, "`4Anticheat marked you as suspicious!");
								continue;
							}
							else
							{
								Player::OnTextOverlay(peer, "`9You Have Shattered 100 `#Amethyst `9Blocks!");
								RemoveInventoryItem(4762, 100, peer, true);
								int gemChance = rand() % 20000;
								GiveChestPrizeGems(peer, gemChance);
								int effect = 221;
								int x = static_cast<PlayerInfo*>(peer->data)->x;
								int y = static_cast<PlayerInfo*>(peer->data)->y;
								ENetPeer* currentPeer;
								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									if (isHere(peer, currentPeer))
									{
										Player::OnParticleEffect(currentPeer, effect, x, y, 0);
									}
								}
								SendGuildPoints(peer, 15);
							}
						}
						if (btn == "yesconvertonyx")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							if (static_cast<PlayerInfo*>(peer->data)->haveGrowId == false) continue;
							bool iscontainsss = false;
							SearchInventoryItem(peer, 7382, 100, iscontainsss);
							if (!iscontainsss)
							{
								Player::OnConsoleMessage(peer, "`4Anticheat marked you as suspicious!");
								continue;
							}
							else
							{
								Player::OnTextOverlay(peer, "`9You Have Shattered 100 `bOnyx `9Blocks!");
								RemoveInventoryItem(7382, 100, peer, true);
								int gemChance = rand() % 30000;
								GiveChestPrizeGems(peer, gemChance);
								int effect = 221;
								int x = static_cast<PlayerInfo*>(peer->data)->x;
								int y = static_cast<PlayerInfo*>(peer->data)->y;
								ENetPeer* currentPeer;
								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									if (isHere(peer, currentPeer))
									{
										Player::OnParticleEffect(currentPeer, effect, x, y, 0);
									}
								}
								SendGuildPoints(peer, 25);
							}
						}
						if (btn == "yesconvertsmaraged")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							if (static_cast<PlayerInfo*>(peer->data)->haveGrowId == false) continue;
							bool iscontainsss = false;
							SearchInventoryItem(peer, 9460, 100, iscontainsss);
							if (!iscontainsss)
							{
								Player::OnConsoleMessage(peer, "`4Anticheat marked you as suspicious!");
								continue;
							}
							else
							{
								Player::OnTextOverlay(peer, "`9You Have Shattered 100 `2Smaraged `9Blocks!");
								RemoveInventoryItem(9460, 100, peer, true);
								int gemChance = rand() % 32000;
								GiveChestPrizeGems(peer, gemChance);
								int effect = 221;
								int x = static_cast<PlayerInfo*>(peer->data)->x;
								int y = static_cast<PlayerInfo*>(peer->data)->y;
								ENetPeer* currentPeer;
								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									if (isHere(peer, currentPeer))
									{
										Player::OnParticleEffect(currentPeer, effect, x, y, 0);
									}
								}
								SendGuildPoints(peer, 30);
							}
						}
						if (btn == "yesconvertdiamondstone")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							if (static_cast<PlayerInfo*>(peer->data)->haveGrowId == false) continue;
							bool iscontainsss = false;
							SearchInventoryItem(peer, 9468, 100, iscontainsss);
							if (!iscontainsss)
							{
								continue;
							}
							else
							{
								Player::OnTextOverlay(peer, "`9You Have Shattered 100 `1Diamond `9Stones!");
								RemoveInventoryItem(9468, 100, peer, true);
								int gemChance = rand() % 41000;
								GiveChestPrizeGems(peer, gemChance);
								int effect = 221;
								int x = static_cast<PlayerInfo*>(peer->data)->x;
								int y = static_cast<PlayerInfo*>(peer->data)->y;
								ENetPeer* currentPeer;
								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									if (isHere(peer, currentPeer))
									{
										Player::OnParticleEffect(currentPeer, effect, x, y, 0);
									}
								}
								SendGuildPoints(peer, 40);
							}
						}
						if (btn == "yesconvertpinkdiamond")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							if (static_cast<PlayerInfo*>(peer->data)->haveGrowId == false) continue;
							bool iscontainsss = false;
							SearchInventoryItem(peer, 10024, 100, iscontainsss);
							if (!iscontainsss)
							{
								Player::OnConsoleMessage(peer, "`4Anticheat marked you as suspicious!");
								continue;
							}
							else
							{
								Player::OnTextOverlay(peer, "`9You Have Shattered 100 `#Pink `1Diamonds!");
								RemoveInventoryItem(10024, 100, peer, true);
								int gemChance = rand() % 46000;
								GiveChestPrizeGems(peer, gemChance);
								int effect = 221;
								int x = static_cast<PlayerInfo*>(peer->data)->x;
								int y = static_cast<PlayerInfo*>(peer->data)->y;
								ENetPeer* currentPeer;
								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									if (isHere(peer, currentPeer))
									{
										Player::OnParticleEffect(currentPeer, effect, x, y, 0);
									}
								}
								SendGuildPoints(peer, 50);
							}
						}
						if (btn == "yesconvertcitrine")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							if (static_cast<PlayerInfo*>(peer->data)->haveGrowId == false) continue;
							bool iscontainsss = false;
							SearchInventoryItem(peer, 10028, 100, iscontainsss);
							if (!iscontainsss)
							{
								Player::OnConsoleMessage(peer, "`4Anticheat marked you as suspicious!");
								continue;
							}
							else
							{
								Player::OnTextOverlay(peer, "`9You Have Shattered 100 `6Citrine `9Blocks!");
								RemoveInventoryItem(10028, 100, peer, true);
								int gemChance = rand() % 57000;
								GiveChestPrizeGems(peer, gemChance);
								int effect = 221;
								int x = static_cast<PlayerInfo*>(peer->data)->x;
								int y = static_cast<PlayerInfo*>(peer->data)->y;
								ENetPeer* currentPeer;
								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									if (isHere(peer, currentPeer))
									{
										Player::OnParticleEffect(currentPeer, effect, x, y, 0);
									}
								}
								SendGuildPoints(peer, 60);
							}
						}
						if (btn == "warptosb")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							if (static_cast<PlayerInfo*>(peer->data)->isCursed == true)
							{
								GamePacket p0 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`4You are cursed now!"));
								ENetPacket* packet0 = enet_packet_create(p0.data,
									p0.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet0);
								delete p0.data;
								continue;
							}
							string act = static_cast<PlayerInfo*>(peer->data)->lastSdbWorld;
							if (act == "")
							{
								GamePacket po = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "Unable to track down the location of the broadcast."));
								ENetPacket* packet = enet_packet_create(po.data,
									po.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
							}
							else if (act == static_cast<PlayerInfo*>(peer->data)->currentWorld)
							{
								GamePacket po = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "Sorry, but you are already in the world!"));
								ENetPacket* packet = enet_packet_create(po.data,
									po.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
							}
							else
							{
								sendPlayerLeave(peer, static_cast<PlayerInfo*>(peer->data));
								joinWorld(peer, act, 0, 0);
							}
						}
						if (btn == "okgo")
						{
							static_cast<PlayerInfo*>(peer->data)->isBot = false;
						}
						if (btn == "invitemenu")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							if (static_cast<PlayerInfo*>(peer->data)->lastInfo == static_cast<PlayerInfo*>(peer->data)->rawName)
							{
								continue;
							}
							GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`w\n\nadd_label_with_icon|big|`5Invite Options|left|1366|\n\nadd_spacer|small|\nadd_button|addfriendrnbutton|`9Add To Friends|0|0|\nadd_button|inviteguildbutton|`9Invite To Guild|0|0|\nend_dialog||Close||\nadd_quick_exit|"));
							ENetPacket* packet2 = enet_packet_create(p2.data,
								p2.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet2);
							delete p2.data;
						}
						if (btn == "inviteguildbutton")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							if (static_cast<PlayerInfo*>(peer->data)->guild != "")
							{
								int number = static_cast<PlayerInfo*>(peer->data)->guildmatelist.size();
								if (number > 9)
								{
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`3FRIEND ERROR: `oYou already have `450 `ofriends! Please remove some before adding new ones!"));
									ENetPacket* packet = enet_packet_create(p.data,
										p.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									continue;
								}
								ENetPeer* currentPeer;
								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									if (isHere(peer, currentPeer))
									{
										if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == static_cast<PlayerInfo*>(peer->data)->lastInfo)
										{
											string name = static_cast<PlayerInfo*>(currentPeer->data)->rawName;
											if (static_cast<PlayerInfo*>(currentPeer->data)->guild != "")
											{
												GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`3GUILD ERROR: `w" + static_cast<PlayerInfo*>(currentPeer->data)->displayName + "`o is already in a Guild!"));
												ENetPacket* packet = enet_packet_create(p.data,
													p.len,
													ENET_PACKET_FLAG_RELIABLE);
												enet_peer_send(peer, 0, packet);
												delete p.data;
											}
											else
											{
												GamePacket p4 = packetEnd(appendString(appendIntx(appendString(createPacket(), "OnTalkBubble"), static_cast<PlayerInfo*>(peer->data)->netID), "`5[`wGuild request sent to `2" + static_cast<PlayerInfo*>(currentPeer->data)->displayName + "`5]"));
												ENetPacket* packet4 = enet_packet_create(p4.data,
													p4.len,
													ENET_PACKET_FLAG_RELIABLE);
												enet_peer_send(peer, 0, packet4);
												delete p4.data;
												string text = "action|play_sfx\nfile|audio/tip_start.wav\ndelayMS|0\n";
												BYTE* data = new BYTE[5 + text.length()];
												BYTE zero = 0;
												int type = 3;
												memcpy(data, &type, 4);
												memcpy(data + 4, text.c_str(), text.length());
												memcpy(data + 4 + text.length(), &zero, 1);
												ENetPacket* packet2 = enet_packet_create(data,
													5 + text.length(),
													ENET_PACKET_FLAG_RELIABLE);
												enet_peer_send(currentPeer, 0, packet2);
												delete data;
												static_cast<PlayerInfo*>(currentPeer->data)->guildlast = static_cast<PlayerInfo*>(peer->data)->guild;
												static_cast<PlayerInfo*>(currentPeer->data)->isinvited = true;
												GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5[GUILD REQUEST] `oYou've been invited to join `2" + static_cast<PlayerInfo*>(peer->data)->guild + "`o by `w" + static_cast<PlayerInfo*>(peer->data)->displayName + "`o! To accept, `wwrench yourself `oand then choose `2Join " + static_cast<PlayerInfo*>(peer->data)->guild + "`o."));
												ENetPacket* packet = enet_packet_create(p.data,
													p.len,
													ENET_PACKET_FLAG_RELIABLE);
												enet_peer_send(currentPeer, 0, packet);
												delete p.data;
											}
										}
									}
								}
							}
							else
							{
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5[GUILD ERROR] `oYou must be in a Guild as a Elder or higher in order to invite players!"));
								ENetPacket* packet = enet_packet_create(p.data,
									p.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (btn == "manage_title")
						{
							string titlecreatedialog = "";
							if (static_cast<PlayerInfo*>(peer->data)->Subscriber)
							{
								titlecreatedialog = "\nadd_button|edit_title|`oEdit Title``|";
							}
							Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label|big|Titles Obtained!|right|\nadd_spacer|small|" + titlecreatedialog + "\nadd_button||OK|noflags|0|0|\nend_dialog|title_edit||");
						}
						if (btn == "edit_title")
						{
							if (!static_cast<PlayerInfo*>(peer->data)->Subscriber) continue;
							Player::OnDialogRequest(peer, "set_default_color|`o\n\nadd_label|big|`oEdit Your Title``|\nadd_textbox|`oHow to create a `$Title`o? Firstly make sure what `$Color `oYou want to use for example `2Green `oOr `4Red `oThen in the `$Input Box `oWrite your new `$Title `oLets say we want to use `4King `oAnd then simply press `$Save`o!|\nadd_spacer|small|\nadd_text_input|title_name|`$Title``||8|\nend_dialog|title_save|Cancel|Save|");
						}
						if (btn == "notebook_edit")
						{
							Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label|big|Notebook|left|0|\nadd_text_box_input|personal_note||" + static_cast<PlayerInfo*>(peer->data)->notebook + "|128|5|\nadd_spacer|small|\nadd_button|save|Save|noflags|0|0|\nadd_button|notebook_clear|Clear|noflags|0|0|\nadd_button|cancel|Cancel|noflags|0|0|\nend_dialog|notebook_edit||\nadd_quick_exit|");
						}
						if (btn == "worlds_view") {
							string tangina = "";
							for (int i = 0; i < ((PlayerInfo*)(peer->data))->worldsowned.size(); i++)
							{
								tangina += "\nadd_url_button||`wWorld : `1" + ((PlayerInfo*)(peer->data))->worldsowned[i] + "|NOFLAGS|OPENWORLD|" + ((PlayerInfo*)(peer->data))->worldsowned[i] + "|0|0|";
							}
							Player::OnDialogRequest(peer, "\nadd_label|big|`$Worlds Locked|left|\nadd_spacer|small|\nadd_smalltext|`5(Clicking the button will make you enter the world indicated)|left|\nadd_spacer|small|" + tangina + "\nadd_spacer|small|\nadd_quick_exit|\nend_dialog||Close|");
						}


						if (btn == "notebook_clear")
						{
							if (!static_cast<PlayerInfo*>(peer->data)->haveGrowId) continue;
							ifstream fg("players/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".json");
							json j;
							fg >> j;
							fg.close();

							j["notebook"] = "";

							ofstream fs("players/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".json");
							fs << j;
							fs.close();
							static_cast<PlayerInfo*>(peer->data)->notebook = "";
							Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`2Text cleared.", 0, true);
						}
						if (btn == "viewfragments")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							UpdateLocalPlayerFragments(peer);
							int earthfragment = static_cast<PlayerInfo*>(peer->data)->fEarth;
							int darkfragment = static_cast<PlayerInfo*>(peer->data)->fDark;
							int firefragment = static_cast<PlayerInfo*>(peer->data)->fFire;
							int waterfragment = static_cast<PlayerInfo*>(peer->data)->fWater;
							GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "add_label_with_icon|big|`wMy Fragments|left|1458|\nadd_spacer|\nadd_label_with_icon|small|`oYou have: `@" + to_string(earthfragment) + " `2Earth `9Fragment's`0!|left|5050|\nadd_label_with_icon|small|`oYou have: `@" + to_string(darkfragment) + " `bDark `9Fragment's`0!|left|5052|\nadd_label_with_icon|small|`oYou have: `@" + to_string(firefragment) + " `4Fire `9Fragment's`0!|left|5046|\nadd_label_with_icon|small|`oYou have: `@" + to_string(waterfragment) + " `1Water `9Fragment's`0!|left|5048|\nadd_spacer|Back|0|0|\nend_dialog||Close||\nadd_quick_exit|"));
							ENetPacket* packet = enet_packet_create(ps.data,
								ps.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete ps.data;
							continue;
						}
						if (btn == "worldgenmachine")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							if (static_cast<PlayerInfo*>(peer->data)->haveGrowId == true)
							{
								Player::OnDialogRequest(peer, "set_default_color|`o\n\nadd_label_with_icon|big|`5World Generation Machine``|left|9432|0|0|\n\nadd_spacer|small|\nadd_text_input|worldname|`$World Name``||18|\nadd_text_input|worldheight|`$World Height``||18|\nadd_text_input|worldwidth|`$World Width``||18|\nadd_text_input|worldforeground|`$World Foreground``||18|\nadd_text_input|worldbackground|`$World Background``||18|\nadd_text_input|worldbedrock|`$World Bedrock``||18|\nend_dialog|wgmgen|Cancel|Generate|");
							}
							else
							{
								autoBan(peer, true, 1, "btn worldgenmachine -> doesnt has growID");
								continue;
							}
						}
						if (btn == "passbutton")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							if (static_cast<PlayerInfo*>(peer->data)->haveGrowId == true)
							{
								GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "add_label_with_icon|big|`wChange Password|left|1280|\nadd_spacer|small|\nadd_text_input|oldpass|`$Current Password``||18|\nadd_text_input|newpass|`$New Password``||18|\nadd_text_input|verifypass|`$Verify Password``||18|\nend_dialog|pssdia|`wCancel``|`wConfirm!``|"));
								ENetPacket* packet = enet_packet_create(ps.data,
									ps.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete ps.data;
								continue;
							}
							else
							{
								autoBan(peer, true, 1, "btn passbutton -> doesnt not has growID");
								continue;
							}
						}
						if (btn == "joinguild")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							vector<string> gmembers;
							string guildname = PlayerDB::getProperName(static_cast<PlayerInfo*>(peer->data)->guildlast);
							if (guildname != "")
							{
								try
								{
									std::ifstream ifff("guilds/" + guildname + ".json");
									if (ifff.fail())
									{
										ifff.close();
										continue;
									}
									json j;
									ifff >> j;
									int glevel;
									glevel = j["GuildLevel"];
									for (int i = 0; i < j["Member"].size(); i++)
									{
										gmembers.push_back(j["Member"][i]);
									}
									ifff.close();
									int membercount = gmembers.size();
									int maxmembers = 15;
									if (glevel == 2)
									{
										maxmembers = 20;
									}
									else if (glevel == 3)
									{
										maxmembers = 25;
									}
									else if (glevel == 4)
									{
										maxmembers = 30;
									}
									else if (glevel == 5)
									{
										maxmembers = 35;
									}
									else if (glevel == 6)
									{
										maxmembers = 40;
									}
									else if (glevel == 7)
									{
										maxmembers = 45;
									}
									else if (glevel == 8)
									{
										maxmembers = 50;
									}
									if (membercount >= maxmembers)
									{
										Player::OnConsoleMessage(peer, "`5[GUILD ALERT] `oThat guild is already full!");
										continue;
									}
									else
									{
										static_cast<PlayerInfo*>(peer->data)->guild = static_cast<PlayerInfo*>(peer->data)->guildlast;
										static_cast<PlayerInfo*>(peer->data)->guildlast = "";
										static_cast<PlayerInfo*>(peer->data)->isinvited = false;
										static_cast<PlayerInfo*>(peer->data)->joinguild = true;
										updateInvis(peer);
										std::ifstream ifff("guilds/" + PlayerDB::getProperName(static_cast<PlayerInfo*>(peer->data)->guild) + ".json");
										if (ifff.fail())
										{
											ifff.close();
											GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`4Error: `oGuild does not exist! If you are seeing this message, please take a screenshot and send it to a developer!"));
											ENetPacket* packet = enet_packet_create(ps.data,
												ps.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(peer, 0, packet);
											delete ps.data;
											continue;
										}
										if (ifff.is_open())
										{
										}
										json j;
										ifff >> j; //load
										vector<string> gmlist;
										for (int i = 0; i < j["Member"].size(); i++)
										{
											gmlist.push_back(j["Member"][i]);
										}
										gmlist.push_back(static_cast<PlayerInfo*>(peer->data)->rawName);
										j["Member"] = gmlist; //edit
										std::ofstream o("guilds/" + PlayerDB::getProperName(static_cast<PlayerInfo*>(peer->data)->guild) + ".json"); //save
										if (!o.is_open()) continue;
										o << j << std::endl;

										ifstream fg("players/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".json");
										json j2;
										fg >> j2;
										fg.close();

										j2["guild"] = static_cast<PlayerInfo*>(peer->data)->guild;
										j2["joinguild"] = true;

										ofstream fs("players/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".json");
										fs << j2;
										fs.close();

										ENetPeer* currentPeer;
										for (currentPeer = server->peers;
											currentPeer < &server->peers[server->peerCount];
											++currentPeer)
										{
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
												continue;
											if (static_cast<PlayerInfo*>(currentPeer->data)->guild == static_cast<PlayerInfo*>(peer->data)->guild)
											{
												updateGuild(peer);
												updateGuild(currentPeer);
												GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5[GUILD ALERT] `2" + static_cast<PlayerInfo*>(peer->data)->displayName + " `ojoined the guild!"));
												ENetPacket* packet = enet_packet_create(p.data,
													p.len,
													ENET_PACKET_FLAG_RELIABLE);
												enet_peer_send(currentPeer, 0, packet);
												delete p.data;
												updateInvis(peer);
											}
										}
									}
								}
								catch (std::exception&)
								{
									SendConsole("joinguild Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
									enet_peer_disconnect_now(peer, 0);
								}
								catch (std::runtime_error&)
								{
									SendConsole("joinguild Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
									enet_peer_disconnect_now(peer, 0);
								}
								catch (...)
								{
									SendConsole("joinguild Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
									enet_peer_disconnect_now(peer, 0);
								}
							}
						}
						if (btn == "showguild")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							string onlinegmlist = "";
							string grole = "";
							int onlinecount = 0;
							string guildname = PlayerDB::getProperName(static_cast<PlayerInfo*>(peer->data)->guild);
							if (guildname != "")
							{
								try
								{
									std::ifstream ifff("guilds/" + guildname + ".json");
									if (ifff.fail())
									{
										ifff.close();
										static_cast<PlayerInfo*>(peer->data)->guild = "";
										continue;
									}
									json j;
									ifff >> j;
									int gfbg, gffg, guildlvl, guildxp;
									string gstatement, gleader;
									vector<string> gmembers;
									gfbg = j["backgroundflag"];
									gffg = j["foregroundflag"];
									gstatement = j["GuildStatement"].get<std::string>();
									gleader = j["Leader"].get<std::string>();
									guildlvl = j["GuildLevel"];
									guildxp = j["GuildExp"];
									for (int i = 0; i < j["Member"].size(); i++)
									{
										gmembers.push_back(j["Member"][i]);
									}
									static_cast<PlayerInfo*>(peer->data)->guildlevel = guildlvl;
									static_cast<PlayerInfo*>(peer->data)->guildexp = guildxp;
									static_cast<PlayerInfo*>(peer->data)->guildBg = gfbg;
									static_cast<PlayerInfo*>(peer->data)->guildFg = gffg;
									static_cast<PlayerInfo*>(peer->data)->guildStatement = gstatement;
									static_cast<PlayerInfo*>(peer->data)->guildLeader = gleader;
									static_cast<PlayerInfo*>(peer->data)->guildMembers = gmembers;
									ifff.close();
								}
								catch (std::exception&)
								{
									SendConsole("showguild Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
									enet_peer_disconnect_now(peer, 0);
								}
								catch (std::runtime_error&)
								{
									SendConsole("showguild Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
									enet_peer_disconnect_now(peer, 0);
								}
								catch (...)
								{
									SendConsole("showguild Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
									enet_peer_disconnect_now(peer, 0);
								}
							}
							ENetPeer* currentPeer;
							for (currentPeer = server->peers;
								currentPeer < &server->peers[server->peerCount];
								++currentPeer)
							{
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
									continue;
								string name = static_cast<PlayerInfo*>(currentPeer->data)->rawName;
								if (find(static_cast<PlayerInfo*>(peer->data)->guildMembers.begin(), static_cast<PlayerInfo*>(peer->data)->guildMembers.end(), name) != static_cast<PlayerInfo*>(peer->data)->guildMembers.end())
								{
									if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == static_cast<PlayerInfo*>(peer->data)->guildLeader)
									{
										onlinegmlist += "\nadd_button|onlinegm_" + static_cast<PlayerInfo*>(currentPeer->data)->rawName + "|`2ONLINE: `o" + static_cast<PlayerInfo*>(currentPeer->data)->displayName + " `e(GL)``|0|0|";
										onlinecount++;
									}
									else
									{
										onlinegmlist += "\nadd_button|onlinegm_" + static_cast<PlayerInfo*>(currentPeer->data)->rawName + "|`2ONLINE: `o" + static_cast<PlayerInfo*>(currentPeer->data)->displayName + " " + grole + "``|0|0|";
										onlinecount++;
									}
								}
							}
							int guildsize = 15;
							if (static_cast<PlayerInfo*>(peer->data)->guildlevel == 2)
							{
								guildsize = 20;
							}
							else if (static_cast<PlayerInfo*>(peer->data)->guildlevel == 3)
							{
								guildsize = 25;
							}
							else if (static_cast<PlayerInfo*>(peer->data)->guildlevel == 4)
							{
								guildsize = 30;
							}
							else if (static_cast<PlayerInfo*>(peer->data)->guildlevel == 5)
							{
								guildsize = 35;
							}
							else if (static_cast<PlayerInfo*>(peer->data)->guildlevel == 6)
							{
								guildsize = 40;
							}
							else if (static_cast<PlayerInfo*>(peer->data)->guildlevel == 7)
							{
								guildsize = 45;
							}
							else if (static_cast<PlayerInfo*>(peer->data)->guildlevel == 8)
							{
								guildsize = 50;
							}
							if (static_cast<PlayerInfo*>(peer->data)->rawName == static_cast<PlayerInfo*>(peer->data)->guildLeader)
							{
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"),
									"set_default_color|`o\n\nadd_dual_layer_icon_label|big|`wGuild Home|left|" + std::to_string(static_cast<PlayerInfo*>(peer->data)->guildBg) + "|" + std::to_string(static_cast<PlayerInfo*>(peer->data)->guildFg) + "|1.0|0|\n\nadd_spacer|small|\nadd_textbox|" + static_cast<PlayerInfo*>(peer->data)->guildStatement + "``|\nadd_textbox|`oGuild size: " + to_string(guildsize) + " members|\nadd_textbox|`oGuild Level: " + std::to_string(static_cast<PlayerInfo*>(peer->data)->guildlevel) + "|\n\nadd_spacer|small|\nadd_button|guildoffline|`wShow offline too``|0|0|\nadd_button|goguildhome|`wGo to Guild Home``|0|0|\nadd_button|guildleveluper|`wUpgrade Guild``|0|0|\nadd_button|leavefromguild|`4Abandon Guild``|0|0|\n\nadd_spacer|small|\nadd_textbox|`5" + std::to_string(onlinecount) + " of " + std::to_string(static_cast<PlayerInfo*>(peer->data)->guildMembers.size()) + " `wGuild Members Online|" + onlinegmlist + "\n\nadd_spacer|small|\nadd_button||`wClose``|0|0|\nadd_quick_exit|"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);
								delete p2.data;
							}
							else
							{
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"),
									"set_default_color|`o\n\nadd_dual_layer_icon_label|big|`wGuild Home|left|" + std::to_string(static_cast<PlayerInfo*>(peer->data)->guildBg) + "|" + std::to_string(static_cast<PlayerInfo*>(peer->data)->guildFg) + "|1.0|0|\n\nadd_spacer|small|\nadd_textbox|" + static_cast<PlayerInfo*>(peer->data)->guildStatement + "``|\nadd_textbox|`oGuild size: " + to_string(guildsize) + " members|\nadd_textbox|`oGuild Level: " + std::to_string(static_cast<PlayerInfo*>(peer->data)->guildlevel) + "|\n\nadd_spacer|small|\nadd_button|guildoffline|`wShow offline too``|0|0|\nadd_button|goguildhome|`wGo to Guild Home``|0|0|\nadd_button|leavefromguild|`4Leave from guild``|0|0|\n\nadd_spacer|small|\nadd_textbox|`5" + std::to_string(onlinecount) + " of " + std::to_string(static_cast<PlayerInfo*>(peer->data)->guildMembers.size()) + " `wGuild Members Online|" + onlinegmlist + "\n\nadd_spacer|small|\nadd_button||`wClose``|0|0|\nadd_quick_exit|"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);
								delete p2.data;
							}
						}
						if (btn == "grewards")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							if (static_cast<PlayerInfo*>(peer->data)->guild == "")
							{
								continue;
							}
							int gpoints = 0;
							ifstream guildstream1("guildrewards/guildpoints/" + static_cast<PlayerInfo*>(peer->data)->guild + ".txt");
							guildstream1 >> gpoints;
							guildstream1.close();
							Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`9Spend Guild Points``|left|752|\nadd_spacer|small|\nadd_textbox|`5Guild Rewards|\nadd_button_with_icon|pirmasitemas||staticBlueFrame|1432|\nadd_button_with_icon|antrasitemas||staticBlueFrame|1432|\nadd_button_with_icon|treciasitemas||staticBlueFrame|1432|\nadd_button_with_icon|ketvirtasitemas||staticBlueFrame|1432|\nadd_button_with_icon|penktasitemas||staticBlueFrame|1432|\nadd_button_with_icon||END_LIST|noflags|0|0||\nadd_textbox|`5Personal Guild Rewards|\nadd_button_with_icon|pirmasitemasp||staticBlueFrame|10022|\nadd_button_with_icon|antrasitemasp||staticBlueFrame|1432|\nadd_button_with_icon|treciasitemasp||staticBlueFrame|1432|\nadd_button_with_icon|ketvirtasitemasp||staticBlueFrame|1432|\nadd_button_with_icon|penktasitemasp||staticBlueFrame|1432|\nadd_quick_exit|");
						}
						if (btn == "gcontribution")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							if (static_cast<PlayerInfo*>(peer->data)->guild == "")
							{
								continue;
							}
							int gpoints = 0;
							try
							{
								ifstream guildstream1("guildrewards/guildpoints/" + static_cast<PlayerInfo*>(peer->data)->guild + ".txt");
								guildstream1 >> gpoints;
								guildstream1.close();
							}
							catch (std::exception& e)
							{
								SendConsole("Button (gcontribution) Failed to Execute!", "ERROR");
								std::cerr << e.what() << std::endl;
							}
							try
							{
								vector<string> allMembers = static_cast<PlayerInfo*>(peer->data)->guildMembers;
								vector<string> names;
								vector<int> points;
								int point = 0;
								int kiekYra = 0;
								for (int i = 0; i < allMembers.size(); i++)
								{
									if (std::experimental::filesystem::exists("guildrewards/contribution/" + static_cast<PlayerInfo*>(peer->data)->guild + "/" + allMembers[i] + ".txt"))
									{
										ifstream get("guildrewards/contribution/" + static_cast<PlayerInfo*>(peer->data)->guild + "/" + allMembers[i] + ".txt");
										get >> point;
										get.close();
										names.push_back(allMembers[i]);
										points.push_back(point);
										kiekYra++;
									}
								}
								for (int i = 0; i < kiekYra; i++)
								{
									for (int j = i + 1; j < kiekYra; j++)
									{
										if (points[j] > points[i])
										{
											swap(points[j], points[i]);
											swap(names[j], names[i]);
										}
									}
								}
								string allList = "";
								int topCount = 0;
								for (int i = 0; i < kiekYra; i++)
								{
									if (names[i] != "")
									{
										topCount++;
										if (topCount == 1)
										{
											allList += "|\n\nadd_label_with_icon|small|`2" + names[i] + " `9Contribution: `^" + std::to_string(points[i]) + " `9Points.|left|6138||";
										}
										else if (topCount == 2)
										{
											allList += "|\n\nadd_label_with_icon|small|`2" + names[i] + " `9Contribution: `^" + std::to_string(points[i]) + " `9Points.|left|6136||";
										}
										else if (topCount == 3)
										{
											allList += "|\n\nadd_label_with_icon|small|`2" + names[i] + " `9Contribution: `^" + std::to_string(points[i]) + " `9Points.|left|6134||";
										}
										else
										{
											allList += "|\n\nadd_label_with_icon|small|`2" + names[i] + " `oContribution: `^" + std::to_string(points[i]) + " `9Points.|left|7970||";
										}
									}
								}
								Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`9Guild Members Contribution``|left|7340|\nadd_label|small|`5Your guild currently have: `^" + std::to_string(gpoints) + " `5Points.|left|4||\nadd_spacer|small|" + allList + "\nadd_quick_exit|");
							}
							catch (...)
							{
								SendConsole("Button (gcontribution) Failed to Execute!", "ERROR");
							}
						}
						if (btn == "pirmasitemasp")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							if (static_cast<PlayerInfo*>(peer->data)->guild == "")
							{
								continue;
							}
							Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`6Claim `2Wings of Seed`6!``|left|10022|\nadd_textbox|`5This item is available for limited time!|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`9Those `2Wings `9Are Pretty `^Shinny`9, Claim them before they `@Dissapear`9!|\nadd_spacer|small|\nadd_button|buywingofseed|`7Claim `2Wings of Seed `7[`43M`8 GPoints`7]|0|0|\nadd_spacer|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|");
						}
						/*if (btn == "penktasitemas")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT") {
								continue;
							}
							if (static_cast<PlayerInfo*>(peer->data)->guild == "")
							{
								continue;
							}
							Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`6Claim `#Finale Ticket`6!``|left|8774|\nadd_textbox|`5This item is available for limited time!|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`9This `#Ticket `9Grants you a `^Random `4Expensive `^Reward`9!|\nadd_spacer|small|\nadd_button|buyfinaleticket|`7Claim `#Finale Ticket `7[`45M`8 GPoints`7]|0|0|\nadd_spacer|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|");
						}*/
						if (btn == "buywingofseed")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							if (static_cast<PlayerInfo*>(peer->data)->guild == "")
							{
								continue;
							}
							int spended = 0;
							ifstream testcount("guildrewards/contribution/" + static_cast<PlayerInfo*>(peer->data)->guild + "/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
							testcount >> spended;
							testcount.close();
							string ispurchasedalr = "false";
							ifstream guildstream132("claimedrewards/wingsofseed/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
							guildstream132 >> ispurchasedalr;
							guildstream132.close();
							if (ispurchasedalr == "true")
							{
								Player::OnTextOverlay(peer, "`@You Already Claimed `2Wings of Seed`@!");
								continue;
							}
							if (spended < 3000000)
							{
								Player::OnTextOverlay(peer, "`9You `@Don't `9Have enough `8Personal Guild Points`9!");
							}
							else
							{
								bool success = false;
								SaveShopsItemMoreTimes(10022, 1, peer, success);
								if (success)
								{
									ofstream guildstream132("claimedrewards/wingsofseed/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									guildstream132 << "true";
									guildstream132.close();
									Player::OnTextOverlay(peer, "`9You have obtained `2Wings of Seed`9!");
									Player::OnParticleEffect(peer, 355, static_cast<PlayerInfo*>(peer->data)->x, static_cast<PlayerInfo*>(peer->data)->y, 0);
								}
							}
						}
						if (btn == "buyfinaleticket")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							if (static_cast<PlayerInfo*>(peer->data)->guild == "")
							{
								continue;
							}
							int spended = 0;
							ifstream testcount("guildrewards/contribution/" + static_cast<PlayerInfo*>(peer->data)->guild + "/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
							testcount >> spended;
							testcount.close();
							if (spended < 30000)
							{
								Player::OnTextOverlay(peer, "`@You Must Earn `430000 `@Points`@!");
								continue;
							}
							string ispurchasedalr = "false";
							ifstream guildstream132("claimedrewards/finaleticket/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
							guildstream132 >> ispurchasedalr;
							guildstream132.close();
							if (ispurchasedalr == "true")
							{
								Player::OnTextOverlay(peer, "`@You Already Claimed `#Finale Ticket`@!");
								continue;
							}
							int gpoints = 0;
							ifstream guildstream1("guildrewards/guildpoints/" + static_cast<PlayerInfo*>(peer->data)->guild + ".txt");
							guildstream1 >> gpoints;
							guildstream1.close();
							if (gpoints < 5000000)
							{
								Player::OnTextOverlay(peer, "`9You `@Don't `9Have enough `8Guild Points`9!");
							}
							else
							{
								bool success = false;
								SaveShopsItemMoreTimes(8774, 1, peer, success);
								if (success)
								{
									ofstream guildstream132("claimedrewards/finaleticket/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									guildstream132 << "true";
									guildstream132.close();
									Player::OnTextOverlay(peer, "`9You have obtained `#Finale Ticket`9!");
									Player::OnParticleEffect(peer, 355, static_cast<PlayerInfo*>(peer->data)->x, static_cast<PlayerInfo*>(peer->data)->y, 0);
								}
							}
						}
						if (btn == "guildleveluper")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							if (static_cast<PlayerInfo*>(peer->data)->guild == "")
							{
								continue;
							}
							int needdls = static_cast<PlayerInfo*>(peer->data)->guildlevel * 30;
							if (static_cast<PlayerInfo*>(peer->data)->guildlevel <= 6)
							{
								Player::OnDialogRequest(peer, "set_default_color|`o\nadd_dual_layer_icon_label|big|`wUpgrade Your Guild|left|" + std::to_string(static_cast<PlayerInfo*>(peer->data)->guildBg) + "|" + std::to_string(static_cast<PlayerInfo*>(peer->data)->guildFg) + "|1.0|0|\n\nadd_spacer|small|\nadd_textbox|`5Upgrading your guild unlocks new features such as increased member slots and various boosts, buffs!|\nadd_textbox|`5Your current guild level: `^" + to_string(static_cast<PlayerInfo*>(peer->data)->guildlevel) + "``|\nadd_spacer|small|\nadd_textbox|`5To `^Upgrade `5Your `9Guild `5You Need:|\nadd_label_with_icon|small|`2" + std::to_string(needdls) + " `!Diamond Locks``|left|1796|\nadd_spacer|small|\nadd_button|upgradeguildnow|`9Upgrade!``|0|0||\nadd_button||`wClose``|0|0|\nadd_quick_exit|");
							}
							else
							{
								Player::OnTextOverlay(peer, "your guild at max level!");
							}
						}
						if (btn == "upgradeguildnow")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							if (static_cast<PlayerInfo*>(peer->data)->guild == "")
							{
								continue;
							}
							int needdls = static_cast<PlayerInfo*>(peer->data)->guildlevel * 30;
							bool iscontains = false;
							SearchInventoryItem(peer, 1796, needdls, iscontains);
							if (!iscontains)
							{
								Player::OnTextOverlay(peer, "`9You `@Don't `9Have enough `eDiamond Locks`9!");
							}
							else
							{
								RemoveInventoryItem(1796, needdls, peer, true);
								int guildlevelnow = static_cast<PlayerInfo*>(peer->data)->guildlevel;
								guildlevelnow += 1;
								if (guildlevelnow == 7)
								{
									Player::OnTextOverlay(peer, "`9Your guild is at `2max level`9!");
									continue;
								}
								static_cast<PlayerInfo*>(peer->data)->guildlevel = guildlevelnow;
								Player::OnTextOverlay(peer, "`0You have `9Upgraded your `^Guild `0To `9Level `2" + std::to_string(guildlevelnow) + "`0!");
								ENetPeer* currentPeer;
								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									if (static_cast<PlayerInfo*>(currentPeer->data)->guild == static_cast<PlayerInfo*>(peer->data)->guild)
									{
										try
										{
											std::ifstream ifff("guilds/" + PlayerDB::getProperName(static_cast<PlayerInfo*>(peer->data)->guild) + ".json");
											if (ifff.fail())
											{
												ifff.close();
												GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`4Error: `oGuild does not exist! If you are seeing this message, please take a screenshot and send it to a developer!"));
												ENetPacket* packet = enet_packet_create(ps.data,
													ps.len,
													ENET_PACKET_FLAG_RELIABLE);
												enet_peer_send(peer, 0, packet);
												delete ps.data;
												continue;
											}
											if (ifff.is_open())
											{
											}
											json j;
											ifff >> j; //load
											j["GuildLevel"] = guildlevelnow; //edit
											std::ofstream o("guilds/" + PlayerDB::getProperName(static_cast<PlayerInfo*>(peer->data)->guild) + ".json"); //save
											if (!o.is_open()) continue;
											o << j << std::endl;
											updateGuild(currentPeer);
											Player::OnConsoleMessage(currentPeer, "`5[GUILD ALERT] `2Your guild have been upgraded to level " + std::to_string(guildlevelnow) + "!");
										}
										catch (std::exception&)
										{
											SendConsole("upgradeguildnow Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
											enet_peer_disconnect_now(peer, 0);
										}
										catch (std::runtime_error&)
										{
											SendConsole("upgradeguildnow Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
											enet_peer_disconnect_now(peer, 0);
										}
										catch (...)
										{
											SendConsole("upgradeguildnow Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
											enet_peer_disconnect_now(peer, 0);
										}
									}
								}
							}
						}
						if (btn == "leavefromguild")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							if (static_cast<PlayerInfo*>(peer->data)->rawName == static_cast<PlayerInfo*>(peer->data)->guildLeader)
							{
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|\nadd_label_with_icon|big|`8Are you sure?``|left|6204|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`oAfter `4Abandon `ofrom the guild, all guild's members will be `4kicked out `oand the guild will be `4destroyed`o!|left|8|\nadd_spacer|small|\nadd_button|confirmguildleaderleave|`4Yes, Abandon!|0|0|\nadd_spacer|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|"));
								ENetPacket* packet = enet_packet_create(p.data,
									p.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else
							{
								try
								{
									std::ifstream ifff("guilds/" + PlayerDB::getProperName(static_cast<PlayerInfo*>(peer->data)->guild) + ".json");
									if (ifff.fail())
									{
										ifff.close();
										GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`4Error: `oGuild does not exist! If you are seeing this message, please take a screenshot and send it to a developer!"));
										ENetPacket* packet = enet_packet_create(ps.data,
											ps.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete ps.data;
										continue;
									}
									if (ifff.is_open())
									{
									}
									remove(("guildrewards/contribution/" + PlayerDB::getProperName(static_cast<PlayerInfo*>(peer->data)->guild) + "/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt").c_str());
									json j;
									ifff >> j; //load
									vector<string> gmlist;
									for (int i = 0; i < j["Member"].size(); i++)
									{
										gmlist.push_back(j["Member"][i]);
									}
									gmlist.erase(std::remove(gmlist.begin(), gmlist.end(), static_cast<PlayerInfo*>(peer->data)->rawName), gmlist.end());
									j["Member"] = gmlist; //edit
									std::ofstream o("guilds/" + PlayerDB::getProperName(static_cast<PlayerInfo*>(peer->data)->guild) + ".json"); //save
									if (!o.is_open()) continue;
									o << j << std::endl;
									ENetPeer* currentPeer;
									for (currentPeer = server->peers;
										currentPeer < &server->peers[server->peerCount];
										++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
											continue;
										if (static_cast<PlayerInfo*>(currentPeer->data)->guild == static_cast<PlayerInfo*>(peer->data)->guild)
										{
											updateGuild(currentPeer);
											updateInvis(currentPeer);
										}
									}
									static_cast<PlayerInfo*>(peer->data)->guildBg = 0;
									static_cast<PlayerInfo*>(peer->data)->guildFg = 0;
									static_cast<PlayerInfo*>(peer->data)->guildLeader = "";
									static_cast<PlayerInfo*>(peer->data)->guild = "";
									static_cast<PlayerInfo*>(peer->data)->guildStatement = "";
									static_cast<PlayerInfo*>(peer->data)->guildlast = "";
									static_cast<PlayerInfo*>(peer->data)->lastgm = "";
									static_cast<PlayerInfo*>(peer->data)->lastgmname = "";
									static_cast<PlayerInfo*>(peer->data)->joinguild = false;
									static_cast<PlayerInfo*>(peer->data)->lastgmworld = "";
									static_cast<PlayerInfo*>(peer->data)->guildMembers.clear();
									updateInvis(peer);
									ifstream fg("players/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".json");
									json j2;
									fg >> j2;
									fg.close();

									j2["guild"] = "";
									j2["joinguild"] = false;

									ofstream fs("players/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".json");
									fs << j2;
									fs.close();
								}
								catch (std::exception&)
								{
									SendConsole("leavefromguild Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
									enet_peer_disconnect_now(peer, 0);
								}
								catch (std::runtime_error&)
								{
									SendConsole("leavefromguild Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
									enet_peer_disconnect_now(peer, 0);
								}
								catch (...)
								{
									SendConsole("leavefromguild Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
									enet_peer_disconnect_now(peer, 0);
								}
							}
						}
						if (btn == "confirmguildleaderleave")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							try
							{
								std::ifstream ifff("guilds/" + PlayerDB::getProperName(static_cast<PlayerInfo*>(peer->data)->guild) + ".json");
								if (ifff.fail())
								{
									ifff.close();
									GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`4Error: `oGuild does not exist! If you are seeing this message, please take a screenshot and send it to a developer!"));
									ENetPacket* packet = enet_packet_create(ps.data,
										ps.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete ps.data;
									continue;
								}
								json j;
								ifff >> j; //load
								ifff.close();
								vector<string> gmlist;
								for (int i = 0; i < j["Member"].size(); i++)
								{
									gmlist.push_back(j["Member"][i]);
								}
								const int result = remove(("guilds/" + PlayerDB::getProperName(static_cast<PlayerInfo*>(peer->data)->guild) + ".json").c_str());
								remove(("guildrewards/guildpoints/" + PlayerDB::getProperName(static_cast<PlayerInfo*>(peer->data)->guild) + ".txt").c_str());
								namespace fs = std::experimental::filesystem;
								fs::remove_all("guildrewards/contribution/" + PlayerDB::getProperName(static_cast<PlayerInfo*>(peer->data)->guild));
								if (result == 0)
								{
								}
								else
								{
									SendConsole("Button (confirmguildleaderleave) Failed to execute!", "ERROR");
								}
								ENetPeer* currentPeer;
								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									if (find(gmlist.begin(), gmlist.end(), static_cast<PlayerInfo*>(currentPeer->data)->rawName) != gmlist.end())
									{
										static_cast<PlayerInfo*>(currentPeer->data)->guildBg = 0;
										static_cast<PlayerInfo*>(currentPeer->data)->guildFg = 0;
										static_cast<PlayerInfo*>(currentPeer->data)->guildLeader = "";
										static_cast<PlayerInfo*>(currentPeer->data)->guild = "";
										static_cast<PlayerInfo*>(currentPeer->data)->guildStatement = "";
										//static_cast<PlayerInfo*>(currentPeer->data)->guildRole = 0;
										static_cast<PlayerInfo*>(currentPeer->data)->guildlast = "";
										static_cast<PlayerInfo*>(currentPeer->data)->lastgm = "";
										static_cast<PlayerInfo*>(currentPeer->data)->lastgmname = "";
										static_cast<PlayerInfo*>(currentPeer->data)->joinguild = false;
										static_cast<PlayerInfo*>(currentPeer->data)->lastgmworld = "";
										static_cast<PlayerInfo*>(currentPeer->data)->guildMembers.clear();
										updateInvis(currentPeer);
										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5[GUILD ALERT] `4Unfortunately, `obut guild's leader `4abandoned `ofrom the guild and you were `4kicked out`o."));
										ENetPacket* packet = enet_packet_create(p.data,
											p.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(currentPeer, 0, packet);
										delete p.data;
									}
								}
								for (int i = 0; i < gmlist.size(); i++)
								{
									ifstream fg("players/" + gmlist[i] + ".json");
									json j;
									fg >> j;
									fg.close();

									j["guild"] = "";
									j["joinguild"] = false;

									ofstream fs("players/" + gmlist[i] + ".json");
									fs << j;
									fs.close();
								}
							}
							catch (std::exception&)
							{
								SendConsole("confirmguildleaderleave Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
								enet_peer_disconnect_now(peer, 0);
							}
							catch (std::runtime_error&)
							{
								SendConsole("confirmguildleaderleave Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
								enet_peer_disconnect_now(peer, 0);
							}
							catch (...)
							{
								SendConsole("confirmguildleaderleave Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
								enet_peer_disconnect_now(peer, 0);
							}
						}
						if (btn == "guildoffline")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							string onlinegmlist = "";
							string offname, offlinegm;
							string grole = "";
							int onlinecount = 0;
							int totalcount = static_cast<PlayerInfo*>(peer->data)->guildMembers.size();
							string gstatement = static_cast<PlayerInfo*>(peer->data)->guildLeader;
							string bg = std::to_string(static_cast<PlayerInfo*>(peer->data)->guildBg);
							string fg = std::to_string(static_cast<PlayerInfo*>(peer->data)->guildFg);
							string guildname = static_cast<PlayerInfo*>(peer->data)->guild;
							string guildleader = static_cast<PlayerInfo*>(peer->data)->guildLeader;
							string guildlvl = "0";
							string guildexp = "0";
							ENetPeer* currentPeer;
							vector<string> offlineguild = static_cast<PlayerInfo*>(peer->data)->guildMembers;
							for (currentPeer = server->peers;
								currentPeer < &server->peers[server->peerCount];
								++currentPeer)
							{
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
									continue;
								string name = static_cast<PlayerInfo*>(currentPeer->data)->rawName;
								if (find(static_cast<PlayerInfo*>(peer->data)->guildMembers.begin(), static_cast<PlayerInfo*>(peer->data)->guildMembers.end(), name) != static_cast<PlayerInfo*>(peer->data)->guildMembers.end())
								{
									if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == static_cast<PlayerInfo*>(peer->data)->guildLeader)
									{
										onlinegmlist += "\nadd_button|onlinegm_" + static_cast<PlayerInfo*>(currentPeer->data)->rawName + "|`2ONLINE: `o" + static_cast<PlayerInfo*>(currentPeer->data)->displayName + " `e(GL)``|0|0|";
										onlinecount++;
									}
									else
									{
										onlinegmlist += "\nadd_button|onlinegm_" + static_cast<PlayerInfo*>(currentPeer->data)->rawName + "|`2ONLINE: `o" + static_cast<PlayerInfo*>(currentPeer->data)->displayName + " " + grole + "``|0|0|";
										onlinecount++;
										offlineguild.erase(std::remove(offlineguild.begin(), offlineguild.end(), name), offlineguild.end());
									}
								}
							}
							for (std::vector<string>::const_iterator i = offlineguild.begin(); i != offlineguild.end(); ++i)
							{
								offname = *i;
								offlinegm += "\nadd_button|offlinegm_" + offname + "|`4OFFLINE: `o" + offname + "``|0|0|";
							}
							int guildsize = 15;
							if (static_cast<PlayerInfo*>(peer->data)->guildlevel == 2)
							{
								guildsize = 20;
							}
							else if (static_cast<PlayerInfo*>(peer->data)->guildlevel == 3)
							{
								guildsize = 25;
							}
							else if (static_cast<PlayerInfo*>(peer->data)->guildlevel == 4)
							{
								guildsize = 30;
							}
							else if (static_cast<PlayerInfo*>(peer->data)->guildlevel == 5)
							{
								guildsize = 35;
							}
							else if (static_cast<PlayerInfo*>(peer->data)->guildlevel == 6)
							{
								guildsize = 40;
							}
							else if (static_cast<PlayerInfo*>(peer->data)->guildlevel == 7)
							{
								guildsize = 45;
							}
							else if (static_cast<PlayerInfo*>(peer->data)->guildlevel == 8)
							{
								guildsize = 50;
							}
							GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\nadd_dual_layer_icon_label|big|`wGuild Home|left|" + std::to_string(static_cast<PlayerInfo*>(peer->data)->guildBg) + "|" + std::to_string(static_cast<PlayerInfo*>(peer->data)->guildFg) + "|1.0|0|\n\nadd_spacer|small|\nadd_textbox|" + static_cast<PlayerInfo*>(peer->data)->guildStatement + "``|\nadd_textbox|`oGuild size: " + std::to_string(guildsize) + " members|\nadd_textbox|`oGuild Level: " + std::to_string(static_cast<PlayerInfo*>(peer->data)->guildlevel) + "|\n\nadd_spacer|small|\nadd_button|goguildhome|`wGo to Guild Home``|0|0|\nadd_button|leavefromguild|`4Leave from guild``|0|0|\n\nadd_spacer|small|\nadd_textbox|`5" + std::to_string(onlinecount) + " of " + std::to_string(static_cast<PlayerInfo*>(peer->data)->guildMembers.size()) + " `wGuild Members Online|" + offlinegm + "\n\nadd_spacer|small|\nadd_button||`wClose``|0|0|\nadd_quick_exit|"));
							ENetPacket* packet2 = enet_packet_create(p2.data,
								p2.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet2);
							delete p2.data;
						}
						if (btn == "goguildhome")
						{
							continue;
							/*if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT") {
								continue;
							}
							bool guildexist = std::experimental::filesystem::exists("guilds/" + PlayerDB::getProperName(static_cast<PlayerInfo*>(peer->data)->guild) + ".json");
							if (guildexist) {
								string gworld;
								string guildName = static_cast<PlayerInfo*>(peer->data)->guild;
								std::ifstream ifs("guilds/" + PlayerDB::getProperName(static_cast<PlayerInfo*>(peer->data)->guild) + ".json");
								if (ifs.is_open()) {
									json j;
									ifs >> j;
									gworld = j["GuildWorld"].get<std::string>();
								}
								sendPlayerLeave(peer, (PlayerInfo*)(peer->data));
								joinWorld(peer, gworld, 0, 0);
							}
							else {
								Player::OnTextOverlay(peer, "Errorx434");
							}*/
						}
						if (btn == "createguildinfo")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`wGrow Guilds|left|242|\nadd_label|small|`9Welcome to Grow Guilds where you can create a Guild! With a Guild you can level up the Guild to add more members!``|left|4|\n\nadd_spacer|small|\nadd_textbox|`9You will be charged `6250,000 `9Gems!``|\nadd_spacer|small|\nadd_button|createguild|`oCreate a Guild``|0|0|\nend_dialog||Close||\nadd_quick_exit|"));
							ENetPacket* packet2 = enet_packet_create(p2.data,
								p2.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet2);
							delete p2.data;
						}
						if (btn == "createguild")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`wGrow Guild Creation``|left|242|\nadd_spacer|small|\nadd_text_input|gname|Guild Name: ||20|\nadd_text_input|gstatement|Guild Statement: ||100|\nadd_text_input|ggcflagbg|`oGuild Flag Background ID:``||5|\nadd_text_input|ggcflagfg|`oGuild Flag Foreground ID:``||5|\nadd_spacer|small|\nadd_textbox|`oConfirm your guild settings by selecting `2Create Guild `obelow to create your guild.|\nadd_spacer|small|\nadd_textbox|`8Remember`o: A guild can only be created in a world owned by you and locked with a `5World Lock`o!|\nadd_spacer|small|\nadd_textbox|`4Warning! `oThe guild name cannot be changed once you have confirmed the guild settings!|\nadd_quick_exit|\nadd_spacer|small|\nend_dialog|guildconfirm|Cancel|Create Guild|\n"));
							ENetPacket* packet2 = enet_packet_create(p2.data,
								p2.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet2);
							delete p2.data;
						}
						if (btn.substr(0, 5) == "warp_") {
							string gago = btn.substr(5, btn.length() - 5).c_str();
							if (gago == ((PlayerInfo*)(peer->data))->currentWorld) {
								Player::OnTextOverlay(peer, "You are in the same world!");
								continue;
							}
							joinWorld(peer, gago, 0, 0);
						}

						if (btn.substr(0, 10) == "offlinegm_")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							static_cast<PlayerInfo*>(peer->data)->lastgm = btn.substr(10, cch.length() - 10 - 1);
							if (btn.substr(10, cch.length() - 10 - 1) == static_cast<PlayerInfo*>(peer->data)->guildLeader)
							{
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_dual_layer_icon_label|big|`w" + static_cast<PlayerInfo*>(peer->data)->lastgm + "|left|" + std::to_string(static_cast<PlayerInfo*>(peer->data)->guildBg) + "|" + std::to_string(static_cast<PlayerInfo*>(peer->data)->guildFg) + "|1.0|0|\n\nadd_spacer|small|\nadd_textbox|`oRank: Leader|\nadd_spacer|small|\nadd_textbox|`o" + static_cast<PlayerInfo*>(peer->data)->lastgm + " is `4offline`o.``|\nadd_spacer|small|\nadd_button|guildoffline|`oBack``|0|0|\nadd_quick_exit|"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);
								delete p2.data;
							}
							else
							{
								if (static_cast<PlayerInfo*>(peer->data)->rawName == static_cast<PlayerInfo*>(peer->data)->guildLeader)
								{
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_dual_layer_icon_label|big|`w" + static_cast<PlayerInfo*>(peer->data)->lastgm + "|left|" + std::to_string(static_cast<PlayerInfo*>(peer->data)->guildBg) + "|" + std::to_string(static_cast<PlayerInfo*>(peer->data)->guildFg) + "|1.0|0|\n\nadd_spacer|small|\nadd_textbox|`oRank: Member|\nadd_spacer|small|\nadd_textbox|`o" + static_cast<PlayerInfo*>(peer->data)->lastgm + " is `4offline`o.``|\nadd_spacer|small|\nadd_button|removegmoffline|`oKick from the guild``|0|0|\nadd_button|guildoffline|`oBack``|0|0|\nadd_quick_exit|"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
								}
								else
								{
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_dual_layer_icon_label|big|`w" + static_cast<PlayerInfo*>(peer->data)->lastgm + "|left|" + std::to_string(static_cast<PlayerInfo*>(peer->data)->guildBg) + "|" + std::to_string(static_cast<PlayerInfo*>(peer->data)->guildFg) + "|1.0|0|\n\nadd_spacer|small|\nadd_textbox|`oRank: Member|\nadd_spacer|small|\nadd_textbox|`o" + static_cast<PlayerInfo*>(peer->data)->lastgm + " is `4offline`o.``|\nadd_spacer|small|\nadd_button|guildoffline|`oBack``|0|0|\nadd_quick_exit|"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
								}
							}
						}
						if (btn == "removegmoffline")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							ENetPeer* currentPeer;
							for (currentPeer = server->peers;
								currentPeer < &server->peers[server->peerCount];
								++currentPeer)
							{
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
									continue;
								if (static_cast<PlayerInfo*>(currentPeer->data)->guild == static_cast<PlayerInfo*>(peer->data)->guild)
								{
									try
									{
										std::ifstream ifff("guilds/" + PlayerDB::getProperName(static_cast<PlayerInfo*>(peer->data)->guild) + ".json");
										if (ifff.fail())
										{
											ifff.close();
											GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`4Error: `oGuild does not exist! If you are seeing this message, please take a screenshot and send it to a developer!"));
											ENetPacket* packet = enet_packet_create(ps.data,
												ps.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(peer, 0, packet);
											delete ps.data;
											continue;
										}
										if (ifff.is_open())
										{
										}
										json j;
										ifff >> j; //load
										vector<string> gmlist;
										for (int i = 0; i < j["Member"].size(); i++)
										{
											gmlist.push_back(j["Member"][i]);
										}
										gmlist.erase(std::remove(gmlist.begin(), gmlist.end(), static_cast<PlayerInfo*>(peer->data)->lastgm), gmlist.end());
										j["Member"] = gmlist; //edit
										std::ofstream o("guilds/" + PlayerDB::getProperName(static_cast<PlayerInfo*>(peer->data)->guild) + ".json"); //save
										if (!o.is_open()) continue;
										o << j << std::endl;

										ifstream fg("players/" + PlayerDB::getProperName(static_cast<PlayerInfo*>(peer->data)->lastgm) + ".json");
										json j2;
										fg >> j2;
										fg.close();

										j2["guild"] = "";
										j2["joinguild"] = false;

										ofstream fs("players/" + PlayerDB::getProperName(static_cast<PlayerInfo*>(peer->data)->lastgm) + ".json");
										fs << j2;
										fs.close();

										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5[GUILD ALERT] `2" + static_cast<PlayerInfo*>(peer->data)->lastgm + "`o has been kicked from the guild!"));
										ENetPacket* packet = enet_packet_create(p.data,
											p.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(currentPeer, 0, packet);
										delete p.data;
									}
									catch (std::exception&)
									{
										SendConsole("removegmoffline Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_now(peer, 0);
									}
									catch (std::runtime_error&)
									{
										SendConsole("removegmoffline Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_now(peer, 0);
									}
									catch (...)
									{
										SendConsole("removegmoffline Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_now(peer, 0);
									}
								}
							}
							GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`4Guild Member removed``|left|1366|\n\nadd_spacer|small|\nadd_textbox|`o" + static_cast<PlayerInfo*>(peer->data)->lastgm + " is no longer in the guild.``|\n\nadd_spacer|small|\nadd_button|guildportalbutton|`oOK``|0|0|\nadd_quick_exit|"));
							ENetPacket* packet2 = enet_packet_create(p2.data,
								p2.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet2);
							delete p2.data;
						}
						if (btn == "removegmonline")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							ENetPeer* currentPeer;
							for (currentPeer = server->peers;
								currentPeer < &server->peers[server->peerCount];
								++currentPeer)
							{
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
									continue;
								if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == static_cast<PlayerInfo*>(peer->data)->lastgm)
								{
									try
									{
										std::ifstream ifff("guilds/" + PlayerDB::getProperName(static_cast<PlayerInfo*>(peer->data)->guild) + ".json");
										if (ifff.fail())
										{
											ifff.close();
											GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`4Error: `oGuild does not exist! If you are seeing this message, please take a screenshot and send it to a developer!"));
											ENetPacket* packet = enet_packet_create(ps.data,
												ps.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(peer, 0, packet);
											delete ps.data;
											continue;
										}
										if (ifff.is_open())
										{
										}
										json j;
										ifff >> j; //load
										vector<string> gmlist;
										for (int i = 0; i < j["Member"].size(); i++)
										{
											gmlist.push_back(j["Member"][i]);
										}
										gmlist.erase(std::remove(gmlist.begin(), gmlist.end(), static_cast<PlayerInfo*>(peer->data)->lastgm), gmlist.end());
										j["Member"] = gmlist; //edit
										std::ofstream o("guilds/" + PlayerDB::getProperName(static_cast<PlayerInfo*>(peer->data)->guild) + ".json"); //save
										if (!o.is_open()) continue;
										o << j << std::endl;
										static_cast<PlayerInfo*>(currentPeer->data)->guildBg = 0;
										static_cast<PlayerInfo*>(currentPeer->data)->guildFg = 0;
										static_cast<PlayerInfo*>(currentPeer->data)->guildLeader = "";
										static_cast<PlayerInfo*>(currentPeer->data)->guild = "";
										static_cast<PlayerInfo*>(currentPeer->data)->guildStatement = "";
										//static_cast<PlayerInfo*>(currentPeer->data)->guildRole = 0;
										static_cast<PlayerInfo*>(currentPeer->data)->guildlast = "";
										static_cast<PlayerInfo*>(currentPeer->data)->lastgm = "";
										static_cast<PlayerInfo*>(currentPeer->data)->lastgmname = "";
										static_cast<PlayerInfo*>(currentPeer->data)->joinguild = false;
										static_cast<PlayerInfo*>(currentPeer->data)->lastgmworld = "";
										static_cast<PlayerInfo*>(currentPeer->data)->guildMembers.clear();
										updateInvis(currentPeer);
										updateInvis(peer);
										ifstream fg("players/" + static_cast<PlayerInfo*>(currentPeer->data)->rawName + ".json");
										json j2;
										fg >> j2;
										fg.close();

										j2["guild"] = "";
										j2["joinguild"] = false;

										ofstream fs("players/" + static_cast<PlayerInfo*>(currentPeer->data)->rawName + ".json");
										fs << j2;
										fs.close();
										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5[GUILD ALERT] `oYou have been kicked from the guild by `2" + static_cast<PlayerInfo*>(peer->data)->displayName + "`o."));
										ENetPacket* packet = enet_packet_create(p.data,
											p.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(currentPeer, 0, packet);
										delete p.data;
									}
									catch (std::exception&)
									{
										SendConsole("removegmonline Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_now(peer, 0);
									}
									catch (std::runtime_error&)
									{
										SendConsole("removegmonline Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_now(peer, 0);
									}
									catch (...)
									{
										SendConsole("removegmonline Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_now(peer, 0);
									}
								}
								if (static_cast<PlayerInfo*>(currentPeer->data)->guild == static_cast<PlayerInfo*>(peer->data)->guild)
								{
									updateGuild(currentPeer);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5[GUILD ALERT] `2" + static_cast<PlayerInfo*>(peer->data)->lastgmname + "`o has been kicked from the guild!"));
									ENetPacket* packet = enet_packet_create(p.data,
										p.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(currentPeer, 0, packet);
									delete p.data;
								}
							}
							GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`4Guild Member removed``|left|1366|\n\nadd_spacer|small|\nadd_textbox|`o" + static_cast<PlayerInfo*>(peer->data)->lastgmname + " is no longer in the guild.``|\n\nadd_spacer|small|\nadd_button|guildportalbutton|`oOK``|0|0|\nadd_quick_exit|"));
							ENetPacket* packet2 = enet_packet_create(p2.data,
								p2.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet2);
							delete p2.data;
						}
						if (btn == "confirmcreateguild")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							std::ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
							std::string content((std::istreambuf_iterator<char>(ifsz)),
								(std::istreambuf_iterator<char>()));
							int b = atoi(content.c_str());
							if (b > 249000)
							{
								int gemcalc10k = b - 250000;
								ofstream myfile2;
								myfile2.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
								myfile2 << std::to_string(gemcalc10k);
								myfile2.close();
								std::ifstream ifszi("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
								std::string contentx((std::istreambuf_iterator<char>(ifszi)),
									(std::istreambuf_iterator<char>()));
								int updgem = atoi(contentx.c_str());
								GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), updgem));
								ENetPacket* packetpp = enet_packet_create(pp.data,
									pp.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packetpp);
								delete pp.data;
								GamePacket pto = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "You created guild!"));
								ENetPacket* packetto = enet_packet_create(pto.data,
									pto.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packetto);
								delete pto.data;
								string guildName = static_cast<PlayerInfo*>(peer->data)->createGuildName;
								string guildStatement = static_cast<PlayerInfo*>(peer->data)->createGuildStatement;
								string fixedguildName = PlayerDB::getProperName(guildName);
								string guildFlagbg = static_cast<PlayerInfo*>(peer->data)->createGuildFlagBg;
								string guildFlagfg = static_cast<PlayerInfo*>(peer->data)->createGuildFlagFg;
								try
								{
									std::ofstream o("guilds/" + fixedguildName + ".json");
									if (!o.is_open()) continue;
									json j;
									vector<string> test1s;
									vector<string> test2s;
									static_cast<PlayerInfo*>(peer->data)->guildMembers.push_back(static_cast<PlayerInfo*>(peer->data)->rawName);
									j["GuildName"] = static_cast<PlayerInfo*>(peer->data)->createGuildName;
									j["GuildRawName"] = fixedguildName;
									j["GuildStatement"] = static_cast<PlayerInfo*>(peer->data)->createGuildStatement;
									j["Leader"] = static_cast<PlayerInfo*>(peer->data)->rawName;
									j["Co-Leader"] = test1s;
									j["Elder-Leader"] = test2s;
									j["Member"] = static_cast<PlayerInfo*>(peer->data)->guildMembers;
									j["GuildLevel"] = 1;
									j["GuildExp"] = 0;
									j["GuildWorld"] = static_cast<PlayerInfo*>(peer->data)->currentWorld;
									j["backgroundflag"] = atoi(static_cast<PlayerInfo*>(peer->data)->createGuildFlagBg.c_str());
									j["foregroundflag"] = atoi(static_cast<PlayerInfo*>(peer->data)->createGuildFlagFg.c_str());
									o << j << std::endl;
								}
								catch (std::exception&)
								{
									SendConsole("confirmcreateguild Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
									enet_peer_disconnect_now(peer, 0);
								}
								catch (std::runtime_error&)
								{
									SendConsole("confirmcreateguild Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
									enet_peer_disconnect_now(peer, 0);
								}
								catch (...)
								{
									SendConsole("confirmcreateguild Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
									enet_peer_disconnect_now(peer, 0);
								}
								ifstream fg("players/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".json");
								json j;
								fg >> j;
								fg.close();

								j["guild"] = guildName;
								j["joinguild"] = true;

								ofstream fs("players/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".json");
								fs << j;
								fs.close();
								static_cast<PlayerInfo*>(peer->data)->guild = guildName;
								static_cast<PlayerInfo*>(peer->data)->joinguild = true;
								static_cast<PlayerInfo*>(peer->data)->guildFg = atoi(static_cast<PlayerInfo*>(peer->data)->createGuildFlagFg.c_str());
								static_cast<PlayerInfo*>(peer->data)->guildBg = atoi(static_cast<PlayerInfo*>(peer->data)->createGuildFlagBg.c_str());
								updateInvis(peer);
							}
							else
							{
								GamePacket pto = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "You don't have enough gems."));
								ENetPacket* packetto = enet_packet_create(pto.data,
									pto.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packetto);
								delete pto.data;
							}
						}
						if (btn == "dotradedialog")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`wTrade Menu``|left|242|\nadd_label|small|\nadd_button_with_icon|dotrade|Do the Trade!|noflags|1424||\nadd_button|decline|`4Cancel/Decline|noflags||\nadd_spacer|small|\nadd_quick_exit|\nadd_button|chc0|Close|noflags|0|0|\nnend_dialog|gazette||OK|"));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						if (btn == "decline")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							string sellerName = static_cast<PlayerInfo*>(peer->data)->lastSeller;
							string sellingworld = static_cast<PlayerInfo*>(peer->data)->lastSellWorld;
							int gemsforworld = static_cast<PlayerInfo*>(peer->data)->lastTradeAmount;
							ENetPeer* currentPeer;
							for (currentPeer = server->peers;
								currentPeer < &server->peers[server->peerCount];
								++currentPeer)
							{
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
									continue;
								if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == sellerName)
								{
									if (static_cast<PlayerInfo*>(currentPeer->data)->haveGrowId == false) continue;
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`2Player `3'" + static_cast<PlayerInfo*>(peer->data)->rawName + "'`4 declined `2your world '" + sellingworld + "'trading!"));
									ENetPacket* packet = enet_packet_create(p.data,
										p.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(currentPeer, 0, packet);
									delete p.data;
									static_cast<PlayerInfo*>(currentPeer->data)->lastSeller = "";
									static_cast<PlayerInfo*>(currentPeer->data)->lastSellWorld = "";
									static_cast<PlayerInfo*>(currentPeer->data)->lastTradeAmount = 99999999999;
									static_cast<PlayerInfo*>(currentPeer->data)->lastBuyer = "";
									break;
								}
							}
							GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`2You successfully `4decline`2 this world called '" + sellingworld + "' trading"));
							ENetPacket* packet2 = enet_packet_create(p2.data,
								p2.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet2);
							delete p2.data;
							static_cast<PlayerInfo*>(peer->data)->lastSeller = "";
							static_cast<PlayerInfo*>(peer->data)->lastSellWorld = "";
							static_cast<PlayerInfo*>(peer->data)->lastTradeAmount = 99999999999;
							static_cast<PlayerInfo*>(peer->data)->lastBuyer = "";
						}
						if (btn == "dotrade")
						{
							if (world == nullptr || world->name == "EXIT" || serverIsFrozen) continue;
							string sellerName = static_cast<PlayerInfo*>(peer->data)->lastSeller;
							if (sellerName != world->owner)
							{
								Player::OnConsoleMessage(peer, "if you see this report to the owner.");
								continue;
							}
							string sellingworld = static_cast<PlayerInfo*>(peer->data)->lastSellWorld;
							int gemsforworld = static_cast<PlayerInfo*>(peer->data)->lastTradeAmount;
							string lastbuyerName = static_cast<PlayerInfo*>(peer->data)->rawName;
							ifstream fdseller("gemdb/" + sellerName + ".txt");
							ifstream fdbuyer("gemdb/" + lastbuyerName + ".txt");
							int nowseller;
							int nowbuyer;
							fdseller >> nowseller;
							fdbuyer >> nowbuyer;
							fdseller.close();
							fdbuyer.close();
							if (nowbuyer < gemsforworld)
							{
								GamePacket pError = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`4You don't how enough gems`3 to buy '`2" + sellingworld + "`3' world for `2" + to_string(gemsforworld) + "`3 gems"));
								ENetPacket* packetError = enet_packet_create(pError.data,
									pError.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packetError);
								delete pError.data;
								static_cast<PlayerInfo*>(peer->data)->lastSeller = "";
								static_cast<PlayerInfo*>(peer->data)->lastSellWorld = "";
								static_cast<PlayerInfo*>(peer->data)->lastTradeAmount = 99999999999;
								static_cast<PlayerInfo*>(peer->data)->lastBuyer = "";
								ENetPeer* currentPeerError;
								for (currentPeerError = server->peers;
									currentPeerError < &server->peers[server->peerCount];
									++currentPeerError)
								{
									if (currentPeerError->state != ENET_PEER_STATE_CONNECTED)
										continue;
									if (static_cast<PlayerInfo*>(currentPeerError->data)->rawName == sellerName)
									{
										if (static_cast<PlayerInfo*>(currentPeerError->data)->haveGrowId == false) continue;
										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`7Player `3" + static_cast<PlayerInfo*>(peer->data)->rawName + "`4 doesn't have '`8" + to_string(gemsforworld) + "`7' to buy your world '`8" + sellingworld + "'"));
										ENetPacket* packet = enet_packet_create(p.data,
											p.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(currentPeerError, 0, packet);
										delete p.data;
										static_cast<PlayerInfo*>(currentPeerError->data)->lastSeller = "";
										static_cast<PlayerInfo*>(currentPeerError->data)->lastSellWorld = "";
										static_cast<PlayerInfo*>(currentPeerError->data)->lastTradeAmount = 99999999999;
										static_cast<PlayerInfo*>(currentPeerError->data)->lastBuyer = "";
										break;
									}
								}
								continue;
							}
							nowseller += gemsforworld;
							nowbuyer -= gemsforworld;
							ofstream ofseller("gemdb/" + sellerName + ".txt");
							ofseller << nowseller;
							ofseller.close();
							ofstream ofbuyer("gemdb/" + lastbuyerName + ".txt");
							ofbuyer << nowbuyer;
							ofbuyer.close();
							string text = "action|play_sfx\nfile|audio/keypad_hit.wav\ndelayMS|0\n";
							BYTE* data = new BYTE[5 + text.length()];
							BYTE zero = 0;
							int type = 3;
							memcpy(data, &type, 4);
							memcpy(data + 4, text.c_str(), text.length());
							memcpy(data + 4 + text.length(), &zero, 1);
							ENetPacket* packettrd = enet_packet_create(data,
								5 + text.length(),
								ENET_PACKET_FLAG_RELIABLE);
							ENetPeer* currentPeerp;
							for (currentPeerp = server->peers;
								currentPeerp < &server->peers[server->peerCount];
								++currentPeerp)
							{
								if (currentPeerp->state != ENET_PEER_STATE_CONNECTED)
									continue;
								if (isHere(peer, currentPeerp))
									enet_peer_send(currentPeerp, 0, packettrd);
							}
							ENetPeer* currentPeer;
							for (currentPeer = server->peers;
								currentPeer < &server->peers[server->peerCount];
								++currentPeer)
							{
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
									continue;
								if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == sellerName)
								{
									if (static_cast<PlayerInfo*>(currentPeer->data)->haveGrowId == false) continue;
									GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), nowseller));
									ENetPacket* packetpp2 = enet_packet_create(pp.data,
										pp.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(currentPeer, 0, packetpp2);
									delete pp.data;
									if (find(static_cast<PlayerInfo*>(currentPeer->data)->worldsowned.begin(), static_cast<PlayerInfo*>(currentPeer->data)->worldsowned.end(), sellingworld) != static_cast<PlayerInfo*>(currentPeer->data)->worldsowned.end())
									{
										static_cast<PlayerInfo*>(currentPeer->data)->worldsowned.erase(std::remove(static_cast<PlayerInfo*>(currentPeer->data)->worldsowned.begin(), static_cast<PlayerInfo*>(currentPeer->data)->worldsowned.end(), sellingworld), static_cast<PlayerInfo*>(currentPeer->data)->worldsowned.end());
									}
									Player::OnConsoleMessage(currentPeer, "`2You successfully sold your world called '`8" + sellingworld + "`2' for `8" + to_string(gemsforworld) + "`2 gems");
									static_cast<PlayerInfo*>(currentPeer->data)->lastSeller = "";
									static_cast<PlayerInfo*>(currentPeer->data)->lastSellWorld = "";
									static_cast<PlayerInfo*>(currentPeer->data)->lastTradeAmount = 99999999999;
									static_cast<PlayerInfo*>(currentPeer->data)->lastBuyer = "";
									sendPlayerLeave(currentPeer, static_cast<PlayerInfo*>(currentPeer->data));
									static_cast<PlayerInfo*>(currentPeer->data)->currentWorld = "EXIT";
									sendWorldOffers(currentPeer);

									ifstream fg("players/" + static_cast<PlayerInfo*>(currentPeer->data)->rawName + ".json");
									json j;
									fg >> j;
									fg.close();

									j["worldsowned"] = static_cast<PlayerInfo*>(currentPeer->data)->worldsowned;

									ofstream fs("players/" + static_cast<PlayerInfo*>(currentPeer->data)->rawName + ".json");
									fs << j;
									fs.close();

									break;
								}
							}
							GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), nowbuyer));
							ENetPacket* packetpp2 = enet_packet_create(pp.data,
								pp.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packetpp2);
							delete pp.data;
							WorldInfo* boughtworld = getPlyersWorld(peer);
							boughtworld->owner = static_cast<PlayerInfo*>(peer->data)->rawName;
							boughtworld->ownerDisplayName = static_cast<PlayerInfo*>(peer->data)->displayName;
							boughtworld->isPublic = false;
							Player::OnConsoleMessage(peer, "`2You successfully bought this world called '`8" + sellingworld + "`2' for `8" + to_string(gemsforworld) + "`2 gems");
							static_cast<PlayerInfo*>(peer->data)->lastSeller = "";
							static_cast<PlayerInfo*>(peer->data)->lastSellWorld = "";
							static_cast<PlayerInfo*>(peer->data)->lastTradeAmount = 99999999999;
							static_cast<PlayerInfo*>(peer->data)->lastBuyer = "";
							sendPlayerLeave(peer, static_cast<PlayerInfo*>(peer->data));
							static_cast<PlayerInfo*>(peer->data)->currentWorld = "EXIT";
							sendWorldOffers(peer);
							static_cast<PlayerInfo*>(peer->data)->worldsowned.push_back(boughtworld->name);
							ifstream fg("players/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".json");
							json j;
							fg >> j;
							fg.close();

							j["worldsowned"] = static_cast<PlayerInfo*>(peer->data)->worldsowned;

							ofstream fs("players/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".json");
							fs << j;
							fs.close();

						}
						if (btn == "btntradeworld")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							if (static_cast<PlayerInfo*>(peer->data)->lastInfo == static_cast<PlayerInfo*>(peer->data)->rawName)
							{
								continue;
							}
							if (static_cast<PlayerInfo*>(peer->data)->rawName == world->owner)
							{
								Player::OnDialogRequest(peer, "set_default_color|`o\n\nadd_label_with_icon|big|`wTrade Options``||18||\nadd_textbox|`oHow many gems for this world?: |\nadd_text_input|worldoffer|||7|\nend_dialog|reqoffer|Cancel|SEND TRADE|\n");
							}
							else
							{
								Player::OnConsoleMessage(peer, "`^This Feature Only `9Available `^For The `2Owner `^Of The World!");
							}
						}
						if (isFindDialog && btn.substr(0, 4) == "tool")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							if (btn.substr(4, btn.length() - 4).size() > 5 || btn.substr(4, btn.length() - 4).size() <= 0)
							{
								continue;
							}
							int id = atoi(btn.substr(4, btn.length() - 4).c_str());
							if (id > maxItems || id <= 0)
							{
								continue;
							}
							size_t invsize = static_cast<PlayerInfo*>(peer->data)->currentInventorySize;
							if (getItemDef(id).name.find("Mooncake") != string::npos || getItemDef(id).name.find("Harvest") != string::npos && id != 1830 || getItemDef(id).name.find("Autumn") != string::npos || id == 1056 || id == 1804 || getItemDef(id).blockType == BlockTypes::COMPONENT || getItemDef(id).properties & Property_Chemical || id == 6920 || id == 6922 || id == 1874 || id == 3402 || id == 1876 || id == 1904 || id == 1932 || id == 1900 || id == 1986 || id == 1996 || id == 2970 || id == 3140 || id == 3174 || id == 6028 || id == 6846 || id == 8962 || id == 2408 || id == 4428 || id == 5086 || id == 1486 || id == 9306 || id == 9290 || id == 7328 || id == 9416 || id == 10386 || id == 9410 || id == 1458 || id == 9408 || id == 9360 || id == 6866 || id == 6868 || id == 6870 || id == 6872 || id == 6874 || id == 6876 || id == 6878 || id == 2480 || id == 8452 || id == 5132 || id == 7166 || id == 5126 || id == 5128 || id == 5130 || id == 5144 || id == 5146 || id == 5148 || id == 5150 || id == 5162 || id == 5164 || id == 5166 || id == 5168 || id == 5180 || id == 5182 || id == 5184 || id == 5186 || id == 7168 || id == 7170 || id == 7172 || id == 7174 || id == 8834 || id == 7912 || id == 9212 || id == 5134 || id == 5152 || id == 5170 || id == 5188 || id == 980 || id == 9448 || id == 9310 || id == 10034 || id == 10036 || id == 8470 || id == 8286 || id == 6026 || id == 1970 || id == 1784 || id == 9356 || id == 10022 || id == 902 || id == 10032 || id == 834 || id == 6 || id == 5640 || id == 9492 || id == 1782 || id == 9288 || id == 1780 || id == 8306 || id == 202 || id == 204 || id == 206 || id == 2950 || id == 4802 || id == 4994 || id == 5260 || id == 5814 || id == 5980 || id == 7734 || id == 2592 || id == 2242 || id == 1794 || id == 1792 || id == 778 || id == 9510 || id == 8774 || id == 2568 || id == 9512 || id == 9502 || id == 9482 || id == 2250 || id == 2248 || id == 2244 || id == 2246 || id == 2286 || id == 9508 || id == 9504 || id == 9506 || id == 274 || id == 276 || id == 9476 || id == 1486 || id == 9498 || id == 4426 || id == 9496 || id == 278 || id == 9490 || id == 2410 || id == 9488 || id == 9452 || id == 9454 || id == 9472 || id == 9456 || id == 732 || id == 9458 || id == 6336 || id == 112 || id == 8 || id == 3760 || getItemDef(id).blockType == BlockTypes::FISH || id == 7372 || id == 9438 || id == 9462 || id == 9440 || id == 9442 || id == 9444 || id == 7960 || id == 7628 || id == 8552) continue;

							if (id == 340) // chands
							{
								Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`6Buy `^Chandelier``|left|340|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`^Chandelier `ogems drop is `^15-35`0! `4WARNING! `o200 `^Chandelier `oCost `23500 Gems!|\nadd_spacer|small|\nadd_button|buychands|`9Buy `2200 `^Chandelier!|0|0|\nadd_spacer|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|");
								continue;
							}
							if (id == 954) // sugar cane
							{
								Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`6Buy `2Sugar `^Cane``|left|954|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`^Sugar Cane `ogems drop is `^1-8`0! `4WARNING! `o200 `^Sugar Cane `oCost `2800 Gems!|\nadd_spacer|small|\nadd_button|buysugarcane|`9Buy `2200 `^Sugar Cane!|0|0|\nadd_spacer|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|");
								continue;
							}
							if (id == 5666) //laser grid
							{
								Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`6Buy `2Laser `^Grid``|left|5666|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`^Laser Grid `ogems drop is `^5-15`0! `4WARNING! `o200 `^Laser Grid `oCost `22000 Gems!|\nadd_spacer|small|\nadd_button|buylasergrid|`9Buy `2200 `^Laser Grid!|0|0|\nadd_spacer|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|");
								continue;
							}
							if (id == 242)
							{
								Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`6Buy `2World `^Locks``|left|242|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`2World `^Lock `0Allows you to lock any free world! `4WARNING! `2World `^Lock `oCosts `21000 Gems!|\nadd_spacer|small|\nadd_button|buywl|`9Buy `2World `^Lock!|0|0|\nadd_spacer|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|");
								continue;
							}
							if (id == 1796)
							{
								Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`6Buy `1Diamond `^Locks``|left|1796|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`1Diamond `^Lock `0Allows you to lock any free world! `4WARNING! `1Diamond `^Lock `oCosts `2100000 Gems!|\nadd_spacer|small|\nadd_button|buydl|`9Buy `1Diamond `^Lock!|0|0|\nadd_spacer|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|");
								continue;
							}
							if (id == 7188)
							{
								Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`6Buy `!Blue Gem Lock``|left|7188|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`9This Item is like world lock, allows you to lock any world, you can convert this item back to `@100 `1Diamond Locks `9At any time!|\nadd_spacer|small|\nadd_button|buybgl|`7Buy `!BGL `7[`4100`e DLS`7]!|0|0|\nadd_spacer|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|");
								continue;
							}
							if (id == 1486)
							{
								Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`6Purchase `@Store Tokens`6!``|left|1486|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`9Tokens! `^Those `9Tokens `^Are second currency just like `9Gems `^And are obtainable by spending `625 `^Real `2WLS `^But also can be `9Obtained `^For being `9online `^Every `^3 `9Hours!|\nadd_spacer|small|\nadd_button|cch101001|`9Close|0|0|\nadd_spacer|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|");
								continue;
							}
							if (id == 9500)
							{
								Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`6Purchase `9Golden `@Store Tokens`6!``|left|9500|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`9Tokens! `^Those `9Tokens `^Are obtainable by `9Buying `^Them For `@100 `2Regular `@Store Tokens `^And can be used as second currency just like `9Gems`^!|\nadd_spacer|small|\nadd_button|purchasegoldenstoretoken|`7Buy `9GStoken `7[`4100`@ STokens`7]!|0|0|\nadd_spacer|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|");
								continue;
							}
							if (id == 9474)
							{
								Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`6Purchase `8Mystery Box`6!``|left|9474|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`9This Block Will give you random number of `^Gems `9Starting from `250k `9And up to `2300k`9 Or maybe even something more `1Rare`9?|\nadd_spacer|small|\nadd_button|buymysterybox|`7Buy `8Mystery Box `7[`430`2 WLS`7]!|0|0|\nadd_spacer|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|");
								continue;
							}
							if (id == 4992)
							{
								Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`6Purchase `2Anti Gravity`6!``|left|4992|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`9This Block Will allow you to `^Unlimited Jump `9In your own world`9!|\nadd_spacer|small|\nadd_button|buyantigravity|`7Buy `2Anti Gravity `7[`430`2 WLS`7]!|0|0|\nadd_spacer|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|");
								continue;
							}
							if (id == 8428)
							{
								Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`6Purchase `5Uranus Blast`6!``|left|8428|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`9Adventures! `^Theres a lot of to `9Explore `^Behind this item, `9Purchase `^One to create an `9Amazing `5Uranus `^World`9!|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`oTo purchase this item you need `410 `@Store Token's`o!|left|1458|\nadd_spacer|small|\nadd_button|crafturanusblast|`9Purchase!|0|0|\nadd_spacer|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|");
								continue;
							}

							if (id == 9478)
							{
								Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`6Purchase `!Crystal `1Winter Wings`6!``|left|9478|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`9Freeze! `^Pretty well `9Designed `^Wings, gives you `9Double Jump `^And `@Movement Effects`9!|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`oTo purchase this item you need `4120 `1Winter Token's`o!|left|1458|\nadd_spacer|small|\nadd_button|craftwinterwings|`9Purchase!|0|0|\nadd_spacer|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|");
								continue;
							}

							if (id == 9170)
							{
								Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`6Buy `9Magic Machine``|left|9170|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`9Really heavy and powerfull machine! `9Who knows what it does?... But the creators are sure that it will lead to profit!|\nadd_spacer|small|\nadd_button|buymagicmachine|`7Buy `9Magic Machine `7[`415`e DLS`7]!|0|0|\nadd_spacer|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|");
								continue;
							}
							if (id == 9432)
							{
								Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`6Buy `5World Generation Machine``|left|9432|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`9Generate Any World You Wish! `9This `^Machine `9Allows you to `@Create `9Any `^World `9You want! You can choose the `^Height, Width, Blocks `9And much more!|\nadd_spacer|small|\nadd_button|buywgm|`7Buy `5WGM `7[`430`e DLS`7]!|0|0|\nadd_spacer|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|");
								continue;
							}
							if (id == 1008)
							{
								Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`6Buy `eATM `3Machine``|left|1008|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`3ATM Machines `1Can give you over `45-10 `2Gems `1Per PUNCH`^!|\nadd_spacer|small|\nadd_button|buyatm|`7Buy `eATM Machine `7[`410`2 WLS`7]!|0|0|\nadd_spacer|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|");
								continue;
							}

							//if (id == 9414)
							//{
								//Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`6Buy `eOcean Chest``|left|9414|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`^Only `9Obtainable `^During `#February, March, April, May`^, Gives `4Great `9Loot`^! `9Small Chance To Obtain `4Rare `9Items `w[`eOcean Wings`9, `eOcean Sword`w]|\nadd_spacer|small|\nadd_button|buyocean|`7Buy `9Ocean Chest `7[`410`e WLS`7]!|0|0|\nadd_spacer|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|");
								//continue;
							//}
							//if (id == 6204)
							//{
								//Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`2Purchase `8Bronze `oChest`2!``|left|6204|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`oThe `eChances `ofor `8Bronze `oChest are:|\nadd_label|small|\nadd_textbox|`9Gems -> `#80% `9[`4MAX `620000`2 Gems!`9]|left|8|\nadd_label|small|\nadd_textbox|`9Crystals -> `#60%|left|8|\nadd_label|small|\nadd_textbox|`9Fragments -> `#35%|left|8|\nadd_label|small|\nadd_textbox|`9Special Blocks -> `#10%|left|8|\nadd_label|small|\nadd_textbox|`9Items -> `#4%|left|8|\nadd_spacer|small|\nadd_button|buybronzechest|`9Purchase `7[`430`2 WLS`7]!|0|0|\nadd_spacer|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|");
								//continue;
							//}
							//if (id == 6202)
							//{
								//Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`2Purchase `sSilver `oChest`2!``|left|6202|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`oThe `eChances `ofor `sSilver `oChest are:|\nadd_label|small|\nadd_textbox|`9Gems -> `#40% `9[`4MAX `670000`2 Gems!`9]|left|8|\nadd_label|small|\nadd_textbox|`9Crystals -> `#70%|left|8|\nadd_label|small|\nadd_textbox|`9Fragments -> `#55%|left|8|\nadd_label|small|\nadd_textbox|`9Special Blocks -> `#20%|left|8|\nadd_label|small|\nadd_textbox|`9Items -> `#15%|left|8|\nadd_spacer|small|\nadd_button|buysilverchest|`9Purchase `7[`450`2 WLS`7]!|0|0|\nadd_spacer|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|");
								//continue;
							//}
							//if (id == 6200)
							//{
								//Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`2Purchase `9Gold `oChest`2!``|left|6200|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`oThe `eChances `ofor `9Gold `oChest are:|\nadd_label|small|\nadd_textbox|`9Gems -> `#20% `9[`4MAX `6120000`2 Gems!`9]|left|8|\nadd_label|small|\nadd_textbox|`9Crystals -> `#45%|left|8|\nadd_label|small|\nadd_textbox|`9Fragments -> `#65%|left|8|\nadd_label|small|\nadd_textbox|`9Special Blocks -> `#70%|left|8|\nadd_label|small|\nadd_textbox|`9Items -> `#30%|left|8|\nadd_spacer|small|\nadd_button|buygoldchest|`9Purchase `7[`470`2 WLS`7]!|0|0|\nadd_spacer|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|");
								//continue;
							//}
							//if (id == 7484)
							//{
							//	Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`2Purchase `qWinter `oChest`2!``|left|7484|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`oThe `eChances `ofor `qWinter `oChest are:|\nadd_label|small|\nadd_textbox|`9Gems -> `#15% `9[`4MAX `6170000`2 Gems!`9]|left|8|\nadd_label|small|\nadd_textbox|`9Crystals -> `#30%|left|8|\nadd_label|small|\nadd_textbox|`9Fragments -> `#60%|left|8|\nadd_label|small|\nadd_textbox|`9Special Blocks -> `#75%|left|8|\nadd_label|small|\nadd_textbox|`9Items -> `#50%|left|8|\nadd_spacer|small|\nadd_button|buywinterchest|`9Purchase `7[`490`2 WLS`7]!|0|0|\nadd_spacer|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|");
								//continue;
							//}
							//if (id == 7954)
							//{
								//Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`2Purchase `^Spring `oChest`2!``|left|7954|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`oThe `eChances `ofor `^Spring `oChest are:|\nadd_label|small|\nadd_textbox|`9Gems -> `#15% `9[`4MAX `6200000`2 Gems!`9]|left|8|\nadd_label|small|\nadd_textbox|`9Crystals -> `#30%|left|8|\nadd_label|small|\nadd_textbox|`9Fragments -> `#60%|left|8|\nadd_label|small|\nadd_textbox|`9Special Blocks -> `#75%|left|8|\nadd_label|small|\nadd_textbox|`9Items -> `#50%|left|8|\nadd_spacer|small|\nadd_button|buyspringchest|`9Purchase `7[`495`2 WLS`7]!|0|0|\nadd_spacer|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|");
								//continue;
							//}
							if (id == 10026)
							{
								Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`6Buy `bThe Dark Stones``|left|10026|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`bDark Dark Dark! `^Gives you `9Random Item `^From the whole server!|\nadd_spacer|small|\nadd_button|buydarkstones|`7Buy `bThe Dark Stones `7[`4500000`2 Gems`7]!|0|0|\nadd_spacer|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|");
								continue;
							}
							if (id == 1790)
							{
								Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`6Purchase `#Legendary Wizard`6!``|left|1790|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`9This Block Will allow you to complete `^Quests `9For `5Very Rare `9Items`9!|\nadd_spacer|small|\nadd_button|buylegendwizard|`7Buy `#Legendary Wizard `7[`4150`e DLS`7]!|0|0|\nadd_spacer|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|");
								continue;
							}
							if (id == 9460)
							{
								Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`6Buy `2Smaraged `^Blocks``|left|9460|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`2Smaraged `^Blocks `1Gives you up to `4350 `2Gems `1Per block`^! And a chance to obtain `2Emerald Shard`^!|\nadd_spacer|small|\nadd_button|buysmaraged|`7Buy `9200 `7Blocks [`450`2 WLS`7]!|0|0|\nadd_spacer|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|");
								continue;
							}
							if (id == 9468)
							{
								Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`6Buy `1Diamond `^Stones``|left|9468|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`1Diamond `^Stones `1Gives you up to `4600 `2Gems `1Per stone`^! And a lot of `!XP`^!|\nadd_spacer|small|\nadd_button|buydiamondstone|`7Buy `9200 `7Stones [`490`2 WLS`7]!|0|0|\nadd_spacer|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|");
								continue;
							}
							if (id == 10024)
							{
								Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`6Buy `#Pink Diamond``|left|10024|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`#Pink Diamond `1Gives you up to `41200 `2Gems `1Per block`^! And a chance to obtain `4Ruby Shard`^!|\nadd_spacer|small|\nadd_button|buypinkdiamond|`7Buy `9200 `#Diamonds `7[`42`e DLS`7]!|0|0|\nadd_spacer|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|");
								continue;
							}
							if (id == 10028)
							{
								Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`6Buy `6Citrine `^Blocks``|left|10028|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`6Citrine `^Blocks `1Gives you up to `41900 `2Gems `1Per block`^!|\nadd_spacer|small|\nadd_button|buycitrine|`7Buy `9200 `6Citrines `7[`43`e DLS`7]!|0|0|\nadd_spacer|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|");
								continue;
							}
							if (id == 7382)
							{
								Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`6Buy `bOnyx `^Blocks``|left|7382|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`bOnyx `^Blocks `1Gives you up to `4250 `2Gems `1Per block`^! And a chance to obtain `#Fragment Crystal `^!|\nadd_spacer|small|\nadd_button|buyonyx|`7Buy `9200 `7Blocks [`430`2 WLS`7]!|0|0|\nadd_spacer|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|");
								continue;
							}
							if (id == 4762)
							{
								Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`6Buy `#Amethyst `^Blocks``|left|4762|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`#Amethyst `^Blocks `1Gives you up to `4150 `2Gems `1Per block`^!|\nadd_spacer|small|\nadd_button|buyamethyst|`7Buy `9200 `7Blocks [`415`2 WLS`7]!|0|0|\nadd_spacer|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|");
								continue;
							}
							if (id == 262)
							{
								Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`6Buy `#Crystal `^Blocks``|left|262|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`#Crystal `^Blocks `1Gives you up to `415-20 `2Gems `1Per block `1And Splice Ability`^!|\nadd_spacer|small|\nadd_button|buycrystalblock|`7Buy `9200 `7Blocks [`42`2 DLS`7]!|0|0|\nadd_spacer|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|");
								continue;
							}
							if (id == 828)
							{
								Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`6Buy `#Ruby `^Blocks``|left|828|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`#Ruby `^Blocks `1Gives you up to `415-20 `2Gems `1Per block `1And Splice Ability`^!|\nadd_spacer|small|\nadd_button|buyrubyblock|`7Buy `9200 `7Blocks [`42`2 DLS`7]!|0|0|\nadd_spacer|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|");
								continue;
							}
							if (id == 826)
							{
								Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`6Buy `#Emerald `^Blocks``|left|826|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`#Emerald `^Blocks `1Gives you up to `415-20 `2Gems `1Per block `1And Splice Ability`^!|\nadd_spacer|small|\nadd_button|buyemeraldblock|`7Buy `9200 `7Blocks [`42`2 DLS`7]!|0|0|\nadd_spacer|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|");
								continue;
							}
							if (id == 5524)
							{
								Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`6Buy `#Nuclear `^Detonator``|left|5524|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`^Allows To `#Clear `^Your `#World`^! `9Warning: `oyou need to be `^level 30 `oor higher, and have a `^Vip rank`o!|\nadd_spacer|small|\nadd_button|buynucleardet|`7Buy `91 `7[`450`2 WLS`7]!|0|0|\nadd_spacer|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|");
								continue;
							}
							int kaina;
							ItemDefinition itemDef = getItemDef(id);
							if (getItemDef(id).blockType == BlockTypes::FOREGROUND || getItemDef(id).blockType == BlockTypes::BACKGROUND || getItemDef(id).blockType == BlockTypes::GROUND_BLOCK)
							{
								bool success = false;
								SaveShopsItem(id, 200, peer, success);
								if (success) Player::OnConsoleMessage(peer, "`@You got `$200 `@" + getItemDef(id).name);
							}
							else if (getItemDef(id).rarity == 999 && getItemDef(id).name.find("Golden") != string::npos)
							{
								kaina = 9000;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5This item is Very Rare`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							else if (getItemDef(id).rarity == 999 && getItemDef(id).name.find("Phoenix") != string::npos)
							{
								kaina = 5000;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5This item is Very Rare`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							else if (getItemDef(id).rarity == 999 && getItemDef(id).name.find("Nightmare") != string::npos)
							{
								kaina = 4000;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5This item is Very Rare`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							else if (getItemDef(id).name.find("Subscription") != string::npos || id == 6260)
							{
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5Sorry, but this item is only available for premium subscribers`5!|\nadd_textbox|`5Subscriptions gives you many benefits including increased daily gems, new titles, and many other. They can be only obtained from `cWebsite Store`5, or `cThe Dark Stones`5`5!|\nadd_spacer|small|\nend_dialog|buyitembyrarity|`wCancel||");
							}
							else if (id == 9644)
							{
								kaina = 25000;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5By consuming this item you will receive 5x of all surgery tools and a Surg-E`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$Gems|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							else if (id == 2204)
							{
								kaina = 60000;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5This item allows you to hunt for geiger stuff! Find the crystals and a lot of more to explore`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$Gems|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							else if (itemDef.properties & Property_Untradable)
							{
								kaina = 3000;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5This item is Rare`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							else if (getItemDef(id).blockType == BlockTypes::CLOTHING)
							{
								ifstream infile("pricedata.txt");
								for (string line; getline(infile, line);)
								{
									if (line.length() > 3 && line[0] != '/' && line[1] != '/')
									{
										auto ex = explode("|", line);
										if (ex[0] == to_string(id))
										{
											kaina = atoi(ex[1].c_str());
											break;
										}
									}
								}
								if (kaina == 0) continue;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							else if (id == 1662)
							{
								kaina = 30;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5This item allows you to walk on spikes for 3 seconds`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							else if (id == 1452)
							{
								kaina = 10;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5This item allows you and other players to place something into it`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							else if (id == 1240)
							{
								kaina = 10;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5This item allows you and other players to place something into it`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							else if (id == 8878)
							{
								kaina = 80;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5This item allows you to store any kind of items in it, also ability to protect it with password`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							/*Mails*/
							else if (id == 1006)
							{
								kaina = 15;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5This item allows players to leave message for the owners`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							else if (id == 656)
							{
								kaina = 15;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5This item allows players to leave message for the owners`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							/*Storage*/
							else if (id == 6286)
							{
								kaina = 20;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5This item allows you to store any kind of items in it, has 20 capacity`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							else if (id == 6288)
							{
								kaina = 50;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5This item allows you to store any kind of items in it, has 40 capacity`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							else if (id == 6290)
							{
								kaina = 120;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5This item allows you to store any kind of items in it, has 90 capacity`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							/*Fishing Things*/
							else if (id == 2912)
							{
								kaina = 10;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5This rod allows you to fish, able to catch small fishes`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							else if (id == 3010)
							{
								kaina = 120;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5This rod allows you to fish, able to catch medium fishes and low rarity gear`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							else if (id == 3040)
							{
								kaina = 690;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5This rod allows you to fish, able to catch big fishes and medium rarity gear`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							else if (id == 3100)
							{
								kaina = 3200;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5This rod allows you to fish, able to catch huge fishes and high rarity gear`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							else if (id == 5740)
							{
								kaina = 9600;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5This thing is so magical...`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							/*Baits*/
							else if (id == 2914)
							{
								kaina = 1;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5Simple regular worm bait for small fishes`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `45`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							else if (id == 3098)
							{
								kaina = 5;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5This bait gives you faster strike time and bigger luck`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							else if (id == 3218)
							{
								kaina = 8;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5Its so sticky that probably stuff will stick to it`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							else if (id == 3432)
							{
								kaina = 90;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5Ever dreamed of becoming a champion of fishing? Try your luck, able to catch high tier gear`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							else if (id == 4246)
							{
								kaina = 3;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5Bait for medium fishes`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							else if (id == 4248)
							{
								kaina = 3;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5Bait for medium fishes`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							else if (id == 5528)
							{
								kaina = 15;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5Woah, this bait is large it must catch something greater`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							/*End*/
							else if (id == 6924)
							{
								kaina = 60;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5This item gives you triple place ability for all farmable blocks 5 minutes when consumed`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							else if (id == 6918)
							{
								kaina = 80;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5This item gives you 1 HIT ability for all farmable blocks 5 minutes when consumed`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							else if (id == 6840)
							{
								kaina = 1200;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5This item gives you 30% chance to obtain extra blocks when harvesting trees`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							else if (id == 1436)
							{
								kaina = 5;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5This item allows you to prevent moderators abuse by logging every action into this camera`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							else if (id == 2978)
							{
								kaina = 5;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5This item is used to sell your stuff directly for world locks, works totally like in real growtopia with full visuals`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							else if (id == 898)
							{
								kaina = 60;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5This item allows you to harvest trees`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							else if (id == 1966)
							{
								kaina = 800;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5This item allows you to harvest trees, with a chance to get bonus drop`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							else if (id == 5022)
							{
								kaina = 350;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5This item allows you to plant trees`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							else if (id == 528)
							{
								kaina = 25;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5This item gives you extra gem drop for 30 minutes when consumed`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							else if (id == 5638)
							{
								kaina = 3500;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5This item can collect any blocks, capacity 5000 and remote included`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							else if (id == 6946)
							{
								kaina = 900;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5This item can collect any seeds, capacity 1500`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							else if (id == 6948)
							{
								kaina = 300;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5This item can collect any foreground or background, capacity 1500`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							else if (id == 10012)
							{
								kaina = 1800;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5This item is made by Shirogane`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							else if (id == 10016)
							{
								kaina = 3500;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5This item is made by Fads`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							else if (id == 10018)
							{
								kaina = 1200;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5This item is made by Shiina`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							else if (getItemDef(id).clothType == ClothTypes::BACK && getItemDef(id).rarity == 999)
							{
								kaina = 900;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							else if (id == 10014)
							{
								kaina = 1500;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5This item is made by Shiina`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							else if (id == 2946)
							{
								kaina = 5;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5This block can store blocks and items in it`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							else if (id == 1404)
							{
								kaina = 15;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5This item allows you to move white door`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							else if (id == 874)
							{
								kaina = 3;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5This item can be used as ingredient for other items`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							else if (getItemDef(id).rarity == 999)
							{
								kaina = 600;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							else
							{
								kaina = round(static_cast<float>(getItemDef(id).rarity) / 10 * 5);
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
						}
						else if (isFindDialog)
						{
							string itemLower2;
							vector<ItemDefinition> itemDefsfind;
							for (char c : itemFind) if (c < 0x20 || c > 0x7A) goto SKIPFind;
							if (itemFind.length() < 3) goto SKIPFind3;
							for (const ItemDefinition& item : itemDefs)
							{
								string itemLower;
								for (char c : item.name) if (c < 0x20 || c > 0x7A) goto SKIPFind2;
								if (!(item.id % 2 == 0)) goto SKIPFind2;
								itemLower2 = item.name;
								std::transform(itemLower2.begin(), itemLower2.end(), itemLower2.begin(), ::tolower);
								if (itemLower2.find(itemLower) != std::string::npos)
								{
									itemDefsfind.push_back(item);
								}
							SKIPFind2:;
							}
						SKIPFind3:;
							string listMiddle = "";
							string listFull = "";
							for (const ItemDefinition& item : itemDefsfind)
							{
								string kys = item.name;
								std::transform(kys.begin(), kys.end(), kys.begin(), ::tolower);
								string kms = itemFind;
								std::transform(kms.begin(), kms.end(), kms.begin(), ::tolower);
								if (kys.find(kms) != std::string::npos)
									listMiddle += "add_button_with_icon|tool" + to_string(item.id) + "|`$" + item.name + "``|left|" + to_string(item.id) + "||\n";
							}
							if (itemFind.length() < 3)
							{
								listFull = "add_textbox|`4Word is less than 3 letters!``|\n";
								showWrong(peer, listFull, itemFind);
							}
							else if (itemDefsfind.size() == 0)
							{
								showWrong(peer, listFull, itemFind);
							}
							else
							{
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Found item : " + itemFind + "``|left|3146|\nadd_textbox|Enter a word below to find the item|\nadd_text_input|item|Item Name||20|\nend_dialog|findid|Cancel|Find the item!|\nadd_spacer|big|\n" + listMiddle + "add_quick_exit|\n");
							}
						}
					SKIPFind:;
						if (btn == "ipbanwrench")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							if (isMod(peer))
							{
								ENetPeer* currentPeer;
								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == static_cast<PlayerInfo*>(peer->data)->lastInfo)
									{
										if (static_cast<PlayerInfo*>(currentPeer->data)->haveGrowId == false) continue;
										using namespace std::chrono;
										if (static_cast<PlayerInfo*>(peer->data)->lastbanipwrench + 300000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count())
										{
											static_cast<PlayerInfo*>(peer->data)->lastbanipwrench = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
											static_cast<PlayerInfo*>(peer->data)->lastbanipwrenchCount = 1;
										}
										else
										{
											static_cast<PlayerInfo*>(peer->data)->lastbanipwrenchCount = static_cast<PlayerInfo*>(peer->data)->lastbanipwrenchCount + 1;
											if (static_cast<PlayerInfo*>(peer->data)->lastbanipwrenchCount == 3)
											{
												AutoDemote(static_cast<PlayerInfo*>(peer->data)->rawName, to_string(static_cast<PlayerInfo*>(peer->data)->adminLevel), to_string(peer->address.host), "3 (ban ips) in wrench in the past 5 minutes!");
												continue;
											}
										}
										ofstream tolog("logs/wrench/ipban.txt", ios::app);
										tolog << "administrator " << static_cast<PlayerInfo*>(peer->data)->rawName << " used ip ban in wrench on " << static_cast<PlayerInfo*>(currentPeer->data)->rawName << endl;
										tolog.close();

										autoBan(currentPeer, true, 100000, "ip ban wrench");
										Player::OnConsoleMessage(currentPeer, "`4You have been ip banned by `2" + static_cast<PlayerInfo*>(peer->data)->rawName + "");
									}
								}
							}
						}
						if (btn == "suspend8w")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							if (isMod(peer))
							{
								ENetPeer* currentPeer;
								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == static_cast<PlayerInfo*>(peer->data)->lastInfo)
									{
										if (static_cast<PlayerInfo*>(currentPeer->data)->haveGrowId == false) continue;
										using namespace std::chrono;
										if (static_cast<PlayerInfo*>(peer->data)->lastsuspend8w + 300000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count())
										{
											static_cast<PlayerInfo*>(peer->data)->lastsuspend8w = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
											static_cast<PlayerInfo*>(peer->data)->lastsuspend8wCount = 1;
										}
										else
										{
											static_cast<PlayerInfo*>(peer->data)->lastsuspend8wCount = static_cast<PlayerInfo*>(peer->data)->lastsuspend8wCount + 1;
											if (static_cast<PlayerInfo*>(peer->data)->lastsuspend8wCount == 3)
											{
												AutoDemote(static_cast<PlayerInfo*>(peer->data)->rawName, to_string(static_cast<PlayerInfo*>(peer->data)->adminLevel), to_string(peer->address.host), "3 (suspends 8 week) in wrench in the past 5 minutes!");
												continue;
											}
										}
										ofstream tolog("logs/wrench/8weeksban.txt", ios::app);
										tolog << "administrator " << static_cast<PlayerInfo*>(peer->data)->rawName << " used 8 weeks ban in wrench on " << static_cast<PlayerInfo*>(currentPeer->data)->rawName << endl;
										tolog.close();

										ofstream savebantime("timebanned/" + PlayerDB::getProperName(static_cast<PlayerInfo*>(currentPeer->data)->rawName) + ".txt");
										savebantime << (GetCurrentTimeInternalSeconds() + (80640 * 60)) << endl;
										savebantime << static_cast<PlayerInfo*>(peer->data)->rawName << endl;
										savebantime << "8 weeks suspend" << endl;
										savebantime.close();
										Player::OnConsoleMessage(currentPeer, "`4You have been banned for 8 weeks by `2" + static_cast<PlayerInfo*>(peer->data)->rawName + "");
										if (!static_cast<PlayerInfo*>(peer->data)->Console) enet_peer_disconnect_now(currentPeer, 0);
									}
								}
							}
						}
						if (btn == "suspend4w")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							if (isMod(peer))
							{
								ENetPeer* currentPeer;
								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == static_cast<PlayerInfo*>(peer->data)->lastInfo)
									{
										if (static_cast<PlayerInfo*>(currentPeer->data)->haveGrowId == false) continue;
										using namespace std::chrono;
										if (static_cast<PlayerInfo*>(peer->data)->lastsuspend4w + 300000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count())
										{
											static_cast<PlayerInfo*>(peer->data)->lastsuspend4w = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
											static_cast<PlayerInfo*>(peer->data)->lastsuspend4wCount = 1;
										}
										else
										{
											static_cast<PlayerInfo*>(peer->data)->lastsuspend4wCount = static_cast<PlayerInfo*>(peer->data)->lastsuspend4wCount + 1;
											if (static_cast<PlayerInfo*>(peer->data)->lastsuspend4wCount == 3)
											{
												AutoDemote(static_cast<PlayerInfo*>(peer->data)->rawName, to_string(static_cast<PlayerInfo*>(peer->data)->adminLevel), to_string(peer->address.host), "3 (suspends 4 week) in wrench in the past 5 minutes!");
												continue;
											}
										}
										ofstream tolog("logs/wrench/4weeksban.txt", ios::app);
										tolog << "administrator " << static_cast<PlayerInfo*>(peer->data)->rawName << " used 4 weeks ban in wrench on " << static_cast<PlayerInfo*>(currentPeer->data)->rawName << endl;
										tolog.close();

										ofstream savebantime("timebanned/" + PlayerDB::getProperName(static_cast<PlayerInfo*>(currentPeer->data)->rawName) + ".txt");
										savebantime << (GetCurrentTimeInternalSeconds() + (40320 * 60)) << endl;
										savebantime << static_cast<PlayerInfo*>(peer->data)->rawName << endl;
										savebantime << "4 weeks suspend" << endl;
										savebantime.close();
										Player::OnConsoleMessage(currentPeer, "`4You have been banned for 4 weeks by `2" + static_cast<PlayerInfo*>(peer->data)->rawName + "");
										if (!static_cast<PlayerInfo*>(peer->data)->Console) enet_peer_disconnect_now(currentPeer, 0);
									}
								}
							}
						}
						if (btn == "suspend2w")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							if (isMod(peer))
							{
								ENetPeer* currentPeer;
								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == static_cast<PlayerInfo*>(peer->data)->lastInfo)
									{
										if (static_cast<PlayerInfo*>(currentPeer->data)->haveGrowId == false) continue;

										using namespace std::chrono;
										if (static_cast<PlayerInfo*>(peer->data)->lastsuspend2w + 300000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count())
										{
											static_cast<PlayerInfo*>(peer->data)->lastsuspend2w = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
											static_cast<PlayerInfo*>(peer->data)->lastsuspend2wCount = 1;
										}
										else
										{
											static_cast<PlayerInfo*>(peer->data)->lastsuspend2wCount = static_cast<PlayerInfo*>(peer->data)->lastsuspend2wCount + 1;
											if (static_cast<PlayerInfo*>(peer->data)->lastsuspend2wCount == 3)
											{
												AutoDemote(static_cast<PlayerInfo*>(peer->data)->rawName, to_string(static_cast<PlayerInfo*>(peer->data)->adminLevel), to_string(peer->address.host), "3 (suspends 2 week) in wrench in the past 5 minutes!");
												continue;
											}
										}
										ofstream tolog("logs/wrench/2weeksban.txt", ios::app);
										tolog << "administrator " << static_cast<PlayerInfo*>(peer->data)->rawName << " used 2 weeks ban in wrench on " << static_cast<PlayerInfo*>(currentPeer->data)->rawName << endl;
										tolog.close();

										ofstream savebantime("timebanned/" + PlayerDB::getProperName(static_cast<PlayerInfo*>(currentPeer->data)->rawName) + ".txt");
										savebantime << (GetCurrentTimeInternalSeconds() + (20160 * 60)) << endl;
										savebantime << static_cast<PlayerInfo*>(peer->data)->rawName << endl;
										savebantime << "2 weeks suspend" << endl;
										savebantime.close();
										Player::OnConsoleMessage(currentPeer, "`4You have been banned for 2 weeks by `2" + static_cast<PlayerInfo*>(peer->data)->rawName + "");
										if (!static_cast<PlayerInfo*>(peer->data)->Console) enet_peer_disconnect_now(currentPeer, 0);
									}
								}
							}
						}
						if (btn == "suspend")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							if (isMod(peer))
							{
								using namespace std::chrono;
								if (static_cast<PlayerInfo*>(peer->data)->lastsuspendwrench + 300000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count())
								{
									static_cast<PlayerInfo*>(peer->data)->lastsuspendwrench = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
									static_cast<PlayerInfo*>(peer->data)->lastsuspendwrenchCount = 1;
								}
								else
								{
									static_cast<PlayerInfo*>(peer->data)->lastsuspendwrenchCount = static_cast<PlayerInfo*>(peer->data)->lastsuspendwrenchCount + 1;
									if (static_cast<PlayerInfo*>(peer->data)->lastsuspendwrenchCount == 3)
									{
										AutoDemote(static_cast<PlayerInfo*>(peer->data)->rawName, to_string(static_cast<PlayerInfo*>(peer->data)->adminLevel), to_string(peer->address.host), "3 (suspends) in wrench in the past 5 minutes!");
										continue;
									}
								}
								GamePacket p7 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`#** `$The Ancient Ones `ohave `4banned `w" + static_cast<PlayerInfo*>(peer->data)->lastDisplayname + " `#** `o(`4/rules `oto see the rules!)"));
								ENetPeer* currentPeer;
								time_t now = time(nullptr);
								char* dt = ctime(&now);
								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == static_cast<PlayerInfo*>(peer->data)->lastInfo)
									{
										if (static_cast<PlayerInfo*>(currentPeer->data)->haveGrowId == false) continue;
										GamePacket ps2 = packetEnd(appendInt(appendString(appendString(appendString(appendString(createPacket(), "OnAddNotification"), "interface/atomic_button.rttex"), "`0Warning from `4System`0: You've been `4BANNED `0from Growtopia for 730 days"), "audio/hub_open.wav"), 0));
										ENetPacket* packet2 = enet_packet_create(ps2.data,
											ps2.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(currentPeer, 0, packet2);
										GamePacket ps3 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`oWarning from `4System`o: You've been `4BANNED `ofrom Growtopia for 730 days"));
										ENetPacket* packet3 = enet_packet_create(ps3.data,
											ps3.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(currentPeer, 0, packet3);
										GamePacket pto = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "Applied punishment on " + static_cast<PlayerInfo*>(peer->data)->lastDisplayname + "."));
										ENetPacket* packetto = enet_packet_create(pto.data,
											pto.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetto);
										if (static_cast<PlayerInfo*>(currentPeer->data)->haveGrowId)
										{
											PlayerInfo* p = static_cast<PlayerInfo*>(currentPeer->data);
											p->ban = 1;
											string username = PlayerDB::getProperName(p->rawName);

											ifstream fg("players/" + static_cast<PlayerInfo*>(currentPeer->data)->rawName + ".json");
											json j;
											fg >> j;
											fg.close();

											j["isBanned"] = 1;
											j["joinguild"] = true;

											ofstream fs("players/" + static_cast<PlayerInfo*>(currentPeer->data)->rawName + ".json");
											fs << j;
											fs.close();

											string bannamed = str.substr(5, cch.length() - 5 - 1);
											std::ofstream outfile("bans/" + bannamed + ".txt");
											outfile << "user who banned this ID: " + static_cast<PlayerInfo*>(peer->data)->rawName;
											outfile.close();
										}
										if (!static_cast<PlayerInfo*>(peer->data)->Console) enet_peer_disconnect_later(currentPeer, 0);
									}
									ENetPacket* packet7 = enet_packet_create(p7.data,
										p7.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(currentPeer, 0, packet7);
								}
							}
						}
						/*
						if (btn == "suspendalts")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							if (isMod(peer))
							{
								using namespace std::chrono;
								if (static_cast<PlayerInfo*>(peer->data)->lastsuspendwrench + 300000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count())
								{
									static_cast<PlayerInfo*>(peer->data)->lastsuspendwrench = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
									static_cast<PlayerInfo*>(peer->data)->lastsuspendwrenchCount = 1;
								}
								else
								{
									static_cast<PlayerInfo*>(peer->data)->lastsuspendwrenchCount = static_cast<PlayerInfo*>(peer->data)->lastsuspendwrenchCount + 1;
									if (static_cast<PlayerInfo*>(peer->data)->lastsuspendwrenchCount == 3)
									{
										AutoDemote(static_cast<PlayerInfo*>(peer->data)->rawName, to_string(static_cast<PlayerInfo*>(peer->data)->adminLevel), to_string(peer->address.host), "3 (suspends) in wrench in the past 5 minutes!");
										continue;
									}
								}

									stringstream sse;
									string code = (str.substr(8).c_str());
									sse << "SELECT * FROM PlayerDatabase WHERE username = '" + PlayerDB::getProperName(static_cast<PlayerInfo*>(peer->data)->lastInfo) + "'";
									auto query = sse.str();
									auto q = query.c_str();
									if (mysql_query(conn, q))
									{
										string ers = mysql_error(conn); if (ers.find("Lost connection") != string::npos) ConnectToDatabase();
										cout << mysql_error(conn) << endl;


										enet_peer_disconnect_now(peer, 0);
										continue;
									}
									string tip;
									string email;
									string ipid;
									res = mysql_store_result(conn);
									while (row = mysql_fetch_row(res))
									{
										email = row[3];
										ipid = row[15];
										tip = row[38];
									}
									if (tip == "") tip = "-1";
									if (ipid == "8421376") ipid = "-1";
									stringstream sse1;
									sse1 << "SELECT * FROM PlayerDatabase WHERE ip = '" + tip + "' OR email = '" + email + "' OR ipID = '" + ipid + "'";
									auto query321 = sse1.str();
									auto q321 = query321.c_str();
									if (mysql_query(conn, q321))
									{
										string ers = mysql_error(conn); if (ers.find("Lost connection") != string::npos) ConnectToDatabase();
										cout << mysql_error(conn) << endl;


										enet_peer_disconnect_now(peer, 0);
										continue;
									}
									string test;
									string isbanned;
									res = mysql_store_result(conn);
									while (row = mysql_fetch_row(res))
									{
										test = row[1];
										isbanned = row[14];
										if (isbanned == "1")
										{
											Player::OnConsoleMessage(peer, test + " was already banned, skipped!");
											continue;
										}
										if (conn == nullptr)
										{
											cout << "conn was nullptr" << endl;
											continue;
										}
										if (conn != nullptr)
										{
											stringstream ss;
											ss << "UPDATE PlayerDatabase SET isBanned = '1' WHERE username = '" + test + "' OR email = '" + email + "' OR ipID = '" + ipid + "'";
											auto query = ss.str();
											const auto q = query.c_str();
											if (mysql_query(conn, q))
											{
												string ers = mysql_error(conn); if (ers.find("Lost connection") != string::npos) ConnectToDatabase();
												cout << mysql_error(conn) << endl;


												enet_peer_disconnect_now(peer, 0);
												continue;
											}
											SendConsole("Player(" + test + ") Duration(Permanent) CausedBy(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "BAN");
											Player::OnTextOverlay(peer, "Applied punishment on " + test + ".");
											ENetPeer* currentPeer;
											for (currentPeer = server->peers;
												currentPeer < &server->peers[server->peerCount];
												++currentPeer)
											{
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
												Player::OnConsoleMessage(currentPeer, "`#** `$The Ancient Ones `ohave `4banned `w" + test + " `#** `o(`4/rules `oto see the rules!)");
												if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == static_cast<PlayerInfo*>(peer->data)->lastInfo)
												{
													if (static_cast<PlayerInfo*>(currentPeer->data)->haveGrowId == false) continue;
													Player::OnAddNotification(currentPeer, "`0Warning from `4System`0: You've been `4BANNED `0from Growtopia for 730 days", "audio/hub_open.wav", "interface/atomic_button.rttex");
													Player::OnConsoleMessage(currentPeer, "`oWarning from `4System`o: You've been `4BANNED `ofrom Growtopia for 730 days");
													if (!static_cast<PlayerInfo*>(peer->data)->Console) enet_peer_disconnect_later(currentPeer, 0);
												}
											}
										}
										else
										{
											cout << "conn was nullptr3" << endl;
											continue;
										}
									}
							}
						}
						*/
						if (btn == "punishview")
						{
							if (static_cast<PlayerInfo*>(peer->data)->lastInfo == static_cast<PlayerInfo*>(peer->data)->rawName) continue;
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT") continue;
							if (!isMod(peer)) continue;
							string playerCalled = static_cast<PlayerInfo*>(peer->data)->lastInfo;
							static_cast<PlayerInfo*>(peer->data)->lastInfoAboutPlayer = playerCalled;
							std::ifstream ifs7("gemdb/" + playerCalled + ".txt");
							std::string contentp((std::istreambuf_iterator<char>(ifs7)),
								(std::istreambuf_iterator<char>()));
							ifs7.close();
							ENetPeer* currentPeer;
							for (currentPeer = server->peers;
								currentPeer < &server->peers[server->peerCount];
								++currentPeer)
							{
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
								if (static_cast<PlayerInfo*>(currentPeer->data)->haveGrowId == false) continue;
								string name = static_cast<PlayerInfo*>(currentPeer->data)->rawName;
								int pullX = static_cast<PlayerInfo*>(peer->data)->x;
								int pullY = static_cast<PlayerInfo*>(peer->data)->y;
								if (name == static_cast<PlayerInfo*>(peer->data)->lastInfo)
								{
									string showcountry = static_cast<PlayerInfo*>(currentPeer->data)->country;
									string showgameversion = static_cast<PlayerInfo*>(currentPeer->data)->gameversion;
									string showrid = static_cast<PlayerInfo*>(currentPeer->data)->rid;
									string showwk = static_cast<PlayerInfo*>(currentPeer->data)->wkid;
									string showmeta = static_cast<PlayerInfo*>(currentPeer->data)->metaip;
									string showmac = static_cast<PlayerInfo*>(currentPeer->data)->mac;
									string showhash2 = static_cast<PlayerInfo*>(currentPeer->data)->hash2;
									string showplatid = static_cast<PlayerInfo*>(currentPeer->data)->platformID;
									string showage = static_cast<PlayerInfo*>(currentPeer->data)->player_age;
									string showaid = static_cast<PlayerInfo*>(currentPeer->data)->aid;
									string showgid = static_cast<PlayerInfo*>(currentPeer->data)->gid;
									string showvid = static_cast<PlayerInfo*>(currentPeer->data)->vid;
									string showworld = static_cast<PlayerInfo*>(currentPeer->data)->currentWorld;
									string showplainip = static_cast<PlayerInfo*>(currentPeer->data)->charIP;
									string showdeviceversion = static_cast<PlayerInfo*>(currentPeer->data)->deviceversion;
									string showlmode = static_cast<PlayerInfo*>(currentPeer->data)->lmode;
									string showgdpr = static_cast<PlayerInfo*>(currentPeer->data)->gdpr;
									string showuser = static_cast<PlayerInfo*>(currentPeer->data)->user;
									string showtoken = static_cast<PlayerInfo*>(currentPeer->data)->token;
									string showf = static_cast<PlayerInfo*>(currentPeer->data)->f;
									string showfz = static_cast<PlayerInfo*>(currentPeer->data)->fz;
									string showfhash = static_cast<PlayerInfo*>(currentPeer->data)->fhash;
									string showplatidplain;
									int levels = static_cast<PlayerInfo*>(currentPeer->data)->level;
									int xp = static_cast<PlayerInfo*>(currentPeer->data)->xp;
									int darkFragments = static_cast<PlayerInfo*>(currentPeer->data)->fDark;
									int earthFragments = static_cast<PlayerInfo*>(currentPeer->data)->fEarth;
									int fireFragments = static_cast<PlayerInfo*>(currentPeer->data)->fFire;
									int waterFragments = static_cast<PlayerInfo*>(currentPeer->data)->fWater;
									string guild = static_cast<PlayerInfo*>(currentPeer->data)->guild;
									if (guild == "") guild = "is not in guild.";
									int inventorySize = static_cast<PlayerInfo*>(currentPeer->data)->currentInventorySize;
									string skill = static_cast<PlayerInfo*>(currentPeer->data)->skill;
									int health = static_cast<PlayerInfo*>(currentPeer->data)->health;
									int warns = 0;
									string registermac = static_cast<PlayerInfo*>(currentPeer->data)->registermac;
									string registerrid = static_cast<PlayerInfo*>(currentPeer->data)->registerrid;
									string registersid = static_cast<PlayerInfo*>(currentPeer->data)->registersid;
									string registergid = static_cast<PlayerInfo*>(currentPeer->data)->registergid;
									string registervid = static_cast<PlayerInfo*>(currentPeer->data)->registervid;
									string registeraid = static_cast<PlayerInfo*>(currentPeer->data)->registeraid;
									string registerIP = static_cast<PlayerInfo*>(currentPeer->data)->registerIP;
									string friendinfo = "";
									for (int i = 0; i < static_cast<PlayerInfo*>(currentPeer->data)->friendinfo.size(); i++)
									{
										friendinfo += static_cast<PlayerInfo*>(currentPeer->data)->friendinfo[i] + ", ";
									}
									if (friendinfo == "") friendinfo = "No friends.";
									string rankgroup = "";
									if (isPlayer(currentPeer)) rankgroup = "Player";
									if (isVip(currentPeer)) rankgroup = "Vip";
									if (isMod(currentPeer)) rankgroup = "Moderator";
									if (isAdmin(currentPeer)) rankgroup = "Administrator";
									if (isDev(currentPeer)) rankgroup = "Co-Owner";
									if (isOwner(currentPeer)) rankgroup = "Owner";
									if (isFounder(currentPeer)) rankgroup = "Founder";
									else rankgroup = "Unknown";
									if (showplatid == "4") showplatidplain = " mobile (android) ";
									else if (showplatid == "0") showplatidplain = " PC (Windows) ";
									else if (showplatid == "6") showplatidplain = " Mac (OS X) ";
									else showplatidplain = " UNIX (Linux, iOS (most likely), FreeBSD etc.) ";

									GTDialog allinfo;
									allinfo.addTextBox("`wEditing " + static_cast<PlayerInfo*>(currentPeer->data)->displayName + " `w(" + static_cast<PlayerInfo*>(currentPeer->data)->rawName + ")");
									allinfo.addSmallText("`oRank: " + rankgroup);
									allinfo.addSmallText("`oLevel: " + to_string(levels));
									allinfo.addSmallText("`oXp: " + to_string(xp));
									allinfo.addSmallText("`oGems: " + contentp);
									allinfo.addSmallText("`oGuild: " + guild);
									allinfo.addSmallText("`oSkill: " + skill);
									allinfo.addSmallText("`oHealth: " + to_string(health));
									allinfo.addSmallText("`oCurrent world: " + showworld);
									allinfo.addSmallText("`oInventory size: " + to_string(inventorySize));
									allinfo.addSmallText("`oMac: " + registermac);
									allinfo.addSmallText("`oRid: " + registerrid);
									allinfo.addSmallText("`oSid: " + registersid);
									allinfo.addSmallText("`oGid: " + registergid);
									allinfo.addSmallText("`oVid: " + registervid);
									allinfo.addSmallText("`oAid: " + registeraid);
									allinfo.addSmallText("`oIP: " + registerIP);
									allinfo.addSmallText("`oDevice: " + showplatidplain);
									//allinfo.addSmallText("`oALT Accounts: " + accounts);
									allinfo.addSpacer(SPACER_SMALL);
									allinfo.addLabelWithIconButton("`o<-- 2 week DGH", 732, "suspend2w");
									allinfo.addLabelWithIconButton("`o<-- 4 week DGH", 732, "suspend4w");
									allinfo.addLabelWithIconButton("`o<-- 8 week DGH", 732, "suspend8w");
									allinfo.addLabelWithIconButton("`o<-- Perma ban DGH", 732, "suspend");
									allinfo.addLabelWithIconButton("`o<-- Perma ban for hacker", 732, "suspend");
									allinfo.addLabelWithIconButton("`o<-- Perma ban alt accounts", 732, "suspendalts");
									allinfo.addLabelWithIconButton("`o<-- Ip ban", 546, "ipbanwrench");
									allinfo.addSpacer(SPACER_SMALL);
									allinfo.addButton("showuserinventory", "Show user's inventory");
									allinfo.addSpacer(SPACER_SMALL);
									allinfo.endDialog("Close", "", "Close it");
									Player::OnDialogRequest(peer, allinfo.finishDialog());
								}
							}
						}
						if (btn == "wban")
						{
							if (world == nullptr || world->name == "EXIT" || serverIsFrozen) continue;
							if (static_cast<PlayerInfo*>(peer->data)->lastInfo == static_cast<PlayerInfo*>(peer->data)->rawName)
							{
								continue;
							}
							if (static_cast<PlayerInfo*>(peer->data)->haveGrowId && static_cast<PlayerInfo*>(peer->data)->rawName == getPlyersWorld(peer)->owner || isMod(peer))
							{
								ENetPeer* currentPeerp;
								for (currentPeerp = server->peers;
									currentPeerp < &server->peers[server->peerCount];
									++currentPeerp)
								{
									if (currentPeerp->state != ENET_PEER_STATE_CONNECTED)
										continue;
									string name = static_cast<PlayerInfo*>(peer->data)->displayName;
									string kickname = static_cast<PlayerInfo*>(peer->data)->lastDisplayname;
									//string kickname = static_cast<PlayerInfo*>(peer->data)->displayName;
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), name + " `4world bans " + "`o" + kickname + " from `w" + world->name + "`o!"));
									string text = "action|play_sfx\nfile|audio/repair.wav\ndelayMS|0\n";
									BYTE* data = new BYTE[5 + text.length()];
									BYTE zero = 0;
									int type = 3;
									memcpy(data, &type, 4);
									memcpy(data + 4, text.c_str(), text.length());
									memcpy(data + 4 + text.length(), &zero, 1);
									if (isHere(peer, currentPeerp))
									{
										ENetPacket* packetsou = enet_packet_create(data,
											5 + text.length(),
											ENET_PACKET_FLAG_RELIABLE);
										ENetPacket* packet = enet_packet_create(p.data,
											p.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(currentPeerp, 0, packetsou);
										enet_peer_send(currentPeerp, 0, packet);
										delete data;
										delete p.data;
										if (static_cast<PlayerInfo*>(currentPeerp->data)->rawName == static_cast<PlayerInfo*>(peer->data)->lastInfo) // if last wrench
										{
											namespace fs = std::experimental::filesystem;
											if (!fs::is_directory("worldbans/" + getPlyersWorld(peer)->name) || !fs::exists("worldbans/" + getPlyersWorld(peer)->name))
											{
												fs::create_directory("worldbans/" + getPlyersWorld(peer)->name);
												std::ofstream outfile("worldbans/" + getPlyersWorld(peer)->name + "/" + static_cast<PlayerInfo*>(currentPeerp->data)->rawName);
												outfile << "worldbanned by: " + static_cast<PlayerInfo*>(peer->data)->rawName;
												outfile.close();
											}
											else
											{
												std::ofstream outfile("worldbans/" + getPlyersWorld(peer)->name + "/" + static_cast<PlayerInfo*>(currentPeerp->data)->rawName);
												outfile << "worldbanned by: " + static_cast<PlayerInfo*>(peer->data)->rawName;
												outfile.close();
											}
											sendPlayerLeave(currentPeerp, static_cast<PlayerInfo*>(currentPeerp->data));
											static_cast<PlayerInfo*>(currentPeerp->data)->currentWorld = "EXIT";
											sendWorldOffers(currentPeerp);
										}
									}
								}
							}
						}
						else if (str == "/unbluename") {

							if (((PlayerInfo*)(peer->data))->level >= 125)
							{
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`w[`2+`w] `oYou need to be level `1125 `wto do that!"));
								ENetPacket* packet = enet_packet_create(p.data,
									p.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else {
								ENetPeer* currentPeer;

								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									if (isHere(peer, currentPeer))
									{
										GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnCountryState"), ((PlayerInfo*)(peer->data))->country + "|showGuild"));
										memcpy(p2.data + 8, &(((PlayerInfo*)(peer->data))->netID), 4);
										ENetPacket* packet2 = enet_packet_create(p2.data,
											p2.len,
											ENET_PACKET_FLAG_RELIABLE);

										enet_peer_send(currentPeer, 0, packet2);
										delete p2.data;
									}
								}
							}
						}
						else if (str == "/howgay") {
							ENetPeer* currentPeer;
							int val = rand() % 100;
							for (currentPeer = server->peers;
								currentPeer < &server->peers[server->peerCount];
								++currentPeer)
							{
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
									continue;
								if (isHere(peer, currentPeer))
								{
									GamePacket p2 = packetEnd(appendIntx(appendString(appendIntx(appendString(createPacket(), "OnTalkBubble"), ((PlayerInfo*)(peer->data))->netID), "`w" + ((PlayerInfo*)(peer->data))->displayName + " `oare `2" + std::to_string(val) + "% `wgay!"), 0));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(currentPeer, 0, packet2);
									delete p2.data;
									GamePacket p0 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), ((PlayerInfo*)(peer->data))->displayName + " `ware `2%" + std::to_string(val) + " `wgay!"));
									ENetPacket* packet0 = enet_packet_create(p0.data,
										p0.len,
										ENET_PACKET_FLAG_RELIABLE);

									enet_peer_send(currentPeer, 0, packet0);
									delete p0.data;
								}
							}
						}
						else if (str == "/kickall") {
							if (((PlayerInfo*)(peer->data))->adminLevel >= 7 || ((PlayerInfo*)(peer->data))->rawName == world->owner) {

								if (((PlayerInfo*)(peer->data))->currentWorld == "HELL")
								{
									Player::OnConsoleMessage(peer, "`4You can't kick players in this world.");
									continue;
								}

								ENetPeer* currentPeer;
								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									if (isHere(peer, currentPeer))
									{
										if (((PlayerInfo*)(currentPeer->data))->rawName != world->owner)
										{
											GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5[INFO] `@You have been kicked by `2" + ((PlayerInfo*)(peer->data))->rawName + "!"));
											ENetPacket* packet = enet_packet_create(p.data,
												p.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(currentPeer, 0, packet);
											delete p.data;
											playerRespawn(currentPeer, false);
										}
									}
								}
							}
							else {
								Player::OnConsoleMessage(peer, "`5[INFO] `9Sorry! `^But this command only available for `2World-Owner `^Or `9MOD `^And `@Higher `^ranks!");
								continue;
							}
						}
						if (btn == "kick")
						{
							if (world == nullptr || world->name == "EXIT" || serverIsFrozen) continue;
							if (static_cast<PlayerInfo*>(peer->data)->lastInfo == static_cast<PlayerInfo*>(peer->data)->rawName)
							{
								continue;
							}
							if (static_cast<PlayerInfo*>(peer->data)->rawName == getPlyersWorld(peer)->owner || isMod(peer))
							{
								ENetPeer* currentPeer;
								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									if (isDev(currentPeer))
									{
										continue;
									}
									string name = static_cast<PlayerInfo*>(peer->data)->displayName;
									string kickname = static_cast<PlayerInfo*>(peer->data)->lastDisplayname;
									//string kickname = static_cast<PlayerInfo*>(peer->data)->displayName;
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), name + " `4kicks " + "`o" + kickname + "`o!"));
									string text = "action|play_sfx\nfile|audio/male_scream.wav\ndelayMS|0\n";
									BYTE* data = new BYTE[5 + text.length()];
									BYTE zero = 0;
									int type = 3;
									memcpy(data, &type, 4);
									memcpy(data + 4, text.c_str(), text.length());
									memcpy(data + 4 + text.length(), &zero, 1);
									if (isHere(peer, currentPeer))
									{
										ENetPacket* packetsou = enet_packet_create(data,
											5 + text.length(),
											ENET_PACKET_FLAG_RELIABLE);
										ENetPacket* packet = enet_packet_create(p.data,
											p.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(currentPeer, 0, packetsou);
										enet_peer_send(currentPeer, 0, packet);
										int x = 3040;
										int y = 736;
										for (int i = 0; i < world->width * world->height; i++)
										{
											if (world->items[i].foreground == 6)
											{
												x = (i % world->width) * 32;
												y = (i / world->width) * 32;
											}
										}
										GamePacket p2 = packetEnd(appendFloat(appendString(createPacket(), "OnSetPos"), x, y));
										memcpy(p2.data + 8, &(static_cast<PlayerInfo*>(currentPeer->data)->netID), 4);
										ENetPacket* packet2 = enet_packet_create(p2.data,
											p2.len,
											ENET_PACKET_FLAG_RELIABLE);
										if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == static_cast<PlayerInfo*>(peer->data)->lastInfo)
										{
											enet_peer_send(currentPeer, 0, packet2);
										}
										delete p2.data;
										delete p.data;
										delete data;
									}
								}
							}
						}
						if (btn == "pull")
						{
							if (world == nullptr || world->name == "EXIT" || serverIsFrozen) continue;
							if (static_cast<PlayerInfo*>(peer->data)->lastInfo == static_cast<PlayerInfo*>(peer->data)->rawName)
							{
								continue;
							}
							if (static_cast<PlayerInfo*>(peer->data)->rawName == getPlyersWorld(peer)->owner || isMod(peer))
							{
								ENetPeer* currentPeer;
								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
									string name = static_cast<PlayerInfo*>(currentPeer->data)->rawName;
									int pullX = static_cast<PlayerInfo*>(peer->data)->x;
									int pullY = static_cast<PlayerInfo*>(peer->data)->y;
									if (name == static_cast<PlayerInfo*>(peer->data)->lastInfo)
									{
										if (isHere(peer, currentPeer) && getPlyersWorld(peer)->name != "EXIT")
										{
											string name = static_cast<PlayerInfo*>(peer->data)->displayName;
											string pullname = static_cast<PlayerInfo*>(currentPeer->data)->displayName;
											GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), name + " `5pulls " + "`o" + pullname + "`o!"));
											string text = "action|play_sfx\nfile|audio/object_spawn.wav\ndelayMS|0\n";
											BYTE* data = new BYTE[5 + text.length()];
											BYTE zero = 0;
											int type = 3;
											memcpy(data, &type, 4);
											memcpy(data + 4, text.c_str(), text.length());
											memcpy(data + 4 + text.length(), &zero, 1);
											ENetPacket* packet = enet_packet_create(p.data,
												p.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(currentPeer, 0, packet);
											enet_peer_send(peer, 0, packet);
											ENetPacket* packetsou = enet_packet_create(data,
												5 + text.length(),
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(currentPeer, 0, packetsou);
											enet_peer_send(peer, 0, packetsou);
											GamePacket p2 = packetEnd(appendFloat(appendString(createPacket(), "OnSetPos"), pullX, pullY));
											memcpy(p2.data + 8, &(static_cast<PlayerInfo*>(currentPeer->data)->netID), 4);
											ENetPacket* packet2 = enet_packet_create(p2.data,
												p2.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(currentPeer, 0, packet2);
											GamePacket pto = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "You have been pulled by " + static_cast<PlayerInfo*>(peer->data)->displayName));
											//memcpy(p2.data + 8, &(static_cast<PlayerInfo*>(currentPeer->data)->netID), 4);
											ENetPacket* packetto = enet_packet_create(pto.data,
												pto.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(currentPeer, 0, packetto);
											delete pto.data;
											delete p2.data;
											delete p.data;
										}
									}
								}
							}
						}
						if (btn == "backsocialportal")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							if (static_cast<PlayerInfo*>(peer->data)->joinguild == true)
							{
								Player::OnDialogRequest(peer, "set_default_color|`w\n\nadd_label_with_icon|big|Social Portal``|left|1366|\n\nadd_spacer|small|\nadd_button|backonlinelist|Show Friends``|0|0|\nadd_button|showguild|Show Guild Members``|0|0|\nend_dialog||OK||\nadd_quick_exit|");
							}
							else
							{
								Player::OnDialogRequest(peer, "set_default_color|`w\n\nadd_label_with_icon|big|Social Portal``|left|1366|\n\nadd_spacer|small|\nadd_button|backonlinelist|Show Friends``|0|0|\nadd_button|createguildinfo|Create Guild``|0|0|\nend_dialog||OK||\nadd_quick_exit|");
							}
						}
						if (btn == "backonlinelist")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							string onlinefrnlist = "";
							int onlinecount = 0;
							int totalcount = static_cast<PlayerInfo*>(peer->data)->friendinfo.size();
							ENetPeer* currentPeer;
							for (currentPeer = server->peers;
								currentPeer < &server->peers[server->peerCount];
								++currentPeer)
							{
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
									continue;
								string name = static_cast<PlayerInfo*>(currentPeer->data)->rawName;
								if (find(static_cast<PlayerInfo*>(peer->data)->friendinfo.begin(), static_cast<PlayerInfo*>(peer->data)->friendinfo.end(), name) != static_cast<PlayerInfo*>(peer->data)->friendinfo.end())
								{
									onlinefrnlist += "\nadd_button|onlinefrns_" + static_cast<PlayerInfo*>(currentPeer->data)->rawName + "|`2ONLINE: `o" + static_cast<PlayerInfo*>(currentPeer->data)->tankIDName + "``|0|0|";
									onlinecount++;
								}
							}
							if (totalcount == 0)
							{
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`o" + std::to_string(onlinecount) + " of " + std::to_string(totalcount) + " `wFriends Online``|left|1366|\n\nadd_spacer|small|\nadd_label|small|`1To add friends in `4Growtopia `1Click on someone's name and click add as a friend!`o.``|left|4|\n\nadd_spacer|small|\nadd_button||`5Close``|0|0|\nadd_quick_exit|"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);
								delete p2.data;
							}
							else if (onlinecount == 0)
							{
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`o" + std::to_string(onlinecount) + " of " + std::to_string(totalcount) + " `wFriends Online``|left|1366|\n\nadd_spacer|small|\nadd_button|chc0|`wClose``|0|0|\nadd_label|small|`oNone of your friends are currently online.``|left|4|\n\nadd_spacer|small|\nadd_button|showoffline|`5Show offline``|0|0|\nadd_button||`5Close``|0|0|\nadd_quick_exit|"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);
								delete p2.data;
							}
							else
							{
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`o" + std::to_string(onlinecount) + " of " + std::to_string(totalcount) + " `wFriends Online``|left|1366|\n\nadd_spacer|small|\nadd_button|chc0|`wClose``|0|0|" + onlinefrnlist + "\n\nadd_spacer|small|\nadd_button|showoffline|`5Show offline``|0|0|\nadd_button||`oClose``|0|0|\nadd_quick_exit|"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);
								delete p2.data;
							}
						}
						if (btn.substr(0, 9) == "onlinegm_")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							ENetPeer* currentPeer;
							for (currentPeer = server->peers;
								currentPeer < &server->peers[server->peerCount];
								++currentPeer)
							{
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
									continue;
								if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == btn.substr(9, cch.length() - 9 - 1))
								{
									static_cast<PlayerInfo*>(peer->data)->lastgmworld = static_cast<PlayerInfo*>(currentPeer->data)->currentWorld;
									static_cast<PlayerInfo*>(peer->data)->lastgmname = static_cast<PlayerInfo*>(currentPeer->data)->displayName;
									static_cast<PlayerInfo*>(peer->data)->lastgm = static_cast<PlayerInfo*>(currentPeer->data)->rawName;
								}
							}
							if (btn.substr(9, cch.length() - 9 - 1) == static_cast<PlayerInfo*>(peer->data)->rawName)
							{
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`w" + static_cast<PlayerInfo*>(peer->data)->lastgmname + "``|left|1366|\n\nadd_spacer|small|\nadd_textbox|This is you!|\n\nadd_spacer|small|\nadd_button|showguild|`oBack``|0|0|\nadd_quick_exit|"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);
								delete p2.data;
							}
							else
							{
								if (static_cast<PlayerInfo*>(peer->data)->rawName == static_cast<PlayerInfo*>(peer->data)->guildLeader)
								{
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`w" + static_cast<PlayerInfo*>(peer->data)->lastgmname + "``|left|1366|\n\nadd_spacer|small|\nadd_textbox|`o" + static_cast<PlayerInfo*>(peer->data)->lastgmname + " is `2online `onow in the world `5" + static_cast<PlayerInfo*>(peer->data)->lastgmworld + "`o.|\n\nadd_spacer|small|\nadd_button|gmwarpbutton|`oWarp to `5" + static_cast<PlayerInfo*>(peer->data)->lastgmworld + "``|0|0|\nadd_button|gmmsgbutton|`5Send message``|0|0|\n\nadd_spacer|small|\nadd_button|removegmonline|Kick from guild|0|0|\nadd_button|showguild|`oBack``|0|0|\nadd_quick_exit|"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
								}
								else
								{
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`w" + static_cast<PlayerInfo*>(peer->data)->lastgmname + "``|left|1366|\n\nadd_spacer|small|\nadd_textbox|`o" + static_cast<PlayerInfo*>(peer->data)->lastgmname + " is `2online `onow in the world `5" + static_cast<PlayerInfo*>(peer->data)->lastgmworld + "`o.|\n\nadd_spacer|small|\nadd_button|gmwarpbutton|`oWarp to `5" + static_cast<PlayerInfo*>(peer->data)->lastgmworld + "``|0|0|\nadd_button|gmmsgbutton|`5Send message``|0|0|\n\nadd_spacer|small|\nadd_button|showguild|`oBack``|0|0|\nadd_quick_exit|"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
								}
							}
						}
						if (btn == "showoffline")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							string onlinelist = "";
							string offlinelist = "";
							string offname = "";
							int onlinecount = 0;
							int totalcount = static_cast<PlayerInfo*>(peer->data)->friendinfo.size();
							vector<string> offliness = static_cast<PlayerInfo*>(peer->data)->friendinfo;
							ENetPeer* currentPeer;
							for (currentPeer = server->peers;
								currentPeer < &server->peers[server->peerCount];
								++currentPeer)
							{
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
									continue;
								string name = static_cast<PlayerInfo*>(currentPeer->data)->rawName;
								if (find(static_cast<PlayerInfo*>(peer->data)->friendinfo.begin(), static_cast<PlayerInfo*>(peer->data)->friendinfo.end(), name) != static_cast<PlayerInfo*>(peer->data)->friendinfo.end())
								{
									onlinelist += "\nadd_button|onlinefrns_" + static_cast<PlayerInfo*>(currentPeer->data)->rawName + "|`2ONLINE: `o" + static_cast<PlayerInfo*>(currentPeer->data)->displayName + "``|0|0|";
									onlinecount++;
									offliness.erase(std::remove(offliness.begin(), offliness.end(), name), offliness.end());
								}
							}
							for (std::vector<string>::const_iterator i = offliness.begin(); i != offliness.end(); ++i)
							{
								offname = *i;
								offlinelist += "\nadd_button|offlinefrns_" + offname + "|`4OFFLINE: `o" + offname + "``|0|0|";
							}
							GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`o" + std::to_string(onlinecount) + " of " + std::to_string(totalcount) + " `wFriends Online|left|1366|\n\nadd_spacer|small|\nadd_button|chc0|`wClose``|0|0|\nadd_spacer|small|" + offlinelist + "\nadd_spacer|small|\n\nadd_button|frnoption|`oFriend Options``|0|0|\nadd_button|backonlinelist|Back``|0|0|\nadd_button||`oClose``|0|0|\nadd_quick_exit|"));
							ENetPacket* packet2 = enet_packet_create(p2.data,
								p2.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet2);
							delete p2.data;
						}
						if (btn == "removecon")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							if (static_cast<PlayerInfo*>(peer->data)->haveGrowId == false)
							{
								continue;
							}
							ENetPeer* currentPeer;
							for (currentPeer = server->peers;
								currentPeer < &server->peers[server->peerCount];
								++currentPeer)
							{
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
									continue;
								if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == static_cast<PlayerInfo*>(peer->data)->lastFrn)
								{
									static_cast<PlayerInfo*>(peer->data)->friendinfo.erase(std::remove(static_cast<PlayerInfo*>(peer->data)->friendinfo.begin(), static_cast<PlayerInfo*>(peer->data)->friendinfo.end(), static_cast<PlayerInfo*>(peer->data)->lastFrn), static_cast<PlayerInfo*>(peer->data)->friendinfo.end());
									static_cast<PlayerInfo*>(currentPeer->data)->friendinfo.erase(std::remove(static_cast<PlayerInfo*>(currentPeer->data)->friendinfo.begin(), static_cast<PlayerInfo*>(currentPeer->data)->friendinfo.end(), static_cast<PlayerInfo*>(peer->data)->rawName), static_cast<PlayerInfo*>(currentPeer->data)->friendinfo.end());

									//for me

									ifstream fg("players/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".json");
									json j;
									fg >> j;
									fg.close();

									j["friends"] = static_cast<PlayerInfo*>(peer->data)->friendinfo;

									ofstream fs("players/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".json");
									fs << j;
									fs.close();

									// for another player

									ifstream fgg("players/" + PlayerDB::getProperName(static_cast<PlayerInfo*>(currentPeer->data)->rawName) + ".json");
									json jj;
									fgg >> jj;
									fgg.close();

									jj["friends"] = static_cast<PlayerInfo*>(currentPeer->data)->friendinfo;

									ofstream fss("players/" + PlayerDB::getProperName(static_cast<PlayerInfo*>(currentPeer->data)->rawName) + ".json");
									fss << jj;
									fss.close();

									Player::OnConsoleMessage(currentPeer, "`3FRIEND ALERT: `2" + static_cast<PlayerInfo*>(peer->data)->displayName + " `ohas removed you as a friend.");
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`4Friend removed``|left|1366|\n\nadd_spacer|small|\nadd_textbox|`oOk, you are no longer friends with `o" + static_cast<PlayerInfo*>(peer->data)->lastFrnName + ".``|\n\nadd_spacer|small|\nadd_button||`oOK``|0|0|\nadd_quick_exit|"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
									break;
								}
							}
						}
						if (btn == "removeconoff")
						{
							/*if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							if (static_cast<PlayerInfo*>(peer->data)->haveGrowId == false)
							{
								continue;
							}
							static_cast<PlayerInfo*>(peer->data)->friendinfo.erase(std::remove(static_cast<PlayerInfo*>(peer->data)->friendinfo.begin(), static_cast<PlayerInfo*>(peer->data)->friendinfo.end(), static_cast<PlayerInfo*>(peer->data)->lastFrn), static_cast<PlayerInfo*>(peer->data)->friendinfo.end());


							MYSQL_ROW row;
							if (conn == nullptr)
							{
								cout << "null" << endl;
								continue;
							}
							if (conn != nullptr)
							{
								stringstream sse;
								sse << "SELECT friends FROM PlayerDatabase WHERE username = '" + static_cast<PlayerInfo*>(peer->data)->lastFrn + "'";
								auto query = sse.str();
								auto q = query.c_str();
								if (mysql_query(conn, q))
								{
											string ers = mysql_error(conn); if (ers.find("Lost connection") != string::npos) ConnectToDatabase();
									cout << mysql_error(conn) << endl;


									enet_peer_disconnect_now(peer, 0);
									continue;
								}
								string Friends;
								res = mysql_store_result(conn);
								while (row = mysql_fetch_row(res))
								{
									Friends = row[17];
								}

								stringstream ss(Friends);
								vector<string> result;
								while (ss.good())
								{
									string substr;
									getline(ss, substr, ',');
									if (substr.size() == 0) continue;
									result.push_back(substr);
								}
								result.erase(std::remove(result.begin(), result.end(), static_cast<PlayerInfo*>(peer->data)->rawName), result.end());
								string friends_string = "";
								for (int i = 0; i < result.size(); i++)
								{
									friends_string += result[i] + ",";
								}
								auto qstate = 0;
								if (conn == nullptr)
								{
									cout << "conn was nullptr" << endl;
									continue;
								}
								if (conn != nullptr)
								{
									stringstream sss;
									sss << "UPDATE PlayerDatabase SET friends = '" + friends_string + "' WHERE username = '" + static_cast<PlayerInfo*>(peer->data)->lastFrn + "'";
									auto queryy = sss.str();
									const auto qq = queryy.c_str();
									if (mysql_query(conn, qq))
									{
												string ers = mysql_error(conn); if (ers.find("Lost connection") != string::npos) ConnectToDatabase();
										cout << mysql_error(conn) << endl;


										enet_peer_disconnect_now(peer, 0);
										continue;
									}
								}
							}
							else
							{
								continue;
							}


							string friends_string = "";
							for (int i = 0; i < static_cast<PlayerInfo*>(peer->data)->friendinfo.size(); i++)
							{
								friends_string += static_cast<PlayerInfo*>(peer->data)->friendinfo[i] + ",";
							}

							auto qstate = 0;
							if (conn == nullptr)
							{
								cout << "conn was nullptr" << endl;
								continue;
							}
							if (conn != nullptr)
							{
								stringstream ss;
								ss << "UPDATE PlayerDatabase SET friends = '" + friends_string + "' WHERE username = '" + PlayerDB::getProperName(static_cast<PlayerInfo*>(peer->data)->rawName) + "'";
								auto query = ss.str();
								const auto q = query.c_str();
								if (mysql_query(conn, q))
								{
											string ers = mysql_error(conn); if (ers.find("Lost connection") != string::npos) ConnectToDatabase();
									cout << mysql_error(conn) << endl;


									enet_peer_disconnect_now(peer, 0);
									continue;
								}
							}*/

							GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`4Friend removed``|left|1366|\n\nadd_spacer|small|\nadd_textbox|`oOk, you are no longer friends with `o" + static_cast<PlayerInfo*>(peer->data)->lastFrn + ".``|\n\nadd_spacer|small|\nadd_button||`oOK``|0|0|\nadd_quick_exit|"));
							ENetPacket* packet2 = enet_packet_create(p2.data,
								p2.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet2);
							delete p2.data;
						}
						if (btn.substr(0, 11) == "onlinefrns_")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							ENetPeer* currentPeer;
							for (currentPeer = server->peers;
								currentPeer < &server->peers[server->peerCount];
								++currentPeer)
							{
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
									continue;
								if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == btn.substr(11, cch.length() - 11 - 1))
								{
									static_cast<PlayerInfo*>(peer->data)->lastFrnWorld = static_cast<PlayerInfo*>(currentPeer->data)->currentWorld;
									static_cast<PlayerInfo*>(peer->data)->lastFrnName = static_cast<PlayerInfo*>(currentPeer->data)->tankIDName;
									static_cast<PlayerInfo*>(peer->data)->lastFrn = static_cast<PlayerInfo*>(currentPeer->data)->rawName;
								}
							}
							GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`w" + static_cast<PlayerInfo*>(peer->data)->lastFrnName + "``|left|1366|\n\nadd_spacer|small|\nadd_textbox|`o" + static_cast<PlayerInfo*>(peer->data)->lastFrnName + " is `2online `onow in the world `5" + static_cast<PlayerInfo*>(peer->data)->lastFrnWorld + "`o.|\n\nadd_spacer|small|\nadd_button|frnwarpbutton|`oWarp to `5" + static_cast<PlayerInfo*>(peer->data)->lastFrnWorld + "``|0|0|\nadd_button|msgbutton|`5Send message``|0|0|\n\nadd_spacer|small|\nadd_button|removecon|`oRemove as friend``|0|0|\nadd_button|backonlinelist|`oBack``|0|0|\nadd_quick_exit|"));
							ENetPacket* packet2 = enet_packet_create(p2.data,
								p2.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet2);
							delete p2.data;
						}
						if (btn == "frnwarpbutton")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							/*if (static_cast<PlayerInfo*>(peer->data)->isCursed == true)
							{
								GamePacket p0 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`4You are cursed now!"));
								ENetPacket* packet0 = enet_packet_create(p0.data,
									p0.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet0);
								delete p0.data;
								continue;
							}
							if (static_cast<PlayerInfo*>(peer->data)->lastFrnWorld == "SERVER")
							{
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`4 You cannot warp to your friend now! `7Try it later."));
								ENetPacket* packet = enet_packet_create(p.data,
									p.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else if (static_cast<PlayerInfo*>(peer->data)->lastFrnWorld == "EXIT" || static_cast<PlayerInfo*>(peer->data)->lastFrnWorld == "exit")
							{
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`4 You cannot warp to your friend because he is in `2EXIT `4world."));
								ENetPacket* packet = enet_packet_create(p.data,
									p.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else
							{
								sendPlayerLeave(peer, (PlayerInfo*)(peer->data));
								joinWorld(peer, static_cast<PlayerInfo*>(peer->data)->lastFrnWorld, 0, 0);
							}*/
						}
						if (btn == "msgbutton")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "add_label_with_icon|big|`5Message to `o" + static_cast<PlayerInfo*>(peer->data)->lastFrnName + "|left|660|\nadd_spacer|small|\nadd_text_input|msgtext|||50|\nend_dialog|msgdia|Cancel|`5Send``| \nadd_spacer|big|\nadd_button|backonlinelist|`oBack``|0|0|\nadd_quick_exit|\n"));
							ENetPacket* packet2 = enet_packet_create(p2.data,
								p2.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet2);
							delete p2.data;
						}
						if (btn.substr(0, 12) == "offlinefrns_")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							static_cast<PlayerInfo*>(peer->data)->lastFrn = btn.substr(12, cch.length() - 12 - 1);
							GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`w" + static_cast<PlayerInfo*>(peer->data)->lastFrn + "``|left|1366|\n\nadd_spacer|small|\nadd_textbox|`o" + static_cast<PlayerInfo*>(peer->data)->lastFrn + " is `4offline`o.``|\nadd_spacer|small|\nadd_button|removeconoff|`oRemove as friend``|0|0|\nadd_button|showoffline|`oBack``|0|0|\nadd_quick_exit|"));
							ENetPacket* packet2 = enet_packet_create(p2.data,
								p2.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet2);
							delete p2.data;
						}
						if (btn == "addfriendrnbutton")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							if (static_cast<PlayerInfo*>(peer->data)->haveGrowId == true)
							{
								ENetPeer* currentPeer;
								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == static_cast<PlayerInfo*>(peer->data)->lastInfo)
									{
										// if last wrench
										if (static_cast<PlayerInfo*>(peer->data)->lastfriend == static_cast<PlayerInfo*>(currentPeer->data)->rawName)
										{
											// last  h friend
											static_cast<PlayerInfo*>(peer->data)->friendinfo.push_back(static_cast<PlayerInfo*>(currentPeer->data)->rawName); //add
											static_cast<PlayerInfo*>(currentPeer->data)->friendinfo.push_back(static_cast<PlayerInfo*>(peer->data)->rawName);

											//for me

											ifstream fg("players/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".json");
											json j;
											fg >> j;
											fg.close();

											j["friends"] = static_cast<PlayerInfo*>(peer->data)->friendinfo;

											ofstream fs("players/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".json");
											fs << j;
											fs.close();

											// for another player

											ifstream fgg("players/" + PlayerDB::getProperName(static_cast<PlayerInfo*>(currentPeer->data)->rawName) + ".json");
											json jj;
											fgg >> jj;
											fgg.close();

											jj["friends"] = static_cast<PlayerInfo*>(currentPeer->data)->friendinfo;

											ofstream fss("players/" + PlayerDB::getProperName(static_cast<PlayerInfo*>(currentPeer->data)->rawName) + ".json");
											fss << jj;
											fss.close();


											string text = "action|play_sfx\nfile|audio/love_in.wav\ndelayMS|0\n";
											BYTE* data = new BYTE[5 + text.length()];
											BYTE zero = 0;
											int type = 3;
											memcpy(data, &type, 4);
											memcpy(data + 4, text.c_str(), text.length());
											memcpy(data + 4 + text.length(), &zero, 1);
											ENetPacket* packet2 = enet_packet_create(data,
												5 + text.length(),
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(currentPeer, 0, packet2);
											enet_peer_send(peer, 0, packet2);
											delete data;
											GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`3FRIEND ADDED: `oYou're now friends with `w" + static_cast<PlayerInfo*>(peer->data)->displayName + "`o!"));
											ENetPacket* packet = enet_packet_create(p.data,
												p.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(currentPeer, 0, packet);
											delete p.data;
											GamePacket p3 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`3FRIEND ADDED: `oYou're now friends with `w" + static_cast<PlayerInfo*>(currentPeer->data)->displayName + "`o!"));
											ENetPacket* packet3 = enet_packet_create(p3.data,
												p3.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(peer, 0, packet3);
											delete p3.data;
										}
										else
										{
											GamePacket p4 = packetEnd(appendString(appendIntx(appendString(createPacket(), "OnTalkBubble"), static_cast<PlayerInfo*>(peer->data)->netID), "`5[`wFriend request sent to " + static_cast<PlayerInfo*>(currentPeer->data)->displayName + "`5]"));
											ENetPacket* packet4 = enet_packet_create(p4.data,
												p4.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(peer, 0, packet4);
											delete p4.data;
											string text = "action|play_sfx\nfile|audio/tip_start.wav\ndelayMS|0\n";
											BYTE* data = new BYTE[5 + text.length()];
											BYTE zero = 0;
											int type = 3;
											memcpy(data, &type, 4);
											memcpy(data + 4, text.c_str(), text.length());
											memcpy(data + 4 + text.length(), &zero, 1);
											ENetPacket* packet2 = enet_packet_create(data,
												5 + text.length(),
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(currentPeer, 0, packet2);
											delete data;
											static_cast<PlayerInfo*>(currentPeer->data)->lastfriend = static_cast<PlayerInfo*>(peer->data)->rawName;
											GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`3FRIEND REQUEST: `oYou've received a `wfriend request `ofrom `w" + static_cast<PlayerInfo*>(peer->data)->displayName + "`o! To accept, click the `wwrench by his/her name `oand then choose `wAdd as friend`o."));
											ENetPacket* packet = enet_packet_create(p.data,
												p.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(currentPeer, 0, packet);
											delete p.data;
										}
									}
								}
							}
							else
							{
								SendRegisterDialog(peer);
							}
						}
						if (btn == "rayman")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|\nadd_label_with_icon|big|`6Super Special items``|left|1458|\nadd_spacer|small|\nadd_label|small|`2Make sure it's the correct item!``|left|\nadd_spacer|small|\nadd_label|small|`4You are about the purchase `5Rayman``|left|\nadd_spacer|small|\nadd_label|small|`2This item contains: `wRayman and gives you 3 far when breaking blocks!``|left|\nadd_spacer|small|\nadd_button|yesrayman|`9Purchase for - `2150.000!|0|0|\nadd_spacer|small|\nadd_button|cl0se|``Close|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|"));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						if (btn == "ances")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|\nadd_label_with_icon|big|`6Super Special items``|left|1458|\nadd_spacer|small|\nadd_label|small|`2Make sure it's the correct item!``|left|\nadd_spacer|small|\nadd_label|small|`4You are about the purchase `6Ancestral``|left|\nadd_spacer|small|\nadd_label|small|`2This item contains: `6Ancestral `wand get 8-20 gems per blocks + /ssb!``|left|\nadd_spacer|small|\nadd_button|yesaac|`9Purchase for - `2950000!|0|0|\nadd_spacer|small|\nadd_button|cl0se|``Close|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|"));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						if (btn == "spd")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|\nadd_label_with_icon|big|`6Super Special items``|left|1486|\nadd_spacer|small|\nadd_label|small|`2Make sure it's the correct item!``|left|\nadd_spacer|small|\nadd_label|small|`4You are about the purchase `bDigger Spade``|left|\nadd_spacer|small|\nadd_label|small|`2This item contains: `bDigger spade `wand 2 hit when breaking block``|left|\nadd_spacer|small|\nadd_button|yesspd|`9Purchase for - `250000!|0|0|\nadd_spacer|small|\nadd_button|cl0se|``Close|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|"));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						if (btn == "craftlavalock")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							UpdateLocalPlayerFragments(peer);
							int firefragment = static_cast<PlayerInfo*>(peer->data)->fFire;
							if (firefragment >= 300)
							{
								bool success = true;
								SaveShopsItemMoreTimes(9308, 1, peer, success);
								RemovePlayerFragmentFire(peer, 300);
								Player::OnTextOverlay(peer, "`9You have bought `4Lava Lock`9!");
							}
							else
							{
								Player::OnTextOverlay(peer, "`4Sorry`9, But you don't have enough `4Fire `9Fragments!");
							}
						}
						if (btn == "buydarkstones")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`6Buying `bThe Dark Stone `9Options``||10026||\nadd_textbox|`oHow many `bDark Stones `odo you want to buy? |\nadd_text_input|darkstoneoffer|||7|\nend_dialog|reqdarkstoneoffer|Cancel|`2Purchase!|\n"));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						if (btn == "buywl")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`6Buying `9World Lock `9Options``||242||\nadd_textbox|`oHow many `9World Locks `odo you want to buy? |\nadd_text_input|worldlockoffer|||7|\nend_dialog|reqworldlockoffer|Cancel|`2Purchase!|\n"));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						if (btn == "buychands")
						{
							std::ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
							std::string content((std::istreambuf_iterator<char>(ifsz)),
								(std::istreambuf_iterator<char>()));
							int b = atoi(content.c_str());
							if (b >= 3500)
							{
								bool success = true;
								SaveShopsItemMoreTimes(340, 200, peer, success); // aposition, itemid, quantity, peer, success
								if (!success) break;
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You have bought `o200 `2Chandelier`9!"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);
								delete p2.data;
								string text = "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0\n";
								BYTE* data = new BYTE[5 + text.length()];
								BYTE zero = 0;
								int type = 3;
								memcpy(data, &type, 4);
								memcpy(data + 4, text.c_str(), text.length()); // change memcpy here
								memcpy(data + 4 + text.length(), &zero, 1); // change memcpy here, revert to 4
								ENetPacket* packetsou = enet_packet_create(data,
									5 + text.length(),
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packetsou);
								int gemcalc10k = b - 3500;
								ofstream myfile2;
								myfile2.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
								myfile2 << std::to_string(gemcalc10k);
								myfile2.close();
								std::ifstream ifszi("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
								std::string contentx((std::istreambuf_iterator<char>(ifszi)),
									(std::istreambuf_iterator<char>()));
								int updgem = atoi(contentx.c_str());
								GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), updgem));
								ENetPacket* packetpp = enet_packet_create(pp.data,
									pp.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packetpp);
								delete pp.data;
							}
							else
							{
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You `@Don't `9Have enough `9Gem's`9!"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);
								delete p2.data;
							}
						}
						if (btn == "buysugarcane")
						{
							std::ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
							std::string content((std::istreambuf_iterator<char>(ifsz)),
								(std::istreambuf_iterator<char>()));
							int b = atoi(content.c_str());
							if (b >= 800)
							{
								bool success = true;
								SaveShopsItemMoreTimes(954, 200, peer, success); // aposition, itemid, quantity, peer, success
								if (!success) break;
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You have bought `o200 `2Sugar Cane`9!"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);
								delete p2.data;
								string text = "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0\n";
								BYTE* data = new BYTE[5 + text.length()];
								BYTE zero = 0;
								int type = 3;
								memcpy(data, &type, 4);
								memcpy(data + 4, text.c_str(), text.length()); // change memcpy here
								memcpy(data + 4 + text.length(), &zero, 1); // change memcpy here, revert to 4
								ENetPacket* packetsou = enet_packet_create(data,
									5 + text.length(),
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packetsou);
								int gemcalc10k = b - 800;
								ofstream myfile2;
								myfile2.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
								myfile2 << std::to_string(gemcalc10k);
								myfile2.close();
								std::ifstream ifszi("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
								std::string contentx((std::istreambuf_iterator<char>(ifszi)),
									(std::istreambuf_iterator<char>()));
								int updgem = atoi(contentx.c_str());
								GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), updgem));
								ENetPacket* packetpp = enet_packet_create(pp.data,
									pp.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packetpp);
								delete pp.data;
							}
							else
							{
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You `@Don't `9Have enough `9Gem's`9!"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);
								delete p2.data;
							}
						}
						if (btn == "buylasergrid")
						{
							std::ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
							std::string content((std::istreambuf_iterator<char>(ifsz)),
								(std::istreambuf_iterator<char>()));
							int b = atoi(content.c_str());
							if (b >= 2000)
							{
								bool success = true;
								SaveShopsItemMoreTimes(5666, 200, peer, success); // aposition, itemid, quantity, peer, success
								if (!success) break;
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You have bought `o200 `2Laser Grid`9!"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);
								delete p2.data;
								string text = "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0\n";
								BYTE* data = new BYTE[5 + text.length()];
								BYTE zero = 0;
								int type = 3;
								memcpy(data, &type, 4);
								memcpy(data + 4, text.c_str(), text.length()); // change memcpy here
								memcpy(data + 4 + text.length(), &zero, 1); // change memcpy here, revert to 4
								ENetPacket* packetsou = enet_packet_create(data,
									5 + text.length(),
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packetsou);
								int gemcalc10k = b - 2000;
								ofstream myfile2;
								myfile2.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
								myfile2 << std::to_string(gemcalc10k);
								myfile2.close();
								std::ifstream ifszi("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
								std::string contentx((std::istreambuf_iterator<char>(ifszi)),
									(std::istreambuf_iterator<char>()));
								int updgem = atoi(contentx.c_str());
								GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), updgem));
								ENetPacket* packetpp = enet_packet_create(pp.data,
									pp.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packetpp);
								delete pp.data;
							}
							else
							{
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You `@Don't `9Have enough `9Gem's`9!"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);
								delete p2.data;
							}
						}
						if (btn == "buydl")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`6Buying `1Diamond Lock `9Options``||1796||\nadd_textbox|`oHow many `1Diamond Locks `odo you want to buy? |\nadd_text_input|diamondlockoffer|||7|\nend_dialog|reqdiamondlockoffer|Cancel|`2Purchase!|\n"));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						if (btn == "crafturanusblast") //BAISIOS NESAMONES ATSARGIAU!
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							bool iscontains = false;
							SearchInventoryItem(peer, 1486, 10, iscontains);
							if (!iscontains)
							{
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You `@Don't `9Have enough `@Store Token's`9!"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);
								delete p2.data;
							}
							else
							{
								bool success = false;
								SaveShopsItemMoreTimes(8428, 1, peer, success);
								if (success)
								{
									RemoveInventoryItem(1486, 10, peer, true);
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`0You have purchased `5Uranus Blast`0!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
								}
							}
						}
						if (btn == "craftxpnecklace") //BAISIOS NESAMONES ATSARGIAU!
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							bool iscontains = false;
							SearchInventoryItem(peer, 1486, 30, iscontains);
							if (!iscontains)
							{
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You `@Don't `9Have enough `@Store Token's`9!"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);
								delete p2.data;
							}
							else
							{
								bool success = false;
								SaveShopsItemMoreTimes(9428, 1, peer, success);
								if (success)
								{
									RemoveInventoryItem(1486, 30, peer, true);
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`0You have purchased `2XP Necklace`0!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
								}
							}
						}
						if (btn == "bsword")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							bool iscontains = false;
							SearchInventoryItem(peer, 1796, 120, iscontains);
							if (!iscontains)
							{
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You `@Don't `9Have enough `@Store Token's`9!"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);
								delete p2.data;
							}
							else
							{
								bool success = false;
								SaveShopsItemMoreTimes(9716, 1, peer, success);
								if (success)
								{
									RemoveInventoryItem(1796, 120, peer, true);
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`0You have purchased `9Sword`0!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
								}
							}
						}
						if (btn == "craftrgbwings") //BAISIOS NESAMONES ATSARGIAU!
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							bool iscontains = false;
							SearchInventoryItem(peer, 1486, 9, iscontains);
							if (!iscontains)
							{
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You `@Don't `9Have enough `@Store Token's`9!"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);
								delete p2.data;
							}
							else
							{
								bool success = false;
								SaveShopsItemMoreTimes(9434, 1, peer, success);
								if (success)
								{
									RemoveInventoryItem(1486, 9, peer, true);
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`0You have purchased `9The `eRGB Wings`0!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
								}
							}
						}
						if (btn == "craftbushwings") //BAISIOS NESAMONES ATSARGIAU!
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							bool iscontains = false;
							SearchInventoryItem(peer, 1486, 30, iscontains);
							if (!iscontains)
							{
								Player::OnTextOverlay(peer, "`9You `@Don't `9Have enough `@Store Token's`9!");
							}
							else
							{
								bool iscontains = false;
								SearchInventoryItem(peer, 2408, 1, iscontains);
								if (!iscontains)
								{
									Player::OnTextOverlay(peer, "`9You `@Don't `9Have `2Emerald Lock`9!");
								}
								else
								{
									UpdateLocalPlayerFragments(peer);
									int earthfragment = static_cast<PlayerInfo*>(peer->data)->fEarth;
									if (earthfragment >= 300000)
									{
										bool success = false;
										SaveShopsItemMoreTimes(9466, 1, peer, success);
										if (success)
										{
											RemoveInventoryItem(1486, 30, peer, false);
											RemoveInventoryItem(2408, 1, peer, true);
											RemovePlayerFragmentEarth(peer, 300000);
											Player::OnTextOverlay(peer, "`0You have purchased `9The `2Bush Wings`0!");
										}
									}
									else
									{
										Player::OnTextOverlay(peer, "`4Sorry`9, But you don't have enough `2Earth `9Fragments!");
									}
								}
							}
						}
						if (btn == "craftwinterwings") //BAISIOS NESAMONES ATSARGIAU!
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							bool iscontains = false;
							SearchInventoryItem(peer, 7328, 120, iscontains);
							if (!iscontains)
							{
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You `@Don't `9Have enough `1Winter Token's`9!"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);
								delete p2.data;
							}
							else
							{
								bool success = false;
								SaveShopsItemMoreTimes(9478, 1, peer, success);
								if (success)
								{
									RemoveInventoryItem(7328, 120, peer, true);
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`0You have purchased `9The `!Crystal `1Winter Wings`0!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
								}
							}
						}
						if (btn == "craftfenixwings") //BAISIOS NESAMONES ATSARGIAU!
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							bool iscontains = false;
							SearchInventoryItem(peer, 1486, 90, iscontains);
							if (!iscontains)
							{
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You `@Don't `9Have enough `@Store Token's`9!"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);
								delete p2.data;
							}
							else
							{
								bool success = false;
								SaveShopsItemMoreTimes(5136, 1, peer, success);
								if (success)
								{
									RemoveInventoryItem(1486, 90, peer, true);
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`0You have purchased `9The `4Fenix Wings`0!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
								}
							}
						}
						if (btn == "purchaseyellowcrystal")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							bool iscontains = false;
							SearchInventoryItem(peer, 2244, 15, iscontains);
							if (!iscontains)
							{
								Player::OnTextOverlay(peer, "`9You `@Don't `9Have enough `2Green Crystal's`9!");
							}
							else
							{
								bool success = false;
								SaveShopsItemMoreTimes(9510, 1, peer, success);
								if (success)
								{
									RemoveInventoryItem(2244, 15, peer, true);
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`0You have purchased `9The `9Golden `@Store Token`0!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
								}
							}
						}
						if (btn == "purchaselegendaryorb")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							bool iscontains = false;
							SearchInventoryItem(peer, 8774, 1, iscontains);
							if (!iscontains)
							{
								Player::OnTextOverlay(peer, "`9You `@Don't `9Have `cSummer Clash Ticket`9!");
							}
							else
							{
								bool success = false;
								SaveShopsItemMoreTimes(1794, 1, peer, success);
								if (success)
								{
									RemoveInventoryItem(8774, 1, peer, true);
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`0You have purchased `9The `8Legendary Orb`0!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
								}
							}
						}
						if (btn == "purchasegoldenstoretoken")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							bool iscontains = false;
							SearchInventoryItem(peer, 1486, 100, iscontains);
							if (!iscontains)
							{
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You `@Don't `9Have enough `@Store Token's`9!"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);
								delete p2.data;
							}
							else
							{
								bool success = false;
								SaveShopsItemMoreTimes(9500, 1, peer, success);
								if (success)
								{
									RemoveInventoryItem(1486, 100, peer, true);
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`0You have purchased `9The `9Golden `@Store Token`0!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
								}
							}
						}
						if (btn == "craftdarklock") //BAISIOS NESAMONES ATSARGIAU!
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							bool iscontains = false;
							SearchInventoryItem(peer, 8, 100, iscontains);
							if (!iscontains)
							{
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You `@Don't `9Have enough `aBedrock's`9!"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);
								delete p2.data;
							}
							else
							{
								bool success = false;
								SaveShopsItemMoreTimes(9290, 1, peer, success);
								if (success)
								{
									RemoveInventoryItem(8, 100, peer, true);
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`0You have crafted `9The `bDark Lock`0!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
								}
							}
						}
						if (btn == "buyamethyst")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							bool iscontains = false;
							SearchInventoryItem(peer, 242, 15, iscontains);
							if (!iscontains)
							{
								bool iscontainss = false;
								SearchInventoryItem(peer, 1796, 1, iscontainss);
								if (!iscontainss)
								{
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You `@Don't `9Have enough `2World Locks`9!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
								}
								else
								{
									bool success = false;
									bool iscontainssss = false;
									SearchInventoryItem(peer, 4762, 1, iscontainssss);
									if (!iscontainssss)
									{
										SaveShopsItem(4762, 200, peer, success);
										if (success)
										{
											RemoveInventoryItem(1796, 1, peer, true);
											GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You have bought `8200 `#Amethyst `9Blocks!"));
											ENetPacket* packet2 = enet_packet_create(p2.data,
												p2.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(peer, 0, packet2);
											delete p2.data;
										}
									}
									else
									{
										GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9Your inventory already contains `#Amethyst `9Blocks!"));
										ENetPacket* packet2 = enet_packet_create(p2.data,
											p2.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet2);
										delete p2.data;
									}
								}
							}
							else
							{
								bool success = false;
								bool iscontainssss = false;
								SearchInventoryItem(peer, 4762, 1, iscontainssss);
								if (!iscontainssss)
								{
									SaveShopsItem(4762, 200, peer, success);
									if (success)
									{
										RemoveInventoryItem(242, 15, peer, true);
										GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You have bought `8200 `#Amethyst `9Blocks!"));
										ENetPacket* packet2 = enet_packet_create(p2.data,
											p2.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet2);
										delete p2.data;
									}
								}
								else
								{
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9Your inventory already contains `#Amethyst `9Blocks!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
								}
							}
						}
						if (btn == "buycrystalblock")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							bool iscontains = false;
							SearchInventoryItem(peer, 242, 200, iscontains);
							if (!iscontains)
							{
								bool iscontainss = false;
								SearchInventoryItem(peer, 1796, 2, iscontainss);
								if (!iscontainss)
								{
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You `@Don't `9Have enough `2World Locks`9!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
								}
								else
								{
									bool success = false;
									bool iscontainssss = false;
									SearchInventoryItem(peer, 262, 1, iscontainssss);
									if (!iscontainssss)
									{
										SaveShopsItem(262, 200, peer, success);
										if (success)
										{
											RemoveInventoryItem(1796, 2, peer, true);
											GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You have bought `8200 `#Crystal `9Blocks!"));
											ENetPacket* packet2 = enet_packet_create(p2.data,
												p2.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(peer, 0, packet2);
											delete p2.data;
										}
									}
									else
									{
										GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9Your inventory already contains `#Crystal `9Blocks!"));
										ENetPacket* packet2 = enet_packet_create(p2.data,
											p2.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet2);
										delete p2.data;
									}
								}
							}
							else
							{
								bool success = false;
								bool iscontainssss = false;
								SearchInventoryItem(peer, 262, 1, iscontainssss);
								if (!iscontainssss)
								{
									SaveShopsItem(262, 200, peer, success);
									if (success)
									{
										RemoveInventoryItem(242, 200, peer, true);
										GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You have bought `8200 `#Crystal `9Blocks!"));
										ENetPacket* packet2 = enet_packet_create(p2.data,
											p2.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet2);
										delete p2.data;
									}
								}
								else
								{
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9Your inventory already contains `#Crystal `9Blocks!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
								}
							}
						}
						if (btn == "buyrubyblock")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							bool iscontains = false;
							SearchInventoryItem(peer, 242, 200, iscontains);
							if (!iscontains)
							{
								bool iscontainss = false;
								SearchInventoryItem(peer, 1796, 2, iscontainss);
								if (!iscontainss)
								{
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You `@Don't `9Have enough `2World Locks`9!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
								}
								else
								{
									bool success = false;
									bool iscontainssss = false;
									SearchInventoryItem(peer, 828, 1, iscontainssss);
									if (!iscontainssss)
									{
										SaveShopsItem(828, 200, peer, success);
										if (success)
										{
											RemoveInventoryItem(1796, 2, peer, true);
											GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You have bought `8200 `#Ruby `9Blocks!"));
											ENetPacket* packet2 = enet_packet_create(p2.data,
												p2.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(peer, 0, packet2);
											delete p2.data;
										}
									}
									else
									{
										GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9Your inventory already contains `#Ruby `9Blocks!"));
										ENetPacket* packet2 = enet_packet_create(p2.data,
											p2.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet2);
										delete p2.data;
									}
								}
							}
							else
							{
								bool success = false;
								bool iscontainssss = false;
								SearchInventoryItem(peer, 828, 1, iscontainssss);
								if (!iscontainssss)
								{
									SaveShopsItem(828, 200, peer, success);
									if (success)
									{
										RemoveInventoryItem(242, 200, peer, true);
										GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You have bought `8200 `#Ruby `9Blocks!"));
										ENetPacket* packet2 = enet_packet_create(p2.data,
											p2.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet2);
										delete p2.data;
									}
								}
								else
								{
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9Your inventory already contains `#Ruby `9Blocks!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
								}
							}
						}
						if (btn == "buyemeraldblock")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							bool iscontains = false;
							SearchInventoryItem(peer, 242, 200, iscontains);
							if (!iscontains)
							{
								bool iscontainss = false;
								SearchInventoryItem(peer, 1796, 2, iscontainss);
								if (!iscontainss)
								{
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You `@Don't `9Have enough `2World Locks`9!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
								}
								else
								{
									bool success = false;
									bool iscontainssss = false;
									SearchInventoryItem(peer, 826, 1, iscontainssss);
									if (!iscontainssss)
									{
										SaveShopsItem(826, 200, peer, success);
										if (success)
										{
											RemoveInventoryItem(1796, 2, peer, true);
											GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You have bought `8200 `#Emerald `9Blocks!"));
											ENetPacket* packet2 = enet_packet_create(p2.data,
												p2.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(peer, 0, packet2);
											delete p2.data;
										}
									}
									else
									{
										GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9Your inventory already contains `#Emerald `9Blocks!"));
										ENetPacket* packet2 = enet_packet_create(p2.data,
											p2.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet2);
										delete p2.data;
									}
								}
							}
							else
							{
								bool success = false;
								bool iscontainssss = false;
								SearchInventoryItem(peer, 826, 1, iscontainssss);
								if (!iscontainssss)
								{
									SaveShopsItem(826, 200, peer, success);
									if (success)
									{
										RemoveInventoryItem(242, 200, peer, true);
										GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You have bought `8200 `#Emerald `9Blocks!"));
										ENetPacket* packet2 = enet_packet_create(p2.data,
											p2.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet2);
										delete p2.data;
									}
								}
								else
								{
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9Your inventory already contains `#Emerald `9Blocks!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
								}
							}
						}
						if (btn == "buybgl") //PRO ITEM ...
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							bool iscontains = false;
							SearchInventoryItem(peer, 1796, 100, iscontains);
							if (!iscontains)
							{
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You `@Don't `9Have enough `eDiamond Locks`9!"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);
								delete p2.data;
							}
							else
							{
								bool success = false;
								SaveShopsItemMoreTimes(7188, 1, peer, success);
								if (success)
								{
									RemoveInventoryItem(1796, 100, peer, true);
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You have bought `!Blue Gem Lock!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
								}
							}
						}
						if (btn == "buyzeus1") //PRO ITEM ...
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							bool iscontains = false;
							SearchInventoryItem(peer, 1796, 50, iscontains);
							if (!iscontains)
							{
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You `@Don't `9Have enough `eDiamond Locks`9!"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);
								delete p2.data;
							}
							else
							{
								bool success = false;
								SaveShopsItemMoreTimes(1804, 1, peer, success);
								if (success)
								{
									RemoveInventoryItem(1796, 50, peer, true);
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You have bought `!Zeus Lighting Bolt!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
								}
							}
						}
						if (btn == "buyriches") //PRO ITEM ...
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							bool iscontains = false;
							SearchInventoryItem(peer, 1796, 25, iscontains);
							if (!iscontains)
							{
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You `@Don't `9Have enough `eDiamond Locks`9!"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);
								delete p2.data;
							}
							else
							{
								bool success = false;
								SaveShopsItemMoreTimes(5084, 1, peer, success);
								if (success)
								{
									RemoveInventoryItem(1796, 25, peer, true);
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You have bought `4Ancestral Of Riches!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
								}
							}
						}
						if (btn == "buywis") //PRO ITEM ...
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							bool iscontains = false;
							SearchInventoryItem(peer, 1796, 25, iscontains);
							if (!iscontains)
							{
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You `@Don't `9Have enough `eDiamond Locks`9!"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);
								delete p2.data;
							}
							else
							{
								bool success = false;
								SaveShopsItemMoreTimes(5078, 1, peer, success);
								if (success)
								{
									RemoveInventoryItem(1796, 25, peer, true);
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You have bought `9Ancestral Totem Of Wisdom!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
								}
							}
						}
						if (btn == "buydim") //PRO ITEM ...
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							bool iscontains = false;
							SearchInventoryItem(peer, 1796, 25, iscontains);
							if (!iscontains)
							{
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You `@Don't `9Have enough `eDiamond Locks`9!"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);
								delete p2.data;
							}
							else
							{
								bool success = false;
								SaveShopsItemMoreTimes(5080, 1, peer, success);
								if (success)
								{
									RemoveInventoryItem(1796, 25, peer, true);
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You have bought `3Ancestral Of Dimensions!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
								}
							}
						}
						if (btn == "buynucleardet")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							bool iscontains = false;
							SearchInventoryItem(peer, 242, 50, iscontains);
							if (!iscontains)
							{
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You `@Don't `9Have enough `eWorld Locks`9!"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);
								delete p2.data;
							}
							else
							{
								bool success = false;
								SaveShopsItemMoreTimes(5524, 1, peer, success);
								if (success)
								{
									RemoveInventoryItem(242, 50, peer, true);
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You have bought `9Digger's `oSpade!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
								}
							}
						}
						
						if (btn == "buylegendwizard")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							bool iscontains = false;
							SearchInventoryItem(peer, 1796, 150, iscontains);
							if (!iscontains)
							{
								Player::OnTextOverlay(peer, "`9You `@Don't `9Have enough `eDiamond Locks`9!");
							}
							else
							{
								bool success = false;
								SaveShopsItemMoreTimes(1790, 1, peer, success);
								if (success)
								{
									RemoveInventoryItem(1796, 150, peer, true);
									Player::OnTextOverlay(peer, "`9You have bought `#Legendary Wizard`9!");
								}
							}
						}
						if (btn == "buyantigravity") //PRO ITEM ...
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							bool iscontains = false;
							SearchInventoryItem(peer, 242, 30, iscontains);
							if (!iscontains)
							{
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You `@Don't `9Have enough `2World Locks`9!"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);
								delete p2.data;
							}
							else
							{
								bool success = false;
								SaveShopsItemMoreTimes(4992, 1, peer, success);
								if (success)
								{
									RemoveInventoryItem(242, 30, peer, true);
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You have bought `2Anti Gravity`9!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
								}
							}
						}
						if (btn == "buywgm") //PRO ITEM ...
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							bool iscontains = false;
							SearchInventoryItem(peer, 1796, 30, iscontains);
							if (!iscontains)
							{
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You `@Don't `9Have enough `eDiamond Locks`9!"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);
								delete p2.data;
							}
							else
							{
								bool success = false;
								SaveShopsItemMoreTimes(9432, 1, peer, success);
								if (success)
								{
									RemoveInventoryItem(1796, 30, peer, true);
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You have bought `5World Generation Machine`9!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
								}
							}
						}
						if (btn == "buymagicmachine") //PRO ITEM ...
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							bool iscontains = false;
							SearchInventoryItem(peer, 1796, 15, iscontains);
							if (!iscontains)
							{
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You `@Don't `9Have enough `eDiamond Locks`9!"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);
								delete p2.data;
							}
							else
							{
								bool success = false;
								SaveShopsItemMoreTimes(9170, 1, peer, success);
								if (success)
								{
									RemoveInventoryItem(1796, 15, peer, true);
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You have bought `9Magic Machine!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
								}
							}
						}
						if (btn == "buyatm")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							bool iscontains = false;
							SearchInventoryItem(peer, 242, 20, iscontains);
							if (!iscontains)
							{
								bool iscontainss = false;
								SearchInventoryItem(peer, 1796, 1, iscontainss);
								if (!iscontainss)
								{
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You `@Don't `9Have enough `2World Locks`9!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
								}
								else
								{
									bool success = false;
									SaveShopsItemMoreTimes(1008, 1, peer, success);
									if (success)
									{
										RemoveInventoryItem(1796, 1, peer, true);
										SaveShopsItemMoreTimes(242, 80, peer, success);
										GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You have bought `eATM Machine`9!"));
										ENetPacket* packet2 = enet_packet_create(p2.data,
											p2.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet2);
										delete p2.data;
									}
								}
							}
							else
							{
								bool success = false;
								SaveShopsItemMoreTimes(1008, 1, peer, success);
								if (success)
								{
									RemoveInventoryItem(242, 20, peer, true);
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You have bought `eATM Machine!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
								}
							}
						}
						if (btn == "buyocean") //PRO ITEM ...
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							bool iscontains = false;
							SearchInventoryItem(peer, 242, 10, iscontains);
							if (!iscontains)
							{
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You `@Don't `9Have enough `9World Locks`9!"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);
								delete p2.data;
							}
							else
							{
								bool success = false;
								SaveShopsItemMoreTimes(9414, 1, peer, success);
								if (success)
								{
									RemoveInventoryItem(242, 10, peer, true);
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You have bought `eOcean `9Chest!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
								}
							}
						}
						if (btn == "buybanwand")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							bool iscontains = false;
							SearchInventoryItem(peer, 1796, 200, iscontains);
							if (!iscontains)
							{
								Player::OnTextOverlay(peer, "`9You `@Don't `9Have enough `eDiamond Locks`9!");
							}
							else
							{
								bool success = false;
								SaveShopsItemMoreTimes(732, 1, peer, success);
								if (success)
								{
									RemoveInventoryItem(1796, 200, peer, true);
									Player::OnTextOverlay(peer, "`9You have bought `4Ban Wand`9!");
								}
							}
						}
						if (btn == "buycursewand")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							bool iscontains = false;
							SearchInventoryItem(peer, 1796, 120, iscontains);
							if (!iscontains)
							{
								Player::OnTextOverlay(peer, "`9You `@Don't `9Have enough `eDiamond Locks`9!");
							}
							else
							{
								bool success = false;
								SaveShopsItemMoreTimes(278, 1, peer, success);
								if (success)
								{
									RemoveInventoryItem(1796, 120, peer, true);
									Player::OnTextOverlay(peer, "`9You have bought `bCurse Wand`9!");
								}
							}
						}
						if (btn == "buyfirewand")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							bool iscontains = false;
							SearchInventoryItem(peer, 1796, 15, iscontains);
							if (!iscontains)
							{
								Player::OnTextOverlay(peer, "`9You `@Don't `9Have enough `eDiamond Locks`9!");
							}
							else
							{
								bool success = false;
								SaveShopsItemMoreTimes(276, 1, peer, success);
								if (success)
								{
									RemoveInventoryItem(1796, 15, peer, true);
									Player::OnTextOverlay(peer, "`9You have bought `@Fire Wand`9!");
								}
							}
						}
						if (btn == "buyfreezewand")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							bool iscontains = false;
							SearchInventoryItem(peer, 1796, 3, iscontains);
							if (!iscontains)
							{
								Player::OnTextOverlay(peer, "`9You `@Don't `9Have enough `eDiamond Locks`9!");
							}
							else
							{
								bool success = false;
								SaveShopsItemMoreTimes(274, 1, peer, success);
								if (success)
								{
									RemoveInventoryItem(1796, 3, peer, true);
									Player::OnTextOverlay(peer, "`9You have bought `!Freeze Wand`9!");
								}
							}
						}
						if (btn == "buypinkdiamond")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							bool iscontains = false;
							SearchInventoryItem(peer, 1796, 2, iscontains);
							if (!iscontains)
							{
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You `@Don't `9Have enough `eDiamond Locks`9!"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);
								delete p2.data;
							}
							else
							{
								bool iscontainssss = false;
								SearchInventoryItem(peer, 10024, 1, iscontainssss);
								if (!iscontainssss)
								{
									bool success = false;
									SaveShopsItemMoreTimesLoginis(10024, 200, peer, success);
									if (success)
									{
										RemoveInventoryItem(1796, 2, peer, true);
										GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You have bought `8200 `#Pink Diamonds`9!"));
										ENetPacket* packet2 = enet_packet_create(p2.data,
											p2.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet2);
										delete p2.data;
									}
								}
								else
								{
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9Your inventory already contains `#Pink Diamonds`9!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
								}
							}
						}
						if (btn == "buycitrine")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT") continue;
							bool iscontains = false;
							SearchInventoryItem(peer, 1796, 3, iscontains);
							if (!iscontains)
							{
								Player::OnTextOverlay(peer, "`9You `@Don't `9Have enough `eDiamond Locks`9!");
							}
							else
							{
								bool iscontainssss = false;
								SearchInventoryItem(peer, 10028, 1, iscontainssss);
								if (!iscontainssss)
								{
									bool success = false;
									SaveShopsItemMoreTimesLoginis(10028, 200, peer, success);
									if (success)
									{
										RemoveInventoryItem(1796, 3, peer, true);
										Player::OnTextOverlay(peer, "`9You have bought `8200 `6Citrine Blocks`9!");
									}
								}
								else
								{
									Player::OnTextOverlay(peer, "`9Your inventory already contains `6Citrine Blocks`9!");
								}
							}
						}
						if (btn == "buydiamondstone") //PRO ITEM ...
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							bool iscontains = false;
							SearchInventoryItem(peer, 242, 90, iscontains);
							if (!iscontains)
							{
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You `@Don't `9Have enough `2World Locks`9!"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);
								delete p2.data;
							}
							else
							{
								bool success = false;
								SaveShopsItemMoreTimesLoginis(9468, 200, peer, success);
								if (success)
								{
									RemoveInventoryItem(242, 90, peer, true);
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You have bought `8200 `1Diamond `9Stones!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
								}
							}
						}
						if (btn == "buysmaraged") //PRO ITEM ...
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							bool iscontains = false;
							SearchInventoryItem(peer, 242, 50, iscontains);
							if (!iscontains)
							{
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You `@Don't `9Have enough `2World Locks`9!"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);
								delete p2.data;
							}
							else
							{
								bool success = false;
								SaveShopsItemMoreTimesLoginis(9460, 200, peer, success);
								if (success)
								{
									RemoveInventoryItem(242, 50, peer, true);
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You have bought `8200 `2Smaraged `9Blocks!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
								}
							}
						}
						if (btn == "buyonyx") //BAISIOS NESAMONES ATSARGIAU!
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							bool iscontains = false;
							SearchInventoryItem(peer, 242, 30, iscontains);
							if (!iscontains)
							{
								bool iscontainss = false;
								SearchInventoryItem(peer, 1796, 1, iscontainss);
								if (!iscontainss)
								{
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You `@Don't `9Have enough `2World Locks`9!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
								}
								else
								{
									bool success = false;
									bool iscontainssss = false;
									SearchInventoryItem(peer, 7382, 1, iscontainssss);
									if (!iscontainssss)
									{
										SaveShopsItem(7382, 200, peer, success);
										if (success)
										{
											RemoveInventoryItem(1796, 1, peer, true);
											SaveShopsItemMoreTimesLoginis(242, 70, peer, success);
											GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You have bought `8200 `bOnyx `9Blocks!"));
											ENetPacket* packet2 = enet_packet_create(p2.data,
												p2.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(peer, 0, packet2);
											delete p2.data;
										}
									}
									else
									{
										GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9Your inventory already contains `bOnyx `9blocks!"));
										ENetPacket* packet2 = enet_packet_create(p2.data,
											p2.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet2);
										delete p2.data;
									}
								}
							}
							else
							{
								bool success = false;
								bool iscontainssss = false;
								SearchInventoryItem(peer, 7382, 1, iscontainssss);
								if (!iscontainssss)
								{
									SaveShopsItem(7382, 200, peer, success);
									if (success)
									{
										RemoveInventoryItem(242, 30, peer, true);
										GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You have bought `8200 `bOnyx `9Blocks!"));
										ENetPacket* packet2 = enet_packet_create(p2.data,
											p2.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet2);
										delete p2.data;
									}
								}
								else
								{
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9Your inventory already contains `bOnyx `9blocks!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
								}
							}
						}
						if (btn == "buybronzechest")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							bool iscontains = false;
							SearchInventoryItem(peer, 242, 30, iscontains);
							if (!iscontains)
							{
								bool iscontainss = false;
								SearchInventoryItem(peer, 1796, 1, iscontainss);
								if (!iscontainss)
								{
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You `@Don't `9Have enough `2World Locks`9!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
								}
								else
								{
									bool success = false;
									SaveShopsItemMoreTimes(6204, 1, peer, success);
									if (success)
									{
										RemoveInventoryItem(1796, 1, peer, true);
										SaveShopsItemMoreTimes(242, 70, peer, success);
										GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You have bought `8Bronze `oChest`9!"));
										ENetPacket* packet2 = enet_packet_create(p2.data,
											p2.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet2);
										delete p2.data;
									}
								}
							}
							else
							{
								bool success = false;
								SaveShopsItemMoreTimes(6204, 1, peer, success);
								if (success)
								{
									RemoveInventoryItem(242, 30, peer, true);
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You have bought `8Bronze `oChest`9!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
								}
							}
						}
						if (btn == "buyinvupgrade")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT") continue;
							bool iscontains = false;
							SearchInventoryItem(peer, 242, 30, iscontains);
							if (iscontains)
							{
								bool success = true;
								short nextSpace = 0;
								if (static_cast<PlayerInfo*>(peer->data)->currentInventorySize + 30 > 200)
								{
									nextSpace = 200;
								}
								else
								{
									nextSpace = static_cast<PlayerInfo*>(peer->data)->currentInventorySize + 30;
								}

								ifstream fg("players/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".json");
								json j;
								fg >> j;
								fg.close();

								j["inventorysize"] = nextSpace;

								ofstream fs("players/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".json");
								fs << j;
								fs.close();
								if (success)
								{
									RemoveInventoryItem(242, 30, peer, true);
									Player::OnTextOverlay(peer, "`2You upgraded your inventory to `5" + to_string(nextSpace) + " `2Spaces!");
									static_cast<PlayerInfo*>(peer->data)->currentInventorySize += 30;
									SendInventory(peer, static_cast<PlayerInfo*>(peer->data)->inventory);
									const auto p3 = packetEnd(appendFloat(appendIntx(appendFloat(appendFloat(appendFloat(appendString(createPacket(), "OnSetClothing"), (static_cast<PlayerInfo*>(peer->data))->cloth_hair, (static_cast<PlayerInfo*>(peer->data))->cloth_shirt, (static_cast<PlayerInfo*>(peer->data))->cloth_pants), (static_cast<PlayerInfo*>(peer->data))->cloth_feet, (static_cast<PlayerInfo*>(peer->data))->cloth_face, (static_cast<PlayerInfo*>(peer->data))->cloth_hand), (static_cast<PlayerInfo*>(peer->data))->cloth_back, (static_cast<PlayerInfo*>(peer->data))->cloth_mask, (static_cast<PlayerInfo*>(peer->data))->cloth_necklace), (static_cast<PlayerInfo*>(peer->data))->skinColor), (static_cast<PlayerInfo*>(peer->data))->cloth_ances, 0.0f, 0.0f));
									memcpy(p3.data + 8, &((static_cast<PlayerInfo*>(peer->data))->netID), 4);
									const auto packet = enet_packet_create(p3.data, p3.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
								}
							}
							else
							{
								Player::OnTextOverlay(peer, "`9You `@Don't `9Have enough `2World Locks`9!");
							}
						}

						if (btn == "buyringofforce")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							bool iscontains = false;
							SearchInventoryItem(peer, 242, 60, iscontains);
							if (!iscontains)
							{
								bool iscontainss = false;
								SearchInventoryItem(peer, 1796, 1, iscontainss);
								if (!iscontainss)
								{
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You `@Don't `9Have enough `2World Locks`9!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
								}
								else
								{
									bool success = false;
									SaveShopsItemMoreTimes(1874, 1, peer, success);
									if (success)
									{
										RemoveInventoryItem(1796, 1, peer, true);
										SaveShopsItemMoreTimes(242, 40, peer, success);
										GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You have bought `4Ring `#Of `8Force`9!"));
										ENetPacket* packet2 = enet_packet_create(p2.data,
											p2.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet2);
										delete p2.data;
									}
								}
							}
							else
							{
								bool success = true;
								if (success)
								{
									SaveShopsItemMoreTimes(1874, 1, peer, success);
									if (success)
									{
										RemoveInventoryItem(242, 60, peer, true);
										GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You have bought `4Ring `#Of `8Force`9!"));
										ENetPacket* packet2 = enet_packet_create(p2.data,
											p2.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet2);
										delete p2.data;
									}
								}
							}
						}
						if (btn == "buyringofwinds")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							bool iscontains = false;
							SearchInventoryItem(peer, 242, 90, iscontains);
							if (!iscontains)
							{
								bool iscontainss = false;
								SearchInventoryItem(peer, 1796, 1, iscontainss);
								if (!iscontainss)
								{
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You `@Don't `9Have enough `2World Locks`9!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
								}
								else
								{
									bool success = false;
									SaveShopsItemMoreTimes(1876, 1, peer, success);
									if (success)
									{
										RemoveInventoryItem(1796, 1, peer, true);
										SaveShopsItemMoreTimes(242, 10, peer, success);
										GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You have bought `4Ring `#Of `!Winds`9!"));
										ENetPacket* packet2 = enet_packet_create(p2.data,
											p2.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet2);
										delete p2.data;
									}
								}
							}
							else
							{
								bool success = false;
								SaveShopsItemMoreTimes(1876, 1, peer, success);
								if (success)
								{
									RemoveInventoryItem(242, 90, peer, true);
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You have bought `4Ring `#Of `!Winds`9!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
								}
							}
						}
						if (btn == "buyringofwater")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							bool iscontains = false;
							SearchInventoryItem(peer, 242, 30, iscontains);
							if (!iscontains)
							{
								bool iscontainss = false;
								SearchInventoryItem(peer, 1796, 1, iscontainss);
								if (!iscontainss)
								{
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You `@Don't `9Have enough `2World Locks`9!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
								}
								else
								{
									bool success = false;
									SaveShopsItemMoreTimes(2970, 1, peer, success);
									if (success)
									{
										RemoveInventoryItem(1796, 1, peer, true);
										SaveShopsItemMoreTimes(242, 70, peer, success);
										GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You have bought `4Ring `#Of `eWater`9!"));
										ENetPacket* packet2 = enet_packet_create(p2.data,
											p2.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet2);
										delete p2.data;
									}
								}
							}
							else
							{
								bool success = false;
								SaveShopsItemMoreTimes(2970, 1, peer, success);
								if (success)
								{
									RemoveInventoryItem(242, 30, peer, true);
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You have bought `4Ring `#Of `eWater`9!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
								}
							}
						}
						if (btn == "buyringofgemini")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							bool iscontains = false;
							SearchInventoryItem(peer, 242, 90, iscontains);
							if (!iscontains)
							{
								bool iscontainss = false;
								SearchInventoryItem(peer, 1796, 1, iscontainss);
								if (!iscontainss)
								{
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You `@Don't `9Have enough `2World Locks`9!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
								}
								else
								{
									bool success = false;
									SaveShopsItemMoreTimes(1986, 1, peer, success);
									if (success)
									{
										RemoveInventoryItem(1796, 1, peer, true);
										SaveShopsItemMoreTimes(242, 10, peer, success);
									}
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You have bought `4Ring `#Of `2Gemini`9!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
								}
							}
							else
							{
								bool success = false;
								SaveShopsItemMoreTimes(1986, 1, peer, success);
								if (success)
								{
									RemoveInventoryItem(242, 90, peer, true);
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You have bought `4Ring `#Of `2Gemini`9!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
								}
							}
						}
						if (btn == "diamondlock")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|\nadd_label_with_icon|big|`6Buy `1Diamond `^Locks``|left|1796|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`1Diamond `^Lock `0Allows you to lock any free world! `4WARNING! `1Diamond `^Lock `oCosts `2100000 Gems!|\nadd_spacer|small|\nadd_button|buydl|`9Buy `1Diamond `^Lock!|0|0|\nadd_spacer|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|"));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						if (btn == "ringofshrinking")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`2Coming Soon!"));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						if (btn == "theonering")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`2Coming Soon!"));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						if (btn == "ringofnight")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`2Coming Soon!"));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						if (btn == "ringofsmithing")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`2Coming Soon!"));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						if (btn == "ringofnature")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`2Coming Soon!"));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						if (btn == "ringofsavings")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`2Coming Soon!"));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						if (btn == "ringofwisdom")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`2Coming Soon!"));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						if (btn == "ringoffistful")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`2Coming Soon!"));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						if (btn == "ringofgemini")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|\nadd_label_with_icon|big|`6Buy `4Ring `#Of `2Gemini``|left|1986|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`4Ring `#Of `2Gemini `^Gives a clone effect for your player`^!|\nadd_spacer|small|\nadd_button|buyringofgemini|`9Purchase `7[`490`2 WLS`7]!|0|0|\nadd_spacer|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|"));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						if (btn == "ringofwater")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|\nadd_label_with_icon|big|`6Buy `4Ring `#Of `eWater``|left|2970|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`4Ring `#Of `eWater `^Allows you to move faster in water`^!|\nadd_spacer|small|\nadd_button|buyringofwater|`9Purchase `7[`430`2 WLS`7]!|0|0|\nadd_spacer|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|"));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						if (btn == "ringofwinds")
						{
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|\nadd_label_with_icon|big|`6Buy `4Ring `#Of `!Winds``|left|1876|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`4Ring `#Of `!Winds `^Gives you exclusive floating effects and allows you to move faster`^!|\nadd_spacer|small|\nadd_button|buyringofwinds|`9Purchase `7[`490`2 WLS`7]!|0|0|\nadd_spacer|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|"));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						if (btn == "ringofforce")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|\nadd_label_with_icon|big|`6Buy `4Ring `#Of `8Force``|left|1874|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`4Ring `#Of `8Force `^Gives you exclusive breaking effects`^!|\nadd_spacer|small|\nadd_button|buyringofforce|`9Purchase `7[`460`2 WLS`7]!|0|0|\nadd_spacer|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|"));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						if (btn == "atm")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|\nadd_label_with_icon|big|`6Buy `eATM `3Machine``|left|1008|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`3ATM Machines `1Can give you over `45-10 `2Gems `1Per PUNCH`^! `#This item is permanent`^!|\nadd_spacer|small|\nadd_button|buyatm|`7Buy `eATM Machine `7[`420`2 WLS`7]!|0|0|\nadd_spacer|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|"));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						if (btn == "oceanchest")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|\nadd_label_with_icon|big|`6Buy `eOcean Chest``|left|9414|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`^Only `9Obtainable `^During `#February, March, April, May`^, Gives `4Great `9Loot`^! `9Small Chance To Obtain `4Rare `9Items `w[`eOcean Wings`9, `eOcean Sword`w]|\nadd_spacer|small|\nadd_button|buyocean|`7Buy `9Ocean Chest `7[`410`e WLS`7]!|0|0|\nadd_spacer|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|"));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						if (btn == "magicmchn")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|\nadd_label_with_icon|big|`6Buy `9Magic Machine``|left|9170|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`9Really heavy and powerfull machine! `9Who knows what it does?... But the creators are sure that it will lead to profit!|\nadd_spacer|small|\nadd_button|buymagicmachine|`7Buy `9Magic Machine `7[`415`e DLS`7]!|0|0|\nadd_spacer|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|"));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
							continue;
						}
						if (btn == "wgm")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|\nadd_label_with_icon|big|`6Buy `5World Generation Machine``|left|9432|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`9Generate Any World You Wish! `9This `^Machine `9Allows you to `@Create `9Any `^World `9You want! You can choose the `^Height, Width, Blocks `9And much more!|\nadd_spacer|small|\nadd_button|buywgm|`7Buy `5WGM `7[`430`e DLS`7]!|0|0|\nadd_spacer|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|"));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
							continue;
						}
						if (btn == "bgllock")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|\nadd_label_with_icon|big|`6Buy `!Blue Gem Lock``|left|7188|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`9This Item is like world lock, allows you to lock any world, you can convert this item back to `@100 `1Diamond Locks `9At any time!|\nadd_spacer|small|\nadd_button|buybgl|`7Buy `!BGL `7[`4100`e DLS`7]!|0|0|\nadd_spacer|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|"));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
							continue;
						}
						if (btn == "lavalock")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`6Purchase `4Lava Lock`6!``|left|9308|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`9This Item is like `5World Lock`9, allows you to `cLock `9Any world, it comes with cool `cAnimations`9!|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`oTo purchase this item you need `@300 `4Fire `9Fragment's`o!|left|1458|\nadd_spacer|small|\nadd_button|craftlavalock|`9Purchase!|0|0|\nadd_spacer|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|");
						}
						if (btn == "darkstone")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|\nadd_label_with_icon|big|`6Buy `bThe Dark Stones``|left|10026|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`bDark Dark Dark! `^Gives you `9Random Item `^From the whole server!|\nadd_spacer|small|\nadd_button|buydarkstones|`7Buy `bThe Dark Stones `7[`4500000`2 Gems`7]!|0|0|\nadd_spacer|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|"));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
							continue;
						}
						if (btn == "worldlock")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|\nadd_label_with_icon|big|`6Buy `2World `^Locks``|left|242|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`2World `^Lock `0Allows you to lock any free world! `4WARNING! `2World `^Lock `oCosts `22000 Gems!|\nadd_spacer|small|\nadd_button|buywl|`9Buy `2World `^Lock!|0|0|\nadd_spacer|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|"));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						if (btn == "darklock")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|\nadd_label_with_icon|big|`6Craft `bDark Lock`6!``|left|9290|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`9The `bDark Lock `9Amazing `2Lock `9With Cool `^Effects`9! `9But not `^Everyone `9Can get it, probably the `^Rarest Lock`9!|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`oTo craft this item you need `9100 `aBedrock's`o!|left|8|\nadd_spacer|small|\nadd_button|craftdarklock|`9Craft Item!|0|0|\nadd_spacer|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|"));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						if (btn == "fenixwings")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|\nadd_label_with_icon|big|`6Purchase `@Fenix Wings`6!``|left|5136|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`9Damn! `^Those wings are made from pure `4Fire `^Gives `@Red Skin Colour `^And `@Movement Effects`9!|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`oTo purchase this item you need `490 `@Store Token's`o!|left|1458|\nadd_spacer|small|\nadd_button|craftfenixwings|`9Purchase!|0|0|\nadd_spacer|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|"));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						if (btn == "crystalwinterwings")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|\nadd_label_with_icon|big|`6Purchase `!Crystal `1Winter Wings`6!``|left|9478|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`9Freeze! `^Pretty well `9Designed `^Wings, gives you `9Double Jump `^And `@Movement Effects`9!|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`oTo purchase this item you need `4120 `1Winter Token's`o!|left|1458|\nadd_spacer|small|\nadd_button|craftwinterwings|`9Purchase!|0|0|\nadd_spacer|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|"));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						if (btn == "mysterybox")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`6Purchase `8Mystery Box`6!``|left|9474|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`9This Block Will give you random number of `^Gems `9Starting from `21k `9And up to `2300k`9 Or maybe even something more `1Rare`9?|\nadd_spacer|small|\nadd_button|buymysterybox|`7Buy `8Mystery Box `7[`430`2 WLS`7]!|0|0|\nadd_spacer|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|");
						}
						if (btn == "antigravity")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`6Purchase `2Anti Gravity`6!``|left|4992|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`9This Block Will allow you to `^Unlimited Jump `9In your own world`9!|\nadd_spacer|small|\nadd_button|buyantigravity|`7Buy `2Anti Gravity `7[`430`2 WLS`7]!|0|0|\nadd_spacer|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|");
						}
						if (btn == "bushwings")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`6Purchase `2Bush Wings`6!``|left|9466|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`9Earth! `^Those wings are pure made by the `9Earth `^Gives `8TRIPLE `1XP `@BUFF`^, `2Green Skin Colour `^And `2Movement Effects`9!|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`oTo purchase this item you need `430 `@Store Token's`o, `2Emerald Lock`o, `@300k `2Earth `9Fragment's`o!|left|1458|\nadd_spacer|small|\nadd_button|craftbushwings|`9Purchase!|0|0|\nadd_spacer|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|");
						}
						if (btn == "banwand")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`6Purchase `4Ban Wand`6!``|left|732|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`@Wand! `^This `9Wand `^Allows you to `4Ban `^Anyone from the `9Game`9!|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`oTo purchase this item you need `@200 `1Diamond Locks`o!|left|1458|\nadd_spacer|small|\nadd_button|buybanwand|`9Purchase!|0|0|\nadd_spacer|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|");
						}
						if (btn == "cursewand")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`6Purchase `bCurse Wand`6!``|left|278|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`@Wand! `^This `9Wand `^Allows you to `bCurse `^Anyone`9!|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`oTo purchase this item you need `@120 `1Diamond Locks`o!|left|1458|\nadd_spacer|small|\nadd_button|buycursewand|`9Purchase!|0|0|\nadd_spacer|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|");
						}
						if (btn == "firewand")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`6Purchase `@Fire Wand`6!``|left|276|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`@Wand! `^This `9Wand `^Allows you to `@Kill `^Anyone in `9World`9!|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`oTo purchase this item you need `@15 `1Diamond Locks`o!|left|1458|\nadd_spacer|small|\nadd_button|buyfirewand|`9Purchase!|0|0|\nadd_spacer|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|");
						}
						if (btn == "freezewand")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`6Purchase `!Freeze Wand`6!``|left|274|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`@Wand! `^This `9Wand `^Allows you to `!Freeze `^Anyone in the `9World`9!|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`oTo purchase this item you need `@3 `1Diamond Locks`o!|left|1458|\nadd_spacer|small|\nadd_button|buyfreezewand|`9Purchase!|0|0|\nadd_spacer|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|");
						}
						if (btn == "uranusblast")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`6Purchase `5Uranus Blast`6!``|left|8428|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`9Adventures! `^Theres a lot of to `9Explore `^Behind this item, `9Purchase `^One to create an `9Amazing `5Uranus `^World`9!|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`oTo purchase this item you need `410 `@Store Token's`o!|left|1458|\nadd_spacer|small|\nadd_button|crafturanusblast|`9Purchase!|0|0|\nadd_spacer|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|");
						}
						if (btn == "rgbwings")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`6Purchase `eRGB Wings`6!``|left|9434|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`9Rainbow! `^Nothing much to expect from this item, but it is `9Rainbow `^And has `@Movement Effects`9!|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`oTo purchase this item you need `49 `@Store Token's`o!|left|1458|\nadd_spacer|small|\nadd_button|craftrgbwings|`9Purchase!|0|0|\nadd_spacer|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|");
						}
						if (btn == "burnsword")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`6Purchase `9Crystal Infused Sword`6!``|left|9716|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`9Golden! `^This Sword Is pretty `9Normal`^, but there is one `9Big Difference `^It can break `@2x2`9!|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`oTo purchase this item you need `4120 `@DLS's`o!|left|1796|\nadd_spacer|small|\nadd_button|bsword|`9Purchase!|0|0|\nadd_spacer|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|");
						}
						if (btn == "xpnecklace")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|\nadd_label_with_icon|big|`6Purchase `2XP Necklace`6!``|left|9428|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`9Buffs! `^This awesome `2Emerald `^Covered `9Necklace `^Will give you `2Double XP `^For all `9Blocks`9!|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`oTo purchase this item you need `430 `@Store Token's`o!|left|1458|\nadd_spacer|small|\nadd_button|craftxpnecklace|`9Purchase!|0|0|\nadd_spacer|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|"));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						if (btn == "storetokensss")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|\nadd_label_with_icon|big|`6Purchase `@Store Tokens`6!``|left|1486|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`9Tokens! `^Those `9Tokens `^Are second currency just like `9Gems `^And are obtainable by spending `625 `^Real `2WLS `^But also can be `9Obtained `^For being `9online `^Every `^3 `9Hours!|\nadd_spacer|small|\nadd_spacer|small|\nadd_button|cch101001|`9Close|0|0|\nadd_spacer|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|"));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						if (btn == "goldentoken")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`6Purchase `9Golden `@Store Tokens`6!``|left|9500|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`9Tokens! `^Those `9Tokens `^Are obtainable by `9Buying `^Them For `@100 `2Regular `@Store Tokens `^And can be used as second currency just like `9Gems`^!|\nadd_spacer|small|\nadd_button|purchasegoldenstoretoken|`7Buy `9GStoken `7[`4100`@ STokens`7]!|0|0|\nadd_spacer|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|");
						}
						if (btn == "undergroundtrader")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|small|`wThe Underground Trader|left|9288|\nadd_button_with_icon|buybedrock||staticBlueFrame|8|\nadd_button_with_icon|buydarklock||staticBlueFrame|9290|\nadd_button_with_icon|buydarkangel||staticBlueFrame|9306|\nadd_quick_exit|");
						}
						if (btn == "buybedrock")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							if (static_cast<PlayerInfo*>(peer->data)->haveGrowId == true)
							{
								UpdateLocalPlayerFragments(peer);
								int darkfragment = static_cast<PlayerInfo*>(peer->data)->fDark;
								Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`6Buy `#Bedrock`6!``|left|8|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`oYou have: `1" + to_string(darkfragment) + " `bDark `9Fragment's`0!|left|8|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`9Very Rare And Strong Block! Not everyone can break it, So think twice before placing! Only Obtainable from `^The Underground Trader`9!|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`oTo buy this block you need `9300 `bDark `9Fragment's`o!|left|8|\nadd_spacer|small|\nadd_button|buybedrocknow|`9Buy Block!|0|0|\nadd_spacer|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|");
							}
						}
						if (btn == "buydarklock")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|\nadd_label_with_icon|big|`6Buy `bDark Lock`6!``|left|9290|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`9The `bDark Lock `9Amazing `2Lock `9With Cool `^Effects`9! `9But not `^Everyone `9Can get it, probably the `^Rarest Lock`9!|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`oTo craft this item you need `9100 `aBedrock's`o!|left|8|\nadd_spacer|small|\nadd_button|craftdarklock|`9Craft Item!|0|0|\nadd_spacer|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|"));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						if (btn == "buydarkangel")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							UpdateLocalPlayerFragments(peer);
							int darkfragment = static_cast<PlayerInfo*>(peer->data)->fDark;
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|\nadd_label_with_icon|big|`6Buy `bDark Angel Wings`6!``|left|9306|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`oYou have: `1" + to_string(darkfragment) + " `bDark `9Fragment's`0!|left|8|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`9Pure `bDark `9Designed Wings! Nothing `^Special`9, Same as a `wAngel Wings`9, But Take A Look At That `^Awesome Design`9! Only Obtainable from `^The Underground Trader`9!|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`oTo buy this item you need `975000 `bDark `9Fragment's`o!|left|8|\nadd_spacer|small|\nadd_button|buydarkangelnow|`9Buy Item!|0|0|\nadd_spacer|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|"));
							ENetPacket* packet = enet_packet_create(p.data,
								p.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						if (btn == "buybedrocknow")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							UpdateLocalPlayerFragments(peer);
							int darkfragment = static_cast<PlayerInfo*>(peer->data)->fDark;
							if (darkfragment >= 300)
							{
								bool success = true;
								SaveShopsItemMoreTimes(8, 1, peer, success); // aposition, itemid, quantity, peer, success
								if (!success)continue;
								RemovePlayerFragmentDark(peer, 300);
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You have bought `#Bedrock`9!"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);
								delete p2.data;
							}
							else
							{
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`4Sorry`9, But you don't have enough `bDark `9Fragments!"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);
								delete p2.data;
							}
						}
						if (btn == "buydarkangelnow")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							UpdateLocalPlayerFragments(peer);
							int darkfragment = static_cast<PlayerInfo*>(peer->data)->fDark;
							if (darkfragment >= 75000)
							{
								bool success = true;
								SaveShopsItemMoreTimes(9306, 1, peer, success); // aposition, itemid, quantity, peer, success
								if (!success)continue;
								RemovePlayerFragmentDark(peer, 75000);
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9You have bought `bDark Angel Wings`9!"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);
								delete p2.data;
							}
							else
							{
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`4Sorry`9, But you don't have enough `bDark `9Fragments!"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);
								delete p2.data;
							}
						}
						if (isPasswordDialog)
						{
							if (static_cast<PlayerInfo*>(peer->data)->tankIDPass != oldpass)
							{
								GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "add_label_with_icon|big|`wChange Password|left|1280|\nadd_spacer|small|\nadd_textbox|`4Oops! `oThe Current Password you have entered is incorrect!``|\nadd_spacer|small|\nadd_text_input|oldpass|`$Current Password``||18|\nadd_text_input|newpass|`$New Password``||18|\nadd_text_input|verifypass|`$Verify Password``||18|\nend_dialog|pssdia|`wCancel``|`wConfirm!``|"));
								ENetPacket* packet = enet_packet_create(ps.data,
									ps.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete ps.data;
							}
							else if (password2 != password2verify)
							{
								GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "add_label_with_icon|big|`wChange Password|left|1280|\nadd_spacer|small|\nadd_textbox|`4Oops! `oThe Password Verify failed.``|\nadd_spacer|small|\nadd_text_input|oldpass|`$Current Password``||18|\nadd_text_input|newpass|`$New Password``||18|\nadd_text_input|verifypass|`$Verify Password``||18|\nend_dialog|pssdia|`wCancel``|`wConfirm!``|"));
								ENetPacket* packet = enet_packet_create(ps.data,
									ps.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete ps.data;
							}
							else
							{
								static_cast<PlayerInfo*>(peer->data)->tankIDPass = password2;

								ifstream fg("players/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".json");
								json j;
								fg >> j;
								fg.close();

								j["password"] = static_cast<PlayerInfo*>(peer->data)->tankIDPass;

								ofstream fs("players/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".json");
								fs << j;
								fs.close();
								GamePacket p3 = packetEnd(appendString(appendString(appendInt(appendString(createPacket(), "SetHasGrowID"), 1), static_cast<PlayerInfo*>(peer->data)->rawName), password2));
								ENetPacket* packet3 = enet_packet_create(p3.data, p3.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet3);
								Player::OnConsoleMessage(peer, "Your password have been changed! (" + password2 + ")");
							}
						}
#ifdef REGISTRATION
						if (isRegisterDialog)
						{

							if (password != passwordver)
							{
								Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "Passwords dont match!", 0, true);
								break;
							}
							auto regState = PlayerDB::playerRegister(peer, username, password, email, code);
							if (regState == 1)
							{
								Player::OnConsoleMessage(peer, "`@Your `^Security Code `@is `4" + code + "`@. Your `^Password `@is `4" + password + "`@. `^Please make screenshot and don't forget them!!!");
								auto arda = 0;
								GamePacket p8 = packetEnd(appendString(appendString(appendInt(appendString(createPacket(), "SetHasGrowID"), 1), username), password));
								ENetPacket* packet8 = enet_packet_create(p8.data, p8.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet8);
								delete p8.data;
								static_cast<PlayerInfo*>(peer->data)->displayName = username;
								static_cast<PlayerInfo*>(peer->data)->tankIDName = username;
								static_cast<PlayerInfo*>(peer->data)->tankIDPass = password;
								static_cast<PlayerInfo*>(peer->data)->rawName = PlayerDB::getProperName(static_cast<PlayerInfo*>(peer->data)->tankIDName);
								static_cast<PlayerInfo*>(peer->data)->msgName = PlayerDB::getProperName(static_cast<PlayerInfo*>(peer->data)->tankIDName);
								static_cast<PlayerInfo*>(peer->data)->haveGrowId = true;
								static_cast<PlayerInfo*>(peer->data)->HasLogged = true;
								static_cast<PlayerInfo*>(peer->data)->effect = 8421376;
								ofstream myfile;
								myfile.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
								myfile << arda;
								myfile.close();
								ofstream WorldSys("misc/effect/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
								WorldSys << 8421376;
								WorldSys.close();
								GamePacket p7 = packetEnd(appendString(appendString(createPacket(), "OnNameChanged"), username));
								memcpy(p7.data + 8, &(static_cast<PlayerInfo*>(peer->data)->netID), 4);
								ENetPacket* packet7 = enet_packet_create(p7.data, p7.len, ENET_PACKET_FLAG_RELIABLE);
								ENetPeer* currentPeer;
								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
									if (isHere(peer, currentPeer))
									{
										enet_peer_send(currentPeer, 0, packet7);
									}
								}
								delete p7.data;
								LoadPlayerData(peer);
								try
								{
									std::ofstream oo("inventory/" + username + ".json");
									if (!oo.is_open()) return 1;
									json items;
									auto jjall = json::array();
									json jj;
									jj["aposition"] = 1;
									jj["itemid"] = 18;
									jj["quantity"] = 1;
									jjall.push_back(jj);
									jj["aposition"] = 2;
									jj["itemid"] = 32;
									jj["quantity"] = 1;
									jjall.push_back(jj);
									for (auto i = 2; i < 200; i++)
									{
										jj["aposition"] = i + 1;
										jj["itemid"] = 0;
										jj["quantity"] = 0;
										jjall.push_back(jj);
									}
									items["items"] = jjall;
									oo << items << std::endl;
									oo.close();
								}
								catch (std::exception& exception)
								{
									SendConsole("playerLogin Critical error", "ERROR");
									enet_peer_disconnect_now(peer, 0);
								}
								catch (std::runtime_error& error)
								{
									SendConsole("playerLogin Critical error", "ERROR");
									enet_peer_disconnect_now(peer, 0);
								}
								catch (...)
								{
									SendConsole("playerLogin Critical error", "ERROR");
									enet_peer_disconnect_now(peer, 0);
								}
								DailyRewardCheck(peer);
								//Player::OnSetBux(peer, 15000, 1);
								auto iscontains = false;
								SearchInventoryItem(peer, 10034, 1, iscontains);
								if (!iscontains)
								{
									auto success = true;
									SaveItemMoreTimes(10034, 1, peer, success);
									//Player::OnAddNotification(peer, "`^You Received the `cMerge Book", "audio/hub_open.wav", "interface/science_button.rttex");
								}
								auto iscontains333 = false;
								SearchInventoryItem(peer, 6336, 1, iscontains333);
								if (!iscontains333)
								{
									auto success = true;
									SaveItemMoreTimes(6336, 1, peer, success);
									//Player::OnAddNotification(peer, "`^You Received the `9Growpedia", "audio/hub_open.wav", "interface/science_button.rttex");
								}
							
							}
							else if (regState == -1)
							{
								Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "This account already exists!", 0, true);
							}
							else if (regState == -2)
							{
								Player::OnConsoleMessage(peer, "`@Account creation failed, because the name is too short!``");
							}
							else if (regState == -3)
							{
								Player::OnConsoleMessage(peer, "`@Passwords mismatch!``");
							}
							else if (regState == -4)
							{
								Player::OnConsoleMessage(peer, "`@Account creation failed, because email address is invalid!``");
							}
							else if (regState == -5)
							{
								Player::OnConsoleMessage(peer, "`@Account creation failed, because Discord ID is invalid!``");
							}
							else if (regState == -6)
							{
								Player::OnConsoleMessage(peer, "`@Account creation failed due to account name that is being used by system!``");
							}
							else if (regState == -7)
							{
								Player::OnConsoleMessage(peer, "`@Oops! `9Looks like players data have been resetted, `wmake sure to use your `bPIN `wthat you used when creating your account. `2For help, message `w! janipalen#1337 on Discord!`w``");
							}
							else if (regState == -8)
							{
								Player::OnConsoleMessage(peer, "`@Oops! `9Looks like `wPIN `9is not in a range of 1000-9999. Choose a `wPIN `9from 1000-9999!``");
							}
							else if (regState == -9)
							{
								Player::OnConsoleMessage(peer, "`@Oops! `9Looks like `wPIN `9contains text, only numbers. Choose a `wPIN `9from 1000-9999!``");
							}
							else if (regState == -10)
							{
								Player::OnConsoleMessage(peer, "`@Player name contains illegal characters.``");
							}
							else if (regState == -11)
							{
								Player::OnConsoleMessage(peer, "`@Your connection have been cancelled!``");
							}
							else if (regState == -14)
							{
								Player::OnConsoleMessage(peer, "`@Account creation failed, because you have `4too much `@accounts created.``");
							}
							else if (regState == -15)
							{
								Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "Invalid email address!", 0, true);
							}
							else if (regState == -16)
							{
								Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "Failed to connect to databases try again later", 0, true);
							}
							else if (regState == -17)
							{
								Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "This account is already created and it's not yours", 0, true);
							}
							else if (regState == -18)
							{
								Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "This account is suspended", 0, true);
							}
							else if (regState == -19)
							{
								Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "Invalid Code", 0, true);
							}
#endif
						}
					}
					if (cch.find("action|dialog_return\ndialog_name|trade_confirm\nbuttonClicked|back") == 0) {
						ENetPeer* currentPeer;
						for (currentPeer = server->peers;
							currentPeer < &server->peers[server->peerCount];
							++currentPeer)
						{
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
								continue;
							if (isHere(peer, currentPeer))
							{

								if (((PlayerInfo*)(currentPeer->data))->netID == ((PlayerInfo*)(peer->data))->lastTradeNetID)
								{
									if (((PlayerInfo*)(currentPeer->data))->lastTradeNetID != ((PlayerInfo*)(peer->data))->netID)
									{
										Player::OnTextOverlay(peer, ((PlayerInfo*)(currentPeer->data))->displayName + " `whas canceled the trade");
									}
									if (((PlayerInfo*)(currentPeer->data))->isTradingWithUser == 1)
									{
										Player::OnConsoleMessage(peer, "`6[```4Trade canceled by`w " + ((PlayerInfo*)(peer->data))->displayName + "``!```6]``");
										//SendTalkSelf(currentPeer, "`6[```4Trade canceled by`w " + ((PlayerInfo*)(peer->data))->displayName + "``!```6]``");
										((PlayerInfo*)(peer->data))->currentTradeItems = "";
										((PlayerInfo*)(currentPeer->data))->currentTradeItems = "";
										((PlayerInfo*)(peer->data))->lastTradeAcceptCount = 0;
										((PlayerInfo*)(currentPeer->data))->lastTradeAcceptCount = 0;
										((PlayerInfo*)(peer->data))->lastTradeNetID = 0;
										((PlayerInfo*)(currentPeer->data))->lastTradeNetID = 0;
										((PlayerInfo*)(peer->data))->isTradingWithUser = 0;
										((PlayerInfo*)(currentPeer->data))->isTradingWithUser = 0;
										((PlayerInfo*)(peer->data))->isDoTrade = 0;
										((PlayerInfo*)(currentPeer->data))->isDoTrade = 0;
										((PlayerInfo*)(peer->data))->lastTD1 = 0;
										((PlayerInfo*)(peer->data))->lastTD2 = 0;
										((PlayerInfo*)(peer->data))->lastTD3 = 0;
										((PlayerInfo*)(peer->data))->lastTD4 = 0;
										((PlayerInfo*)(peer->data))->lastCT1 = 0;
										((PlayerInfo*)(peer->data))->lastCT2 = 0;
										((PlayerInfo*)(peer->data))->lastCT3 = 0;
										((PlayerInfo*)(peer->data))->lastCT4 = 0;
										((PlayerInfo*)(currentPeer->data))->lastTD1 = 0;
										((PlayerInfo*)(currentPeer->data))->lastTD2 = 0;
										((PlayerInfo*)(currentPeer->data))->lastTD3 = 0;
										((PlayerInfo*)(currentPeer->data))->lastTD4 = 0;
										((PlayerInfo*)(currentPeer->data))->lastCT1 = 0;
										((PlayerInfo*)(currentPeer->data))->lastCT2 = 0;
										((PlayerInfo*)(currentPeer->data))->lastCT3 = 0;
										((PlayerInfo*)(currentPeer->data))->lastCT4 = 0;
									}
									else
									{
										Player::OnTextOverlay(peer, "The other person left the trade!");
										((PlayerInfo*)(peer->data))->currentTradeItems = "";
										((PlayerInfo*)(peer->data))->lastTradeAcceptCount = 0;
										((PlayerInfo*)(peer->data))->lastTradeNetID = 0;
										((PlayerInfo*)(peer->data))->isTradingWithUser = 0;
										((PlayerInfo*)(peer->data))->isDoTrade = 0;
										((PlayerInfo*)(peer->data))->lastTD1 = 0;
										((PlayerInfo*)(peer->data))->lastTD2 = 0;
										((PlayerInfo*)(peer->data))->lastTD3 = 0;
										((PlayerInfo*)(peer->data))->lastTD4 = 0;
										((PlayerInfo*)(peer->data))->lastCT1 = 0;
										((PlayerInfo*)(peer->data))->lastCT2 = 0;
										((PlayerInfo*)(peer->data))->lastCT3 = 0;
										((PlayerInfo*)(peer->data))->lastCT4 = 0;
									}
								}

							}

						}
					}
					if (cch.find("action|dialog_return\ndialog_name|trade_confirm\nbuttonClicked|accept") == 0) {
						ENetPeer* currentPeer;
						for (currentPeer = server->peers;
							currentPeer < &server->peers[server->peerCount];
							++currentPeer)
						{
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
								continue;
							if (isHere(peer, currentPeer))
							{

								if (((PlayerInfo*)(currentPeer->data))->netID == ((PlayerInfo*)(peer->data))->lastTradeNetID)
								{
									if (((PlayerInfo*)(currentPeer->data))->isTradingWithUser == 1)
									{
										((PlayerInfo*)(peer->data))->isDoTrade++;
										int accept = ((PlayerInfo*)(peer->data))->isDoTrade + ((PlayerInfo*)(currentPeer->data))->isDoTrade;
										bool success = true;
										if (accept == 2)
										{
											int netID = ((PlayerInfo*)(peer->data))->netID;
											//PlayAudioWorld(peer, "audio/keypad_hit.wav");
											string peertraded = "Nothing!";
											string cpeertraded = "Nothing!";
											if (((PlayerInfo*)(peer->data))->lastTD1 == 0)
											{
												RemoveItemFromInv(peer, ((PlayerInfo*)(currentPeer->data))->lastTD1, ((PlayerInfo*)(currentPeer->data))->lastCT2, true);
												SaveShopsItemMoreTimess(((PlayerInfo*)(peer->data))->lastTD1, ((PlayerInfo*)(peer->data))->lastCT2, peer, success);
											}
											if (((PlayerInfo*)(peer->data))->lastTD2 == 0)
											{
												RemoveItemFromInv(peer, ((PlayerInfo*)(currentPeer->data))->lastTD2, ((PlayerInfo*)(currentPeer->data))->lastCT2, true);
												SaveShopsItemMoreTimess(((PlayerInfo*)(peer->data))->lastTD2, ((PlayerInfo*)(peer->data))->lastCT2, peer, success);
											}
											if (((PlayerInfo*)(peer->data))->lastTD3 == 0)
											{
												RemoveItemFromInv(peer, ((PlayerInfo*)(currentPeer->data))->lastTD2, ((PlayerInfo*)(currentPeer->data))->lastCT3, true);
												SaveShopsItemMoreTimess(((PlayerInfo*)(peer->data))->lastTD2, ((PlayerInfo*)(peer->data))->lastCT3, peer, success);
											}
											if (((PlayerInfo*)(peer->data))->lastTD4 == 0)
											{
												RemoveItemFromInv(peer, ((PlayerInfo*)(currentPeer->data))->lastTD2, ((PlayerInfo*)(currentPeer->data))->lastCT4, true);
												SaveShopsItemMoreTimess(((PlayerInfo*)(peer->data))->lastTD2, ((PlayerInfo*)(peer->data))->lastCT4, peer, success);
											}
											if (((PlayerInfo*)(peer->data))->lastTD1 != 0)
											{

												peertraded = to_string(((PlayerInfo*)(peer->data))->lastCT1) + " " + GetItemDef(((PlayerInfo*)(peer->data))->lastTD1).name;
												RemoveItemFromInv(peer, ((PlayerInfo*)(currentPeer->data))->lastTD1, ((PlayerInfo*)(currentPeer->data))->lastCT1, true);
												SendTradeEffect(peer, ((PlayerInfo*)(peer->data))->lastTD1, netID, ((PlayerInfo*)(currentPeer->data))->netID, 180);
												SendTradeEffect(currentPeer, ((PlayerInfo*)(peer->data))->lastTD1, netID, ((PlayerInfo*)(currentPeer->data))->netID, 180);
												SaveShopsItemMoreTimess(((PlayerInfo*)(peer->data))->lastTD1, ((PlayerInfo*)(peer->data))->lastCT1, peer, success);
											}
											if (((PlayerInfo*)(peer->data))->lastTD2 != 0)
											{
												peertraded += ", " + to_string(((PlayerInfo*)(peer->data))->lastCT2) + " " + GetItemDef(((PlayerInfo*)(peer->data))->lastTD2).name;
												RemoveItemFromInv(peer, ((PlayerInfo*)(currentPeer->data))->lastTD2, ((PlayerInfo*)(currentPeer->data))->lastCT2, true);
												SendTradeEffect(peer, ((PlayerInfo*)(peer->data))->lastTD2, netID, ((PlayerInfo*)(currentPeer->data))->netID, 180);
												SendTradeEffect(currentPeer, ((PlayerInfo*)(peer->data))->lastTD2, netID, ((PlayerInfo*)(currentPeer->data))->netID, 180);

												SaveShopsItemMoreTimess(((PlayerInfo*)(peer->data))->lastTD2, ((PlayerInfo*)(peer->data))->lastCT2, peer, success);
											}
											if (((PlayerInfo*)(peer->data))->lastTD3 != 0)
											{
												peertraded += ", " + to_string(((PlayerInfo*)(peer->data))->lastCT3) + " " + GetItemDef(((PlayerInfo*)(peer->data))->lastTD3).name;
												RemoveItemFromInv(peer, ((PlayerInfo*)(currentPeer->data))->lastTD3, ((PlayerInfo*)(currentPeer->data))->lastCT3, true);
												SendTradeEffect(peer, ((PlayerInfo*)(peer->data))->lastTD3, netID, ((PlayerInfo*)(currentPeer->data))->netID, 180);
												SendTradeEffect(currentPeer, ((PlayerInfo*)(peer->data))->lastTD3, netID, ((PlayerInfo*)(currentPeer->data))->netID, 180);

												SaveShopsItemMoreTimess(((PlayerInfo*)(peer->data))->lastTD3, ((PlayerInfo*)(peer->data))->lastCT3, peer, success);
											}
											if (((PlayerInfo*)(peer->data))->lastTD4 != 0)
											{
												peertraded += ", " + to_string(((PlayerInfo*)(peer->data))->lastCT4) + " " + GetItemDef(((PlayerInfo*)(peer->data))->lastTD4).name;
												RemoveItemFromInv(peer, ((PlayerInfo*)(currentPeer->data))->lastTD4, ((PlayerInfo*)(currentPeer->data))->lastCT4, true);
												SendTradeEffect(peer, ((PlayerInfo*)(peer->data))->lastTD4, netID, ((PlayerInfo*)(currentPeer->data))->netID, 180);
												SendTradeEffect(currentPeer, ((PlayerInfo*)(peer->data))->lastTD4, netID, ((PlayerInfo*)(currentPeer->data))->netID, 180);

												SaveShopsItemMoreTimess(((PlayerInfo*)(peer->data))->lastTD4, ((PlayerInfo*)(peer->data))->lastCT4, peer, success);
											}
											//EndPeer
											//CurrentPeer
											if (((PlayerInfo*)(currentPeer->data))->lastTD1 == 0)
											{
												RemoveItemFromInv(currentPeer, ((PlayerInfo*)(peer->data))->lastTD1, ((PlayerInfo*)(peer->data))->lastCT1, true);
												SaveShopsItemMoreTimess(((PlayerInfo*)(currentPeer->data))->lastTD1, ((PlayerInfo*)(currentPeer->data))->lastCT1, currentPeer, success);
											}
											if (((PlayerInfo*)(currentPeer->data))->lastTD2 == 0)
											{
												RemoveItemFromInv(currentPeer, ((PlayerInfo*)(peer->data))->lastTD2, ((PlayerInfo*)(peer->data))->lastCT2, true);
												SaveShopsItemMoreTimess(((PlayerInfo*)(currentPeer->data))->lastTD2, ((PlayerInfo*)(currentPeer->data))->lastCT2, currentPeer, success);
											}
											if (((PlayerInfo*)(currentPeer->data))->lastTD3 == 0)
											{
												RemoveItemFromInv(currentPeer, ((PlayerInfo*)(peer->data))->lastTD3, ((PlayerInfo*)(peer->data))->lastCT3, true);
												SaveShopsItemMoreTimess(((PlayerInfo*)(currentPeer->data))->lastTD3, ((PlayerInfo*)(currentPeer->data))->lastCT3, currentPeer, success);
											}
											if (((PlayerInfo*)(currentPeer->data))->lastTD4 == 0)
											{
												RemoveItemFromInv(currentPeer, ((PlayerInfo*)(peer->data))->lastTD4, ((PlayerInfo*)(peer->data))->lastCT4, true);
												SaveShopsItemMoreTimess(((PlayerInfo*)(currentPeer->data))->lastTD4, ((PlayerInfo*)(currentPeer->data))->lastCT4, currentPeer, success);
											}
											if (((PlayerInfo*)(currentPeer->data))->lastTD1 != 0)
											{
												cpeertraded = to_string(((PlayerInfo*)(currentPeer->data))->lastCT1) + " " + GetItemDef(((PlayerInfo*)(currentPeer->data))->lastTD1).name;
												RemoveItemFromInv(currentPeer, ((PlayerInfo*)(peer->data))->lastTD1, ((PlayerInfo*)(peer->data))->lastCT1, true);

												SendTradeEffect(peer, ((PlayerInfo*)(currentPeer->data))->lastTD1, ((PlayerInfo*)(currentPeer->data))->netID, netID, 180);
												SendTradeEffect(currentPeer, ((PlayerInfo*)(currentPeer->data))->lastTD1, ((PlayerInfo*)(currentPeer->data))->netID, netID, 180);

												SaveShopsItemMoreTimess(((PlayerInfo*)(currentPeer->data))->lastTD1, ((PlayerInfo*)(currentPeer->data))->lastCT1, currentPeer, success);
											}
											if (((PlayerInfo*)(currentPeer->data))->lastTD2 != 0)
											{
												cpeertraded += ", " + to_string(((PlayerInfo*)(currentPeer->data))->lastCT2) + " " + GetItemDef(((PlayerInfo*)(currentPeer->data))->lastTD2).name;
												RemoveItemFromInv(currentPeer, ((PlayerInfo*)(peer->data))->lastTD2, ((PlayerInfo*)(peer->data))->lastCT2, true);
												SendTradeEffect(peer, ((PlayerInfo*)(currentPeer->data))->lastTD2, ((PlayerInfo*)(currentPeer->data))->netID, netID, 180);
												SendTradeEffect(currentPeer, ((PlayerInfo*)(currentPeer->data))->lastTD2, ((PlayerInfo*)(currentPeer->data))->netID, netID, 180);

												SaveShopsItemMoreTimess(((PlayerInfo*)(currentPeer->data))->lastTD2, ((PlayerInfo*)(currentPeer->data))->lastCT2, currentPeer, success);
											}
											if (((PlayerInfo*)(currentPeer->data))->lastTD3 != 0)
											{
												cpeertraded += ", " + to_string(((PlayerInfo*)(currentPeer->data))->lastCT3) + " " + GetItemDef(((PlayerInfo*)(currentPeer->data))->lastTD3).name;
												RemoveItemFromInv(currentPeer, ((PlayerInfo*)(peer->data))->lastTD3, ((PlayerInfo*)(peer->data))->lastCT3, true);
												SendTradeEffect(peer, ((PlayerInfo*)(currentPeer->data))->lastTD3, ((PlayerInfo*)(currentPeer->data))->netID, netID, 180);
												SendTradeEffect(currentPeer, ((PlayerInfo*)(currentPeer->data))->lastTD3, ((PlayerInfo*)(currentPeer->data))->netID, netID, 180);


												SaveShopsItemMoreTimess(((PlayerInfo*)(currentPeer->data))->lastTD3, ((PlayerInfo*)(currentPeer->data))->lastCT3, currentPeer, success);
											}
											if (((PlayerInfo*)(currentPeer->data))->lastTD4 != 0)
											{
												cpeertraded += ", " + to_string(((PlayerInfo*)(currentPeer->data))->lastCT4) + " " + GetItemDef(((PlayerInfo*)(currentPeer->data))->lastTD4).name;
												RemoveItemFromInv(currentPeer, ((PlayerInfo*)(peer->data))->lastTD4, ((PlayerInfo*)(peer->data))->lastCT4, true);
												SendTradeEffect(peer, ((PlayerInfo*)(currentPeer->data))->lastTD4, ((PlayerInfo*)(currentPeer->data))->netID, netID, 180);
												SendTradeEffect(currentPeer, ((PlayerInfo*)(currentPeer->data))->lastTD4, ((PlayerInfo*)(currentPeer->data))->netID, netID, 180);

												SaveShopsItemMoreTimess(((PlayerInfo*)(currentPeer->data))->lastTD4, ((PlayerInfo*)(currentPeer->data))->lastCT4, currentPeer, success);
											}

											if (((PlayerInfo*)(peer->data))->cloth_ances == ((PlayerInfo*)(peer->data))->lastTD1)
											{
												short int currentItemCount = 0;
												for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++)
												{
													if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(peer->data))->lastTD1)
													{
														currentItemCount = (unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
														if (currentItemCount < 0)
														{
															currentItemCount = FixCountItem((unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount);
														}
													}
												}
												if (currentItemCount - ((PlayerInfo*)(peer->data))->lastCT1 == 0)
												{
													((PlayerInfo*)(peer->data))->cloth_ances = 0;
													sendClothes(peer);
												}
											}
											else if (((PlayerInfo*)(peer->data))->cloth_ances == ((PlayerInfo*)(peer->data))->lastTD2)
											{
												short int currentItemCount = 0;
												for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++)
												{
													if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(peer->data))->lastTD2)
													{
														currentItemCount = (unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
														if (currentItemCount < 0)
														{
															currentItemCount = FixCountItem((unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount);
														}
													}
												}
												if (currentItemCount - ((PlayerInfo*)(peer->data))->lastCT2 == 0)
												{
													((PlayerInfo*)(peer->data))->cloth_ances = 0;
													sendClothes(peer);
												}
											}
											else if (((PlayerInfo*)(peer->data))->cloth_ances == ((PlayerInfo*)(peer->data))->lastTD3)
											{
												short int currentItemCount = 0;
												for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++)
												{
													if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(peer->data))->lastTD3)
													{
														currentItemCount = (unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
														if (currentItemCount < 0)
														{
															currentItemCount = FixCountItem((unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount);
														}
													}
												}
												if (currentItemCount - ((PlayerInfo*)(peer->data))->lastCT3 == 0)
												{
													((PlayerInfo*)(peer->data))->cloth_ances = 0;
													sendClothes(peer);
												}
											}
											else if (((PlayerInfo*)(peer->data))->cloth_ances == ((PlayerInfo*)(peer->data))->lastTD4)
											{
												short int currentItemCount = 0;
												for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++)
												{
													if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(peer->data))->lastTD4)
													{
														currentItemCount = (unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
														if (currentItemCount < 0)
														{
															currentItemCount = FixCountItem((unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount);
														}
													}
												}
												if (currentItemCount - ((PlayerInfo*)(peer->data))->lastCT4 == 0)
												{
													((PlayerInfo*)(peer->data))->cloth_ances = 0;
													sendClothes(peer);
												}
											}

											if (((PlayerInfo*)(peer->data))->cloth_back == ((PlayerInfo*)(peer->data))->lastTD1)
											{
												short int currentItemCount = 0;
												for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++)
												{
													if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(peer->data))->lastTD1)
													{
														currentItemCount = (unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
														if (currentItemCount < 0)
														{
															currentItemCount = FixCountItem((unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount);
														}
													}
												}
												Player::OnConsoleMessage(peer, "OKE1");
												Player::OnConsoleMessage(peer, "CurrentItem: " + to_string(currentItemCount) + " LASTCT1: " + to_string(((PlayerInfo*)(peer->data))->lastCT1));
												if (currentItemCount - ((PlayerInfo*)(peer->data))->lastCT1 == 0)
												{
													Player::OnConsoleMessage(peer, "OK2");
													((PlayerInfo*)(peer->data))->cloth_back = 0;
													sendClothes(peer);
												}
											}
											else if (((PlayerInfo*)(peer->data))->cloth_back == ((PlayerInfo*)(peer->data))->lastTD2)
											{
												short int currentItemCount = 0;
												for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++)
												{
													if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(peer->data))->lastTD2)
													{
														currentItemCount = (unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
														if (currentItemCount < 0)
														{
															currentItemCount = FixCountItem((unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount);
														}
													}
												}
												if (currentItemCount - ((PlayerInfo*)(peer->data))->lastCT2 == 0)
												{
													((PlayerInfo*)(peer->data))->cloth_back = 0;
													sendClothes(peer);
												}
											}
											else if (((PlayerInfo*)(peer->data))->cloth_back == ((PlayerInfo*)(peer->data))->lastTD3)
											{
												short int currentItemCount = 0;
												for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++)
												{
													if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(peer->data))->lastTD3)
													{
														currentItemCount = (unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
														if (currentItemCount < 0)
														{
															currentItemCount = FixCountItem((unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount);
														}
													}
												}
												if (currentItemCount - ((PlayerInfo*)(peer->data))->lastCT3 == 0)
												{
													((PlayerInfo*)(peer->data))->cloth_back = 0;
													sendClothes(peer);
												}
											}
											else if (((PlayerInfo*)(peer->data))->cloth_back == ((PlayerInfo*)(peer->data))->lastTD4)
											{
												short int currentItemCount = 0;
												for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++)
												{
													if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(peer->data))->lastTD4)
													{
														currentItemCount = (unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
														if (currentItemCount < 0)
														{
															currentItemCount = FixCountItem((unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount);
														}
													}
												}
												if (currentItemCount - ((PlayerInfo*)(peer->data))->lastCT4 == 0)
												{
													((PlayerInfo*)(peer->data))->cloth_back = 0;
													sendClothes(peer);
												}
											}

											if (((PlayerInfo*)(peer->data))->cloth_face == ((PlayerInfo*)(peer->data))->lastTD1)
											{
												short int currentItemCount = 0;
												for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++)
												{
													if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(peer->data))->lastTD1)
													{
														currentItemCount = (unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
														if (currentItemCount < 0)
														{
															currentItemCount = FixCountItem((unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount);
														}
													}
												}
												if (currentItemCount - ((PlayerInfo*)(peer->data))->lastCT1 == 0)
												{
													((PlayerInfo*)(peer->data))->cloth_face = 0;
													sendClothes(peer);
												}
											}
											else if (((PlayerInfo*)(peer->data))->cloth_face == ((PlayerInfo*)(peer->data))->lastTD2)
											{
												short int currentItemCount = 0;
												for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++)
												{
													if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(peer->data))->lastTD2)
													{
														currentItemCount = (unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
														if (currentItemCount < 0)
														{
															currentItemCount = FixCountItem((unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount);
														}
													}
												}
												if (currentItemCount - ((PlayerInfo*)(peer->data))->lastCT2 == 0)
												{
													((PlayerInfo*)(peer->data))->cloth_face = 0;
													sendClothes(peer);
												}
											}
											else if (((PlayerInfo*)(peer->data))->cloth_face == ((PlayerInfo*)(peer->data))->lastTD3)
											{
												short int currentItemCount = 0;
												for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++)
												{
													if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(peer->data))->lastTD3)
													{
														currentItemCount = (unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
														if (currentItemCount < 0)
														{
															currentItemCount = FixCountItem((unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount);
														}
													}
												}
												if (currentItemCount - ((PlayerInfo*)(peer->data))->lastCT3 == 0)
												{
													((PlayerInfo*)(peer->data))->cloth_face = 0;
													sendClothes(peer);
												}
											}
											else if (((PlayerInfo*)(peer->data))->cloth_face == ((PlayerInfo*)(peer->data))->lastTD4)
											{
												short int currentItemCount = 0;
												for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++)
												{
													if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(peer->data))->lastTD4)
													{
														currentItemCount = (unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
														if (currentItemCount < 0)
														{
															currentItemCount = FixCountItem((unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount);
														}
													}
												}
												if (currentItemCount - ((PlayerInfo*)(peer->data))->lastCT4 == 0)
												{
													((PlayerInfo*)(peer->data))->cloth_face = 0;
													sendClothes(peer);
												}
											}

											if (((PlayerInfo*)(peer->data))->cloth_feet == ((PlayerInfo*)(peer->data))->lastTD1)
											{
												short int currentItemCount = 0;
												for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++)
												{
													if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(peer->data))->lastTD1)
													{
														currentItemCount = (unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
														if (currentItemCount < 0)
														{
															currentItemCount = FixCountItem((unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount);
														}
													}
												}
												if (currentItemCount - ((PlayerInfo*)(peer->data))->lastCT1 == 0)
												{
													((PlayerInfo*)(peer->data))->cloth_feet = 0;
													sendClothes(peer);
												}
											}
											else if (((PlayerInfo*)(peer->data))->cloth_feet == ((PlayerInfo*)(peer->data))->lastTD2)
											{
												short int currentItemCount = 0;
												for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++)
												{
													if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(peer->data))->lastTD2)
													{
														currentItemCount = (unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
														if (currentItemCount < 0)
														{
															currentItemCount = FixCountItem((unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount);
														}
													}
												}
												if (currentItemCount - ((PlayerInfo*)(peer->data))->lastCT2 == 0)
												{
													((PlayerInfo*)(peer->data))->cloth_feet = 0;
													sendClothes(peer);
												}
											}
											else if (((PlayerInfo*)(peer->data))->cloth_feet == ((PlayerInfo*)(peer->data))->lastTD3)
											{
												short int currentItemCount = 0;
												for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++)
												{
													if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(peer->data))->lastTD3)
													{
														currentItemCount = (unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
														if (currentItemCount < 0)
														{
															currentItemCount = FixCountItem((unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount);
														}
													}
												}
												if (currentItemCount - ((PlayerInfo*)(peer->data))->lastCT3 == 0)
												{
													((PlayerInfo*)(peer->data))->cloth_feet = 0;
													sendClothes(peer);
												}
											}
											else if (((PlayerInfo*)(peer->data))->cloth_feet == ((PlayerInfo*)(peer->data))->lastTD4)
											{
												short int currentItemCount = 0;
												for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++)
												{
													if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(peer->data))->lastTD4)
													{
														currentItemCount = (unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
														if (currentItemCount < 0)
														{
															currentItemCount = FixCountItem((unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount);
														}
													}
												}
												if (currentItemCount - ((PlayerInfo*)(peer->data))->lastCT4 == 0)
												{
													((PlayerInfo*)(peer->data))->cloth_feet = 0;
													sendClothes(peer);
												}
											}

											if (((PlayerInfo*)(peer->data))->cloth_hair == ((PlayerInfo*)(peer->data))->lastTD1)
											{
												short int currentItemCount = 0;
												for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++)
												{
													if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(peer->data))->lastTD1)
													{
														currentItemCount = (unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
														if (currentItemCount < 0)
														{
															currentItemCount = FixCountItem((unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount);
														}
													}
												}
												if (currentItemCount - ((PlayerInfo*)(peer->data))->lastCT1 == 0)
												{
													((PlayerInfo*)(peer->data))->cloth_hair = 0;
													sendClothes(peer);
												}
											}
											else if (((PlayerInfo*)(peer->data))->cloth_hair == ((PlayerInfo*)(peer->data))->lastTD2)
											{
												short int currentItemCount = 0;
												for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++)
												{
													if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(peer->data))->lastTD2)
													{
														currentItemCount = (unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
														if (currentItemCount < 0)
														{
															currentItemCount = FixCountItem((unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount);
														}
													}
												}
												if (currentItemCount - ((PlayerInfo*)(peer->data))->lastCT2 == 0)
												{
													((PlayerInfo*)(peer->data))->cloth_hair = 0;
													sendClothes(peer);
												}
											}
											else if (((PlayerInfo*)(peer->data))->cloth_hair == ((PlayerInfo*)(peer->data))->lastTD3)
											{
												short int currentItemCount = 0;
												for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++)
												{
													if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(peer->data))->lastTD3)
													{
														currentItemCount = (unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
														if (currentItemCount < 0)
														{
															currentItemCount = FixCountItem((unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount);
														}
													}
												}
												if (currentItemCount - ((PlayerInfo*)(peer->data))->lastCT3 == 0)
												{
													((PlayerInfo*)(peer->data))->cloth_hair = 0;
													sendClothes(peer);
												}
											}
											else if (((PlayerInfo*)(peer->data))->cloth_hair == ((PlayerInfo*)(peer->data))->lastTD4)
											{
												short int currentItemCount = 0;
												for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++)
												{
													if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(peer->data))->lastTD4)
													{
														currentItemCount = (unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
														if (currentItemCount < 0)
														{
															currentItemCount = FixCountItem((unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount);
														}
													}
												}
												if (currentItemCount - ((PlayerInfo*)(peer->data))->lastCT4 == 0)
												{
													((PlayerInfo*)(peer->data))->cloth_hair = 0;
													sendClothes(peer);
												}
											}

											if (((PlayerInfo*)(peer->data))->cloth_hand == ((PlayerInfo*)(peer->data))->lastTD1)
											{
												short int currentItemCount = 0;
												for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++)
												{
													if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(peer->data))->lastTD1)
													{
														currentItemCount = (unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
														if (currentItemCount < 0)
														{
															currentItemCount = FixCountItem((unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount);
														}
													}
												}
												if (currentItemCount - ((PlayerInfo*)(peer->data))->lastCT1 == 0)
												{
													((PlayerInfo*)(peer->data))->cloth_hand = 0;
													sendClothes(peer);
												}
											}
											else if (((PlayerInfo*)(peer->data))->cloth_hand == ((PlayerInfo*)(peer->data))->lastTD2)
											{
												short int currentItemCount = 0;
												for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++)
												{
													if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(peer->data))->lastTD2)
													{
														currentItemCount = (unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
														if (currentItemCount < 0)
														{
															currentItemCount = FixCountItem((unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount);
														}
													}
												}
												if (currentItemCount - ((PlayerInfo*)(peer->data))->lastCT2 == 0)
												{
													((PlayerInfo*)(peer->data))->cloth_hand = 0;
													sendClothes(peer);
												}
											}
											else if (((PlayerInfo*)(peer->data))->cloth_hand == ((PlayerInfo*)(peer->data))->lastTD3)
											{
												short int currentItemCount = 0;
												for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++)
												{
													if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(peer->data))->lastTD3)
													{
														currentItemCount = (unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
														if (currentItemCount < 0)
														{
															currentItemCount = FixCountItem((unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount);
														}
													}
												}
												if (currentItemCount - ((PlayerInfo*)(peer->data))->lastCT3 == 0)
												{
													((PlayerInfo*)(peer->data))->cloth_hand = 0;
													sendClothes(peer);
												}
											}
											else if (((PlayerInfo*)(peer->data))->cloth_hand == ((PlayerInfo*)(peer->data))->lastTD4)
											{
												short int currentItemCount = 0;
												for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++)
												{
													if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(peer->data))->lastTD4)
													{
														currentItemCount = (unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
														if (currentItemCount < 0)
														{
															currentItemCount = FixCountItem((unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount);
														}
													}
												}
												if (currentItemCount - ((PlayerInfo*)(peer->data))->lastCT4 == 0)
												{
													((PlayerInfo*)(peer->data))->cloth_hand = 0;
													sendClothes(peer);
												}
											}

											if (((PlayerInfo*)(peer->data))->cloth_mask == ((PlayerInfo*)(peer->data))->lastTD1)
											{
												short int currentItemCount = 0;
												for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++)
												{
													if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(peer->data))->lastTD1)
													{
														currentItemCount = (unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
														if (currentItemCount < 0)
														{
															currentItemCount = FixCountItem((unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount);
														}
													}
												}
												if (currentItemCount - ((PlayerInfo*)(peer->data))->lastCT1 == 0)
												{
													((PlayerInfo*)(peer->data))->cloth_mask = 0;
													sendClothes(peer);
												}
											}
											else if (((PlayerInfo*)(peer->data))->cloth_mask == ((PlayerInfo*)(peer->data))->lastTD2)
											{
												short int currentItemCount = 0;
												for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++)
												{
													if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(peer->data))->lastTD2)
													{
														currentItemCount = (unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
														if (currentItemCount < 0)
														{
															currentItemCount = FixCountItem((unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount);
														}
													}
												}
												if (currentItemCount - ((PlayerInfo*)(peer->data))->lastCT2 == 0)
												{
													((PlayerInfo*)(peer->data))->cloth_mask = 0;
													sendClothes(peer);
												}
											}
											else if (((PlayerInfo*)(peer->data))->cloth_mask == ((PlayerInfo*)(peer->data))->lastTD3)
											{
												short int currentItemCount = 0;
												for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++)
												{
													if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(peer->data))->lastTD3)
													{
														currentItemCount = (unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
														if (currentItemCount < 0)
														{
															currentItemCount = FixCountItem((unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount);
														}
													}
												}
												if (currentItemCount - ((PlayerInfo*)(peer->data))->lastCT3 == 0)
												{
													((PlayerInfo*)(peer->data))->cloth_mask = 0;
													sendClothes(peer);
												}
											}
											else if (((PlayerInfo*)(peer->data))->cloth_mask == ((PlayerInfo*)(peer->data))->lastTD4)
											{
												short int currentItemCount = 0;
												for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++)
												{
													if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(peer->data))->lastTD4)
													{
														currentItemCount = (unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
														if (currentItemCount < 0)
														{
															currentItemCount = FixCountItem((unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount);
														}
													}
												}
												if (currentItemCount - ((PlayerInfo*)(peer->data))->lastCT4 == 0)
												{
													((PlayerInfo*)(peer->data))->cloth_mask = 0;
													sendClothes(peer);
												}
											}

											if (((PlayerInfo*)(peer->data))->cloth_necklace == ((PlayerInfo*)(peer->data))->lastTD1)
											{
												short int currentItemCount = 0;
												for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++)
												{
													if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(peer->data))->lastTD1)
													{
														currentItemCount = (unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
														if (currentItemCount < 0)
														{
															currentItemCount = FixCountItem((unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount);
														}
													}
												}
												if (currentItemCount - ((PlayerInfo*)(peer->data))->lastCT1 == 0)
												{
													((PlayerInfo*)(peer->data))->cloth_necklace = 0;
													sendClothes(peer);
												}
											}
											else if (((PlayerInfo*)(peer->data))->cloth_necklace == ((PlayerInfo*)(peer->data))->lastTD2)
											{
												short int currentItemCount = 0;
												for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++)
												{
													if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(peer->data))->lastTD2)
													{
														currentItemCount = (unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
														if (currentItemCount < 0)
														{
															currentItemCount = FixCountItem((unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount);
														}
													}
												}
												if (currentItemCount - ((PlayerInfo*)(peer->data))->lastCT2 == 0)
												{
													((PlayerInfo*)(peer->data))->cloth_necklace = 0;
													sendClothes(peer);
												}
											}
											else if (((PlayerInfo*)(peer->data))->cloth_necklace == ((PlayerInfo*)(peer->data))->lastTD3)
											{
												short int currentItemCount = 0;
												for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++)
												{
													if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(peer->data))->lastTD3)
													{
														currentItemCount = (unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
														if (currentItemCount < 0)
														{
															currentItemCount = FixCountItem((unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount);
														}
													}
												}
												if (currentItemCount - ((PlayerInfo*)(peer->data))->lastCT3 == 0)
												{
													((PlayerInfo*)(peer->data))->cloth_necklace = 0;
													sendClothes(peer);
												}
											}
											else if (((PlayerInfo*)(peer->data))->cloth_necklace == ((PlayerInfo*)(peer->data))->lastTD4)
											{
												short int currentItemCount = 0;
												for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++)
												{
													if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(peer->data))->lastTD4)
													{
														currentItemCount = (unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
														if (currentItemCount < 0)
														{
															currentItemCount = FixCountItem((unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount);
														}
													}
												}
												if (currentItemCount - ((PlayerInfo*)(peer->data))->lastCT4 == 0)
												{
													((PlayerInfo*)(peer->data))->cloth_necklace = 0;
													sendClothes(peer);
												}
											}

											if (((PlayerInfo*)(peer->data))->cloth_shirt == ((PlayerInfo*)(peer->data))->lastTD1)
											{
												short int currentItemCount = 0;
												for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++)
												{
													if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(peer->data))->lastTD1)
													{
														currentItemCount = (unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
														if (currentItemCount < 0)
														{
															currentItemCount = FixCountItem((unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount);
														}
													}
												}
												if (currentItemCount - ((PlayerInfo*)(peer->data))->lastCT1 == 0)
												{
													((PlayerInfo*)(peer->data))->cloth_shirt = 0;
													sendClothes(peer);
												}
											}
											else if (((PlayerInfo*)(peer->data))->cloth_shirt == ((PlayerInfo*)(peer->data))->lastTD2)
											{
												short int currentItemCount = 0;
												for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++)
												{
													if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(peer->data))->lastTD2)
													{
														currentItemCount = (unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
														if (currentItemCount < 0)
														{
															currentItemCount = FixCountItem((unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount);
														}
													}
												}
												if (currentItemCount - ((PlayerInfo*)(peer->data))->lastCT2 == 0)
												{
													((PlayerInfo*)(peer->data))->cloth_shirt = 0;
													sendClothes(peer);
												}
											}
											else if (((PlayerInfo*)(peer->data))->cloth_shirt == ((PlayerInfo*)(peer->data))->lastTD3)
											{
												short int currentItemCount = 0;
												for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++)
												{
													if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(peer->data))->lastTD3)
													{
														currentItemCount = (unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
														if (currentItemCount < 0)
														{
															currentItemCount = FixCountItem((unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount);
														}
													}
												}
												if (currentItemCount - ((PlayerInfo*)(peer->data))->lastCT3 == 0)
												{
													((PlayerInfo*)(peer->data))->cloth_shirt = 0;
													sendClothes(peer);
												}
											}
											else if (((PlayerInfo*)(peer->data))->cloth_shirt == ((PlayerInfo*)(peer->data))->lastTD4)
											{
												short int currentItemCount = 0;
												for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++)
												{
													if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(peer->data))->lastTD4)
													{
														currentItemCount = (unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
														if (currentItemCount < 0)
														{
															currentItemCount = FixCountItem((unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount);
														}
													}
												}
												if (currentItemCount - ((PlayerInfo*)(peer->data))->lastCT4 == 0)
												{
													((PlayerInfo*)(peer->data))->cloth_shirt = 0;
													sendClothes(peer);
												}
											}

											if (((PlayerInfo*)(peer->data))->cloth_pants == ((PlayerInfo*)(peer->data))->lastTD1)
											{
												short int currentItemCount = 0;
												for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++)
												{
													if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(peer->data))->lastTD1)
													{
														currentItemCount = (unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
														if (currentItemCount < 0)
														{
															currentItemCount = FixCountItem((unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount);
														}
													}
												}
												if (currentItemCount - ((PlayerInfo*)(peer->data))->lastCT1 == 0)
												{
													((PlayerInfo*)(peer->data))->cloth_pants = 0;
													sendClothes(peer);
												}
											}
											else if (((PlayerInfo*)(peer->data))->cloth_pants == ((PlayerInfo*)(peer->data))->lastTD2)
											{
												short int currentItemCount = 0;
												for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++)
												{
													if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(peer->data))->lastTD2)
													{
														currentItemCount = (unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
														if (currentItemCount < 0)
														{
															currentItemCount = FixCountItem((unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount);
														}
													}
												}
												if (currentItemCount - ((PlayerInfo*)(peer->data))->lastCT2 == 0)
												{
													((PlayerInfo*)(peer->data))->cloth_pants = 0;
													sendClothes(peer);
												}
											}
											else if (((PlayerInfo*)(peer->data))->cloth_pants == ((PlayerInfo*)(peer->data))->lastTD3)
											{
												short int currentItemCount = 0;
												for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++)
												{
													if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(peer->data))->lastTD3)
													{
														currentItemCount = (unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
														if (currentItemCount < 0)
														{
															currentItemCount = FixCountItem((unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount);
														}
													}
												}
												if (currentItemCount - ((PlayerInfo*)(peer->data))->lastCT3 == 0)
												{
													((PlayerInfo*)(peer->data))->cloth_pants = 0;
													sendClothes(peer);
												}
											}
											else if (((PlayerInfo*)(peer->data))->cloth_pants == ((PlayerInfo*)(peer->data))->lastTD4)
											{
												short int currentItemCount = 0;
												for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++)
												{
													if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(peer->data))->lastTD4)
													{
														currentItemCount = (unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
														if (currentItemCount < 0)
														{
															currentItemCount = FixCountItem((unsigned int)((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount);
														}
													}
												}
												if (currentItemCount - ((PlayerInfo*)(peer->data))->lastCT4 == 0)
												{
													((PlayerInfo*)(peer->data))->cloth_pants = 0;
													sendClothes(peer);
												}
											}
											//End Peer
											//Current Peer
											if (((PlayerInfo*)(currentPeer->data))->cloth_ances == ((PlayerInfo*)(currentPeer->data))->lastTD1)
											{
												short int currentItemCount = 0;
												for (int i = 0; i < ((PlayerInfo*)(currentPeer->data))->inventory.items.size(); i++)
												{
													if (((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(currentPeer->data))->lastTD1)
													{
														currentItemCount = (unsigned int)((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemCount;
														if (currentItemCount < 0)
														{
															currentItemCount = FixCountItem((unsigned int)((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemCount);
														}
													}
												}
												if (currentItemCount - ((PlayerInfo*)(currentPeer->data))->lastCT1 == 0)
												{
													((PlayerInfo*)(currentPeer->data))->cloth_ances = 0;
													sendClothes(currentPeer);
												}
											}
											else if (((PlayerInfo*)(currentPeer->data))->cloth_ances == ((PlayerInfo*)(currentPeer->data))->lastTD2)
											{
												short int currentItemCount = 0;
												for (int i = 0; i < ((PlayerInfo*)(currentPeer->data))->inventory.items.size(); i++)
												{
													if (((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(currentPeer->data))->lastTD2)
													{
														currentItemCount = (unsigned int)((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemCount;
														if (currentItemCount < 0)
														{
															currentItemCount = FixCountItem((unsigned int)((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemCount);
														}
													}
												}
												if (currentItemCount - ((PlayerInfo*)(currentPeer->data))->lastCT2 == 0)
												{
													((PlayerInfo*)(currentPeer->data))->cloth_ances = 0;
													sendClothes(currentPeer);
												}
											}
											else if (((PlayerInfo*)(currentPeer->data))->cloth_ances == ((PlayerInfo*)(currentPeer->data))->lastTD3)
											{
												short int currentItemCount = 0;
												for (int i = 0; i < ((PlayerInfo*)(currentPeer->data))->inventory.items.size(); i++)
												{
													if (((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(currentPeer->data))->lastTD3)
													{
														currentItemCount = (unsigned int)((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemCount;
														if (currentItemCount < 0)
														{
															currentItemCount = FixCountItem((unsigned int)((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemCount);
														}
													}
												}
												if (currentItemCount - ((PlayerInfo*)(currentPeer->data))->lastCT3 == 0)
												{
													((PlayerInfo*)(currentPeer->data))->cloth_ances = 0;
													sendClothes(currentPeer);
												}
											}
											else if (((PlayerInfo*)(currentPeer->data))->cloth_ances == ((PlayerInfo*)(currentPeer->data))->lastTD4)
											{
												short int currentItemCount = 0;
												for (int i = 0; i < ((PlayerInfo*)(currentPeer->data))->inventory.items.size(); i++)
												{
													if (((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(currentPeer->data))->lastTD4)
													{
														currentItemCount = (unsigned int)((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemCount;
														if (currentItemCount < 0)
														{
															currentItemCount = FixCountItem((unsigned int)((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemCount);
														}
													}
												}
												if (currentItemCount - ((PlayerInfo*)(currentPeer->data))->lastCT4 == 0)
												{
													((PlayerInfo*)(currentPeer->data))->cloth_ances = 0;
													sendClothes(currentPeer);
												}
											}

											if (((PlayerInfo*)(currentPeer->data))->cloth_back == ((PlayerInfo*)(currentPeer->data))->lastTD1)
											{
												short int currentItemCount = 0;
												for (int i = 0; i < ((PlayerInfo*)(currentPeer->data))->inventory.items.size(); i++)
												{
													if (((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(currentPeer->data))->lastTD1)
													{
														currentItemCount = (unsigned int)((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemCount;
														if (currentItemCount < 0)
														{
															currentItemCount = FixCountItem((unsigned int)((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemCount);
														}
													}
												}
												if (currentItemCount - ((PlayerInfo*)(currentPeer->data))->lastCT1 == 0)
												{
													((PlayerInfo*)(currentPeer->data))->cloth_back = 0;
													sendClothes(currentPeer);
												}
											}
											else if (((PlayerInfo*)(currentPeer->data))->cloth_back == ((PlayerInfo*)(currentPeer->data))->lastTD2)
											{
												short int currentItemCount = 0;
												for (int i = 0; i < ((PlayerInfo*)(currentPeer->data))->inventory.items.size(); i++)
												{
													if (((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(currentPeer->data))->lastTD2)
													{
														currentItemCount = (unsigned int)((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemCount;
														if (currentItemCount < 0)
														{
															currentItemCount = FixCountItem((unsigned int)((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemCount);
														}
													}
												}
												if (currentItemCount - ((PlayerInfo*)(currentPeer->data))->lastCT2 == 0)
												{
													((PlayerInfo*)(currentPeer->data))->cloth_back = 0;
													sendClothes(currentPeer);
												}
											}
											else if (((PlayerInfo*)(currentPeer->data))->cloth_back == ((PlayerInfo*)(currentPeer->data))->lastTD3)
											{
												short int currentItemCount = 0;
												for (int i = 0; i < ((PlayerInfo*)(currentPeer->data))->inventory.items.size(); i++)
												{
													if (((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(currentPeer->data))->lastTD3)
													{
														currentItemCount = (unsigned int)((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemCount;
														if (currentItemCount < 0)
														{
															currentItemCount = FixCountItem((unsigned int)((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemCount);
														}
													}
												}
												if (currentItemCount - ((PlayerInfo*)(currentPeer->data))->lastCT3 == 0)
												{
													((PlayerInfo*)(currentPeer->data))->cloth_back = 0;
													sendClothes(currentPeer);
												}
											}
											else if (((PlayerInfo*)(currentPeer->data))->cloth_back == ((PlayerInfo*)(currentPeer->data))->lastTD4)
											{
												short int currentItemCount = 0;
												for (int i = 0; i < ((PlayerInfo*)(currentPeer->data))->inventory.items.size(); i++)
												{
													if (((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(currentPeer->data))->lastTD4)
													{
														currentItemCount = (unsigned int)((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemCount;
														if (currentItemCount < 0)
														{
															currentItemCount = FixCountItem((unsigned int)((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemCount);
														}
													}
												}
												if (currentItemCount - ((PlayerInfo*)(currentPeer->data))->lastCT4 == 0)
												{
													((PlayerInfo*)(currentPeer->data))->cloth_back = 0;
													sendClothes(currentPeer);
												}
											}

											if (((PlayerInfo*)(currentPeer->data))->cloth_face == ((PlayerInfo*)(currentPeer->data))->lastTD1)
											{
												short int currentItemCount = 0;
												for (int i = 0; i < ((PlayerInfo*)(currentPeer->data))->inventory.items.size(); i++)
												{
													if (((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(currentPeer->data))->lastTD1)
													{
														currentItemCount = (unsigned int)((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemCount;
														if (currentItemCount < 0)
														{
															currentItemCount = FixCountItem((unsigned int)((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemCount);
														}
													}
												}
												if (currentItemCount - ((PlayerInfo*)(currentPeer->data))->lastCT1 == 0)
												{
													((PlayerInfo*)(currentPeer->data))->cloth_face = 0;
													sendClothes(currentPeer);
												}
											}
											else if (((PlayerInfo*)(currentPeer->data))->cloth_face == ((PlayerInfo*)(currentPeer->data))->lastTD2)
											{
												short int currentItemCount = 0;
												for (int i = 0; i < ((PlayerInfo*)(currentPeer->data))->inventory.items.size(); i++)
												{
													if (((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(currentPeer->data))->lastTD2)
													{
														currentItemCount = (unsigned int)((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemCount;
														if (currentItemCount < 0)
														{
															currentItemCount = FixCountItem((unsigned int)((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemCount);
														}
													}
												}
												if (currentItemCount - ((PlayerInfo*)(currentPeer->data))->lastCT2 == 0)
												{
													((PlayerInfo*)(currentPeer->data))->cloth_face = 0;
													sendClothes(currentPeer);
												}
											}
											else if (((PlayerInfo*)(currentPeer->data))->cloth_face == ((PlayerInfo*)(currentPeer->data))->lastTD3)
											{
												short int currentItemCount = 0;
												for (int i = 0; i < ((PlayerInfo*)(currentPeer->data))->inventory.items.size(); i++)
												{
													if (((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(currentPeer->data))->lastTD3)
													{
														currentItemCount = (unsigned int)((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemCount;
														if (currentItemCount < 0)
														{
															currentItemCount = FixCountItem((unsigned int)((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemCount);
														}
													}
												}
												if (currentItemCount - ((PlayerInfo*)(currentPeer->data))->lastCT3 == 0)
												{
													((PlayerInfo*)(currentPeer->data))->cloth_face = 0;
													sendClothes(currentPeer);
												}
											}
											else if (((PlayerInfo*)(currentPeer->data))->cloth_face == ((PlayerInfo*)(currentPeer->data))->lastTD4)
											{
												short int currentItemCount = 0;
												for (int i = 0; i < ((PlayerInfo*)(currentPeer->data))->inventory.items.size(); i++)
												{
													if (((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(currentPeer->data))->lastTD4)
													{
														currentItemCount = (unsigned int)((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemCount;
														if (currentItemCount < 0)
														{
															currentItemCount = FixCountItem((unsigned int)((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemCount);
														}
													}
												}
												if (currentItemCount - ((PlayerInfo*)(currentPeer->data))->lastCT4 == 0)
												{
													((PlayerInfo*)(currentPeer->data))->cloth_face = 0;
													sendClothes(currentPeer);
												}
											}

											if (((PlayerInfo*)(currentPeer->data))->cloth_feet == ((PlayerInfo*)(currentPeer->data))->lastTD1)
											{
												short int currentItemCount = 0;
												for (int i = 0; i < ((PlayerInfo*)(currentPeer->data))->inventory.items.size(); i++)
												{
													if (((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(currentPeer->data))->lastTD1)
													{
														currentItemCount = (unsigned int)((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemCount;
														if (currentItemCount < 0)
														{
															currentItemCount = FixCountItem((unsigned int)((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemCount);
														}
													}
												}
												if (currentItemCount - ((PlayerInfo*)(currentPeer->data))->lastCT1 == 0)
												{
													((PlayerInfo*)(currentPeer->data))->cloth_feet = 0;
													sendClothes(currentPeer);
												}
											}
											else if (((PlayerInfo*)(currentPeer->data))->cloth_feet == ((PlayerInfo*)(currentPeer->data))->lastTD2)
											{
												short int currentItemCount = 0;
												for (int i = 0; i < ((PlayerInfo*)(currentPeer->data))->inventory.items.size(); i++)
												{
													if (((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(currentPeer->data))->lastTD2)
													{
														currentItemCount = (unsigned int)((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemCount;
														if (currentItemCount < 0)
														{
															currentItemCount = FixCountItem((unsigned int)((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemCount);
														}
													}
												}
												if (currentItemCount - ((PlayerInfo*)(currentPeer->data))->lastCT2 == 0)
												{
													((PlayerInfo*)(currentPeer->data))->cloth_feet = 0;
													sendClothes(currentPeer);
												}
											}
											else if (((PlayerInfo*)(currentPeer->data))->cloth_feet == ((PlayerInfo*)(currentPeer->data))->lastTD3)
											{
												short int currentItemCount = 0;
												for (int i = 0; i < ((PlayerInfo*)(currentPeer->data))->inventory.items.size(); i++)
												{
													if (((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(currentPeer->data))->lastTD3)
													{
														currentItemCount = (unsigned int)((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemCount;
														if (currentItemCount < 0)
														{
															currentItemCount = FixCountItem((unsigned int)((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemCount);
														}
													}
												}
												if (currentItemCount - ((PlayerInfo*)(currentPeer->data))->lastCT3 == 0)
												{
													((PlayerInfo*)(currentPeer->data))->cloth_feet = 0;
													sendClothes(currentPeer);
												}
											}
											else if (((PlayerInfo*)(currentPeer->data))->cloth_feet == ((PlayerInfo*)(currentPeer->data))->lastTD4)
											{
												short int currentItemCount = 0;
												for (int i = 0; i < ((PlayerInfo*)(currentPeer->data))->inventory.items.size(); i++)
												{
													if (((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(currentPeer->data))->lastTD4)
													{
														currentItemCount = (unsigned int)((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemCount;
														if (currentItemCount < 0)
														{
															currentItemCount = FixCountItem((unsigned int)((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemCount);
														}
													}
												}
												if (currentItemCount - ((PlayerInfo*)(currentPeer->data))->lastCT4 == 0)
												{
													((PlayerInfo*)(currentPeer->data))->cloth_feet = 0;
													sendClothes(currentPeer);
												}
											}

											if (((PlayerInfo*)(currentPeer->data))->cloth_hair == ((PlayerInfo*)(currentPeer->data))->lastTD1)
											{
												short int currentItemCount = 0;
												for (int i = 0; i < ((PlayerInfo*)(currentPeer->data))->inventory.items.size(); i++)
												{
													if (((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(currentPeer->data))->lastTD1)
													{
														currentItemCount = (unsigned int)((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemCount;
														if (currentItemCount < 0)
														{
															currentItemCount = FixCountItem((unsigned int)((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemCount);
														}
													}
												}
												if (currentItemCount - ((PlayerInfo*)(currentPeer->data))->lastCT1 == 0)
												{
													((PlayerInfo*)(currentPeer->data))->cloth_hair = 0;
													sendClothes(currentPeer);
												}
											}
											else if (((PlayerInfo*)(currentPeer->data))->cloth_hair == ((PlayerInfo*)(currentPeer->data))->lastTD2)
											{
												short int currentItemCount = 0;
												for (int i = 0; i < ((PlayerInfo*)(currentPeer->data))->inventory.items.size(); i++)
												{
													if (((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(currentPeer->data))->lastTD2)
													{
														currentItemCount = (unsigned int)((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemCount;
														if (currentItemCount < 0)
														{
															currentItemCount = FixCountItem((unsigned int)((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemCount);
														}
													}
												}
												if (currentItemCount - ((PlayerInfo*)(currentPeer->data))->lastCT2 == 0)
												{
													((PlayerInfo*)(currentPeer->data))->cloth_hair = 0;
													sendClothes(currentPeer);
												}
											}
											else if (((PlayerInfo*)(currentPeer->data))->cloth_hair == ((PlayerInfo*)(currentPeer->data))->lastTD3)
											{
												short int currentItemCount = 0;
												for (int i = 0; i < ((PlayerInfo*)(currentPeer->data))->inventory.items.size(); i++)
												{
													if (((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(currentPeer->data))->lastTD3)
													{
														currentItemCount = (unsigned int)((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemCount;
														if (currentItemCount < 0)
														{
															currentItemCount = FixCountItem((unsigned int)((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemCount);
														}
													}
												}
												if (currentItemCount - ((PlayerInfo*)(currentPeer->data))->lastCT3 == 0)
												{
													((PlayerInfo*)(currentPeer->data))->cloth_hair = 0;
													sendClothes(currentPeer);
												}
											}
											else if (((PlayerInfo*)(currentPeer->data))->cloth_hair == ((PlayerInfo*)(currentPeer->data))->lastTD4)
											{
												short int currentItemCount = 0;
												for (int i = 0; i < ((PlayerInfo*)(currentPeer->data))->inventory.items.size(); i++)
												{
													if (((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(currentPeer->data))->lastTD4)
													{
														currentItemCount = (unsigned int)((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemCount;
														if (currentItemCount < 0)
														{
															currentItemCount = FixCountItem((unsigned int)((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemCount);
														}
													}
												}
												if (currentItemCount - ((PlayerInfo*)(currentPeer->data))->lastCT4 == 0)
												{
													((PlayerInfo*)(currentPeer->data))->cloth_hair = 0;
													sendClothes(currentPeer);
												}
											}

											if (((PlayerInfo*)(currentPeer->data))->cloth_hand == ((PlayerInfo*)(currentPeer->data))->lastTD1)
											{
												short int currentItemCount = 0;
												for (int i = 0; i < ((PlayerInfo*)(currentPeer->data))->inventory.items.size(); i++)
												{
													if (((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(currentPeer->data))->lastTD1)
													{
														currentItemCount = (unsigned int)((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemCount;
														if (currentItemCount < 0)
														{
															currentItemCount = FixCountItem((unsigned int)((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemCount);
														}
													}
												}
												if (currentItemCount - ((PlayerInfo*)(currentPeer->data))->lastCT1 == 0)
												{
													((PlayerInfo*)(currentPeer->data))->cloth_hand = 0;
													sendClothes(currentPeer);
												}
											}
											else if (((PlayerInfo*)(currentPeer->data))->cloth_hand == ((PlayerInfo*)(currentPeer->data))->lastTD2)
											{
												short int currentItemCount = 0;
												for (int i = 0; i < ((PlayerInfo*)(currentPeer->data))->inventory.items.size(); i++)
												{
													if (((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(currentPeer->data))->lastTD2)
													{
														currentItemCount = (unsigned int)((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemCount;
														if (currentItemCount < 0)
														{
															currentItemCount = FixCountItem((unsigned int)((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemCount);
														}
													}
												}
												if (currentItemCount - ((PlayerInfo*)(currentPeer->data))->lastCT2 == 0)
												{
													((PlayerInfo*)(currentPeer->data))->cloth_hand = 0;
													sendClothes(currentPeer);
												}
											}
											else if (((PlayerInfo*)(currentPeer->data))->cloth_hand == ((PlayerInfo*)(currentPeer->data))->lastTD3)
											{
												short int currentItemCount = 0;
												for (int i = 0; i < ((PlayerInfo*)(currentPeer->data))->inventory.items.size(); i++)
												{
													if (((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(currentPeer->data))->lastTD3)
													{
														currentItemCount = (unsigned int)((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemCount;
														if (currentItemCount < 0)
														{
															currentItemCount = FixCountItem((unsigned int)((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemCount);
														}
													}
												}
												if (currentItemCount - ((PlayerInfo*)(currentPeer->data))->lastCT3 == 0)
												{
													((PlayerInfo*)(currentPeer->data))->cloth_hand = 0;
													sendClothes(currentPeer);
												}
											}
											else if (((PlayerInfo*)(currentPeer->data))->cloth_hand == ((PlayerInfo*)(currentPeer->data))->lastTD4)
											{
												short int currentItemCount = 0;
												for (int i = 0; i < ((PlayerInfo*)(currentPeer->data))->inventory.items.size(); i++)
												{
													if (((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(currentPeer->data))->lastTD4)
													{
														currentItemCount = (unsigned int)((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemCount;
														if (currentItemCount < 0)
														{
															currentItemCount = FixCountItem((unsigned int)((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemCount);
														}
													}
												}
												if (currentItemCount - ((PlayerInfo*)(currentPeer->data))->lastCT4 == 0)
												{
													((PlayerInfo*)(currentPeer->data))->cloth_hand = 0;
													sendClothes(currentPeer);
												}
											}

											if (((PlayerInfo*)(currentPeer->data))->cloth_mask == ((PlayerInfo*)(currentPeer->data))->lastTD1)
											{
												short int currentItemCount = 0;
												for (int i = 0; i < ((PlayerInfo*)(currentPeer->data))->inventory.items.size(); i++)
												{
													if (((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(currentPeer->data))->lastTD1)
													{
														currentItemCount = (unsigned int)((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemCount;
														if (currentItemCount < 0)
														{
															currentItemCount = FixCountItem((unsigned int)((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemCount);
														}
													}
												}
												if (currentItemCount - ((PlayerInfo*)(currentPeer->data))->lastCT1 == 0)
												{
													((PlayerInfo*)(currentPeer->data))->cloth_mask = 0;
													sendClothes(currentPeer);
												}
											}
											else if (((PlayerInfo*)(currentPeer->data))->cloth_mask == ((PlayerInfo*)(currentPeer->data))->lastTD2)
											{
												short int currentItemCount = 0;
												for (int i = 0; i < ((PlayerInfo*)(currentPeer->data))->inventory.items.size(); i++)
												{
													if (((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(currentPeer->data))->lastTD2)
													{
														currentItemCount = (unsigned int)((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemCount;
														if (currentItemCount < 0)
														{
															currentItemCount = FixCountItem((unsigned int)((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemCount);
														}
													}
												}
												if (currentItemCount - ((PlayerInfo*)(currentPeer->data))->lastCT2 == 0)
												{
													((PlayerInfo*)(currentPeer->data))->cloth_mask = 0;
													sendClothes(currentPeer);
												}
											}
											else if (((PlayerInfo*)(currentPeer->data))->cloth_mask == ((PlayerInfo*)(currentPeer->data))->lastTD3)
											{
												short int currentItemCount = 0;
												for (int i = 0; i < ((PlayerInfo*)(currentPeer->data))->inventory.items.size(); i++)
												{
													if (((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(currentPeer->data))->lastTD3)
													{
														currentItemCount = (unsigned int)((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemCount;
														if (currentItemCount < 0)
														{
															currentItemCount = FixCountItem((unsigned int)((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemCount);
														}
													}
												}
												if (currentItemCount - ((PlayerInfo*)(currentPeer->data))->lastCT3 == 0)
												{
													((PlayerInfo*)(currentPeer->data))->cloth_mask = 0;
													sendClothes(currentPeer);
												}
											}
											else if (((PlayerInfo*)(currentPeer->data))->cloth_mask == ((PlayerInfo*)(currentPeer->data))->lastTD4)
											{
												short int currentItemCount = 0;
												for (int i = 0; i < ((PlayerInfo*)(currentPeer->data))->inventory.items.size(); i++)
												{
													if (((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(currentPeer->data))->lastTD4)
													{
														currentItemCount = (unsigned int)((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemCount;
														if (currentItemCount < 0)
														{
															currentItemCount = FixCountItem((unsigned int)((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemCount);
														}
													}
												}
												if (currentItemCount - ((PlayerInfo*)(currentPeer->data))->lastCT4 == 0)
												{
													((PlayerInfo*)(currentPeer->data))->cloth_mask = 0;
													sendClothes(currentPeer);
												}
											}

											if (((PlayerInfo*)(currentPeer->data))->cloth_necklace == ((PlayerInfo*)(currentPeer->data))->lastTD1)
											{
												short int currentItemCount = 0;
												for (int i = 0; i < ((PlayerInfo*)(currentPeer->data))->inventory.items.size(); i++)
												{
													if (((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(currentPeer->data))->lastTD1)
													{
														currentItemCount = (unsigned int)((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemCount;
														if (currentItemCount < 0)
														{
															currentItemCount = FixCountItem((unsigned int)((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemCount);
														}
													}
												}
												if (currentItemCount - ((PlayerInfo*)(currentPeer->data))->lastCT1 == 0)
												{
													((PlayerInfo*)(currentPeer->data))->cloth_necklace = 0;
													sendClothes(currentPeer);
												}
											}
											else if (((PlayerInfo*)(currentPeer->data))->cloth_necklace == ((PlayerInfo*)(currentPeer->data))->lastTD2)
											{
												short int currentItemCount = 0;
												for (int i = 0; i < ((PlayerInfo*)(currentPeer->data))->inventory.items.size(); i++)
												{
													if (((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(currentPeer->data))->lastTD2)
													{
														currentItemCount = (unsigned int)((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemCount;
														if (currentItemCount < 0)
														{
															currentItemCount = FixCountItem((unsigned int)((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemCount);
														}
													}
												}
												if (currentItemCount - ((PlayerInfo*)(currentPeer->data))->lastCT2 == 0)
												{
													((PlayerInfo*)(currentPeer->data))->cloth_necklace = 0;
													sendClothes(currentPeer);
												}
											}
											else if (((PlayerInfo*)(currentPeer->data))->cloth_necklace == ((PlayerInfo*)(currentPeer->data))->lastTD3)
											{
												short int currentItemCount = 0;
												for (int i = 0; i < ((PlayerInfo*)(currentPeer->data))->inventory.items.size(); i++)
												{
													if (((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(currentPeer->data))->lastTD3)
													{
														currentItemCount = (unsigned int)((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemCount;
														if (currentItemCount < 0)
														{
															currentItemCount = FixCountItem((unsigned int)((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemCount);
														}
													}
												}
												if (currentItemCount - ((PlayerInfo*)(currentPeer->data))->lastCT3 == 0)
												{
													((PlayerInfo*)(currentPeer->data))->cloth_necklace = 0;
													sendClothes(currentPeer);
												}
											}
											else if (((PlayerInfo*)(currentPeer->data))->cloth_necklace == ((PlayerInfo*)(currentPeer->data))->lastTD4)
											{
												short int currentItemCount = 0;
												for (int i = 0; i < ((PlayerInfo*)(currentPeer->data))->inventory.items.size(); i++)
												{
													if (((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(currentPeer->data))->lastTD4)
													{
														currentItemCount = (unsigned int)((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemCount;
														if (currentItemCount < 0)
														{
															currentItemCount = FixCountItem((unsigned int)((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemCount);
														}
													}
												}
												if (currentItemCount - ((PlayerInfo*)(currentPeer->data))->lastCT4 == 0)
												{
													((PlayerInfo*)(currentPeer->data))->cloth_necklace = 0;
													sendClothes(currentPeer);
												}
											}

											if (((PlayerInfo*)(currentPeer->data))->cloth_shirt == ((PlayerInfo*)(currentPeer->data))->lastTD1)
											{
												short int currentItemCount = 0;
												for (int i = 0; i < ((PlayerInfo*)(currentPeer->data))->inventory.items.size(); i++)
												{
													if (((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(currentPeer->data))->lastTD1)
													{
														currentItemCount = (unsigned int)((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemCount;
														if (currentItemCount < 0)
														{
															currentItemCount = FixCountItem((unsigned int)((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemCount);
														}
													}
												}
												if (currentItemCount - ((PlayerInfo*)(currentPeer->data))->lastCT1 == 0)
												{
													((PlayerInfo*)(currentPeer->data))->cloth_shirt = 0;
													sendClothes(currentPeer);
												}
											}
											else if (((PlayerInfo*)(currentPeer->data))->cloth_shirt == ((PlayerInfo*)(currentPeer->data))->lastTD2)
											{
												short int currentItemCount = 0;
												for (int i = 0; i < ((PlayerInfo*)(currentPeer->data))->inventory.items.size(); i++)
												{
													if (((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(currentPeer->data))->lastTD2)
													{
														currentItemCount = (unsigned int)((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemCount;
														if (currentItemCount < 0)
														{
															currentItemCount = FixCountItem((unsigned int)((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemCount);
														}
													}
												}
												if (currentItemCount - ((PlayerInfo*)(currentPeer->data))->lastCT2 == 0)
												{
													((PlayerInfo*)(currentPeer->data))->cloth_shirt = 0;
													sendClothes(currentPeer);
												}
											}
											else if (((PlayerInfo*)(currentPeer->data))->cloth_shirt == ((PlayerInfo*)(currentPeer->data))->lastTD3)
											{
												short int currentItemCount = 0;
												for (int i = 0; i < ((PlayerInfo*)(currentPeer->data))->inventory.items.size(); i++)
												{
													if (((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(currentPeer->data))->lastTD3)
													{
														currentItemCount = (unsigned int)((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemCount;
														if (currentItemCount < 0)
														{
															currentItemCount = FixCountItem((unsigned int)((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemCount);
														}
													}
												}
												if (currentItemCount - ((PlayerInfo*)(currentPeer->data))->lastCT3 == 0)
												{
													((PlayerInfo*)(currentPeer->data))->cloth_shirt = 0;
													sendClothes(currentPeer);
												}
											}
											else if (((PlayerInfo*)(currentPeer->data))->cloth_shirt == ((PlayerInfo*)(currentPeer->data))->lastTD4)
											{
												short int currentItemCount = 0;
												for (int i = 0; i < ((PlayerInfo*)(currentPeer->data))->inventory.items.size(); i++)
												{
													if (((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(currentPeer->data))->lastTD4)
													{
														currentItemCount = (unsigned int)((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemCount;
														if (currentItemCount < 0)
														{
															currentItemCount = FixCountItem((unsigned int)((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemCount);
														}
													}
												}
												if (currentItemCount - ((PlayerInfo*)(currentPeer->data))->lastCT4 == 0)
												{
													((PlayerInfo*)(currentPeer->data))->cloth_shirt = 0;
													sendClothes(currentPeer);
												}
											}

											if (((PlayerInfo*)(currentPeer->data))->cloth_pants == ((PlayerInfo*)(currentPeer->data))->lastTD1)
											{
												short int currentItemCount = 0;
												for (int i = 0; i < ((PlayerInfo*)(currentPeer->data))->inventory.items.size(); i++)
												{
													if (((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(currentPeer->data))->lastTD1)
													{
														currentItemCount = (unsigned int)((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemCount;
														if (currentItemCount < 0)
														{
															currentItemCount = FixCountItem((unsigned int)((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemCount);
														}
													}
												}
												if (currentItemCount - ((PlayerInfo*)(currentPeer->data))->lastCT1 == 0)
												{
													((PlayerInfo*)(currentPeer->data))->cloth_pants = 0;
													sendClothes(currentPeer);
												}
											}
											else if (((PlayerInfo*)(currentPeer->data))->cloth_pants == ((PlayerInfo*)(currentPeer->data))->lastTD2)
											{
												short int currentItemCount = 0;
												for (int i = 0; i < ((PlayerInfo*)(currentPeer->data))->inventory.items.size(); i++)
												{
													if (((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(currentPeer->data))->lastTD2)
													{
														currentItemCount = (unsigned int)((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemCount;
														if (currentItemCount < 0)
														{
															currentItemCount = FixCountItem((unsigned int)((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemCount);
														}
													}
												}
												if (currentItemCount - ((PlayerInfo*)(currentPeer->data))->lastCT2 == 0)
												{
													((PlayerInfo*)(currentPeer->data))->cloth_pants = 0;
													sendClothes(currentPeer);
												}
											}
											else if (((PlayerInfo*)(currentPeer->data))->cloth_pants == ((PlayerInfo*)(currentPeer->data))->lastTD3)
											{
												short int currentItemCount = 0;
												for (int i = 0; i < ((PlayerInfo*)(currentPeer->data))->inventory.items.size(); i++)
												{
													if (((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(currentPeer->data))->lastTD3)
													{
														currentItemCount = (unsigned int)((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemCount;
														if (currentItemCount < 0)
														{
															currentItemCount = FixCountItem((unsigned int)((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemCount);
														}
													}
												}
												if (currentItemCount - ((PlayerInfo*)(currentPeer->data))->lastCT3 == 0)
												{
													((PlayerInfo*)(currentPeer->data))->cloth_pants = 0;
													sendClothes(currentPeer);
												}
											}
											else if (((PlayerInfo*)(currentPeer->data))->cloth_pants == ((PlayerInfo*)(currentPeer->data))->lastTD4)
											{
												short int currentItemCount = 0;
												for (int i = 0; i < ((PlayerInfo*)(currentPeer->data))->inventory.items.size(); i++)
												{
													if (((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemID == ((PlayerInfo*)(currentPeer->data))->lastTD4)
													{
														currentItemCount = (unsigned int)((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemCount;
														if (currentItemCount < 0)
														{
															currentItemCount = FixCountItem((unsigned int)((PlayerInfo*)(currentPeer->data))->inventory.items.at(i).itemCount);
														}
													}
												}
												if (currentItemCount - ((PlayerInfo*)(currentPeer->data))->lastCT4 == 0)
												{
													((PlayerInfo*)(currentPeer->data))->cloth_pants = 0;
													sendClothes(currentPeer);
												}
											}
											//End Current Peer
											Player::OnConsoleMessage(peer, "`w" + ((PlayerInfo*)(peer->data))->displayName + " `1traded " + cpeertraded + " to `w" + ((PlayerInfo*)(currentPeer->data))->displayName);
											Player::OnConsoleMessage(peer, "`w" + ((PlayerInfo*)(currentPeer->data))->displayName + " `1traded " + peertraded + " to `w" + ((PlayerInfo*)(peer->data))->displayName);
											((PlayerInfo*)(peer->data))->lastTradeAcceptCount = 0;
											((PlayerInfo*)(currentPeer->data))->lastTradeAcceptCount = 0;
											((PlayerInfo*)(peer->data))->lastTradeNetID = 0;
											((PlayerInfo*)(currentPeer->data))->lastTradeNetID = 0;
											((PlayerInfo*)(peer->data))->isTradingWithUser = 0;
											((PlayerInfo*)(currentPeer->data))->isTradingWithUser = 0;
											((PlayerInfo*)(peer->data))->isDoTrade = 0;
											((PlayerInfo*)(currentPeer->data))->isDoTrade = 0;
											((PlayerInfo*)(peer->data))->lastTD1 = 0;
											((PlayerInfo*)(peer->data))->lastTD2 = 0;
											((PlayerInfo*)(peer->data))->lastTD3 = 0;
											((PlayerInfo*)(peer->data))->lastTD4 = 0;
											((PlayerInfo*)(peer->data))->lastCT1 = 0;
											((PlayerInfo*)(peer->data))->lastCT2 = 0;
											((PlayerInfo*)(peer->data))->lastCT3 = 0;
											((PlayerInfo*)(peer->data))->lastCT4 = 0;
											((PlayerInfo*)(currentPeer->data))->lastTD1 = 0;
											((PlayerInfo*)(currentPeer->data))->lastTD2 = 0;
											((PlayerInfo*)(currentPeer->data))->lastTD3 = 0;
											((PlayerInfo*)(currentPeer->data))->lastTD4 = 0;
											((PlayerInfo*)(currentPeer->data))->lastCT1 = 0;
											((PlayerInfo*)(currentPeer->data))->lastCT2 = 0;
											((PlayerInfo*)(currentPeer->data))->lastCT3 = 0;
											((PlayerInfo*)(currentPeer->data))->lastCT4 = 0;
										}
										else
										{
											Player::OnConsoleMessage(peer, "`6[``Trade accepted, waiting for other player to accept`6]``");
											//SendTalkSelf(currentPeer, "`6[``Trade accepted, waiting for other player to accept`6]``");
										}
									}
									else
									{
										Player::OnTextOverlay(peer, "The other person left the trade!");
										((PlayerInfo*)(peer->data))->currentTradeItems = "";
										((PlayerInfo*)(peer->data))->lastTradeAcceptCount = 0;
										((PlayerInfo*)(peer->data))->lastTradeNetID = 0;
										((PlayerInfo*)(peer->data))->isTradingWithUser = 0;
										((PlayerInfo*)(peer->data))->isDoTrade = 0;
										((PlayerInfo*)(peer->data))->lastTD1 = 0;
										((PlayerInfo*)(peer->data))->lastTD2 = 0;
										((PlayerInfo*)(peer->data))->lastTD3 = 0;
										((PlayerInfo*)(peer->data))->lastTD4 = 0;
										((PlayerInfo*)(peer->data))->lastCT1 = 0;
										((PlayerInfo*)(peer->data))->lastCT2 = 0;
										((PlayerInfo*)(peer->data))->lastCT3 = 0;
										((PlayerInfo*)(peer->data))->lastCT4 = 0;
									}

								}
							}

						}
					}

					if (cch.find("action|trade_started") == 0)
					{
						std::stringstream ss(cch);
						std::string to;
						int netid = -1;

						while (std::getline(ss, to, '\n')) {
							vector<string> infoDat = explode("|", to);



							if (infoDat.size() == 2) {
								if (infoDat[0] == "netid") netid = atoi(infoDat[1].c_str());
							}
						}

						if (netid < 0) continue;


						((PlayerInfo*)(peer->data))->item1 = 0;
						((PlayerInfo*)(peer->data))->item1count = 0;
						((PlayerInfo*)(peer->data))->item2 = 0;
						((PlayerInfo*)(peer->data))->item2count = 0;
						((PlayerInfo*)(peer->data))->item3 = 0;
						((PlayerInfo*)(peer->data))->item3count = 0;
						((PlayerInfo*)(peer->data))->item4 = 0;
						((PlayerInfo*)(peer->data))->item4count = 0;
						((PlayerInfo*)(peer->data))->accepted = false;


						ENetPeer* currentPeer;
						for (currentPeer = server->peers;
							currentPeer < &server->peers[server->peerCount];
							++currentPeer)
						{
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
								continue;
							tradestatus(peer, ((PlayerInfo*)(currentPeer->data))->netID, "", ((PlayerInfo*)(currentPeer->data))->displayName, "locked|0\nreset_locks|1\naccepted|0");
							tradestatus(currentPeer, ((PlayerInfo*)(peer->data))->netID, "", ((PlayerInfo*)(peer->data))->displayName, "locked|0\nreset_locks|1\naccepted|0");
						}
					}
					if (cch.find("action|trade_accept") == 0)
					{
						ENetPeer* currentPeer;
						for (currentPeer = server->peers;
							currentPeer < &server->peers[server->peerCount];
							++currentPeer)
						{
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
								continue;
							if (((PlayerInfo*)(currentPeer->data))->rawName == ((PlayerInfo*)(peer->data))->tradingme)
							{
								if (((PlayerInfo*)(currentPeer->data))->accepted == true)
								{
									GamePacket p2 = packetEnd(appendString(createPacket(), "OnForceTradeEnd"));
									ENetPacket* packet1 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet1);
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(currentPeer, 0, packet2);
									delete p2.data;
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "add_label_with_icon|big|`wTrade Confirmation``|left|1366|\nadd_spacer|small|\n\nadd_label|small|`4You'll give:``|left|4|\nadd_spacer|small|\n\nadd_label_with_icon|small|`o(`w" + to_string(((PlayerInfo*)(peer->data))->item1count) + "`o) " + itemDefs[((PlayerInfo*)(peer->data))->item1].name + "``|left|" + to_string(((PlayerInfo*)(peer->data))->item1) + "|\n\nadd_label_with_icon|small|`o(`w" + to_string(((PlayerInfo*)(peer->data))->item2count) + "`o) " + itemDefs[((PlayerInfo*)(peer->data))->item2].name + "``|left|" + to_string(((PlayerInfo*)(peer->data))->item2) + "|\n\nadd_label_with_icon|small|`o(`w" + to_string(((PlayerInfo*)(peer->data))->item3count) + "`o) " + itemDefs[((PlayerInfo*)(peer->data))->item3].name + "``|left|" + to_string(((PlayerInfo*)(peer->data))->item3) + "|\n\nadd_label_with_icon|small|`o(`w" + to_string(((PlayerInfo*)(peer->data))->item4count) + "`o) " + itemDefs[((PlayerInfo*)(peer->data))->item4].name + "``|left|" + to_string(((PlayerInfo*)(peer->data))->item4) + "|\nadd_spacer|small|\n\nadd_label|small|`2You'll get:``|left|4|\nadd_spacer|small|\n\nadd_label_with_icon|small|`o(`w" + to_string(((PlayerInfo*)(currentPeer->data))->item1count) + "`o) " + itemDefs[((PlayerInfo*)(currentPeer->data))->item1].name + "``|left|" + to_string(((PlayerInfo*)(currentPeer->data))->item1) + "|\n\nadd_label_with_icon|small|`o(`w" + to_string(((PlayerInfo*)(currentPeer->data))->item2count) + "`o) " + itemDefs[((PlayerInfo*)(currentPeer->data))->item2].name + "``|left|" + to_string(((PlayerInfo*)(currentPeer->data))->item2) + "|\n\nadd_label_with_icon|small|`o(`w" + to_string(((PlayerInfo*)(currentPeer->data))->item3count) + "`o) " + itemDefs[((PlayerInfo*)(currentPeer->data))->item3].name + "``|left|" + to_string(((PlayerInfo*)(currentPeer->data))->item3) + "|\n\nadd_label_with_icon|small|`o(`w" + to_string(((PlayerInfo*)(currentPeer->data))->item4count) + "`o) " + itemDefs[((PlayerInfo*)(currentPeer->data))->item4].name + "``|left|" + to_string(((PlayerInfo*)(currentPeer->data))->item4) + "|\nadd_spacer|small|\nadd_button|dothetrade|`oDo The Trade!``|0|0|\nadd_button|notrade|`oCancel``|0|0|"));
									ENetPacket* packet3 = enet_packet_create(p.data,
										p.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet3);
									GamePacket p1 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "add_label_with_icon|big|`wTrade Confirmation``|left|1366|\nadd_spacer|small|\n\nadd_label|small|`4You'll give:``|left|4|\nadd_spacer|small|\n\nadd_label_with_icon|small|`o(`w" + to_string(((PlayerInfo*)(currentPeer->data))->item1count) + "`o) " + itemDefs[((PlayerInfo*)(currentPeer->data))->item1].name + "``|left|" + to_string(((PlayerInfo*)(currentPeer->data))->item1) + "|\n\nadd_label_with_icon|small|`o(`w" + to_string(((PlayerInfo*)(currentPeer->data))->item2count) + "`o) " + itemDefs[((PlayerInfo*)(currentPeer->data))->item2].name + "``|left|" + to_string(((PlayerInfo*)(currentPeer->data))->item2) + "|\n\nadd_label_with_icon|small|`o(`w" + to_string(((PlayerInfo*)(currentPeer->data))->item3count) + "`o) " + itemDefs[((PlayerInfo*)(currentPeer->data))->item3].name + "``|left|" + to_string(((PlayerInfo*)(currentPeer->data))->item3) + "|\n\nadd_label_with_icon|small|`o(`w" + to_string(((PlayerInfo*)(currentPeer->data))->item4count) + "`o) " + itemDefs[((PlayerInfo*)(currentPeer->data))->item4].name + "``|left|" + to_string(((PlayerInfo*)(currentPeer->data))->item4) + "|\nadd_spacer|small|\n\nadd_label|small|`2You'll get:``|left|4|\nadd_spacer|small|\n\nadd_label_with_icon|small|`o(`w" + to_string(((PlayerInfo*)(peer->data))->item1count) + "`o) " + itemDefs[((PlayerInfo*)(peer->data))->item1].name + "``|left|" + to_string(((PlayerInfo*)(peer->data))->item1) + "|\n\nadd_label_with_icon|small|`o(`w" + to_string(((PlayerInfo*)(peer->data))->item2count) + "`o) " + itemDefs[((PlayerInfo*)(peer->data))->item2].name + "``|left|" + to_string(((PlayerInfo*)(peer->data))->item2) + "|\n\nadd_label_with_icon|small|`o(`w" + to_string(((PlayerInfo*)(peer->data))->item3count) + "`o) " + itemDefs[((PlayerInfo*)(peer->data))->item3].name + "``|left|" + to_string(((PlayerInfo*)(peer->data))->item3) + "|\n\nadd_label_with_icon|small|`o(`w" + to_string(((PlayerInfo*)(peer->data))->item4count) + "`o) " + itemDefs[((PlayerInfo*)(peer->data))->item4].name + "``|left|" + to_string(((PlayerInfo*)(peer->data))->item4) + "|\nadd_spacer|small|\nadd_button|dothetrade|`oDo The Trade!``|0|0|\nadd_button|notrade|`oCancel``|0|0|"));
									ENetPacket* packet4 = enet_packet_create(p1.data,
										p1.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(currentPeer, 0, packet4);
									delete p.data;
									delete p1.data;
								}
								else
								{
									tradestatus(currentPeer, ((PlayerInfo*)(peer->data))->netID, "", ((PlayerInfo*)(peer->data))->displayName, "add_slot|" + to_string(((PlayerInfo*)(peer->data))->item1) + "|" + to_string(((PlayerInfo*)(peer->data))->item1count) + "\nadd_slot|" + to_string(((PlayerInfo*)(peer->data))->item2) + "|" + to_string(((PlayerInfo*)(peer->data))->item2count) + "\nadd_slot|" + to_string(((PlayerInfo*)(peer->data))->item3) + "|" + to_string(((PlayerInfo*)(peer->data))->item3count) + "\nadd_slot|" + to_string(((PlayerInfo*)(peer->data))->item4) + "|" + to_string(((PlayerInfo*)(peer->data))->item4count) + "locked|0\nreset_locks|0\naccepted|1");
									((PlayerInfo*)(peer->data))->accepted = true;
								}
							}
						}
					}
					string tradeText = "action|mod_trade";
					if (cch.find(tradeText) == 0)
					{
						std::stringstream ss(cch);
						std::string to;
						int idd = -1;

						while (std::getline(ss, to, '\n')) {
							vector<string> infoDat = explode("|", to);
							if (infoDat.size() == 2) {
								if (infoDat[0] == "itemID") idd = atoi(infoDat[1].c_str());
							}
						}


						if (idd == 1) continue;
						if (((PlayerInfo*)(peer->data))->item1 == 0)
						{
							if (idd == 18 || idd == 32 || idd == 6336 || idd == 8552 || idd == 9472 || idd == 9482 || idd == 9356 || idd == 9492 || idd == 9498 || idd == 8774 || idd == 1790 || idd == 2592 || idd == 1784 || idd == 1792 || idd == 1794 || idd == 7734 || idd == 8306 || idd == 9458)
							{
								GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`wYou'd be sorry sorry if you lost that!"));
								ENetPacket* packet1 = enet_packet_create(ps.data,
									ps.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet1);
								delete ps.data;
								continue;
							}
							else
							{
								((PlayerInfo*)(peer->data))->item1 = idd;
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "add_label_with_icon|big|`2Trade`w " + itemDefs[idd].name + "``|left|" + to_string(idd) + "|\nadd_textbox|`2Trade how many?|\nadd_text_input|itemcount|||3|\nend_dialog|tradingdialog|Cancel|Ok|\n"));
								ENetPacket* packet1 = enet_packet_create(p.data,
									p.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet1);
								delete p.data;
							}
							continue;
						}


						if (((PlayerInfo*)(peer->data))->item2 == 0)
						{
							if (idd == 18 || idd == 32 || idd == 6336 || idd == 8552 || idd == 9472 || idd == 9482 || idd == 9356 || idd == 9492 || idd == 9498 || idd == 8774 || idd == 1790 || idd == 2592 || idd == 1784 || idd == 1792 || idd == 1794 || idd == 7734 || idd == 8306 || idd == 9458)
							{
								GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`wYou'd be sorry sorry if you lost that!"));
								ENetPacket* packet1 = enet_packet_create(ps.data,
									ps.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet1);
								delete ps.data;
								continue;
							}
							else
							{
								((PlayerInfo*)(peer->data))->item2 = idd;
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "add_label_with_icon|big|`2Trade`w " + itemDefs[idd].name + "``|left|" + to_string(idd) + "|\nadd_textbox|`2Trade how many?|\nadd_text_input|itemcount2|||3|\nend_dialog|tradingdialog|Cancel|Ok|\n"));
								ENetPacket* packet1 = enet_packet_create(p.data,
									p.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet1);
								delete p.data;
								continue;
							}
						}

						if (((PlayerInfo*)(peer->data))->item3 == 0)
						{
							if (idd == 18 || idd == 32 || idd == 6336 || idd == 8552 || idd == 9472 || idd == 9482 || idd == 9356 || idd == 9492 || idd == 9498 || idd == 8774 || idd == 1790 || idd == 2592 || idd == 1784 || idd == 1792 || idd == 1794 || idd == 7734 || idd == 8306 || idd == 9458)
							{
								GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`wYou'd be sorry sorry if you lost that!"));
								ENetPacket* packet1 = enet_packet_create(ps.data,
									ps.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet1);
								delete ps.data;
								continue;
							}
							else
							{
								((PlayerInfo*)(peer->data))->item3 = idd;
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "add_label_with_icon|big|`2Trade`w " + itemDefs[idd].name + "``|left|" + to_string(idd) + "|\nadd_textbox|`2Trade how many?|\nadd_text_input|itemcount3|||3|\nend_dialog|tradingdialog|Cancel|Ok|\n"));
								ENetPacket* packet1 = enet_packet_create(p.data,
									p.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet1);
								delete p.data;
								continue;
							}
						}

						if (((PlayerInfo*)(peer->data))->item4 == 0)
						{
							if (idd == 18 || idd == 32 || idd == 6336 || idd == 8552 || idd == 9472 || idd == 9482 || idd == 9356 || idd == 9492 || idd == 9498 || idd == 8774 || idd == 1790 || idd == 2592 || idd == 1784 || idd == 1792 || idd == 1794 || idd == 7734 || idd == 8306 || idd == 9458)
							{
								GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`wYou'd be sorry sorry if you lost that!"));
								ENetPacket* packet1 = enet_packet_create(ps.data,
									ps.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet1);
								delete ps.data;
								continue;
							}
							else
							{
								((PlayerInfo*)(peer->data))->item4 = idd;
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "add_label_with_icon|big|`2Trade`w " + itemDefs[idd].name + "``|left|" + to_string(idd) + "|\nadd_textbox|`2Trade how many?|\nadd_text_input|itemcount4|||3|\nend_dialog|tradingdialog|Cancel|Ok|\n"));
								ENetPacket* packet1 = enet_packet_create(p.data,
									p.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet1);
								delete p.data;
								continue;
							}
						}
					}
					if (cch.find("action|trade_cancel") == 0)
					{
						GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`wYou canceled the trade."));
						ENetPacket* packet1 = enet_packet_create(p.data,
							p.len,
							ENET_PACKET_FLAG_RELIABLE);
						enet_peer_send(peer, 0, packet1);
						delete p.data;

						((PlayerInfo*)(peer->data))->item1 = 0;
						((PlayerInfo*)(peer->data))->item1count = 0;
						((PlayerInfo*)(peer->data))->item2 = 0;
						((PlayerInfo*)(peer->data))->item2count = 0;
						((PlayerInfo*)(peer->data))->item3 = 0;
						((PlayerInfo*)(peer->data))->item3count = 0;
						((PlayerInfo*)(peer->data))->item4 = 0;
						((PlayerInfo*)(peer->data))->item4count = 0;
						((PlayerInfo*)(peer->data))->istrading = false;
						((PlayerInfo*)(peer->data))->accepted = false;
						((PlayerInfo*)(peer->data))->dotrade = false;

						ENetPeer* currentPeer;
						for (currentPeer = server->peers;
							currentPeer < &server->peers[server->peerCount];
							++currentPeer)
						{
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
								continue;
							if (((PlayerInfo*)(currentPeer->data))->rawName == ((PlayerInfo*)(peer->data))->tradingme)
							{
								GamePacket p24 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), ((PlayerInfo*)(peer->data))->displayName + " `wcanceled the trade."));

								ENetPacket* packet2 = enet_packet_create(p24.data,
									p24.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(currentPeer, 0, packet2);

								GamePacket p2 = packetEnd(appendString(createPacket(), "OnForceTradeEnd"));

								ENetPacket* packet3 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(currentPeer, 0, packet3);

								ENetPacket* packet4 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet4);

								delete p24.data;
								delete p2.data;

								((PlayerInfo*)(currentPeer->data))->item1 = 0;
								((PlayerInfo*)(currentPeer->data))->item1count = 0;
								((PlayerInfo*)(currentPeer->data))->item2 = 0;
								((PlayerInfo*)(currentPeer->data))->item2count = 0;
								((PlayerInfo*)(currentPeer->data))->item3 = 0;
								((PlayerInfo*)(currentPeer->data))->item3count = 0;
								((PlayerInfo*)(currentPeer->data))->item4 = 0;
								((PlayerInfo*)(currentPeer->data))->item4count = 0;
								((PlayerInfo*)(currentPeer->data))->tradingme = "";
								((PlayerInfo*)(currentPeer->data))->istrading = false;
								((PlayerInfo*)(currentPeer->data))->accepted = false;
								((PlayerInfo*)(currentPeer->data))->dotrade = false;
							}
						}
						((PlayerInfo*)(peer->data))->tradingme = "";
					}

					if (cch.find("action|rem_trade") == 0) {
						std::stringstream ss(cch);
						std::string to;
						int itemid = -1;
						int count = 0;
						while (std::getline(ss, to, '\n')) {
							vector<string> infoDat = explode("|", to);
							if (infoDat.size() == 2) {

								if (infoDat[0] == "itemID") itemid = atoi(infoDat[1].c_str());
								if (infoDat[0] == "count") count = atoi(infoDat[1].c_str());

							}
						}
						if (itemid == -1) continue;
						if (itemDefs.size() < itemid || itemid < 0) continue;
						ENetPeer* currentPeer;
						for (currentPeer = server->peers;
							currentPeer < &server->peers[server->peerCount];
							++currentPeer)
						{
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
								continue;
							if (isHere(peer, currentPeer))
							{
								if (((PlayerInfo*)(currentPeer->data))->netID == ((PlayerInfo*)(peer->data))->lastTradeNetID)
								{
									if (((PlayerInfo*)(peer->data))->lastTD1 == itemid)
									{
										((PlayerInfo*)(peer->data))->lastTD1 = 0;
										((PlayerInfo*)(peer->data))->lastCT1 = 0;
									}
									else if (((PlayerInfo*)(peer->data))->lastTD2 == itemid)
									{
										((PlayerInfo*)(peer->data))->lastTD2 = 0;
										((PlayerInfo*)(peer->data))->lastCT2 = 0;
									}
									else if (((PlayerInfo*)(peer->data))->lastTD3 == itemid)
									{
										((PlayerInfo*)(peer->data))->lastTD3 = 0;
										((PlayerInfo*)(peer->data))->lastCT3 = 0;
									}
									else if (((PlayerInfo*)(peer->data))->lastTD4 == itemid)
									{
										((PlayerInfo*)(peer->data))->lastTD4 = 0;
										((PlayerInfo*)(peer->data))->lastCT4 = 0;
									}
									replace(((PlayerInfo*)(peer->data))->currentTradeItems, "add_slot|" + to_string(itemid), "");
									Player::OnTradeStatus(peer, ((PlayerInfo*)(peer->data))->netID, ((PlayerInfo*)(peer->data))->displayName, ((PlayerInfo*)(peer->data))->currentTradeItems);
									Player::OnTradeStatus(currentPeer, ((PlayerInfo*)(peer->data))->netID, ((PlayerInfo*)(peer->data))->displayName, ((PlayerInfo*)(peer->data))->currentTradeItems);
									Player::OnTextOverlay(peer, "The deal has changed");
									Player::OnTextOverlay(currentPeer, "The deal has changed");
									Player::PlayAudio(peer, "audio/tile_removed.wav", 0);
									Player::PlayAudio(currentPeer, "audio/tile_removed.wav", 0);
								}

							}
						}
					}
					string dropText = "action|drop\n|itemID|";
				    if (((PlayerInfo*)(peer->data))->istrading == true)
					{
						//Player::OnConsoleMessage(peer, "`4You cant drop while trading.");
					}
					else if (cch.find(dropText) == 0)
					{
						if (static_cast<PlayerInfo*>(peer->data)->haveGrowId == true)
						{
							if (static_cast<PlayerInfo*>(peer->data)->isCursed == true)
							{
								Player::OnConsoleMessage(peer, "`4You are cursed now!");
								continue;
							}
							std::stringstream ss(cch);
							std::string to;
							int idx = -1;
							int count = -1;
							while (std::getline(ss, to, '\n'))
							{
								vector<string> infoDat = explode("|", to);
								if (infoDat.size() == 3)
								{
									if (infoDat[1] == "itemID") idx = atoi(infoDat[2].c_str());
									if (infoDat[1] == "count") count = atoi(infoDat[2].c_str());
								}
							}
							static_cast<PlayerInfo*>(peer->data)->lastdropitem = idx;
							static_cast<PlayerInfo*>(peer->data)->lastdropitemcount = count;
							if (idx == -1) continue;
							if (itemDefs.size() < idx || idx < 0) continue;
							int x = static_cast<PlayerInfo*>(peer->data)->x + (32 * (static_cast<PlayerInfo*>(peer->data)->isRotatedLeft ? -1 : 1));
							x /= 32;
							int y = static_cast<PlayerInfo*>(peer->data)->y / 32;
							if (static_cast<PlayerInfo*>(peer->data)->lastdropitem == 18 || static_cast<PlayerInfo*>(peer->data)->lastdropitem == 32 || static_cast<PlayerInfo*>(peer->data)->lastdropitem == 6336 || static_cast<PlayerInfo*>(peer->data)->lastdropitem == 8552 || static_cast<PlayerInfo*>(peer->data)->lastdropitem == 9472 || static_cast<PlayerInfo*>(peer->data)->lastdropitem == 1782 || static_cast<PlayerInfo*>(peer->data)->lastdropitem == 1784 || static_cast<PlayerInfo*>(peer->data)->lastdropitem == 1780 || static_cast<PlayerInfo*>(peer->data)->lastdropitem == 9482 || static_cast<PlayerInfo*>(peer->data)->lastdropitem == 9356 || static_cast<PlayerInfo*>(peer->data)->lastdropitem == 9492 || static_cast<PlayerInfo*>(peer->data)->lastdropitem == 9498 || static_cast<PlayerInfo*>(peer->data)->lastdropitem == 8774 || static_cast<PlayerInfo*>(peer->data)->lastdropitem == 1790 || static_cast<PlayerInfo*>(peer->data)->lastdropitem == 2592 || static_cast<PlayerInfo*>(peer->data)->lastdropitem == 1784 || static_cast<PlayerInfo*>(peer->data)->lastdropitem == 1792 || static_cast<PlayerInfo*>(peer->data)->lastdropitem == 1794 || static_cast<PlayerInfo*>(peer->data)->lastdropitem == 7734 || static_cast<PlayerInfo*>(peer->data)->lastdropitem == 1204 || static_cast<PlayerInfo*>(peer->data)->lastdropitem == 8306 || static_cast<PlayerInfo*>(peer->data)->lastdropitem == 9458 || static_cast<PlayerInfo*>(peer->data)->lastdropitem == 5640)
							{
								Player::OnTextOverlay(peer, "You can't drop that.");
								continue;
							}
							/*else if (getItemDef(world->items[x + (y * world->width)].foreground).blockType == BlockTypes::FOREGROUND && world->items[x + (y * world->width)].foreground != 0)
							{
								Player::OnTextOverlay(peer, "You can't drop that here, face somewhere with open space.");
								continue;
							}*/
							else
							{
								auto KiekTuri = 0;
								for (auto i = 0; i < static_cast<PlayerInfo*>(peer->data)->inventory.items.size(); i++)
								{
									if (static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemID == static_cast<PlayerInfo*>(peer->data)->lastdropitem && static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount >= 1)
									{

										KiekTuri = static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount;

									}
								}
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`wDrop " + itemDefs.at(idx).name + "``|left|" + std::to_string(idx) + "|\nadd_textbox|`oHow many to drop?|\nadd_text_input|dropitemcount||" + to_string(KiekTuri) + "|3|||\nend_dialog|dropdialog|Cancel|OK|\n");
								continue;
							}
						}
						else
						{
							Player::OnTextOverlay(peer, "`^This Feature Only `9Available `^For Registered Players!");
						}
					}
					string trashText = "action|trash\n|itemID|";
					if (((PlayerInfo*)(peer->data))->istrading == true)
					{
						//Player::OnConsoleMessage(peer, "`4You cant trash while trading.");
					}
					else if (cch.find(trashText) == 0)
					{
						std::stringstream ss(cch);
						std::string to;
						int idx = -1;
						int count = -1;
						while (std::getline(ss, to, '\n'))
						{
							vector<string> infoDat = explode("|", to);
							if (infoDat.size() == 3)
							{
								if (infoDat[1] == "itemID") idx = atoi(infoDat[2].c_str());
								if (infoDat[1] == "count") count = atoi(infoDat[2].c_str());
							}
						}
						static_cast<PlayerInfo*>(peer->data)->lasttrashitem = idx;
						static_cast<PlayerInfo*>(peer->data)->lasttrashitemcount = count;
						if (idx == -1) continue;
						if (itemDefs.size() < idx || idx < 0) continue;
						if (static_cast<PlayerInfo*>(peer->data)->lasttrashitem == 18 || static_cast<PlayerInfo*>(peer->data)->lasttrashitem == 32 || static_cast<PlayerInfo*>(peer->data)->lasttrashitem == 6336 || static_cast<PlayerInfo*>(peer->data)->lasttrashitem == 8552 || static_cast<PlayerInfo*>(peer->data)->lasttrashitem == 9472 || static_cast<PlayerInfo*>(peer->data)->lasttrashitem == 9482 || static_cast<PlayerInfo*>(peer->data)->lasttrashitem == 9356 || static_cast<PlayerInfo*>(peer->data)->lasttrashitem == 9492 || static_cast<PlayerInfo*>(peer->data)->lasttrashitem == 9498 || static_cast<PlayerInfo*>(peer->data)->lasttrashitem == 8774 || static_cast<PlayerInfo*>(peer->data)->lasttrashitem == 1790 || static_cast<PlayerInfo*>(peer->data)->lasttrashitem == 2592 || static_cast<PlayerInfo*>(peer->data)->lasttrashitem == 1784 || static_cast<PlayerInfo*>(peer->data)->lasttrashitem == 1792 || static_cast<PlayerInfo*>(peer->data)->lasttrashitem == 1794 || static_cast<PlayerInfo*>(peer->data)->lasttrashitem ==
							7734 || static_cast<PlayerInfo*>(peer->data)->lasttrashitem == 8306 || static_cast<PlayerInfo*>(peer->data)->lasttrashitem == 9458 || static_cast<PlayerInfo*>(peer->data)->lasttrashitem == 10034)
						{
							Player::OnTextOverlay(peer, "You can't trash that.");
							continue;
						}
						else
						{
							auto KiekTuri = 0;
							for (auto i = 0; i < static_cast<PlayerInfo*>(peer->data)->inventory.items.size(); i++)
							{
								if (static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemID == static_cast<PlayerInfo*>(peer->data)->lasttrashitem && static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount >= 1)
								{

									KiekTuri = static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount;

								}
							}
							Player::OnDialogRequest(peer, "add_label_with_icon|big|`4Trash `w" + itemDefs.at(idx).name + "``|left|" + std::to_string(idx) + "|\nadd_textbox|`oHow many to `4destroy`o? (you have " + to_string(KiekTuri) + ")|\nadd_text_input|trashitemcount||0|3|\nend_dialog|trashdialog|Cancel|OK|\n");
						}
					}
					if (cch.find("text|") != std::string::npos)
					{
						bool canchat = true;
						PlayerInfo* pData = static_cast<PlayerInfo*>(peer->data);
						if (str.length() > 120)
						{
							Player::OnConsoleMessage(peer, "`4Too many symbols");
							continue;
						}
						if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
						{
							continue;
						}
						//SendConsole("Text action received details: str(" + str + ") rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ") currentWorld(" + static_cast<PlayerInfo*>(peer->data)->currentWorld + ")", "INFO");
						if (str.length() && str[0] == '/')
						{
							sendAction(peer, static_cast<PlayerInfo*>(peer->data)->netID, str);
							if (str.find("/msg") != string::npos)
							{
								if (!static_cast<PlayerInfo*>(peer->data)->Console)
								{
									Player::OnConsoleMessage(peer, "CP:_PL:0_OID:_CT:[MSG]_ `6" + str);
								}
							}
							else if (str.find("/r") != string::npos)
							{
								if (!static_cast<PlayerInfo*>(peer->data)->Console)
								{
									Player::OnConsoleMessage(peer, "CP:_PL:0_OID:_CT:[MSG]_ `6" + str);
								}
							}
							else if (str.find("/sb") != string::npos)
							{
								if (!static_cast<PlayerInfo*>(peer->data)->Console)
								{
									Player::OnConsoleMessage(peer, "CP:_PL:0_OID:_CT:[SB]_ `6" + str);
								}
							}
							else if (str.find("/ssb") != string::npos)
							{
								if (!static_cast<PlayerInfo*>(peer->data)->Console)
								{
									Player::OnConsoleMessage(peer, "CP:_PL:0_OID:_CT:[CB]_ `6" + str);
								}
							}
							else
							{
								if (!static_cast<PlayerInfo*>(peer->data)->Console)
								{
									Player::OnConsoleMessage(peer, "`6" + str);
								}
							}
							ENetPeer* currentPeer;
							for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer)
							{
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
								if (static_cast<PlayerInfo*>(currentPeer->data)->GlobalChat)
								{
									Player::OnConsoleMessage(currentPeer, "CP:_PL:0_OID:_CT:[W]_ `6<`w" + static_cast<PlayerInfo*>(peer->data)->displayName + "`6> `" + static_cast<PlayerInfo*>(peer->data)->chatcolor + str);
								}
							}
						}
						else if (static_cast<PlayerInfo*>(peer->data)->taped == false)
						{
							SendChat(peer, static_cast<PlayerInfo*>(peer->data)->netID, str);
							SendConsole("" + static_cast<PlayerInfo*>(peer->data)->rawName + " (" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "): " + str, "CHAT");
						}
						else
						{
							for (char c : str)
							{
								if (str.find(" "))
								{
									canchat = false;
								}
							}
							if (canchat)
							{
								if (std::experimental::filesystem::exists("timemuted/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt"))
								{
									Player::OnConsoleMessage(peer, "`4You are muted now.`8 Your mute will expire in `2" + OutputBanTime(calcBanDuration(static_cast<PlayerInfo*>(peer->data)->lastMuted)) + "");
									const string mf[4] = { "mf ff mf fm", "f fmf fmfmf fmm", "mfm ff mf mf", "mff ffmf mf " };
									string word = mf[rand() % 4];
									SendChat(peer, static_cast<PlayerInfo*>(peer->data)->netID, word);
									continue;
								}
								else
								{
									static_cast<PlayerInfo*>(peer->data)->taped = false;
									static_cast<PlayerInfo*>(peer->data)->isDuctaped = false;
									static_cast<PlayerInfo*>(peer->data)->cantsay = false;
									send_state(peer);
									sendClothes(peer);
								}
							}
						}
						if (static_cast<PlayerInfo*>(peer->data)->haveGrowId == true)
						{
							if (str == "/ghost")
							{
								if (!isMod(peer))
								{
									//sendwrongcmd(peer);
									continue;
								}
								if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "GAME1")
								{
									Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4You can't use this command in `2GAME1", 0, false);
									continue;
								}
								if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "GAME2")
								{
									Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4You can't use this command in `2GAME2", 0, false);
									continue;
								}
								SendGhost(peer);
							}
							else if (str == "/mods")
							{
								string x;
								ENetPeer* currentPeer;
								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									if (isMod(currentPeer) && static_cast<PlayerInfo*>(currentPeer->data)->isinv == false && static_cast<PlayerInfo*>(currentPeer->data)->isNicked == false && !static_cast<PlayerInfo*>(currentPeer->data)->Console)
									{
										x.append("" + static_cast<PlayerInfo*>(currentPeer->data)->displayName + "`w, ");
									}
								}
								x = x.substr(0, x.length() - 2);
								if (x == "")
								{
									x = "(All are hidden)";
								}
								Player::OnConsoleMessage(peer, "`oMods online: " + x);
							}
							else if (str == "/tradeinfo")
							{
								if (static_cast<PlayerInfo*>(peer->data)->receivedFrom == "")
								{
									Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4You don't have any trade offers!``", 0, false);
									continue;
								}

								ENetPeer* currentPeer;
								bool found = false;
								for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
									if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == PlayerDB::getProperName(static_cast<PlayerInfo*>(peer->data)->receivedFrom))
									{
										found = true;
										if (static_cast<PlayerInfo*>(currentPeer->data)->lastTradeGrowid != static_cast<PlayerInfo*>(peer->data)->rawName) break;
										GTDialog receivedTrade;
										receivedTrade.addLabelWithIcon("`wTrade from `$" + static_cast<PlayerInfo*>(peer->data)->receivedFrom, 9288, LABEL_BIG);
										receivedTrade.addSpacer(SPACER_SMALL);
										receivedTrade.addSmallText("`4You will give:");
										receivedTrade.addSpacer(SPACER_SMALL);
										if (static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem1Count != "0" && static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem1 != "3308")
										{
											receivedTrade.addLabelWithIcon(" `$(`w" + static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem1Count + "`$) " + getItemDef(atoi(static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem1.c_str())).name + "", atoi(static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem1.c_str()), LABEL_SMALL);
										}
										if (static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem2Count != "0" && static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem2 != "3308")
										{
											receivedTrade.addLabelWithIcon(" `$(`w" + static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem2Count + "`$) " + getItemDef(atoi(static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem2.c_str())).name + "", atoi(static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem2.c_str()), LABEL_SMALL);
										}
										if (static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem3Count != "0" && static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem3 != "3308")
										{
											receivedTrade.addLabelWithIcon(" `$(`w" + static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem3Count + "`$) " + getItemDef(atoi(static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem3.c_str())).name + "", atoi(static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem3.c_str()), LABEL_SMALL);
										}
										if (static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem4Count != "0" && static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem4 != "3308")
										{
											receivedTrade.addLabelWithIcon(" `$(`w" + static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem4Count + "`$) " + getItemDef(atoi(static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem4.c_str())).name + "", atoi(static_cast<PlayerInfo*>(currentPeer->data)->hisSellingItem4.c_str()), LABEL_SMALL);
										}
										receivedTrade.addSpacer(SPACER_SMALL);
										receivedTrade.addSmallText("`2You will get:");
										receivedTrade.addSpacer(SPACER_SMALL);
										if (static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem1Count != "0" && static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem1 != "3308")
										{
											receivedTrade.addLabelWithIcon(" `$(`w" + static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem1Count + "`$) " + getItemDef(atoi(static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem1.c_str())).name + "", atoi(static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem1.c_str()), LABEL_SMALL);
										}
										if (static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem2Count != "0" && static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem2 != "3308")
										{
											receivedTrade.addLabelWithIcon(" `$(`w" + static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem2Count + "`$) " + getItemDef(atoi(static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem2.c_str())).name + "", atoi(static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem2.c_str()), LABEL_SMALL);
										}
										if (static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem3Count != "0" && static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem3 != "3308")
										{
											receivedTrade.addLabelWithIcon(" `$(`w" + static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem3Count + "`$) " + getItemDef(atoi(static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem3.c_str())).name + "", atoi(static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem3.c_str()), LABEL_SMALL);
										}
										if (static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem4Count != "0" && static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem4 != "3308")
										{
											receivedTrade.addLabelWithIcon(" `$(`w" + static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem4Count + "`$) " + getItemDef(atoi(static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem4.c_str())).name + "", atoi(static_cast<PlayerInfo*>(currentPeer->data)->mySellingItem4.c_str()), LABEL_SMALL);
										}

										receivedTrade.addSpacer(SPACER_SMALL);
										receivedTrade.addButton("dothetrade", "`2Do The Trade!");
										receivedTrade.addSpacer(SPACER_SMALL);

										receivedTrade.addQuickExit();
										receivedTrade.endDialog("Close", "", "`4Cancel Trade!");
										Player::OnDialogRequest(peer, receivedTrade.finishDialog());
									}
								}
								if (!found)
								{
									static_cast<PlayerInfo*>(peer->data)->receivedFrom = "";
									Player::OnConsoleMessage(peer, "`@Player is not `4Online! `@Trade was `4aborted`@!");
									break;
								}
							}
							else if (str.substr(0, 7) == "/trade ")
							{
								if (str.substr(7, cch.length() - 7 - 1) == "")
								{
									Player::OnConsoleMessage(peer, "`4Usage: `2/trade <growid>");
									continue;
								}

								if (static_cast<PlayerInfo*>(peer->data)->rawName == str.substr(7, cch.length() - 7 - 1))
								{
									Player::OnConsoleMessage(peer, "`4You can't trade with your-self!");
									continue;
								}

								if (static_cast<PlayerInfo*>(peer->data)->isCursed == true)
								{
									Player::OnConsoleMessage(peer, "`4You are cursed now!");
									continue;
								}

								using namespace std::chrono;
								if (static_cast<PlayerInfo*>(peer->data)->lastTrade + 120000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count())
								{
									static_cast<PlayerInfo*>(peer->data)->lastTrade = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
								}
								else
								{
									int kiekDar = (static_cast<PlayerInfo*>(peer->data)->lastTrade + 120000 - (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) / 1000;
									//Player::OnConsoleMessage(peer, "`9Cooldown `@Please Wait `9" + to_string(kiekDar) + " Seconds `@To Make Another Trade!");
									//continue;
								}

								string user = str.substr(7, cch.length() - 7 - 1);
								bool isonline = false;

								static_cast<PlayerInfo*>(peer->data)->mySellingItem1 = "3308";
								static_cast<PlayerInfo*>(peer->data)->mySellingItem2 = "3308";
								static_cast<PlayerInfo*>(peer->data)->mySellingItem3 = "3308";
								static_cast<PlayerInfo*>(peer->data)->mySellingItem4 = "3308";
								static_cast<PlayerInfo*>(peer->data)->mySellingItem1Count = "0";
								static_cast<PlayerInfo*>(peer->data)->mySellingItem2Count = "0";
								static_cast<PlayerInfo*>(peer->data)->mySellingItem3Count = "0";
								static_cast<PlayerInfo*>(peer->data)->mySellingItem4Count = "0";
								static_cast<PlayerInfo*>(peer->data)->hisSellingItem1 = "3308";
								static_cast<PlayerInfo*>(peer->data)->hisSellingItem2 = "3308";
								static_cast<PlayerInfo*>(peer->data)->hisSellingItem3 = "3308";
								static_cast<PlayerInfo*>(peer->data)->hisSellingItem4 = "3308";
								static_cast<PlayerInfo*>(peer->data)->hisSellingItem1Count = "0";
								static_cast<PlayerInfo*>(peer->data)->hisSellingItem2Count = "0";
								static_cast<PlayerInfo*>(peer->data)->hisSellingItem3Count = "0";
								static_cast<PlayerInfo*>(peer->data)->hisSellingItem4Count = "0";

								ENetPeer* currentPeer;
								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == PlayerDB::getProperName(user))
									{
										isonline = true;
										if (!isHere(peer, currentPeer))
										{
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4You must be in the same world with him.", 0, true);
											break;
										}
										static_cast<PlayerInfo*>(peer->data)->lastTradeGrowid = static_cast<PlayerInfo*>(currentPeer->data)->displayName;

										GTDialog tradedialog;
										tradedialog.addLabelWithIcon("`wTrade with `$" + static_cast<PlayerInfo*>(peer->data)->lastTradeGrowid, 1434, LABEL_SMALL);

										tradedialog.addSpacer(SPACER_SMALL);
										tradedialog.addSmallText("`$Add items that you want to sell.");
										tradedialog.addSmallText("`$(click on the boxes below)");
										tradedialog.addSpacer(SPACER_SMALL);

										if (static_cast<PlayerInfo*>(peer->data)->mySellingItem1 == "3308" || static_cast<PlayerInfo*>(peer->data)->mySellingItem1Count == "0")
										{
											tradedialog.addStaticBlueFrameWithIdCountText("6156", "0", "empty", "putMySellingItem_1", false);
										}
										else
										{
											tradedialog.addStaticBlueFrameWithIdCountText(static_cast<PlayerInfo*>(peer->data)->mySellingItem1, static_cast<PlayerInfo*>(peer->data)->mySellingItem1Count, getItemDef(atoi(static_cast<PlayerInfo*>(peer->data)->mySellingItem1.c_str())).name, "putMySellingItem_1", false);
										}

										if (static_cast<PlayerInfo*>(peer->data)->mySellingItem2 == "3308" || static_cast<PlayerInfo*>(peer->data)->mySellingItem2Count == "0")
										{
											tradedialog.addStaticBlueFrameWithIdCountText("6156", "0", "empty", "putMySellingItem_2", false);
										}
										else
										{
											tradedialog.addStaticBlueFrameWithIdCountText(static_cast<PlayerInfo*>(peer->data)->mySellingItem2, static_cast<PlayerInfo*>(peer->data)->mySellingItem2Count, getItemDef(atoi(static_cast<PlayerInfo*>(peer->data)->mySellingItem2.c_str())).name, "putMySellingItem_2", false);
										}

										if (static_cast<PlayerInfo*>(peer->data)->mySellingItem3 == "3308" || static_cast<PlayerInfo*>(peer->data)->mySellingItem3Count == "0")
										{
											tradedialog.addStaticBlueFrameWithIdCountText("6156", "0", "empty", "putMySellingItem_3", false);
										}
										else
										{
											tradedialog.addStaticBlueFrameWithIdCountText(static_cast<PlayerInfo*>(peer->data)->mySellingItem3, static_cast<PlayerInfo*>(peer->data)->mySellingItem3Count, getItemDef(atoi(static_cast<PlayerInfo*>(peer->data)->mySellingItem3.c_str())).name, "putMySellingItem_3", false);
										}

										if (static_cast<PlayerInfo*>(peer->data)->mySellingItem4 == "3308" || static_cast<PlayerInfo*>(peer->data)->mySellingItem4Count == "0")
										{
											tradedialog.addStaticBlueFrameWithIdCountText("6156", "0", "empty", "putMySellingItem_4", false);
										}
										else
										{
											tradedialog.addStaticBlueFrameWithIdCountText(static_cast<PlayerInfo*>(peer->data)->mySellingItem4, static_cast<PlayerInfo*>(peer->data)->mySellingItem4Count, getItemDef(atoi(static_cast<PlayerInfo*>(peer->data)->mySellingItem4.c_str())).name, "putMySellingItem_4", false);
										}
										tradedialog.addNewLineAfterFrame();

										tradedialog.addSpacer(SPACER_SMALL);
										tradedialog.addSpacer(SPACER_SMALL);
										tradedialog.addSpacer(SPACER_SMALL);
										tradedialog.addSmallText("`$Add items that you want to get.");
										tradedialog.addSmallText("`$(click on the boxes below)");
										tradedialog.addSpacer(SPACER_SMALL);

										if (static_cast<PlayerInfo*>(peer->data)->hisSellingItem1 == "3308" || static_cast<PlayerInfo*>(peer->data)->hisSellingItem1Count == "0")
										{
											tradedialog.addStaticBlueFrameWithIdCountText("6156", "0", "empty", "putHisSellingItem_1", false);
										}
										else
										{
											tradedialog.addStaticBlueFrameWithIdCountText(static_cast<PlayerInfo*>(peer->data)->hisSellingItem1, static_cast<PlayerInfo*>(peer->data)->hisSellingItem1Count, getItemDef(atoi(static_cast<PlayerInfo*>(peer->data)->hisSellingItem1.c_str())).name, "putHisSellingItem_1", false);
										}

										if (static_cast<PlayerInfo*>(peer->data)->hisSellingItem2 == "3308" || static_cast<PlayerInfo*>(peer->data)->hisSellingItem2Count == "0")
										{
											tradedialog.addStaticBlueFrameWithIdCountText("6156", "0", "empty", "putHisSellingItem_2", false);
										}
										else
										{
											tradedialog.addStaticBlueFrameWithIdCountText(static_cast<PlayerInfo*>(peer->data)->hisSellingItem2, static_cast<PlayerInfo*>(peer->data)->hisSellingItem2Count, getItemDef(atoi(static_cast<PlayerInfo*>(peer->data)->hisSellingItem2.c_str())).name, "putHisSellingItem_2", false);
										}

										if (static_cast<PlayerInfo*>(peer->data)->hisSellingItem3 == "3308" || static_cast<PlayerInfo*>(peer->data)->hisSellingItem3Count == "0")
										{
											tradedialog.addStaticBlueFrameWithIdCountText("6156", "0", "empty", "putHisSellingItem_3", false);
										}
										else
										{
											tradedialog.addStaticBlueFrameWithIdCountText(static_cast<PlayerInfo*>(peer->data)->hisSellingItem3, static_cast<PlayerInfo*>(peer->data)->hisSellingItem3Count, getItemDef(atoi(static_cast<PlayerInfo*>(peer->data)->hisSellingItem3.c_str())).name, "putHisSellingItem_3", false);
										}

										if (static_cast<PlayerInfo*>(peer->data)->hisSellingItem4 == "3308" || static_cast<PlayerInfo*>(peer->data)->hisSellingItem4Count == "0")
										{
											tradedialog.addStaticBlueFrameWithIdCountText("6156", "0", "empty", "putHisSellingItem_4", false);
										}
										else
										{
											tradedialog.addStaticBlueFrameWithIdCountText(static_cast<PlayerInfo*>(peer->data)->hisSellingItem4, static_cast<PlayerInfo*>(peer->data)->hisSellingItem4Count, getItemDef(atoi(static_cast<PlayerInfo*>(peer->data)->hisSellingItem4.c_str())).name, "putHisSellingItem_4", false);
										}
										tradedialog.addNewLineAfterFrame();

										tradedialog.addSpacer(SPACER_SMALL);
										tradedialog.addSpacer(SPACER_SMALL);
										tradedialog.addButton("sendtrade", "`2Send Trade Request.");
										tradedialog.addSpacer(SPACER_SMALL);
										tradedialog.addSpacer(SPACER_SMALL);
										tradedialog.addButton("closetrade", "Cancel Trade.");
										tradedialog.addQuickExit();
										tradedialog.endDialog("", "", "");
										Player::OnDialogRequest(peer, tradedialog.finishDialog());
									}
								}
								if (!isonline)
								{
									Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4This player is not online.", 0, true);
								}
							}
							else if (str == "/go")
							{
								if (serverIsFrozen) continue;
								if (static_cast<PlayerInfo*>(peer->data)->isCursed == true)
								{
									GamePacket p0 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`4You are cursed now!"));
									ENetPacket* packet0 = enet_packet_create(p0.data,
										p0.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet0);
									delete p0.data;
									continue;
								}
								string act = static_cast<PlayerInfo*>(peer->data)->lastSbbWorld;
								if (act == "")
								{
									GamePacket po = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "Unable to track down the location of the broadcast."));
									ENetPacket* packet = enet_packet_create(po.data,
										po.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
								}
								else if (act == static_cast<PlayerInfo*>(peer->data)->currentWorld)
								{
									GamePacket po = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "Sorry, but you are already in the world!"));
									ENetPacket* packet = enet_packet_create(po.data,
										po.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
								}
								else
								{
									sendPlayerLeave(peer, static_cast<PlayerInfo*>(peer->data));
									joinWorld(peer, act, 0, 0);
								}
							}
							else if (str == "/find")
							{
							Player::OnConsoleMessage(peer, "`eUsage /find <name>");
							}
							else if (str.substr(0, 6) == "/find ")
							{
							if (static_cast<PlayerInfo*>(peer->data)->haveGrowId)
							{
								//Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Item Finder``|left|3146|\nadd_textbox|`^Enter a word below to Find the item!|\nadd_text_input|item|`^Item Name||30|\nend_dialog|findid|Cancel|Find the item!|\nadd_quick_exit|\n");

								string itemFind = str.substr(6, cch.length() - 6 - 1);
								if (itemFind.length() < 3)
								{
									Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wThis item name is too short!``", 0, false);
									break;
								}
							SKIPFinds:;

								string itemLower2;
								vector<ItemDefinition> itemDefsfind;
								for (char c : itemFind) if (c < 0x20 || c > 0x7A) goto SKIPFinds;
								if (itemFind.length() < 3) goto SKIPFinds3;
								for (const ItemDefinition& item : itemDefs)
								{
									string itemLower;
									for (char c : item.name) if (c < 0x20 || c > 0x7A) goto SKIPFinds2;
									if (!(item.id % 2 == 0)) goto SKIPFinds2;
									itemLower2 = item.name;
									std::transform(itemLower2.begin(), itemLower2.end(), itemLower2.begin(), ::tolower);
									if (itemLower2.find(itemLower) != std::string::npos)
									{
										itemDefsfind.push_back(item);
									}
								SKIPFinds2:;
								}
							SKIPFinds3:;
								string listMiddle = "";
								string listFull = "";



								for (const ItemDefinition& item : itemDefsfind)
								{
									if (item.name != "")
									{
										string kys = item.name;
										std::transform(kys.begin(), kys.end(), kys.begin(), ::tolower);
										string kms = itemFind;
										std::transform(kms.begin(), kms.end(), kms.begin(), ::tolower);
										if (kys.find(kms) != std::string::npos)
										{
											int id = item.id;
											int itemid = item.id;
											if (id == 10034 || getItemDef(id).name.find("null") != string::npos || id == 10036 || getItemDef(id).name.find("Mooncake") != string::npos || getItemDef(id).properties & Property_Untradable || getItemDef(id).name.find("Harvest") != string::npos && id != 1830 || getItemDef(id).name.find("Autumn") != string::npos || id == 1056 || id == 1804 || getItemDef(id).blockType == BlockTypes::COMPONENT || getItemDef(id).properties & Property_Chemical || id == 6920 || id == 6922 || id == 1874 || id == 1876 || id == 1904 || id == 1932 || id == 1900 || id == 1986 || id == 1996 || id == 2970 || id == 3140 || id == 3174 || id == 6028 || id == 6846 || id == 8962 || id == 2408 || id == 4428 || id == 5086 || id == 1486 || id == 9306 || id == 9290 || id == 7328 || id == 9416 || id == 10386 || id == 9410 || id == 1458 || id == 9408 || id == 9360 || id == 6866 || id == 6868 || id == 6870 || id == 6872 || id == 6874 || id == 6876 || id == 6878 || id == 2480 || id == 8452 || id == 5132 || id == 7166 || id == 5126 || id == 5128 || id == 5130 || id == 5144 || id == 5146 || id == 5148 || id == 5150 || id == 5162 || id == 5164 || id == 5166 || id == 5168 || id == 5180 || id == 5182 || id == 5184 || id == 5186 || id == 7168 || id == 7170 || id == 7172 || id == 7174 || id == 8834 || id == 7912 || id == 9212 || id == 5134 || id == 5152 || id == 5170 || id == 5188 || id == 980 || id == 9448 || id == 9310 || id == 10034 || id == 10036 || id == 8470 || id == 8286 || id == 6026 || id == 1970 || id == 1784 || id == 9356 || id == 10022 || id == 902 || id == 10032 || id == 834 || id == 6 || id == 5640 || id == 9492 || id == 1782 || id == 9288 || id == 1780 || id == 8306 || id == 202 || id == 204 || id == 206 || id == 2950 || id == 4802 || id == 4994 || id == 5260 || id == 5814 || id == 5980 || id == 7734 || id == 2592 || id == 2242 || id == 1794 || id == 1792 || id == 778 || id == 9510 || id == 8774 || id == 2568 || id == 9512 || id == 9502 || id == 9482 || id == 2250 || id == 2248 || id == 2244 || id == 2246 || id == 2286 || id == 9508 || id == 9504 || id == 9506 || id == 274 || id == 276 || id == 9476 || id == 1486 || id == 9498 || id == 4426 || id == 9496 || id == 278 || id == 9490 || id == 2410 || id == 9488 || id == 9452 || id == 9454 || id == 9472 || id == 9456 || id == 732 || id == 9458 || id == 6336 || id == 112 || id == 8 || id == 3760 || getItemDef(id).blockType == BlockTypes::FISH || id == 7372 || id == 9438 || id == 9462 || id == 9440 || id == 9442 || id == 9444 || id == 7960 || id == 7628 || id == 8552) continue;
											if (itemid == 10246 || itemid == 4296 || itemid == 6212 || itemid == 1212 || itemid == 1190 || itemid == 1206 || itemid == 1166 || itemid == 1964 || itemid == 1976 || itemid == 1998 || itemid == 1946 || itemid == 2002 || itemid == 1958 || itemid == 1952 || itemid == 2030 || itemid == 3104 || itemid == 3112 || itemid == 3120 || itemid == 3092 || itemid == 3094 || itemid == 3096 || itemid == 4184 || itemid == 4178 || itemid == 4174 || itemid == 4180 || itemid == 4170 || itemid == 4168 || itemid == 4150 || itemid == 1180 || itemid == 1224 || itemid == 5226 || itemid == 5228 || itemid == 5230 || itemid == 5212 || itemid == 5246 || itemid == 5242 || itemid == 5234 || itemid == 7134 || itemid == 7118 || itemid == 7132 || itemid == 7120 || itemid == 7098 || itemid == 9018 || itemid == 9038 || itemid == 9026 || itemid == 9066 || itemid == 9058 || itemid == 9044 || itemid == 9024 || itemid == 9032 || itemid == 9036 || itemid == 9028 || itemid == 9030 || itemid == 9110 || itemid == 9112 || itemid == 10386 || itemid == 10326 || itemid == 10324 || itemid == 10322 || itemid == 10328 || itemid == 10316 || itemid == 1198 || itemid == 1208 || itemid == 1222 || itemid == 1200 || itemid == 1220 || itemid == 1202 || itemid == 1238 || itemid == 1168 || itemid == 1172 || itemid == 1230 || itemid == 1194 || itemid == 1192 || itemid == 1226 || itemid == 1196 || itemid == 1236 || itemid == 1182 || itemid == 1184 || itemid == 1186 || itemid == 1188 || itemid == 1170 || itemid == 1212 || itemid == 1214 || itemid == 1232 || itemid == 1178 || itemid == 1234 || itemid == 1250 || itemid == 1956 || itemid == 1990 || itemid == 1968 || itemid == 1960 || itemid == 1948 || itemid == 1966 || itemid == 3114 || itemid == 3118 || itemid == 3100 || itemid == 3122 || itemid == 3124 || itemid == 3126 || itemid == 3108 || itemid == 3098 || itemid == 1962 || itemid == 2000 || itemid == 1970 || itemid == 4186 || itemid == 4188 || itemid == 4246 || itemid == 4248 || itemid == 4192 || itemid == 4156 || itemid == 4136 || itemid == 4152 || itemid == 4166 || itemid == 4190 || itemid == 4172 || itemid == 4182 || itemid == 4144 || itemid == 4146 || itemid == 4148 || itemid == 4140 || itemid == 4138 || itemid == 4142 || itemid == 5256 || itemid == 5208 || itemid == 5216 || itemid == 5218 || itemid == 5220 || itemid == 5214 || itemid == 5210 || itemid == 5254 || itemid == 5250 || itemid == 5252 || itemid == 5244 || itemid == 5236 || itemid == 7104 || itemid == 7124 || itemid == 7122 || itemid == 7102 || itemid == 7100 || itemid == 7126 || itemid == 7104 || itemid == 7124 || itemid == 7122 || itemid == 7102 || itemid == 7100 || itemid == 9048 || itemid == 9056 || itemid == 9114 || itemid == 9034 || itemid == 1210 || itemid == 1216 || itemid == 1218 || itemid == 1992 || itemid == 1982 || itemid == 1994 || itemid == 1972 || itemid == 1980 || itemid == 1988 || itemid == 1984 || itemid == 3116 || itemid == 3102 || itemid == 3106 || itemid == 3110 || itemid == 4160 || itemid == 4162 || itemid == 4164 || itemid == 4154 || itemid == 4158 || itemid == 5224 || itemid == 5222 || itemid == 5232 || itemid == 5240 || itemid == 5248 || itemid == 5238 || itemid == 5256 || itemid == 7116 || itemid == 7108 || itemid == 7110 || itemid == 7128 || itemid == 7112 || itemid == 7114 || itemid == 7130) continue;
											if (itemid == 6398 || itemid == 6426 || itemid == 6340 || itemid == 10388 || itemid == 10390 || itemid == 1360 || itemid == 6342 || itemid == 6350 || itemid == 6818 || itemid == 8244 || itemid == 8242 || itemid == 8240 || itemid == 8452 || itemid == 8454 || itemid == 8488 || itemid == 8498 || itemid == 8474 || itemid == 8476 || itemid == 8492 || itemid == 1498 || itemid == 1500 || itemid == 2804 || itemid == 2806 || itemid == 8270 || itemid == 8272 || itemid == 8274 || itemid == 3172 || itemid == 8478 || itemid == 8480 || itemid == 8486 || itemid == 8484 || itemid == 8482 || itemid == 8468 || itemid == 8494 || itemid == 8466 || itemid == 8490 || itemid == 8456 || itemid == 8458 || itemid == 8496 || itemid == 8472 || itemid == 5482 || itemid == 2240 || itemid == 3204 || itemid == 6114 || itemid == 4328 || itemid == 4326 || itemid == 4330 || itemid == 4324 || itemid == 4334 || itemid == 1242 || itemid == 1244 || itemid == 1246 || itemid == 1248 || itemid == 1282 || itemid == 1284 || itemid == 1286 || itemid == 1290 || itemid == 1288 || itemid == 1292 || itemid == 1294 || itemid == 1256 || itemid == 2586 || itemid == 782 || itemid == 3536 || itemid == 764 || itemid == 4176 || itemid == 4322 || itemid == 4080 || itemid == 2992 || itemid == 2976 || itemid == 3790 || itemid == 4990 || itemid == 1506 || itemid == 1274 || itemid == 9000 || itemid == 1252 || itemid == 8284 || itemid == 8954 || itemid == 8534 || itemid == 1460 || itemid == 1462 || itemid == 1466 || itemid == 1464 || itemid == 2386 || itemid == 2392 || itemid == 2394 || itemid == 4414 || itemid == 4420 || itemid == 4428 || itemid == 4426 || itemid == 5662 || itemid == 5642 || itemid == 5654 || itemid == 5646 || itemid == 5650 || itemid == 7828 || itemid == 7832 || itemid == 7834 || itemid == 9322 || itemid == 9344 || itemid == 9326 || itemid == 9316 || itemid == 9318 || itemid == 362 || itemid == 3398 || itemid == 386 || itemid == 4422 || itemid == 364 || itemid == 9340 || itemid == 9342 || itemid == 9332 || itemid == 9334 || itemid == 9336 || itemid == 9338 || itemid == 366 || itemid == 2388 || itemid == 7808 || itemid == 7810 || itemid == 4416 || itemid == 7818 || itemid == 7820 || itemid == 5652 || itemid == 7822 || itemid == 7824 || itemid == 5644 || itemid == 390 || itemid == 7826 || itemid == 7830 || itemid == 9324 || itemid == 5658 || itemid == 3396 || itemid == 2384 || itemid == 5660 || itemid == 3400 || itemid == 4418 || itemid == 4412 || itemid == 388 || itemid == 3408 || itemid == 1470 || itemid == 3404 || itemid == 3406 || itemid == 2390 || itemid == 5656 || itemid == 5648 || itemid == 2396 || itemid == 384 || itemid == 5664 || itemid == 4424 || itemid == 4400 || itemid == 9350 || itemid == 5040 || itemid == 5042 || itemid == 5044 || itemid == 392 || itemid == 3402 || itemid == 5032 || itemid == 5034 || itemid == 5036 || itemid == 5038 || itemid == 5018 || itemid == 5022 || itemid == 5060 || itemid == 5054 || itemid == 5058 || itemid == 5056 || itemid == 5050 || itemid == 5046 || itemid == 5052 || itemid == 5048 || itemid == 5070 || itemid == 5072 || itemid == 5074 || itemid == 5076 || itemid == 5066 || itemid == 5062 || itemid == 5068 || itemid == 5064 || itemid == 5080 || itemid == 5082 || itemid == 5084 || itemid == 5078 || itemid == 10236 || itemid == 10232 || itemid == 10194 || itemid == 10206 || itemid == 10184 || itemid == 10192 || itemid == 10190 || itemid == 10186 || itemid == 10212 || itemid == 10214 || itemid == 10216 || itemid == 10220 || itemid == 10222 || itemid == 10224 || itemid == 10226 || itemid == 10208 || itemid == 10210 || itemid == 10218 || itemid == 10196 || itemid == 10198 || itemid == 10200 || itemid == 10202 || itemid == 10204) continue;

											if (isFounder(peer) && itemid == 10026) continue;

											listMiddle += "add_button_with_icon|tool" + to_string(item.id) + "|`$" + item.name + "``|left|" + to_string(item.id) + "||\n";
										}
									}
								}
								if (itemFind.length() < 3)
								{
									listFull = "add_textbox|`4Word is less then 3 letters!``|\nadd_spacer|small|\n";

									showWrong(peer, listFull, itemFind);
								}
								else if (itemDefsfind.size() == 0)
								{
									//listFull = "add_textbox|`4Found no item match!``|\nadd_spacer|small|\n";
									showWrong(peer, listFull, itemFind);
								}
								else
								{
									if (listMiddle.size() == 0)
									{
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wNo items were found with that name!``", 0, false);
									}
									else
									{
										GamePacket fff = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "add_label_with_icon|big|`wFound item : " + itemFind + "``|left|6016|\nadd_spacer|small|\nend_dialog|findid|Cancel|\nadd_spacer|big|\n" + listMiddle + "add_quick_exit|\n"));
										ENetPacket* packetd = enet_packet_create(fff.data,
											fff.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetd);

										//enet_host_flush(server);
										delete fff.data;
									}
								}
							}
							}
							
							else if (str == "/online")
							{
								if (!isMod(peer))
								{
									//sendwrongcmd(peer);
									continue;
								}
								string online = "";
								int total = 0;
								ENetPeer* currentPeer;
								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									if (static_cast<PlayerInfo*>(currentPeer->data)->adminLevel >= 0 && static_cast<PlayerInfo*>(currentPeer->data)->isinv == false && !static_cast<PlayerInfo*>(currentPeer->data)->Console)
									{
										online += static_cast<PlayerInfo*>(currentPeer->data)->displayName + "`o, `w";
										total++;
									}
								}
								Player::OnConsoleMessage(peer, "`5Players online [`wTotal: `2" + to_string(total) + "`5]: `w" + online);
							}
							else if (str.substr(0, 8) == "/summon ")
							{
								if (!isMod(peer))
								{
									//sendwrongcmd(peer);
									continue;
								}
								if (str.substr(8, cch.length() - 8 - 1) == "") continue;
								if (static_cast<PlayerInfo*>(peer->data)->rawName == str.substr(8, cch.length() - 8 - 1))
								{
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`#You can't summon yourself!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
									continue;
								}
								string name = str.substr(8, str.length());
								ENetPeer* currentPeer;
								bool found = false;
								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									if (isDev(currentPeer))
									{
										continue;
									}
									string name2 = static_cast<PlayerInfo*>(currentPeer->data)->rawName;
									std::transform(name.begin(), name.end(), name.begin(), ::tolower);
									std::transform(name2.begin(), name2.end(), name2.begin(), ::tolower);
									if (name == name2)
									{
										if (static_cast<PlayerInfo*>(currentPeer->data)->currentWorld == "GAME1")
										{
											Player::OnConsoleMessage(peer, "`@This player is currently in `4GAME1`@!");
											found = false;
											break;
										}
										if (static_cast<PlayerInfo*>(currentPeer->data)->currentWorld == "GAME2")
										{
											Player::OnConsoleMessage(peer, "`@This player is currently in `4GAME2`@!");
											found = false;
											break;
										}
										if (static_cast<PlayerInfo*>(currentPeer->data)->currentWorld == "HELL" || static_cast<PlayerInfo*>(currentPeer->data)->currentWorld == "EXIT")
										{
											found = false;
											break;
										}
										else
										{
											GamePacket pox = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`^You were `@Summoned `^By `#Moderator`^!"));
											ENetPacket* packetpox = enet_packet_create(pox.data,
												pox.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(currentPeer, 0, packetpox);
											int x = static_cast<PlayerInfo*>(peer->data)->x;
											int y = static_cast<PlayerInfo*>(peer->data)->y;
											string world = static_cast<PlayerInfo*>(peer->data)->currentWorld;
											sendPlayerLeave(currentPeer, static_cast<PlayerInfo*>(currentPeer->data));
											joinWorld(currentPeer, world, x, y);
											found = true;
											break;
										}
									}
								}
								if (found)
								{
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`^Summoning Player..."));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
								}
								else
								{
									Player::OnConsoleMessage(peer, "`@Player `4Not Found `@Or Summoning the player is `4Prohibited`@!");
								}
							}
							else if (str == "/game1start")
							{
								if (game1status == true)
								{
									Player::OnConsoleMessage(peer, "`4`w[`2GAME1`8-`2BOT`w]`4 There is already game going. `2Please wait...");
									continue;
								}
								if (static_cast<PlayerInfo*>(peer->data)->currentWorld != "GAME1")
								{
									Player::OnConsoleMessage(peer, "`4`w[`2GAME1`8-`2BOT`w]`4 You can use this command only in GAME1 world.");
									continue;
								}
								if (static_cast<PlayerInfo*>(peer->data)->game1bet == false)
								{
									Player::OnConsoleMessage(peer, "`4`w[`2GAME1`8-`2BOT`w]`4 Place a bet first. `2Use /game1bet <gems> ");
									continue;
								}
								int playersCount = 0;
								bool arok = true;
								ENetPeer* currentPeer;
								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
									if (static_cast<PlayerInfo*>(currentPeer->data)->isinv == false && !static_cast<PlayerInfo*>(currentPeer->data)->Console)
									{
										if (static_cast<PlayerInfo*>(currentPeer->data)->currentWorld == "GAME1")
										{
											playersCount++;
											if (static_cast<PlayerInfo*>(currentPeer->data)->game1bet == false)
											{
												Player::OnConsoleMessage(peer, "`4`w[`2GAME1`8-`2BOT`w]`4 You can't start the game, because `2" + static_cast<PlayerInfo*>(currentPeer->data)->rawName + " `4didn't place a bet.");
												Player::OnConsoleMessage(currentPeer, "`4`w[`2GAME1`8-`2BOT`w] `2" + static_cast<PlayerInfo*>(peer->data)->rawName + " `4tried to start the game, but you still haven't placed a bet. `2Use /game1bet <gems>");
												arok = false;
												break;
											}
										}
									}
								}

								if (!arok) continue;

								if (playersCount < 3)
								{
									Player::OnConsoleMessage(peer, "`4`w[`2GAME1`8-`2BOT`w]`4 There are not enough participants for the game. We need 3 players at least.");
									continue;
								}

								if (game1status == true)
								{
									Player::OnConsoleMessage(peer, "`4`w[`2GAME1`8-`2BOT`w]`4 There is already game going. `2Please wait...");
									continue;
								}

								game1status = true;
								bool error = false;

								ENetPeer* currentPeer2;
								for (currentPeer2 = server->peers;
									currentPeer2 < &server->peers[server->peerCount];
									++currentPeer2)
								{
									if (currentPeer2->state != ENET_PEER_STATE_CONNECTED) continue;
									if (static_cast<PlayerInfo*>(currentPeer2->data)->isinv == false && !static_cast<PlayerInfo*>(currentPeer2->data)->Console)
									{
										if (static_cast<PlayerInfo*>(currentPeer2->data)->currentWorld == "GAME1")
										{
											if (static_cast<PlayerInfo*>(currentPeer2->data)->game1bet == false)
											{
												error = true;
												break;
											}
											else
											{
												if (static_cast<PlayerInfo*>(currentPeer2->data)->canWalkInBlocks == true)
												{
													SendGhost(currentPeer2);
												}
												Player::OnConsoleMessage(currentPeer2, "`4`w[`2GAME1`8-`2BOT`w] `^Spike minigame was started. All bets: " + to_string(betamount) + " gems! Participants: " + to_string(playersCount) + " players.");

											}
										}
									}
								}
								if (error)
								{
									game1status = false;
								}

							}
							else if (str == "/game2start")
							{
								if (game2status == true)
								{
									Player::OnConsoleMessage(peer, "`4`w[`2GAME2`8-`2BOT`w]`4 There is already game going. `2Please wait...");
									continue;
								}
								if (static_cast<PlayerInfo*>(peer->data)->currentWorld != "GAME2")
								{
									Player::OnConsoleMessage(peer, "`4`w[`2GAME2`8-`2BOT`w]`4 You can use this command only in GAME2 world.");
									continue;
								}
								if (static_cast<PlayerInfo*>(peer->data)->game2bet == false)
								{
									Player::OnConsoleMessage(peer, "`4`w[`2GAME2`8-`2BOT`w]`4 Place a bet first. `2Use /game2bet <gems> ");
									continue;
								}
								int playersCount = 0;
								bool arok = true;
								ENetPeer* currentPeer;
								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
									if (static_cast<PlayerInfo*>(currentPeer->data)->isinv == false && !static_cast<PlayerInfo*>(currentPeer->data)->Console)
									{
										if (static_cast<PlayerInfo*>(currentPeer->data)->currentWorld == "GAME2")
										{
											playersCount++;
											if (static_cast<PlayerInfo*>(currentPeer->data)->game2bet == false)
											{
												Player::OnConsoleMessage(peer, "`4`w[`2GAME2`8-`2BOT`w]`4 You can't start the game, because `2" + static_cast<PlayerInfo*>(currentPeer->data)->rawName + " `4didn't place a bet.");
												Player::OnConsoleMessage(currentPeer, "`4`w[`2GAME2`8-`2BOT`w] `2" + static_cast<PlayerInfo*>(peer->data)->rawName + " `4tried to start the game, but you still haven't placed a bet. `2Use /game2bet <gems>");
												arok = false;
												break;
											}
										}
									}
								}

								if (!arok) continue;

								if (playersCount < 3)
								{
									Player::OnConsoleMessage(peer, "`4`w[`2GAME2`8-`2BOT`w]`4 There are not enough participants for the game. We need 3 players at least.");
									continue;
								}

								if (game2status == true)
								{
									Player::OnConsoleMessage(peer, "`4`w[`2GAME2`8-`2BOT`w]`4 There is already game going. `2Please wait...");
									continue;
								}

								game2status = true;
								bool error = false;

								ENetPeer* currentPeer2;
								for (currentPeer2 = server->peers;
									currentPeer2 < &server->peers[server->peerCount];
									++currentPeer2)
								{
									if (currentPeer2->state != ENET_PEER_STATE_CONNECTED) continue;
									if (static_cast<PlayerInfo*>(currentPeer2->data)->isinv == false && !static_cast<PlayerInfo*>(currentPeer2->data)->Console)
									{
										if (static_cast<PlayerInfo*>(currentPeer2->data)->currentWorld == "GAME2")
										{
											if (static_cast<PlayerInfo*>(currentPeer2->data)->game2bet == false)
											{
												error = true;
												break;
											}
											else
											{
												if (static_cast<PlayerInfo*>(currentPeer2->data)->canWalkInBlocks == true)
												{
													SendGhost(currentPeer2);
												}
												static_cast<PlayerInfo*>(currentPeer2->data)->health = 100;
												Player::OnConsoleMessage(currentPeer2, "`4`w[`2GAME2`8-`2BOT`w] `^Spike minigame was started. All bets: " + to_string(bet2amount) + " gems! Participants: " + to_string(playersCount) + " players.");

											}
										}
									}
								}
								if (error)
								{
									game2status = false;
								}

							}
							else if (str.substr(0, 10) == "/game1bet ")
							{
								string imie = str.substr(10, cch.length() - 10 - 1);
								int gems = atoi(imie.c_str());
								int currentgems = 0;
								ifstream fs("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
								fs >> currentgems;
								fs.close();
								if (gems < 5000 || gems > 1000000)
								{
									Player::OnConsoleMessage(peer, "`4You can only bet `25.000 `4- `21.000.000 `4gems.");
									continue;
								}
								if (gems > currentgems)
								{
									Player::OnConsoleMessage(peer, "`4You don't have so much gems.");
									continue;
								}
								if (game1status == true)
								{
									Player::OnConsoleMessage(peer, "`4`w[`2GAME1`8-`2BOT`w]`4 There is already game going. `2Please wait...");
									continue;
								}
								if (static_cast<PlayerInfo*>(peer->data)->currentWorld != "GAME1")
								{
									Player::OnConsoleMessage(peer, "`4`w[`2GAME1`8-`2BOT`w]`4 You can use this command only in GAME1 world.");
									continue;
								}
								currentgems -= gems;
								GamePacket psa = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), currentgems));
								ENetPacket* packetsa = enet_packet_create(psa.data, psa.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packetsa);
								ofstream of("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
								of << currentgems;
								of.close();
								static_cast<PlayerInfo*>(peer->data)->game1bet = true;
								Player::OnConsoleMessage(peer, "`4`w[`2GAME1`8-`2BOT`w]`2 Bet was accepted. (You can bet more times). Don't leave this world.");
								betamount += gems;
							}
							else if (str.substr(0, 10) == "/game2bet ")
							{
								string imie = str.substr(10, cch.length() - 10 - 1);
								int gems = atoi(imie.c_str());
								int currentgems = 0;
								ifstream fs("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
								fs >> currentgems;
								fs.close();
								if (gems < 5000 || gems > 1000000)
								{
									Player::OnConsoleMessage(peer, "`4You can only bet `25.000 `4- `21.000.000 `4gems.");
									continue;
								}
								if (gems > currentgems)
								{
									Player::OnConsoleMessage(peer, "`4You don't have so much gems.");
									continue;
								}
								if (game2status == true)
								{
									Player::OnConsoleMessage(peer, "`4`w[`2GAME2`8-`2BOT`w]`4 There is already game going. `2Please wait...");
									continue;
								}
								if (static_cast<PlayerInfo*>(peer->data)->currentWorld != "GAME2")
								{
									Player::OnConsoleMessage(peer, "`4`w[`2GAME2`8-`2BOT`w]`4 You can use this command only in GAME2 world.");
									continue;
								}
								currentgems -= gems;
								GamePacket psa = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), currentgems));
								ENetPacket* packetsa = enet_packet_create(psa.data, psa.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packetsa);
								ofstream of("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
								of << currentgems;
								of.close();
								static_cast<PlayerInfo*>(peer->data)->game2bet = true;
								Player::OnConsoleMessage(peer, "`4`w[`2GAME2`8-`2BOT`w]`2 Bet was accepted. (You can bet more times). Don't leave this world.");
								bet2amount += gems;
							}
							else if (str.substr(0, 5) == "/pay ")
							{
								if (static_cast<PlayerInfo*>(peer->data)->isCursed)
								{
									Player::OnTextOverlay(peer, "You cannot perform this action while you are cursed");
									continue;
								}
								if (static_cast<PlayerInfo*>(peer->data)->Console)
								{
									Player::OnConsoleMessage(peer, "You cannot perform this action on console");
									continue;
								}
								std::ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
								std::string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
								int b = atoi(content.c_str());
								ENetPeer* currentPeer;
								string imie = str.substr(5, cch.length() - 5 - 1);
								int phm = 0;
								if (imie.find(" ") != std::string::npos)
								{
									phm = atoi(imie.substr(imie.find(" ") + 1).c_str());
									imie = imie.substr(0, imie.find(" "));
								}
								else
								{
									continue;
								}
								if (static_cast<PlayerInfo*>(peer->data)->rawName == str.substr(5, cch.length() - 5 - 1))
								{
									continue;
								}
								if (phm < 0)
								{
									continue;
								}
								else if (b >= phm)
								{
									GamePacket p = packetEnd(appendInt(appendString(appendString(appendString(appendString(createPacket(), "OnAddNotification"), "interface/cash_icon_overlay.rttex"), "Player`w " + static_cast<PlayerInfo*>(peer->data)->rawName + "`o paid you `2" + std::to_string(phm) + " Gems`o!"), "audio/piano_nice.wav"), 0));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									for (currentPeer = server->peers;
										currentPeer < &server->peers[server->peerCount];
										++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
										if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == imie or static_cast<PlayerInfo*>(currentPeer->data)->displayName == imie)
										{
											std::ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(currentPeer->data)->rawName + ".txt");
											std::string acontent((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
											int a = atoi(acontent.c_str());
											int bb = b - phm;
											int aa = a + phm;
											ofstream myfile;
											myfile.open("gemdb/" + static_cast<PlayerInfo*>(currentPeer->data)->rawName + ".txt");
											myfile << aa;
											myfile.close();
											myfile.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
											myfile << bb;
											myfile.close();
											GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`9You've sent `2" + to_string(phm) + " `9gems to `2" + imie + "`9!"));
											ENetPacket* packet2 = enet_packet_create(p2.data, p2.len, ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(peer, 0, packet2);
											delete p2.data;
											GamePacket psa = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), bb));
											ENetPacket* packetsa = enet_packet_create(psa.data, psa.len, ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(peer, 0, packetsa);
											GamePacket psa2 = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), aa));
											ENetPacket* packetsa2 = enet_packet_create(psa2.data, psa2.len, ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(currentPeer, 0, packetsa2);
											enet_peer_send(currentPeer, 0, packet);
											delete psa.data;
											delete psa2.data;
										}
									}
									delete p.data;
								}
								else if (b < phm)
								{
									GamePacket p3 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`@Sorry but you need " + std::to_string(phm) + " `9Gems `@To `2Pay `@Someone!"));
									ENetPacket* packet3 = enet_packet_create(p3.data, p3.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet3);
									delete p3.data;
								}
							}
							else if (str == "/test91")
							{
								if (!isMod(peer)) continue;
								if (static_cast<PlayerInfo*>(peer->data)->startedTest != 0)
								{
									Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4You already opened this test. You can't open it again.", 0, true);
									continue;
								}
								static_cast<PlayerInfo*>(peer->data)->startedTest = GetCurrentTimeInternalSeconds();
								GTDialog myTest;
								myTest.addLabelWithIcon("`wStaff /rules Test.", 9228, LABEL_BIG);
								myTest.addSpacer(SPACER_SMALL);
								myTest.addTextBox("`1Rules:");
								myTest.addTextBox("`o1 rule: `51/10, 2/10, 3/10 - `4demote`5.");
								myTest.addTextBox("`o2 rule: `54/10, 5/10 - `42 warns`5.");
								myTest.addTextBox("`o3 rule: `56/10, 7/10 - `41 warn`5.");
								myTest.addTextBox("`o4 rule: `58/10, 9/10 - `4nothing`5.");
								myTest.addTextBox("`o5 rule: `510/10 - `4/unwarn, if you have warns`5.");
								myTest.addTextBox("`o6 rule: `5Only 1 answer is correct of 4 answers in each question.");
								myTest.addTextBox("`o7 rule: `5if you will cheat, you will get `4suspend`5.");
								myTest.addTextBox("`o7 rule: `5if you close test accidentally, you will get `42 warns`5.");
								myTest.addTextBox("`o8 rule: `5To complete this test you have `45 minutes`5, if you don't have time to complete the test, then `41 warn`5.");
								myTest.addSpacer(SPACER_SMALL);
								myTest.addSpacer(SPACER_SMALL);
								myTest.addTextBox("`oQuestion 1: `$Player swearing. What to do?");
								myTest.addCheckbox("question1a", "`5mute 10-30 minutes", CHECKBOX_NOT_SELECTED);//+
								myTest.addCheckbox("question1b", "`5mute 10-25 minutes", CHECKBOX_NOT_SELECTED);
								myTest.addCheckbox("question1c", "`5warn + mute 10-30 minutes", CHECKBOX_NOT_SELECTED);
								myTest.addCheckbox("question1d", "`5warn + mute 10-25 minutes", CHECKBOX_NOT_SELECTED);
								myTest.addSpacer(SPACER_SMALL);
								myTest.addTextBox("`oQuestion 2: `$Player(1) insults player(2). Player(2) is not mod/dev. What to do?");
								myTest.addCheckbox("question2a", "`5warn + mute 240-360 minutes", CHECKBOX_NOT_SELECTED);
								myTest.addCheckbox("question2b", "`5mute 240-360 minutes", CHECKBOX_NOT_SELECTED);
								myTest.addCheckbox("question2c", "`5warn + mute 120-360 minutes", CHECKBOX_NOT_SELECTED);
								myTest.addCheckbox("question2d", "`5warn + mute 60-160 minutes", CHECKBOX_NOT_SELECTED);//+
								myTest.addSpacer(SPACER_SMALL);
								myTest.addTextBox("`oQuestion 3: `$You see that the player(1) begging to player(2). Player(2) is not mod/dev. What to do?");
								myTest.addCheckbox("question3a", "`5warn", CHECKBOX_NOT_SELECTED);
								myTest.addCheckbox("question3b", "`5mute 30 minutes", CHECKBOX_NOT_SELECTED);
								myTest.addCheckbox("question3c", "`5nothing", CHECKBOX_NOT_SELECTED);//+
								myTest.addCheckbox("question3d", "`5mute 60 minutes", CHECKBOX_NOT_SELECTED);
								myTest.addSpacer(SPACER_SMALL);
								myTest.addTextBox("`oQuestion 4: `$Moderator applied a punishment to another player(2). Then that player(2) wrote a report to this moderator. The head of Staff checked the report and asked the moderator for a proofs. But he said that he had no proofs. What punishment will the moderator receive?");
								myTest.addCheckbox("question4a", "`5warn or 360 minutes curse or demote", CHECKBOX_NOT_SELECTED);//+
								myTest.addCheckbox("question4b", "`5warn or 120 minutes curse or demote", CHECKBOX_NOT_SELECTED);
								myTest.addCheckbox("question4c", "`5warn or 360 minutes curse", CHECKBOX_NOT_SELECTED);
								myTest.addCheckbox("question4d", "`5warn or 120 minutes curse", CHECKBOX_NOT_SELECTED);
								myTest.addSpacer(SPACER_SMALL);
								myTest.addTextBox("`oQuestion 5: `$You got /msg from the player. He asks you to help him. But you ignore him. What punishment you can receive?");
								myTest.addCheckbox("question5a", "`5warn", CHECKBOX_NOT_SELECTED);
								myTest.addCheckbox("question5b", "`5curse 60 minutes", CHECKBOX_NOT_SELECTED);
								myTest.addCheckbox("question5c", "`5warn or curse 60 minutes", CHECKBOX_NOT_SELECTED);
								myTest.addCheckbox("question5d", "`5warn or curse 120 minutes", CHECKBOX_NOT_SELECTED); //+
								myTest.addSpacer(SPACER_SMALL);
								myTest.addTextBox("`oQuestion 6: `$Player(1) scammed player(2). What punishment player(1) will receive?");
								myTest.addCheckbox("question6a", "`5suspend + dev will clear from player(1) inventory scammed items", CHECKBOX_NOT_SELECTED);
								myTest.addCheckbox("question6b", "`5ban 30 days + dev will clear from player(1) inventory scammed items", CHECKBOX_NOT_SELECTED);
								myTest.addCheckbox("question6c", "`5curse 560 minutes + dev will clear from player(1) inventory scammed items", CHECKBOX_NOT_SELECTED); //+
								myTest.addCheckbox("question6d", "`5warn + curse 560 minutes + dev will clear from player(1) inventory scammed items", CHECKBOX_NOT_SELECTED);
								myTest.addSpacer(SPACER_SMALL);
								myTest.addTextBox("`oQuestion 7: `$Bypass world ban?");
								myTest.addCheckbox("question7a", "`5curse 60 minutes + warn", CHECKBOX_NOT_SELECTED);//+
								myTest.addCheckbox("question7b", "`5warn", CHECKBOX_NOT_SELECTED);
								myTest.addCheckbox("question7c", "`5curse 60 minutes", CHECKBOX_NOT_SELECTED);
								myTest.addCheckbox("question7d", "`5curse 30 minutes + warn", CHECKBOX_NOT_SELECTED);
								myTest.addSpacer(SPACER_SMALL);
								myTest.addTextBox("`oQuestion 8: `$Betting?");
								myTest.addCheckbox("question8a", "`5curse 120 + nuke world", CHECKBOX_NOT_SELECTED);
								myTest.addCheckbox("question8b", "`5curse 360 + nuke world", CHECKBOX_NOT_SELECTED);//+
								myTest.addCheckbox("question8c", "`5nuke world + warn", CHECKBOX_NOT_SELECTED);
								myTest.addCheckbox("question8d", "`5nuke world + suspend", CHECKBOX_NOT_SELECTED);
								myTest.addSpacer(SPACER_SMALL);
								myTest.addTextBox("`oQuestion 9: `$Mod playing an event with /invis. What to do?");
								myTest.addCheckbox("question9a", "`5curse 360 minutes", CHECKBOX_NOT_SELECTED);
								myTest.addCheckbox("question9b", "`5demote", CHECKBOX_NOT_SELECTED); //+
								myTest.addCheckbox("question9c", "`5warn", CHECKBOX_NOT_SELECTED);
								myTest.addCheckbox("question9d", "`5ban from world", CHECKBOX_NOT_SELECTED);
								myTest.addSpacer(SPACER_SMALL);
								myTest.addTextBox("`oQuestion 10: `$Long punch in GAME1");
								myTest.addCheckbox("question10a", "`5ban from world", CHECKBOX_NOT_SELECTED);
								myTest.addCheckbox("question10b", "`5curse 120 minutes", CHECKBOX_NOT_SELECTED);//+
								myTest.addCheckbox("question10c", "`5warn + curse 60 minutes", CHECKBOX_NOT_SELECTED);
								myTest.addCheckbox("question10d", "`5warn + curse 30 minutes", CHECKBOX_NOT_SELECTED);
								myTest.addSpacer(SPACER_SMALL);
								myTest.addButton("stafftestok", "`wSubmit Test");
								myTest.endDialog("", "", "");
								Player::OnDialogRequest(peer, myTest.finishDialog());
							}
							else if (str == "/kickall")
							{
								if (isMod(peer) || static_cast<PlayerInfo*>(peer->data)->rawName == world->owner)
								{
									ENetPeer* currentPeer;
									for (currentPeer = server->peers;
										currentPeer < &server->peers[server->peerCount];
										++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
											continue;
										if (isHere(peer, currentPeer))
										{
											if (static_cast<PlayerInfo*>(currentPeer->data)->rawName != world->owner)
											{
												GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`@You have been kicked by `2" + static_cast<PlayerInfo*>(peer->data)->rawName + "!"));
												ENetPacket* packet = enet_packet_create(p.data,
													p.len,
													ENET_PACKET_FLAG_RELIABLE);
												enet_peer_send(currentPeer, 0, packet);
												delete p.data;
												playerRespawn(currentPeer, false);
											}
										}
									}
								}
								else
								{
									//sendwrongcmd(peer);
									continue;
								}
							}
							else if (str.substr(0, 6) == "/pull ")
							{
								if (world == nullptr || world->name == "EXIT" || serverIsFrozen) continue;
								WorldInfo* world = getPlyersWorld(peer);
								if (static_cast<PlayerInfo*>(peer->data)->rawName == world->owner || isMod(peer))
								{

									string imie = str.substr(6, cch.length() - 6 - 1);
									int x = static_cast<PlayerInfo*>(peer->data)->x;
									int y = static_cast<PlayerInfo*>(peer->data)->y;
									string dupa;
									GamePacket pmsg = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`o" + static_cast<PlayerInfo*>(peer->data)->displayName + " `5pulls `o" + imie + "`o!"));
									bool arApskritaiYra = false;
									for (ENetPeer* currentPeer = server->peers;
										currentPeer < &server->peers[server->peerCount];
										++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
											continue;

										if (isHere(peer, currentPeer))
										{
											bool arYra = false;
											for (int i = 0; i < imie.size(); i++)
											{
												if (imie.size() > static_cast<PlayerInfo*>(currentPeer->data)->rawName.size()) break;
												if (imie[i] == static_cast<PlayerInfo*>(currentPeer->data)->rawName[i])
												{
													arYra = true;
												}
												else
												{
													arYra = false;
													break;
												}
											}
											if (arYra == false)
											{
												continue;
											}
											else
											{
												if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == static_cast<PlayerInfo*>(peer->data)->rawName) continue;
												arApskritaiYra = true;
												dupa = static_cast<PlayerInfo*>(currentPeer->data)->rawName;
												PlayerMoving data;
												data.packetType = 0x0;
												data.characterState = 0x924; // animation
												data.x = x;
												data.y = y;
												data.punchX = -1;
												data.punchY = -1;
												data.XSpeed = 0;
												data.YSpeed = 0;
												data.netID = static_cast<PlayerInfo*>(currentPeer->data)->netID;
												data.plantingTree = 0x0;
												SendPacketRaw(4, packPlayerMoving(&data), 56, nullptr, currentPeer, ENET_PACKET_FLAG_RELIABLE);
												GamePacket p2 = packetEnd(appendFloat(appendString(createPacket(), "OnSetPos"), x, y));
												memcpy(p2.data + 8, &(static_cast<PlayerInfo*>(currentPeer->data)->netID), 4);
												ENetPacket* packet2 = enet_packet_create(p2.data,
													p2.len,
													ENET_PACKET_FLAG_RELIABLE);
												enet_peer_send(currentPeer, 0, packet2);
												delete p2.data;
												ENetPacket* packetmsg = enet_packet_create(pmsg.data,
													pmsg.len,
													ENET_PACKET_FLAG_RELIABLE);
												for (ENetPeer* currentPeer2 = server->peers;
													currentPeer2 < &server->peers[server->peerCount];
													++currentPeer2)
												{
													if (currentPeer2->state != ENET_PEER_STATE_CONNECTED)
														continue;
													if (isHere(peer, currentPeer2))
													{
														enet_peer_send(currentPeer2, 0, packetmsg);
													}
												}
												delete pmsg.data;
												break;
											}
										}
									}
									if (!arApskritaiYra)
									{
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4This player is not in your world.", 0, true);
										continue;
									}
								}
								else
								{
									Player::OnConsoleMessage(peer, "You need to be world owner to use that command.");
								}
							}
							else if (str.substr(0, 4) == "/me ")
							{
								if (world->silence == true && !isWorldOwner(peer, world))
								{
									Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`1(Peasants must not to talk)", 0, true);
									continue;
								}
								if (static_cast<PlayerInfo*>(peer->data)->isDuctaped == false && static_cast<PlayerInfo*>(peer->data)->haveGrowId == true)
								{
									string namer = static_cast<PlayerInfo*>(peer->data)->displayName;
									GamePacket p2 = packetEnd(appendIntx(appendString(appendIntx(appendString(createPacket(), "OnTalkBubble"), static_cast<PlayerInfo*>(peer->data)->netID), "`#<`w" + namer + " `#" + str.substr(3, cch.length() - 3 - 1).c_str() + "`5>"), 0));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									GamePacket p3 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`w<" + namer + " `#" + str.substr(3, cch.length() - 3 - 1).c_str() + "`w>"));
									ENetPacket* packet3 = enet_packet_create(p3.data,
										p3.len,
										ENET_PACKET_FLAG_RELIABLE);
									ENetPeer* currentPeer;
									for (currentPeer = server->peers;
										currentPeer < &server->peers[server->peerCount];
										++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
											continue;
										if (isHere(peer, currentPeer))
										{
											enet_peer_send(currentPeer, 0, packet2);
											enet_peer_send(currentPeer, 0, packet3);
										}
									}
									delete p2.data;
									delete p3.data;
									continue;
								}
							}
							else if (str.substr(0, 6) == "/warn ")
							{
								if (!isMod(peer))
								{
									//sendwrongcmd(peer);
									continue;
								}
								string warn_info = str;
								size_t extra_space = warn_info.find("  ");
								if (extra_space != std::string::npos)
								{
									warn_info.replace(extra_space, 2, " ");
								}
								string delimiter = " ";
								size_t pos = 0;
								string warn_user;
								string warn_message;
								if ((pos = warn_info.find(delimiter)) != std::string::npos)
								{
									warn_info.erase(0, pos + delimiter.length());
								}
								else
								{
									Player::OnConsoleMessage(peer, "`@Please specify a `9Player `@You want to `4Warn`@!");
									continue;
								}
								if ((pos = warn_info.find(delimiter)) != std::string::npos)
								{
									warn_user = warn_info.substr(0, pos);
									warn_info.erase(0, pos + delimiter.length());
								}
								else
								{
									Player::OnConsoleMessage(peer, "`@Please enter your `4Warn `@Reason!");
									continue;
								}
								warn_message = warn_info;
								int kiekDabarTuriWarns = 0;

								if (static_cast<PlayerInfo*>(peer->data)->rawName != "time" && static_cast<PlayerInfo*>(peer->data)->rawName != "timetopia")
								{
									if (warn_message.length() < 5)
									{
										AutoDemote(static_cast<PlayerInfo*>(peer->data)->rawName, to_string(static_cast<PlayerInfo*>(peer->data)->adminLevel), to_string(peer->address.host), "warn reason length < 5. He wrote: " + warn_message);
										continue;
									}
									vector<string> blackWords = { "retard", "bitch", "damn", "fuck", "away", "you", "hello", "lol", "xd", "no", "yes", "what", "go", "noob", "niger", "top", "nigger", "nigga", "niga", "idiot", "shut", "stupid", "why", "gg", "haha", "wtf", "die", "suck", "server", "shut" };
									if (std::find(blackWords.begin(), blackWords.end(), warn_message) != blackWords.end())
									{
										AutoDemote(static_cast<PlayerInfo*>(peer->data)->rawName, to_string(static_cast<PlayerInfo*>(peer->data)->adminLevel), to_string(peer->address.host), "Found black world in reason. He wrote: " + warn_message);
										continue;
									}
								}
								bool found = false;

								ENetPeer* currentPeer;
								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == warn_user)
									{
										found = true;

										if (static_cast<PlayerInfo*>(peer->data)->rawName != "time" && static_cast<PlayerInfo*>(peer->data)->rawName != "timetopia")
										{
											using namespace std::chrono;
											if (static_cast<PlayerInfo*>(peer->data)->lastwarn + 120000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count())
											{
												static_cast<PlayerInfo*>(peer->data)->lastwarn = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
												static_cast<PlayerInfo*>(peer->data)->lastwarnCount = 1;
											}
											else
											{
												static_cast<PlayerInfo*>(peer->data)->lastwarnCount = static_cast<PlayerInfo*>(peer->data)->lastwarnCount + 1;
												if (static_cast<PlayerInfo*>(peer->data)->lastwarnCount == 6)
												{
													AutoDemote(static_cast<PlayerInfo*>(peer->data)->rawName, to_string(static_cast<PlayerInfo*>(peer->data)->adminLevel), to_string(peer->address.host), "6 warns in the past 2 minutes! He wrote: " + warn_message);
													continue;
												}
											}
										}

										bool existx = std::experimental::filesystem::exists("players/" + PlayerDB::getProperName(warn_user) + ".json");
										if (!existx)
										{
											Player::OnConsoleMessage(peer, "`9Player `@Not Found!");
											continue;
										}

										ifstream fg("players/" + PlayerDB::getProperName(warn_user) + ".json");
										json j;
										fg >> j;
										fg.close();

										kiekDabarTuriWarns = j["receivedwarns"];

										bool shouldcurse = false;
										bool shoulddisconnect = false;
										if (kiekDabarTuriWarns < 2)
										{
											kiekDabarTuriWarns++;
											j["receivedwarns"] = kiekDabarTuriWarns;
											ofstream fs("players/" + PlayerDB::getProperName(warn_user) + ".json");
											fs << j;
											fs.close();
										}
										else
										{
											j["receivedwarns"] = 0;
											ofstream fs("players/" + PlayerDB::getProperName(warn_user) + ".json");
											fs << j;
											fs.close();
											shouldcurse = true;
											ofstream savecursetime("cursedplayers/" + PlayerDB::getProperName(warn_user) + ".txt");
											savecursetime << (GetCurrentTimeInternalSeconds() + (240 * 60)) << endl;
											savecursetime << "By system" << endl;
											savecursetime << "auto-cursed because of [3/3] warns" << endl;
											savecursetime.close();

											ofstream curselog("logs/curse.txt", ios::app);
											curselog << PlayerDB::getProperName(warn_user) << " auto-cursed because of [3/3] warns. Last warn by administrator " << static_cast<PlayerInfo*>(peer->data)->rawName << endl;
											curselog.close();

											if (isMod(currentPeer))
											{
												j["adminLevel"] = 0;
												ofstream fs("players/" + static_cast<PlayerInfo*>(currentPeer->data)->rawName + ".json");
												fs << j;
												fs.close();
												shoulddisconnect = true;
											}
											if (isDev(currentPeer))
											{
												j["adminLevel"] = 1;
												ofstream fs("players/" + static_cast<PlayerInfo*>(currentPeer->data)->rawName + ".json");
												fs << j;
												fs.close();
												shoulddisconnect = true;
											}
										}

										ofstream warnslog("logs/warns.txt", ios::app);
										warnslog << "administrator " << static_cast<PlayerInfo*>(peer->data)->rawName << " used /warn " << warn_user << " " << warn_message << endl;
										warnslog.close();
										string textInfo = "`1[M] `1[`o" + currentDateTime() + "`1] `6" + static_cast<PlayerInfo*>(peer->data)->tankIDName + " `4Just `2WARNED `4player `w" + warn_user + "`4[`9" + to_string(kiekDabarTuriWarns) + "`4/`93`4] `6with reason: `4 " + warn_message + "`6.";
										showModLogs(textInfo);

										GamePacket p0;
										if (shouldcurse)
										{
											p0 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`^Player `9" + warn_user + " `^Has Been `4Warned`^ [3/3] `4and got cursed for 4 hours!"));
										}
										else
										{
											p0 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`^Player `9" + warn_user + " `^Has Been `4Warned `^[" + to_string(kiekDabarTuriWarns) + "/3]`4!"));
										}
										ENetPacket* packet0 = enet_packet_create(p0.data,
											p0.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet0);
										delete p0.data;
										GamePacket pall;
										GamePacket ps;
										if (shouldcurse)
										{
											pall = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`#** `$The Ancient Ones `ohave `bwarned `4[`93`4/`93`4] `2" + warn_user + " `ofor `2" + warn_message + "`#** `o(`4/rules `oto see the rules!)"));
											ps = packetEnd(appendInt(appendString(appendString(appendString(appendString(createPacket(), "OnAddNotification"), "interface/atomic_button.rttex"), "`wWarning [3/3] from `4Admin `2" + static_cast<PlayerInfo*>(peer->data)->rawName + "`0: " + warn_message), "audio/hub_open.wav"), 0));
										}
										else
										{
											pall = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`#** `$The Ancient Ones `ohave `bwarned `4[`9" + to_string(kiekDabarTuriWarns) + "`4/`93`4] `2" + warn_user + " `ofor `2" + warn_message + "`#** `o(`4/rules `oto see the rules!)"));
											ps = packetEnd(appendInt(appendString(appendString(appendString(appendString(createPacket(), "OnAddNotification"), "interface/atomic_button.rttex"), "`wWarning `4[`9" + to_string(kiekDabarTuriWarns) + "`4/`93`4] `wfrom Admin `2" + static_cast<PlayerInfo*>(peer->data)->rawName + "`0: " + warn_message), "audio/hub_open.wav"), 0));
										}
										ENetPacket* packet = enet_packet_create(ps.data,
											ps.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(currentPeer, 0, packet);
										delete ps.data;
										if (shoulddisconnect)
										{
											Player::OnConsoleMessage(currentPeer, "`wWarning from SYSTEM: `1You have been cursed for`9 4 hours `1 and you were `4demoted `1because you got `4[`93`4/`93`4] `1warnings! Last warning was given by `9" + static_cast<PlayerInfo*>(peer->data)->rawName + "`1, reason: `2" + warn_message + "");
											if (!static_cast<PlayerInfo*>(peer->data)->Console) enet_peer_disconnect_now(currentPeer, 0);
										}
										if (shouldcurse)
										{
											using namespace std::chrono;
											Player::OnConsoleMessage(currentPeer, "`wWarning from SYSTEM: `1You have been cursed for`9 4 hours `1because you got `4[`93`4/`93`4] `1warnings! Last warning was given by `9" + static_cast<PlayerInfo*>(peer->data)->rawName + "`1, reason: `2" + warn_message + "");
											static_cast<PlayerInfo*>(currentPeer->data)->isCursed = true;
											static_cast<PlayerInfo*>(currentPeer->data)->lastCursed = ((duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) + (240 * 60 * 1000);
											sendPlayerToWorld(currentPeer, static_cast<PlayerInfo*>(currentPeer->data), "HELL");
										}
										ENetPeer* currentPeer2;
										for (currentPeer2 = server->peers;
											currentPeer2 < &server->peers[server->peerCount];
											++currentPeer2)
										{
											if (currentPeer2->state != ENET_PEER_STATE_CONNECTED)
												continue;
											ENetPacket* packet3 = enet_packet_create(pall.data,
												pall.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(currentPeer2, 0, packet3);
										}
										delete pall.data;
										break;
									}
								}

								if (!found)
								{
									int offAdminLevel = 0;

									bool existx = std::experimental::filesystem::exists("players/" + PlayerDB::getProperName(warn_user) + ".json");
									if (!existx)
									{
										Player::OnConsoleMessage(peer, "`9Player `@Not Found!");
										continue;
									}

									ifstream fg("players/" + PlayerDB::getProperName(warn_user) + ".json");
									json j;
									fg >> j;
									fg.close();

									kiekDabarTuriWarns = j["receivedwarns"];
									offAdminLevel = j["adminLevel"];

									if (static_cast<PlayerInfo*>(peer->data)->rawName != "time" && static_cast<PlayerInfo*>(peer->data)->rawName != "timetopia")
									{
										using namespace std::chrono;
										if (static_cast<PlayerInfo*>(peer->data)->lastwarn + 120000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count())
										{
											static_cast<PlayerInfo*>(peer->data)->lastwarn = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
											static_cast<PlayerInfo*>(peer->data)->lastwarnCount = 1;
										}
										else
										{
											static_cast<PlayerInfo*>(peer->data)->lastwarnCount = static_cast<PlayerInfo*>(peer->data)->lastwarnCount + 1;
											if (static_cast<PlayerInfo*>(peer->data)->lastwarnCount == 6)
											{
												AutoDemote(static_cast<PlayerInfo*>(peer->data)->rawName, to_string(static_cast<PlayerInfo*>(peer->data)->adminLevel), to_string(peer->address.host), "6 warns in the past 2 minutes! He wrote: " + warn_message);
												continue;
											}
										}
									}

									bool shouldcurse = false;
									if (kiekDabarTuriWarns < 2)
									{
										kiekDabarTuriWarns++;

										j["receivedwarns"] = kiekDabarTuriWarns;
										ofstream fs("players/" + PlayerDB::getProperName(warn_user) + ".json");
										fs << j;
										fs.close();
									}
									else
									{
										j["receivedwarns"] = 0;
										ofstream fs("players/" + PlayerDB::getProperName(warn_user) + ".json");
										fs << j;
										fs.close();
										shouldcurse = true;
										ofstream savecursetime("cursedplayers/" + PlayerDB::getProperName(warn_user) + ".txt");
										savecursetime << (GetCurrentTimeInternalSeconds() + (240 * 60)) << endl;
										savecursetime << "By system" << endl;
										savecursetime << "auto-cursed because of [3/3] warns" << endl;
										savecursetime.close();

										ofstream curselog("logs/curse.txt", ios::app);
										curselog << PlayerDB::getProperName(warn_user) << " auto-cursed because of [3/3] warns. Last offline warn by administrator " << static_cast<PlayerInfo*>(peer->data)->rawName << endl;
										curselog.close();

										if (offAdminLevel == 4)
										{
											j["adminLevel"] = 3;
											ofstream fs("players/" + PlayerDB::getProperName(warn_user) + ".json");
											fs << j;
											fs.close();
										}
										if (offAdminLevel == 5)
										{
											j["adminLevel"] = 4;
											ofstream fs("players/" + PlayerDB::getProperName(warn_user) + ".json");
											fs << j;
											fs.close();
										}
									}

									ofstream warnslog("logs/warns.txt", ios::app);
									warnslog << "administrator " << static_cast<PlayerInfo*>(peer->data)->rawName << " used offline /warn " << warn_user << " " << warn_message << endl;
									warnslog.close();
									string textInfo = "`1[M] `1[`o" + currentDateTime() + "`1] `6" + static_cast<PlayerInfo*>(peer->data)->tankIDName + " `4Just `2WARNED OFFLINE `4player `w" + warn_user + "`4[`9" + to_string(kiekDabarTuriWarns) + "`4/`93`4] `6with reason: `4 " + warn_message + "`6.";
									showModLogs(textInfo);

									GamePacket p0;
									if (shouldcurse)
									{
										p0 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`^Player `9" + warn_user + " `^Has Been `bOffline `4Warned`^ [3/3] `4and got cursed for 4 hours!"));
									}
									else
									{
										p0 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`^Player `9" + warn_user + " `^Has Been `bOffline `4Warned `^[" + to_string(kiekDabarTuriWarns) + "/3]`4!"));
									}
									ENetPacket* packet0 = enet_packet_create(p0.data,
										p0.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet0);
									delete p0.data;
									GamePacket pall;
									GamePacket ps;
									if (shouldcurse)
									{
										pall = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`#** `$The Ancient Ones `ohave `boffline `bwarned `4[`93`4/`93`4] `2" + warn_user + " `ofor `2" + warn_message + "`#** `o(`4/rules `oto see the rules!)"));
										ps = packetEnd(appendInt(appendString(appendString(appendString(appendString(createPacket(), "OnAddNotification"), "interface/atomic_button.rttex"), "`wWarning [3/3] from `4Admin `2" + static_cast<PlayerInfo*>(peer->data)->rawName + "`0: " + warn_message), "audio/hub_open.wav"), 0));
									}
									else
									{
										pall = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`#** `$The Ancient Ones `ohave `boffline `bwarned `4[`9" + to_string(kiekDabarTuriWarns) + "`4/`93`4] `2" + warn_user + " `ofor `2" + warn_message + "`#** `o(`4/rules `oto see the rules!)"));
										ps = packetEnd(appendInt(appendString(appendString(appendString(appendString(createPacket(), "OnAddNotification"), "interface/atomic_button.rttex"), "`wWarning `4[`9" + to_string(kiekDabarTuriWarns) + "`4/`93`4] `wfrom Admin `2" + static_cast<PlayerInfo*>(peer->data)->rawName + "`0: " + warn_message), "audio/hub_open.wav"), 0));
									}
									ENetPacket* packet = enet_packet_create(ps.data,
										ps.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(currentPeer, 0, packet);
									delete ps.data;

									ENetPeer* currentPeer2;
									for (currentPeer2 = server->peers;
										currentPeer2 < &server->peers[server->peerCount];
										++currentPeer2)
									{
										if (currentPeer2->state != ENET_PEER_STATE_CONNECTED)
											continue;
										ENetPacket* packet3 = enet_packet_create(pall.data,
											pall.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(currentPeer2, 0, packet3);
									}
									delete pall.data;
								}
							}
							else if (str.substr(0, 8) == "/unwarn ")
							{
								if (!isDev(peer))
								{
									//sendwrongcmd(peer);
									continue;
								}
								string warn_info = str;
								size_t extra_space = warn_info.find("  ");
								if (extra_space != std::string::npos)
								{
									warn_info.replace(extra_space, 2, " ");
								}
								string delimiter = " ";
								size_t pos = 0;
								string warn_user;
								string warn_message;
								if ((pos = warn_info.find(delimiter)) != std::string::npos)
								{
									warn_info.erase(0, pos + delimiter.length());
								}
								else
								{
									Player::OnConsoleMessage(peer, "`@Please specify a `9Player `@You want to `4UnWarn`@!");
									continue;
								}
								if ((pos = warn_info.find(delimiter)) != std::string::npos)
								{
									warn_user = warn_info.substr(0, pos);
									warn_info.erase(0, pos + delimiter.length());
								}
								else
								{
									Player::OnConsoleMessage(peer, "`@Please enter your `4UnWarn `@Reason!");
									continue;
								}
								warn_message = warn_info;
								bool isonline = false;
								int kiekDabarTuriWarns = 0;

								ENetPeer* currentPeer;
								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == warn_user)
									{
										isonline = true;
										ofstream warnslog("logs/unwarns.txt", ios::app);
										warnslog << "administrator " << static_cast<PlayerInfo*>(peer->data)->rawName << " used /unwarn " << warn_user << " " << warn_message << endl;
										warnslog.close();


										ifstream fg("players/" + PlayerDB::getProperName(warn_user) + ".json");
										json j;
										fg >> j;
										fg.close();
										kiekDabarTuriWarns = j["receivedwarns"];

										if (kiekDabarTuriWarns > 0)
										{
											kiekDabarTuriWarns--;
											j["receivedwarns"] = kiekDabarTuriWarns;
											ofstream fs("players/" + PlayerDB::getProperName(warn_user) + ".json");
											fs << j;
											fs.close();
										}
										else
										{
											Player::OnConsoleMessage(peer, "`4This player doesn't have any warns!");
											continue;
										}

										string textInfo = "`1[M] `1[`o" + currentDateTime() + "`1] `6" + static_cast<PlayerInfo*>(peer->data)->tankIDName + " `4Just `2UNWARNED `4player `w" + warn_user + " `6with reason: `4 " + warn_message + "`6.";
										showModLogs(textInfo);

										GamePacket p0 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`^Player `9" + warn_user + " `^Has Been `4UnWarned!`w Now he has `^[" + to_string(kiekDabarTuriWarns) + "/3]`w warns."));
										ENetPacket* packet0 = enet_packet_create(p0.data,
											p0.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet0);
										delete p0.data;
										GamePacket ps = packetEnd(appendInt(appendString(appendString(appendString(appendString(createPacket(), "OnAddNotification"), "interface/atomic_button.rttex"), "`wYou was `2UnWarned `w by staff member `4" + static_cast<PlayerInfo*>(peer->data)->rawName + "`w. You have `4[" + to_string(kiekDabarTuriWarns) + "/3] `wwarns now. `8UnWarn reason: `2" + warn_message), "audio/hub_open.wav"), 0));
										ENetPacket* packet = enet_packet_create(ps.data,
											ps.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(currentPeer, 0, packet);
										delete ps.data;
										break;
									}
								}

								if (!isonline)
								{
									ifstream fg("players/" + PlayerDB::getProperName(warn_user) + ".json");
									json j;
									fg >> j;
									fg.close();
									kiekDabarTuriWarns = j["receivedwarns"];

									if (kiekDabarTuriWarns > 0)
									{
										kiekDabarTuriWarns--;
										j["receivedwarns"] = kiekDabarTuriWarns;
										ofstream fs("players/" + PlayerDB::getProperName(warn_user) + ".json");
										fs << j;
										fs.close();
									}
									else
									{
										Player::OnConsoleMessage(peer, "`4This player doesn't have any warns!");
										continue;
									}

									string textInfo = "`1[M] `1[`o" + currentDateTime() + "`1] `6" + static_cast<PlayerInfo*>(peer->data)->tankIDName + " `4Just `2UNWARNED `bOFFlINE `4player `w" + warn_user + " `6with reason: `4 " + warn_message + "`6.";
									showModLogs(textInfo);

									GamePacket p0 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`^Player `9" + warn_user + " `^Has Been `bOffline `4UnWarned!`w Now he has `^[" + to_string(kiekDabarTuriWarns) + "/3]`w warns."));
									ENetPacket* packet0 = enet_packet_create(p0.data,
										p0.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet0);
									delete p0.data;
								}
							}
							else if (str == "/logs")
							{
								if (!isMod(peer))
								{
									//sendwrongcmd(peer);
									continue;
								}
								GTDialog allLog;
								allLog.addLabelWithIcon("`wLogs:", 1434, LABEL_SMALL);
								allLog.addSpacer(SPACER_SMALL);
								allLog.addButton("banslogs", "Ban logs");
								allLog.addSpacer(SPACER_SMALL);
								allLog.addButton("mutecursewarnlogs", "Mute, Curse and Warn logs");
								allLog.addSpacer(SPACER_SMALL);
								allLog.addButton("wrenchlogs", "Wrench punishment logs");
								allLog.addSpacer(SPACER_SMALL);
								allLog.addButton("autodemoteautobanlogs", "Auto-ban and Auto-demote logs");
								allLog.addSpacer(SPACER_SMALL);
								allLog.addButton("worldlogs", "World punishment logs");
								allLog.addSpacer(SPACER_SMALL);
								allLog.addButton("otherlogs", "Other logs");
								allLog.addSpacer(SPACER_SMALL);

								allLog.addSpacer(SPACER_SMALL);
								allLog.addQuickExit();
								allLog.endDialog("Close", "", "Close it");
								Player::OnDialogRequest(peer, allLog.finishDialog());
							}
							else if (str == "/server")
							{
								if (!isMod(peer))
								{
									//sendwrongcmd(peer);
									continue;
								}
								vector<string> cursedPlayers;
								vector<unsigned long long> lastCursed;
								vector<string> mutedPlayers;
								vector<unsigned long long> lastMuted;
								ENetPeer* currentPeer;
								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									if (static_cast<PlayerInfo*>(currentPeer->data)->isCursed == true)
									{
										cursedPlayers.push_back(static_cast<PlayerInfo*>(currentPeer->data)->rawName);
										lastCursed.push_back(static_cast<PlayerInfo*>(currentPeer->data)->lastCursed);
									}
									if (static_cast<PlayerInfo*>(currentPeer->data)->isDuctaped == true)
									{
										mutedPlayers.push_back(static_cast<PlayerInfo*>(currentPeer->data)->rawName);
										lastMuted.push_back(static_cast<PlayerInfo*>(currentPeer->data)->lastMuted);
									}
								}
								GTDialog allInfo;
								allInfo.addLabelWithIcon("`bCursed `7players:", 1434, LABEL_SMALL);
								if (cursedPlayers.size() == 0)
								{
									allInfo.addSmallText("`1No cursed players.");
								}
								for (int i = 0; i < cursedPlayers.size(); i++)
								{
									allInfo.addSmallText("`1" + to_string(i + 1) + "`7. `w" + cursedPlayers[i] + "`7. `1Curse expires in`7: `$" + OutputBanTime(calcBanDuration(lastCursed[i])) + "");
								}
								allInfo.addSpacer(SPACER_SMALL);
								allInfo.addLabelWithIcon("`bMuted `7players:", 1434, LABEL_SMALL);
								if (mutedPlayers.size() == 0)
								{
									allInfo.addSmallText("`1No muted players.");
								}
								for (int i = 0; i < mutedPlayers.size(); i++)
								{
									allInfo.addSmallText("`1" + to_string(i + 1) + "`7. `w" + mutedPlayers[i] + "`7. `1Mute expires in`7: `$" + OutputBanTime(calcBanDuration(lastMuted[i])) + "");
								}
								if (isDev(peer))
								{
									allInfo.addSpacer(SPACER_SMALL);
									allInfo.addLabelWithIcon("`bNicked `7players:", 1434, LABEL_SMALL);
									ENetPeer* currentPeer;
									for (currentPeer = server->peers;
										currentPeer < &server->peers[server->peerCount];
										++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
										if (isMod(currentPeer) && static_cast<PlayerInfo*>(currentPeer->data)->isNicked && static_cast<PlayerInfo*>(currentPeer->data)->rawName != "time" || static_cast<PlayerInfo*>(currentPeer->data)->rawName != "timetopia")
										{
											allInfo.addSmallText("`1" + static_cast<PlayerInfo*>(currentPeer->data)->rawName + " `1(" + static_cast<PlayerInfo*>(currentPeer->data)->displayName + "`1)");
										}
									}
								}
								allInfo.addSpacer(SPACER_SMALL);
								allInfo.endDialog("Close", "", "Close it.");
								Player::OnDialogRequest(peer, allInfo.finishDialog());
							}
							else if (str == "/rules") {
								Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wHelp & Rules``|left|18|\nadd_spacer|small|\nadd_textbox|`wTo keep this place fun we've got some ground rules to check out:``|left|\nadd_spacer|small|\nadd_label_with_icon|small|`wKeep your password secret. Sharing your password will result in stolen items.``|left|24|\nadd_label_with_icon|small|`wUnprotected items are at risk of being stolen. Use doors, locks, and blocks wisely to protect your items.``|left|24|\nadd_label_with_icon|small|`wWe cannot return stolen items, so BE CAREFUL!``|left|24|\nadd_label_with_icon|small|`wBe civil. Bullying, racism, excessive profanity, sexual content, and abusive behavior are not allowed.``|left|24|\nadd_label_with_icon|small|`wPlayers that are harmful to the community may be banned. This includes accounts that use lies, fake games, or trickery to mistreat other players.``|left|24|\nadd_label_with_icon|small|`wPunishments may be applied to alt accounts as well as any devices and IP addresses used by the offender.``|left|24|\nadd_label_with_icon|small|`wTrying to get punished or asking for a punishment can earn you a worse punishment.``|left|24|\nadd_label_with_icon|small|`w'Hacking' the game - including client-side manipulation, auto-clickers, speed hacks, clock manipulation, bots, macroing, and autofarming - will result in a ban.``|left|24|\nadd_label_with_icon|small|`wDon't lie about mods or fake official Growtopia system messages.``|left|24|\nadd_label_with_icon|small|`w'Drop games' are illegal scams. You can be punished for hosting, playing, advertising or even watching.``|left|24|\nadd_label_with_icon|small|`wBetting or gambling (asking players to pay for a chance to win something) is not allowed.``|left|24|\nadd_label_with_icon|small|`wIf you find a world or player name that is in violation of our rules, message a @Mod. Do not /bc or /sb from an inappropriate world.``|left|24|\nadd_label_with_icon|small|`w@Moderators are here to enforce the rules. Abusing, spamming or harassing mods will have consequences.``|left|24|\nadd_label_with_icon|small|`wAccounts, locks, or worlds may be deleted after long periods of inactivity.``|left|24|\nadd_label_with_icon|small|`wOut of game buying/selling of Growtopia accounts, items or worlds is not allowed and may result in a ban.``|left|24|\nadd_label_with_icon|small|`wIAP fraud will result in permanent suspension.``|left|24|\nadd_label_with_icon|small|`wItem function and prices are subject to change without warning.``|left|24|\nadd_label_with_icon|small|`wYour creations and items could be deleted at any time. We do everything in our power to prevent this, but data loss may happen without warning. Lost items cannot be restored.``|left|24|\nadd_spacer|small|\nadd_label_with_icon|small|`wFor technical support, IAP issues, or to report a problem, please dm Time#1337``|left|24|\nadd_spacer|small|\nend_dialog|popup||Continue|");
							}
							else if (str.substr(0, 8) == "/report ")
							{
								if (static_cast<PlayerInfo*>(peer->data)->isDuctaped == true)
								{
									GamePacket p0 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`4You are muted now!"));
									ENetPacket* packet0 = enet_packet_create(p0.data,
										p0.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet0);
									delete p0.data;
									continue;
								}
								string reportText = str.substr(8, cch.length() - 8 - 1);
								if (reportText == "")
								{
									Player::OnConsoleMessage(peer, "`4Your report text should be not empty.");
									continue;
								}
								GamePacket p6 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`1[R]: `3from player `2" + static_cast<PlayerInfo*>(peer->data)->displayName + ". `4His violation/question: `2" + reportText + ""));
								string text = "action|play_sfx\nfile|audio/siren.wav\ndelayMS|0\n";
								BYTE* data = new BYTE[5 + text.length()];
								BYTE zero = 0;
								int type = 3;
								memcpy(data, &type, 4);
								memcpy(data + 4, text.c_str(), text.length());
								memcpy(data + 4 + text.length(), &zero, 1);
								ENetPeer* currentPeer;
								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									if (isSupport(currentPeer))
									{
										if (static_cast<PlayerInfo*>(currentPeer->data)->isinv == true) continue;
										if (static_cast<PlayerInfo*>(currentPeer->data)->isNicked == true) continue;
										ENetPacket* packet6 = enet_packet_create(p6.data,
											p6.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(currentPeer, 0, packet6);
										ENetPacket* packet2 = enet_packet_create(data,
											5 + text.length(),
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(currentPeer, 0, packet2);
										//Player::PlayAudio(peer, "action|play_sfx\nfile|audio/siren.wav\ndelayMS|0\n", 0);
										//enet_host_flush(server);
									}
								}
								delete data;
								delete p6.data;
								Player::OnConsoleMessage(peer, "`2Successfully sent a report `w(`7" + getModsAndSupportsOnlineCount() + "`w)");
							}
							else if (str.substr(0, 5) == "/ans ")
							{
								if (!isSupport(peer))
								{
									//sendwrongcmd(peer);
									continue;
								}
								string ban_info = str;
								size_t extra_space = ban_info.find("  ");
								if (extra_space != std::string::npos)
								{
									ban_info.replace(extra_space, 2, " ");
								}
								string delimiter = " ";
								size_t pos = 0;
								string ban_user;
								string ban_time;
								if ((pos = ban_info.find(delimiter)) != std::string::npos)
								{
									ban_info.erase(0, pos + delimiter.length());
								}
								else
								{
									GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`oUsage: /ans <user> <answer text>"));
									ENetPacket* packet = enet_packet_create(ps.data,
										ps.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete ps.data;
									continue;
								}
								if ((pos = ban_info.find(delimiter)) != std::string::npos)
								{
									ban_user = ban_info.substr(0, pos);
									ban_info.erase(0, pos + delimiter.length());
								}
								else
								{
									GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`oUsage: /ans <user> <answer text>"));
									ENetPacket* packet = enet_packet_create(ps.data,
										ps.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete ps.data;
									continue;
								}
								ban_time = ban_info;
								string playerName = PlayerDB::getProperName(ban_user);
								string answerText = ban_time;
								bool sucanswered = false;
								ENetPeer* currentPeer;
								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == playerName)
									{
										Player::OnConsoleMessage(currentPeer, "`9[`#Growtopia STAFF`9]`w: `3Administrator `2" + static_cast<PlayerInfo*>(peer->data)->rawName + "`3 just answered to your question`w:`2 " + answerText + "");
										Player::OnConsoleMessage(peer, "`2You successfully answered to `8" + playerName + "'s `2question.");
										sucanswered = true;

										string textInfo = "`1[M] `1[`o" + currentDateTime() + "`1] `6" + static_cast<PlayerInfo*>(peer->data)->tankIDName + " `4Just `2ANSWERD `8to `4player's `w" + playerName + " `6 question. `4The answer: `2 " + answerText + "";
										showModLogs(textInfo);

										break;
									}
								}
								if (!sucanswered)
								{
									Player::OnConsoleMessage(peer, "`4The player `2" + playerName + " `4 is not online.");
								}
							}
							else if (str.substr(0, 3) == "/r ")
							{
								if (static_cast<PlayerInfo*>(peer->data)->haveGrowId == false)
								{
									Player::OnConsoleMessage(peer, "`oTo prevent abuse, you `4must `obe `2registered `oin order to use this command!");
									continue;
								}
								if (static_cast<PlayerInfo*>(peer->data)->isDuctaped == true)
								{
									Player::OnConsoleMessage(peer, "`4You are muted now!");
									continue;
								}
								ENetPeer* currentPeer;
								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == static_cast<PlayerInfo*>(peer->data)->lastMsger)
									{
										static_cast<PlayerInfo*>(currentPeer->data)->lastMsger = static_cast<PlayerInfo*>(peer->data)->rawName;
										Player::OnConsoleMessage(peer, "CP:_PL:0_OID:_CT:[MSG]_ `o(Sent to `$" + static_cast<PlayerInfo*>(currentPeer->data)->displayName + "`o)");
										GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "CP:_PL:0_OID:_CT:[MSG]_ `c>> from (`w" + static_cast<PlayerInfo*>(peer->data)->displayName + "`c) in [`o" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "`c] > `o" + str.substr(3, cch.length() - 3 - 1)));
										string text = "action|play_sfx\nfile|audio/pay_time.wav\ndelayMS|0\n";
										BYTE* data = new BYTE[5 + text.length()];
										BYTE zero = 0;
										int type = 3;
										memcpy(data, &type, 4);
										memcpy(data + 4, text.c_str(), text.length());
										memcpy(data + 4 + text.length(), &zero, 1);
										ENetPacket* packet2 = enet_packet_create(data,
											5 + text.length(),
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(currentPeer, 0, packet2);
										delete data;
										ENetPacket* packet = enet_packet_create(ps.data,
											ps.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(currentPeer, 0, packet);
										delete ps.data;
										break;
									}
								}
							}
							else if (str.substr(0, 4) == "/rgo")
							{
								if (serverIsFrozen) continue;
								if (static_cast<PlayerInfo*>(peer->data)->isCursed == true)
								{
									GamePacket p0 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`4You are cursed now!"));
									ENetPacket* packet0 = enet_packet_create(p0.data,
										p0.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet0);
									delete p0.data;
									continue;
								}
								string act = static_cast<PlayerInfo*>(peer->data)->lastMsgWorld;
								if (act == "")
								{
									GamePacket po = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "Unable to track down the location of the message."));
									ENetPacket* packet = enet_packet_create(po.data,
										po.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
								}
								else if (act == static_cast<PlayerInfo*>(peer->data)->currentWorld)
								{
									GamePacket po = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "Sorry, but you are already in the world!"));
									ENetPacket* packet = enet_packet_create(po.data,
										po.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
								}
								else
								{
									sendPlayerLeave(peer, static_cast<PlayerInfo*>(peer->data));
									joinWorld(peer, act, 0, 0);
								}
							}
							else if (str.substr(0, 7) == "/save")
							{
								if (!isDev(peer))
								{
									//sendwrongcmd(peer);
									continue;
								}
								if (serverIsFrozen) continue;
								saveAllWorlds();
							}
							else if (str.substr(0, 8) == "/itemid ")
							{
								if (static_cast<PlayerInfo*>(peer->data)->haveGrowId) {
									string itemFind = str.substr(8, cch.length() - 8 - 1);
									if (itemFind.length() < 3)
									{
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wThis item name is too short!``", 0, false);
										break;
									}
								SKIPFindss:;

									string itemLower2;
									vector<ItemDefinition> itemDefsfind;
									for (char c : itemFind) if (c < 0x20 || c > 0x7A) goto SKIPFindss;
									if (itemFind.length() < 3) goto SKIPFinds3s;
									for (const ItemDefinition& item : itemDefs)
									{
										string itemLower;
										for (char c : item.name) if (c < 0x20 || c > 0x7A) goto SKIPFinds2s;
										if (!(item.id % 2 == 0)) goto SKIPFinds2s;
										itemLower2 = item.name;
										std::transform(itemLower2.begin(), itemLower2.end(), itemLower2.begin(), ::tolower);
										if (itemLower2.find(itemLower) != std::string::npos)
										{
											itemDefsfind.push_back(item);
										}
									SKIPFinds2s:;
									}
								SKIPFinds3s:;
									string listMiddle = "";
									string listFull = "";
									int count = 0;


									for (const ItemDefinition& item : itemDefsfind)
									{
										if (item.name != "")
										{
											string kys = item.name;
											std::transform(kys.begin(), kys.end(), kys.begin(), ::tolower);
											string kms = itemFind;
											std::transform(kms.begin(), kms.end(), kms.begin(), ::tolower);
											if (kys.find(kms) != std::string::npos)
											{
												int id = item.id;
												int itemid = item.id;
												count++;
												listMiddle += "\nadd_label_with_icon|small|`$Item name: `o" + item.name + "|left|" + to_string(item.id) + "|\nadd_label_with_icon|small|`$Item ID : `o" + to_string(item.id) + "|left|482|\nadd_spacer|small|";
											}
										}
									}
									if (itemFind.length() < 3)
									{
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wWords should be more than 3!``", 0, false);
									}
									else if (itemDefsfind.size() == 0)
									{
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wNo items were found with that name!``", 0, false);
									}
									else
									{
										if (listMiddle.size() == 0)
										{
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wNo items were found with that name!``", 0, false);
										}
										else
										{
											GamePacket fff = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "add_label_with_icon|big|`wItem ID finder : " + itemFind + "``|left|6016|\nadd_spacer|small|\nadd_smalltext|`$Found item : `o" + to_string(count) + "|left|\nadd_spacer|small|" + listMiddle + "\nadd_spacer|small|\nend_dialog||Close|\nadd_quick_exit|\n"));
											ENetPacket* packetd = enet_packet_create(fff.data,
												fff.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(peer, 0, packetd);
											delete fff.data;
										}
									}
								}
							}
							else if (str.substr(0, 6) == "/item ")
							{
								if (!isOwner(peer))
								{
									//sendwrongcmd(peer);
									continue;
								}
								string id = (str.substr(6, cch.length() - 6 - 1).c_str());
								bool contains_non_int2 = !std::regex_match(id, std::regex("^[0-9]+$"));
								if (contains_non_int2 == true)
								{
									continue;
								}
								PlayerInventory inventory;
								if (id.length() > 5)
								{
									Player::OnConsoleMessage(peer, "`oThis item does not exist");
									continue;
								}
								int ids = stoi(id);
								if (ids > maxItems || ids < 0)
								{
									Player::OnConsoleMessage(peer, "`oThis item does not exist");
									continue;
								}
								if (getItemDef(ids).name.find("Subscription") != string::npos)
								{
									Player::OnConsoleMessage(peer, "`oThis item does not exist");
									continue;
								}
								if (ids == 10026 || ids == 10390 || ids == 10388)
								{
									Player::OnConsoleMessage(peer, "`oThis item does not exist");
									continue;
								}
								Player::OnConsoleMessage(peer, "`^Item `@" + id + " `^has been `2added `oto your inventory!");
								bool success = false;
								if (static_cast<PlayerInfo*>(peer->data)->rawName != "time") SaveShopsItem(ids, 200, peer, success);
								else SaveShopsItem(ids, 200, peer, success);
							}
							else if (str == "/disablemsg")
							{
								if (static_cast<PlayerInfo*>(peer->data)->isDisableMessages == true)
								{
									Player::OnConsoleMessage(peer, "`oSuccessfully enabled private messages.");
									static_cast<PlayerInfo*>(peer->data)->isDisableMessages = false;
								}
								else
								{
									Player::OnConsoleMessage(peer, "`oSuccessfully disabled private messages.");
									static_cast<PlayerInfo*>(peer->data)->isDisableMessages = true;
								}
							}
							else if (str == "/enablelogs")
							{
								if (!isDev(peer))
								{
									//sendwrongcmd(peer);
									continue;
								}
								if (world->areLogsEnabled == true)
								{
									world->areLogsEnabled = false;
									Player::OnConsoleMessage(peer, "`7Disabled logs for this world.");
								}
								else
								{
									world->areLogsEnabled = true;
									Player::OnConsoleMessage(peer, "`7Enabled logs for this world.");
								}
							}
							else if (str.substr(0, 7) == "/event ")
							{
								if (!isDev(peer))
								{
									//sendwrongcmd(peer);
									continue;
								}
								string eventname = (str.substr(7, cch.length() - 7 - 1).c_str());
								if (eventname == "harvestfestival")
								{
									if (HarvestEvent)
									{
										HarvestEvent = false;
										ofstream Harvest("events/harvestfestival.txt");
										Harvest << "false";
										Harvest.close();
										ENetPeer* currentPeer;
										for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer)
										{
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
											Player::OnConsoleMessage(currentPeer, "`5Harvest Festival Is Ending...");
											Player::PlayAudio(currentPeer, "audio/boo_ghost_be_gone.wav", 0);
										}
										SendConsole("Harvest Event Stopped!", "EVENT");
									}
									else
									{
										HarvestEvent = true;
										ofstream Harvest("events/harvestfestival.txt");
										Harvest << "true";
										Harvest.close();
										ENetPeer* currentPeer;
										for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer)
										{
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
											Player::OnConsoleMessage(currentPeer, "`5Harvest Festival Is Starting!");
											Player::PlayAudio(currentPeer, "audio/boo_pke_warning_light.wav", 0);
										}
										SendConsole("Harvest Event Started!", "EVENT");
									}
								}
								if (eventname == "farming")
								{
									if (FarmingEvent)
									{
										FarmingEvent = false;
										ofstream Farming("events/farming.txt");
										Farming << "false";
										Farming.close();
										ENetPeer* currentPeer;
										for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer)
										{
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
											Player::OnConsoleMessage(currentPeer, "`5Farming Event Is Ending...");
											Player::PlayAudio(currentPeer, "audio/boo_ghost_be_gone.wav", 0);
										}
										SendConsole("Farming Event Stopped!", "EVENT");
									}
									else
									{
										FarmingEvent = true;
										ofstream Farming("events/farming.txt");
										Farming << "true";
										Farming.close();
										ENetPeer* currentPeer;
										for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer)
										{
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
											Player::OnConsoleMessage(currentPeer, "`5Farming Event Is Starting!");
											Player::PlayAudio(currentPeer, "audio/boo_pke_warning_light.wav", 0);
										}
										SendConsole("Farming Event Started!", "EVENT");
									}
								}
								if (eventname == "growganoth")
								{
									if (GrowganothEvent)
									{
										GrowganothEvent = false;
										ofstream Growganoth("events/growganoth.txt");
										Growganoth << "false";
										Growganoth.close();
										ENetPeer* currentPeer;
										for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer)
										{
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
											Player::OnConsoleMessage(currentPeer, "`5Growganoth Event Is Ending...");
											Player::PlayAudio(currentPeer, "audio/boo_ghost_be_gone.wav", 0);
										}
										SendConsole("Growganoth Event Stopped!", "EVENT");
									}
									else
									{
										GrowganothEvent = true;
										ofstream Growganoth("events/growganoth.txt");
										Growganoth << "true";
										Growganoth.close();
										ENetPeer* currentPeer;
										for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer)
										{
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
											Player::OnConsoleMessage(currentPeer, "`5Growganoth Event Is Starting!");
											Player::PlayAudio(currentPeer, "audio/boo_pke_warning_light.wav", 0);
										}
										SendConsole("Growganoth Event Started!", "EVENT");
									}
								}
								if (eventname == "valentine")
								{
									if (ValentineEvent)
									{
										ValentineEvent = false;
										ofstream Valentine("events/Valentine.txt");
										Valentine << "false";
										Valentine.close();
										ENetPeer* currentPeer;
										for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer)
										{
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
											Player::OnConsoleMessage(currentPeer, "`5Valentine Event Is Ending...");
											Player::PlayAudio(currentPeer, "audio/boo_ghost_be_gone.wav", 0);
										}
										SendConsole("Valentine Event Stopped!", "EVENT");
									}
									else
									{
										ValentineEvent = true;
										ofstream Valentine("events/Valentine.txt");
										Valentine << "true";
										Valentine.close();
										ENetPeer* currentPeer;
										for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer)
										{
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
											Player::OnConsoleMessage(currentPeer, "`5Valentine Event Is Starting!");
											Player::PlayAudio(currentPeer, "audio/boo_pke_warning_light.wav", 0);
										}
										SendConsole("Valentine Event Started!", "EVENT");
									}
								}
							}
							else if (str == "/status")
							{
								string visited = "";
								for (auto i = 0; i < static_cast<PlayerInfo*>(peer->data)->lastworlds.size(); i++)
								{
									visited += static_cast<PlayerInfo*>(peer->data)->lastworlds[i] + ", ";
								}
								Player::OnConsoleMessage(peer, "`$Current World: `w" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "`$(`w" + to_string(static_cast<PlayerInfo*>(peer->data)->x) + "`$, `w" + to_string(static_cast<PlayerInfo*>(peer->data)->y) + "`$) (" + std::to_string(getPlayersCountInWorld(static_cast<PlayerInfo*>(peer->data)->currentWorld)) + " `$people)");
								Player::OnConsoleMessage(peer, "`$Last Visited Worlds: `5" + visited);
							}
							else if (str == "/sellfish")
							{
								auto kiekfishgemu = 0;
								for (auto i = 0; i < static_cast<PlayerInfo*>(peer->data)->inventory.items.size(); i++)
								{
									if (getItemDef(static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemID).blockType == BlockTypes::FISH && static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount >= 1)
									{
										kiekfishgemu = kiekfishgemu + 5 * static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount;
										RemoveInventoryItem(static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemID, static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount, peer, false);
									}
								}
								if (kiekfishgemu != 0)
								{
									Player::OnConsoleMessage(peer, "`wAll fishes `orecycled, `w" + std::to_string(kiekfishgemu) + " `ogems earned.");
									std::ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									std::string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
									auto gembux = atoi(content.c_str());
									auto fingembux = gembux + kiekfishgemu;
									ofstream myfile;
									myfile.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									myfile << fingembux;
									myfile.close();
									auto gemcalc = gembux + kiekfishgemu;
									Player::OnSetBux(peer, gemcalc, 0);
									const auto p3 = packetEnd(appendFloat(appendIntx(appendFloat(appendFloat(appendFloat(appendString(createPacket(), "OnSetClothing"), (static_cast<PlayerInfo*>(peer->data))->cloth_hair, (static_cast<PlayerInfo*>(peer->data))->cloth_shirt, (static_cast<PlayerInfo*>(peer->data))->cloth_pants), (static_cast<PlayerInfo*>(peer->data))->cloth_feet, (static_cast<PlayerInfo*>(peer->data))->cloth_face, (static_cast<PlayerInfo*>(peer->data))->cloth_hand), (static_cast<PlayerInfo*>(peer->data))->cloth_back, (static_cast<PlayerInfo*>(peer->data))->cloth_mask, (static_cast<PlayerInfo*>(peer->data))->cloth_necklace), (static_cast<PlayerInfo*>(peer->data))->skinColor), (static_cast<PlayerInfo*>(peer->data))->cloth_ances, 0.0f, 0.0f));
									memcpy(p3.data + 8, &((static_cast<PlayerInfo*>(peer->data))->netID), 4);
									const auto packet = enet_packet_create(p3.data, p3.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
								}
								else
								{
									Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "I dont have any fishes to recycle!", 0, true);
								}
							}
							else if (str.substr(0, 9) == "/setchat ")
							{
								if (!isDev(peer) && !static_cast<PlayerInfo*>(peer->data)->Subscriber)
								{
									//sendwrongcmd(peer);
									continue;
								}
								string chatcode = (str.substr(9).c_str());
								if (chatcode.size() >= 2 || chatcode.size() <= 0) continue;
								if (chatcode == "o") chatcode = "";
								ifstream fg("players/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".json");
								json j;
								fg >> j;
								fg.close();

								j["chatcolor"] = chatcode;

								ofstream fs("players/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".json");
								fs << j;
								fs.close();
								static_cast<PlayerInfo*>(peer->data)->chatcolor = chatcode;
								if (chatcode != "") Player::OnConsoleMessage(peer, "`oYour chat color have been changed to `" + chatcode + " color `o!");
								else Player::OnConsoleMessage(peer, "`oYour chat color have been reverted to default!");
							}
							else if (str == "/regenerate")
							{
								if (!isDev(peer))
								{
									//sendwrongcmd(peer);
									continue;
								}
								remove("pricedata.txt");
								auto itemid = 0;
								auto kaina = 0;
								for (int i = 0; i <= maxItems; i++)
								{
									itemid++;
									if (getItemDef(itemid).blockType == BlockTypes::CLOTHING)
									{
										kaina = -1;
										if (getItemDef(itemid).rarity <= 10) kaina = rand() % 60;
										else if (getItemDef(itemid).rarity <= 20) kaina = rand() % 190;
										else if (getItemDef(itemid).rarity <= 30) kaina = rand() % 250;
										else if (getItemDef(itemid).rarity <= 40) kaina = rand() % 310;
										else if (getItemDef(itemid).rarity <= 50) kaina = rand() % 430;
										else if (getItemDef(itemid).rarity <= 60) kaina = rand() % 660;
										else if (getItemDef(itemid).rarity <= 70) kaina = rand() % 850;
										else if (getItemDef(itemid).rarity <= 80) kaina = rand() % 1100;
										else if (getItemDef(itemid).rarity <= 600) kaina = rand() % 1300;
										else kaina = rand() % 1800;
										if (getItemDef(itemid).clothType == ClothTypes::BACK && getItemDef(itemid).rarity == 999) kaina = rand() % 2900;
										if (getItemDef(itemid).clothType == ClothTypes::SHIRT) kaina = rand() % 160;
										if (getItemDef(itemid).clothType == ClothTypes::HAIR) kaina = rand() % 620;
										if (getItemDef(itemid).clothType == ClothTypes::PANTS) kaina = rand() % 420;
										if (getItemDef(itemid).clothType == ClothTypes::FEET) kaina = rand() % 230;
										if (getItemDef(itemid).clothType == ClothTypes::FACE) kaina = rand() % 690;
										if (getItemDef(itemid).clothType == ClothTypes::HAND && getItemDef(itemid).rarity == 999) kaina = rand() % 2000;
										if (getItemDef(itemid).clothType == ClothTypes::NECKLACE) kaina = rand() % 730;
										if (getItemDef(itemid).clothType == ClothTypes::MASK) kaina = rand() % 680;
										if (getItemDef(itemid).name.find("Cape") != string::npos) kaina = rand() % 470;
										if (getItemDef(itemid).name.find("Riding") != string::npos) kaina = rand() % 1500;
										if (kaina % 10 < 5) kaina = (kaina / 10) * 10;
										else if (kaina % 10 == 5) {
											if (dec > 0) kaina = (((kaina + 10) / 10) * 10);
											else kaina = (kaina / 10) * 10;
										}
										else {
											kaina = (((kaina + 10) / 10) * 10);
										}
										if (kaina == 0) kaina = 10;
										if (itemid == 1966) kaina = 660;
										if (itemid == 1830) kaina = 520;
										if (itemid == 5022) kaina = 760;
										if (itemid == 6300) kaina = 960;
										if (itemid == 2912) kaina = 5;
										if (itemid == 3008) kaina = 75;
										if (itemid == 3010) kaina = 180;
										if (itemid == 5740) kaina = 390;
										ofstream breaklogs("pricedata.txt", ios::app);
										breaklogs << to_string(itemid) + "|" + to_string(kaina) << endl;
										breaklogs.close();
									}
								}
								ENetPeer* currentPeer;
								for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
									Player::OnConsoleMessage(currentPeer, "`5All prices were randomized!");
									Player::PlayAudio(currentPeer, "audio/boo_pke_warning_light.wav", 0);
								}
							}
							else if (str == "/help" || str == "/?")
							{
								if (isOwner(peer))
								{
									Player::OnConsoleMessage(peer, "`o>> Commands: /market /osb /csb /cmsb /msb /asb /ysb /vsb/ghost /mods /trade /tradeinfo /setchat /sellfish /redeem /go /buy /online /summon /pay /kickall /status /pull /me /warn /unwarn /logs /server /rules /report /ans /r /rgo /item /disablemsg /enablelogs /warpto /warp /banworld /ssb /ban /pban /suspend /spk /unmute /mute /curse /time /uncurse /unban /givelevel /save /msg /tradeworld /uba /wkick /gsm /info /banip /nick /giverank /delstatus /unbanip /invis /jsb /sb /schat /sdb /g /radio /restart /color /who /wave /dance /love /sleep /facepalm /fp /yes /no /omg /idk /shrug /furious /rolleyes /foldarms /fa /stubborn /fold /dab /sassy /dance2");
								}
								else if (isDev(peer))
								{
									Player::OnConsoleMessage(peer, "`o>> Commands: /market /csb /cmsb /msb /asb /ysb /vsb /ghost /mods /trade /tradeinfo /setchat /sellfish /redeem /go /buy /online /summon /pay /kickall /status /pull /me /warn /unwarn /logs /server /rules /report /ans /r /rgo /item /disablemsg /enablelogs /warpto /warp /banworld /ssb /ban /pban /suspend /spk /unmute /mute /curse /time /uncurse /unban /givelevel /save /msg /tradeworld /uba /wkick /gsm /info /banip /nick /invis /jsb /sb /schat /sdb /g /radio /color /who /wave /dance /love /sleep /facepalm /fp /yes /no /omg /idk /shrug /furious /rolleyes /foldarms /fa /stubborn /fold /dab /sassy /dance2");
								}
								else if (isMod(peer))
								{
									Player::OnConsoleMessage(peer, "`o>> Commands: /market /cmsb /msb /asb /ysb /vsb /ghost /mods /trade /tradeinfo /sellfish /redeem /go /buy /online /summon /pay /kickall /status /pull /me /warn /logs /server /rules /report /ans /r /rgo /disablemsg /warpto /warp /banworld /ssb /ban /pban /spk /mute /curse /time /msg /tradeworld /uba /wkick /info /nick /invis /jsb /sb /schat /sdb /g /radio /color /who /save /wave /dance /love /sleep /facepalm /fp /yes /no /omg /idk /shrug /furious /rolleyes /foldarms /fa /stubborn /fold /dab /sassy /dance2");
								}
								else if (isSupport(peer))
								{
									Player::OnConsoleMessage(peer, "`o>> Commands: /market /ysb /vsb `$/ans `o/mods /go /trade /tradeinfo /sellfish /redeem /buy /pay /kickall /pull /me /rules /status /report /r /rgo /disablemsg /warp /ssb /ban /time /msg /tradeworld /uba /wkick /sb /sdb /g /radio /who /save /wave /dance /love /sleep /facepalm /fp /yes /no /omg /idk /shrug /furious /rolleyes /foldarms /fa /stubborn /fold /dab /sassy /dance2 /bluename /unbluename");
								}
								else if (static_cast<PlayerInfo*>(peer->data)->Subscriber)
								{
									Player::OnConsoleMessage(peer, "`o>> Commands: /market /mods /go /trade /tradeinfo /setchat /invis /jsb /sellfish /redeem /buy /pay /kickall /pull /me /rules /status /report /r /rgo /disablemsg /warp /ssb /ban /time /msg /tradeworld /uba /wkick /sb /sdb /g /radio /who /save /wave /dance /love /sleep /facepalm /fp /yes /no /omg /idk /shrug /furious /rolleyes /foldarms /fa /stubborn /fold /dab /sassy /dance2");
								}
								else
								{
									Player::OnConsoleMessage(peer, "`o>> Commands: /market /mods /go /trade /tradeinfo /sellfish /redeem /buy /pay /kickall /pull /me /rules /status /report /r /rgo /disablemsg /warp /ssb /ban /time /msg /tradeworld /uba /wkick /sb /sdb /g /radio /who /save /wave /dance /love /sleep /facepalm /fp /yes /no /omg /idk /shrug /furious /rolleyes /foldarms /fa /stubborn /fold /dab /sassy /dance2");
								}
							}
							if (str.substr(0, 5) == "/eye ") {
								string ev = str.substr(5, cch.length() - 5 - 1);
								if (ev.length() > 9) continue;
								if (ev.length() < 0) continue;
								if (!has_only_digits(ev)) continue;
								int n = stoi(ev);
								if (n < 0) continue;
								pdata(peer)->eyecolor = n;
								pdata(peer)->eyecolor2 = n;
								sendState(peer, pdata(peer));
							}
							if (str.substr(0, 5) == "/dye ") {
								string ev = str.substr(5, cch.length() - 5 - 1);
								if (ev.length() > 9) continue;
								if (ev.length() < 0) continue;
								if (!has_only_digits(ev)) continue;
								int n = stoi(ev);
								if (n < 0) continue;
							    pdata(peer)->dyecolor = n;
								sendState(peer, pdata(peer));
							}
							if (str.substr(0, 10) == "/gemevent ") {
								if (isMod(peer)) {
									string ev = str.substr(10, cch.length() - 10 - 1);
									if (ev.length() > 5) continue;
									if (ev.length() < 0) continue;
									if (!has_only_digits(ev)) continue;
									int n = stoi(ev);
									if (n > itemDefs.size()) continue;
									if (n < 0) continue;
									if (n > 5) continue;
									gem_event = n;
								}
							}
							else if (str == "/magic") {
							if (isMod(peer)) {
								if (!world) continue;
								Player::OnConsoleMessage(peer, "Magic!");
								string text = "action|play_sfx\nfile|audio/magic.wav\ndelayMS|0\n";
								BYTE* data = new BYTE[5 + text.length()];
								BYTE zero = 0;
								int type = 3;
								memcpy(data, &type, 4);
								memcpy(data + 4, text.c_str(), text.length());
								memcpy(data + 4 + text.length(), &zero, 1);
								ENetPacket* packetsou = enet_packet_create(data,
									5 + text.length(),
									ENET_PACKET_FLAG_RELIABLE);
								float x = ((PlayerInfo*)(peer->data))->x;
								float y = ((PlayerInfo*)(peer->data))->y;
								ENetPeer* currentPeer;
								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									Player::OnParticleEffect(currentPeer, 90, x, y, 0);
								}
								bool found = false;
								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									if (isHere(peer, currentPeer)) {
										bool isRev = false;
										for (int i = 5; i < 45; i++) {
											if (isRev == false) {
												Player::OnParticleEffect(currentPeer, 3, x + i * (rand() % 9), y + i * (rand() % 9), i * 100);
												Player::OnParticleEffect(currentPeer, 2, x + i * (rand() % 9), y + i * (rand() % 9), i * 100);
												isRev = true;
											}
											else {
												Player::OnParticleEffect(currentPeer, 3, x - i * (rand() % 9), y - i * (rand() % 9), i * 100);
												Player::OnParticleEffect(currentPeer, 2, x + i * (rand() % 9), y + i * (rand() % 9), i * 100);
												isRev = false;
											}
										}
									}
								}
							}
							}
							else if (str == "/news")
							{
								sendnews(peer);
							}
							else if (str == "/market")
							{
								GTDialog store;
								store.addLabelWithIcon("`wMarket Place", 1430, LABEL_BIG);
								store.addSpacer(SPACER_SMALL);
								store.addLabelWithIcon("`wOwn store:", 1434, LABEL_SMALL);
								bool existx = std::experimental::filesystem::exists("store/" + PlayerDB::getProperName(((PlayerInfo*)(peer->data))->rawName) + ".json");
								if (!existx)
								{
									store.addSmallText("`wYou don't have store right now. You can create it for 150.000 gems.");
									store.addSpacer(SPACER_SMALL);
									store.addButton("createstore", "Create my store.");
								}
								else
								{
									ifstream ifff("store/" + PlayerDB::getProperName(((PlayerInfo*)(peer->data))->rawName) + ".json");
									json j;
									ifff >> j;
									ifff.close();

									string ownedFgItemID = "2";
									string ownedStoreName = "0";

									ownedStoreName = j["name"].get<string>();

									//store.addStaticBlueFrame(ownedFgItemID, ownedStoreName,"entermystore", true);
									store.addItemWithCustomText(ownedFgItemID, ownedStoreName, "entermystore");
									store.addSpacer(SPACER_SMALL);
								}
								store.addSpacer(SPACER_BIG);
								store.addLabelWithIcon("`wPlayer's store:", 1434, LABEL_SMALL);

								bool existx2 = std::experimental::filesystem::exists("storeinfo/stores.json");
								if (!existx2)
								{
									store.addSmallText("`wThere is no any stores yet.");
								}
								else
								{
									vector<string> allStores;

									ifstream iffff("storeinfo/stores.json");
									json j2;
									iffff >> j2;
									iffff.close();
									for (int i = 0; i < j2["owners"].size(); i++)
									{
										allStores.push_back(j2["owners"][i]);
									}

									if (allStores.size() == 0 || (allStores[0] == ((PlayerInfo*)(peer->data))->rawName && allStores.size() == 1))
									{
										store.addSmallText("`wThere is no any stores yet.");
									}
									else
									{
										for (int i = 0; i < allStores.size(); i++)
										{
											if (allStores[i] == ((PlayerInfo*)(peer->data))->rawName)
											{
												continue;
											}
											ifstream ifffff("store/" + allStores[i] + ".json");
											json j3;
											ifffff >> j3;
											ifffff.close();

											/*if (i % 6 == 0 && i != 0) {
												store.addStaticBlueFrame(j3["fg"].get<string>(), j3["name"].get<string>(),"storeitem_"+ allStores[i] +"", true);
											}
											else {
												store.addStaticBlueFrame(j3["fg"].get<string>(), j3["name"].get<string>(),"storeitem_"+ allStores[i] +"", false);
											}*/

											store.addItemWithCustomText(j3["fg"].get<string>(), j3["name"].get<string>(), "storeitem_" + allStores[i] + "");

										}

									}
								}

								store.addSpacer(SPACER_SMALL);
								store.addQuickExit();
								store.endDialog("Close", "Close", "");
								Player::OnDialogRequest(peer, store.finishDialog());
							}
							/*
							else if (str.substr(0, 8) == "/redeem ")
							{
								MYSQL_ROW row;
								if (conn == nullptr) continue;
								if (conn != nullptr)
								{
									stringstream sse;
									string code = (str.substr(8).c_str());
									sse << "SELECT * FROM Redeem WHERE code = '" + code + "'";
									auto query = sse.str();
									auto q = query.c_str();
									if (mysql_query(conn, q))
									{
										string ers = mysql_error(conn); if (ers.find("Lost connection") != string::npos) ConnectToDatabase();
										cout << mysql_error(conn) << endl;


										enet_peer_disconnect_now(peer, 0);
										continue;
									}
									string key;
									string contains;
									string activated;
									string itemid;
									string itemcount;
									res = mysql_store_result(conn);
									while (row = mysql_fetch_row(res))
									{
										key = row[1];
										contains = row[2];
										activated = row[3];
										itemid = row[6];
										itemcount = row[7];
									}
									if (code.size() <= 3 || code.size() >= 30) continue;
									if (code == key && activated == "false")
									{
										auto qstate = 0;
										if (conn == nullptr)
										{
											cout << "conn was nullptr" << endl;
											continue;
										}
										if (conn != nullptr)
										{
											stringstream ss;
											ss << "UPDATE Redeem SET activated = 'true', activatedby = '" + static_cast<PlayerInfo*>(peer->data)->rawName + "' WHERE code = '" + code + "'";
											auto query = ss.str();
											const auto q = query.c_str();
											if (mysql_query(conn, q))
											{
												string ers = mysql_error(conn); if (ers.find("Lost connection") != string::npos) ConnectToDatabase();
												cout << mysql_error(conn) << endl;


												enet_peer_disconnect_now(peer, 0);
												continue;
											}
											if (contains == "modrank" || contains == "devrank")
											{
												string type;
												string prefix;
												string fullname;
												if (contains == "modrank")
												{
													type = "mod";
													prefix = "`#@";
													fullname = "Moderator";
												}
												else if (contains == "devrank")
												{
													type = "dev";
													prefix = "`6@";
													fullname = "Developer";
												}
												bool success = true;
												GiveRank(type, static_cast<PlayerInfo*>(peer->data)->rawName, success);
												string name2 = prefix + static_cast<PlayerInfo*>(peer->data)->tankIDName;
												GamePacket p7 = packetEnd(appendString(appendString(createPacket(), "OnNameChanged"), name2));
												memcpy(p7.data + 8, &(static_cast<PlayerInfo*>(peer->data)->netID), 4);
												static_cast<PlayerInfo*>(peer->data)->displayName = name2;
												ENetPacket* packet7 = enet_packet_create(p7.data,
													p7.len,
													ENET_PACKET_FLAG_RELIABLE);
												ENetPeer* currentPeer;
												for (currentPeer = server->peers;
													currentPeer < &server->peers[server->peerCount];
													++currentPeer)
												{
													if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
														continue;
													if (isHere(peer, currentPeer))
													{
														enet_peer_send(currentPeer, 0, packet7);
													}
												}
												delete p7.data;
												Player::OnTextOverlay(peer, "`cYou have obtained `^" + fullname + " `cRank!");
												continue;
											}
											else if (contains == "randitem")
											{
												bool success = true;
												SaveItemMoreTimes(atoi(itemid.c_str()), atoi(itemcount.c_str()), peer, success, static_cast<PlayerInfo*>(peer->data)->rawName + " from redeem");
												Player::OnTextOverlay(peer, "`cYou have obtained `^" + getItemDef(atoi(itemid.c_str())).name + " `cItem!");
												continue;
											}
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "Something went wrong while activating your code!", 0, true);
										}
									}
									else
									{
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "Invalid redeem code!", 0, true);
									}
								}
								else continue;
							}
							*/
							else if (str.substr(0, 8) == "/warpto ")
							{
								if (!isMod(peer))
								{
									//sendwrongcmd(peer);
									continue;
								}
								if (static_cast<PlayerInfo*>(peer->data)->isCursed == true)
								{
									GamePacket p0 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`4You are cursed now!"));
									ENetPacket* packet0 = enet_packet_create(p0.data,
										p0.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet0);
									delete p0.data;
									continue;
								}
								if (str.substr(8, cch.length() - 8 - 1) == "") continue;
								if (static_cast<PlayerInfo*>(peer->data)->rawName == str.substr(8, cch.length() - 8 - 1))
								{
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`#You can't warp to yourself!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
									continue;
								}
								string name = str.substr(8, str.length());
								ENetPeer* currentPeer;
								bool found = false;
								for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
									string name2 = static_cast<PlayerInfo*>(currentPeer->data)->rawName;
									std::transform(name.begin(), name.end(), name.begin(), ::tolower);
									std::transform(name2.begin(), name2.end(), name2.begin(), ::tolower);
									if (name == name2)
									{
										if (static_cast<PlayerInfo*>(currentPeer->data)->isinv || static_cast<PlayerInfo*>(currentPeer->data)->isNicked || static_cast<PlayerInfo*>(currentPeer->data)->currentWorld == "EXIT") break;
										if (static_cast<PlayerInfo*>(currentPeer->data)->currentWorld == "GAME1")
										{
											Player::OnConsoleMessage(peer, "`@This player is currently in `4GAME1`@!");
											break;
										}
										if (static_cast<PlayerInfo*>(currentPeer->data)->currentWorld == "GAME2")
										{
											Player::OnConsoleMessage(peer, "`@This player is currently in `4GAME2`@!");
											break;
										}
										int x = static_cast<PlayerInfo*>(currentPeer->data)->x;
										int y = static_cast<PlayerInfo*>(currentPeer->data)->y;
										string world = static_cast<PlayerInfo*>(currentPeer->data)->currentWorld;
										sendPlayerLeave(peer, static_cast<PlayerInfo*>(peer->data));
										joinWorld(peer, world, x, y);
										found = true;
									}
								}
								if (found)
								{
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`9Warping To Player..."));
									ENetPacket* packet = enet_packet_create(p.data,
										p.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
								}
								else
								{
									Player::OnConsoleMessage(peer, "`@Player Not `4Found! `@Or is currently in `4EXIT`@!");
								}
							}
							else if (str.substr(0, 6) == "/warp ")
							{
								string world = str.substr(6, str.length());
								std::transform(world.begin(), world.end(), world.begin(), ::toupper);
								if (serverIsFrozen)
								{
									Player::OnConsoleMessage(peer, "Try again later...");
									continue;
								}
								if (world.length() > 24)
								{
									Player::OnConsoleMessage(peer, "World name too long");
									continue;
								}
								if (static_cast<PlayerInfo*>(peer->data)->isCursed == true)
								{
									Player::OnConsoleMessage(peer, "You are cursed!");
									continue;
								}
								if (world == "EXIT")
								{
									Player::OnConsoleMessage(peer, "You cant warp to this world!");
									continue;
								}
								if (std::experimental::filesystem::exists("worlds/_" + world + ".json"))
								{
									std::streampos fsize = 0;
									std::ifstream myfile("worlds/_" + world + ".json", ios::in);
									fsize = myfile.tellg();
									myfile.seekg(0, ios::end);
									fsize = myfile.tellg() - fsize;
									myfile.close();
									static_assert(sizeof(fsize) >= sizeof(long long), "Oops.");
									if (fsize <= 90000)
									{
										Player::OnConsoleMessage(peer, "`4Oh no! ``This world have been corrupted.");
										continue;
									}
									auto existsban = std::experimental::filesystem::exists("worldbans/" + world + "/" + static_cast<PlayerInfo*>(peer->data)->rawName);
									if (existsban)
									{
										Player::OnConsoleMessage(peer, "`4Oh no! ``You've been banned from that world by its owner! Try again later after ban wears off.");
										continue;
									}
									auto info1 = worldDB.get(world);
									if (info1.isNuked)
									{
										Player::OnConsoleMessage(peer, "`4This world is nuked!");
										continue;
									}
									sendPlayerToWorld(peer, static_cast<PlayerInfo*>(peer->data), world);
								}
								else
								{
									bool contains_non_alpha
										= !std::regex_match(world, std::regex("^[A-Za-z0-9]+$"));
									if (contains_non_alpha == true)
									{
										Player::OnConsoleMessage(peer, "You cant warp to this world!");
										continue;
									}
									auto info1 = worldDB.get(world);
									if (info1.isNuked)
									{
										Player::OnConsoleMessage(peer, "`4This world is nuked!");
										continue;
									}
									sendPlayerToWorld(peer, static_cast<PlayerInfo*>(peer->data), world);
								}
							}
							else if (str == "/banworld")
							{
								if (!isMod(peer))
								{
									//sendwrongcmd(peer);
									continue;
								}
								if (world == nullptr || world->name == "EXIT" || world->name == "GAME1" || world->name == "GAME2" || serverIsFrozen) continue;
								WorldInfo* world = getPlyersWorld(peer);
								if (world->isNuked)
								{
									world->isNuked = false;
									Player::OnTextOverlay(peer, "`^You have `@Un-Nuked `^the world!");
									ofstream unnukeLog("logs/unnuke.txt", ios::app);
									unnukeLog << "administrator " << static_cast<PlayerInfo*>(peer->data)->rawName << " un-nuked world: " << world->name << endl;
									unnukeLog.close();
									if (isDev(peer))
									{
									}
									else
									{
										string textInfo = "`1[M] `1[`o" + currentDateTime() + "`1] `6" + static_cast<PlayerInfo*>(peer->data)->tankIDName + " `4Just `2UNNUKED `4" + world->name + "";
										showModLogs(textInfo);
									}
								}
								else
								{
									if (isDev(peer))
									{
									}
									else
									{
										string textInfo = "`1[M] `1[`o" + currentDateTime() + "`1] `6" + static_cast<PlayerInfo*>(peer->data)->tankIDName + " `4Just `2NUKED `4" + world->name + "";
										showModLogs(textInfo);
									}
									ofstream nukeLog("logs.txt", ios::app);
									nukeLog << "administrator " << static_cast<PlayerInfo*>(peer->data)->rawName << " nuked world: " << world->name << endl;
									nukeLog.close();
									world->isNuked = true;
									Player::OnTextOverlay(peer, "`^You have `@Nuked `^the world!");
									string name = static_cast<PlayerInfo*>(peer->data)->displayName;
									GamePacket p1 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`o>>`4" + world->name + " `4was nuked from orbit`o. It's the only way to be sure. Play nice, everybody!"));
									string text = "action|play_sfx\nfile|audio/bigboom.wav\ndelayMS|0\n";
									BYTE* data = new BYTE[5 + text.length()];
									BYTE zero = 0;
									int type = 3;
									memcpy(data, &type, 4);
									memcpy(data + 4, text.c_str(), text.length());
									memcpy(data + 4 + text.length(), &zero, 1);
									ENetPeer* currentPeer;
									for (currentPeer = server->peers;
										currentPeer < &server->peers[server->peerCount];
										++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
											continue;
										if (!static_cast<PlayerInfo*>(currentPeer->data)->radio)
											continue;
										ENetPacket* packet = enet_packet_create(p1.data,
											p1.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(currentPeer, 0, packet);
										ENetPacket* packet2 = enet_packet_create(data,
											5 + text.length(),
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(currentPeer, 0, packet2);
										if (isHere(peer, currentPeer))
										{
											if (!isMod(currentPeer))
											{
												sendPlayerLeave(currentPeer, static_cast<PlayerInfo*>(currentPeer->data));
												static_cast<PlayerInfo*>(currentPeer->data)->currentWorld = "EXIT";
												sendWorldOffers(currentPeer);
											}
										}
										//enet_host_flush(server);
									}
									delete data;
									delete p1.data;
								}
								continue;
							}
							else if (str == "/bluename") {
								using namespace std::chrono;
								if (static_cast<PlayerInfo*>(peer->data)->level < 125)
								{
									Player::OnConsoleMessage(peer, "`1You need to be level `@125 `1to do that!");
									continue;
								}
								else
								{
									if (((PlayerInfo*)(peer->data))->rawName == ((PlayerInfo*)(peer->data))->displayName) {
										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5blue name enabled"));
										ENetPacket* packet = enet_packet_create(p.data,
											p.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete p.data;
										static_cast<PlayerInfo*>(peer->data)->country = "|maxLevel";
									}
									else
									{
										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5blue name disabled"));
										ENetPacket* packet = enet_packet_create(p.data,
											p.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete p.data;
										static_cast<PlayerInfo*>(peer->data)->country = "|maxLevel";
									}
								}
								//enet_host_flush(server);

							}
							else if (str.substr(0, 5) == "/ssb ")
							{
								using namespace std::chrono;
								if (static_cast<PlayerInfo*>(peer->data)->level < 80)
								{
									Player::OnConsoleMessage(peer, "`1You need to be level `@80 `1to do that!");
									continue;
								}
								if (static_cast<PlayerInfo*>(peer->data)->isDuctaped == true)
								{
									GamePacket p0 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`4You are muted now!"));
									ENetPacket* packet0 = enet_packet_create(p0.data,
										p0.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet0);
									delete p0.data;
									continue;
								}
								using namespace std::chrono;
								if (static_cast<PlayerInfo*>(peer->data)->lastSSB + 60000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count())
								{
									static_cast<PlayerInfo*>(peer->data)->lastSSB = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
								}
								else
								{
									int kiekDar = (static_cast<PlayerInfo*>(peer->data)->lastSSB + 60000 - (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) / 1000; // jei nedalinti is 1000, tai rodys milisekundem laika, reikia paversti i sekundes
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`9Cooldown `@Please Wait `9" + to_string(kiekDar) + " Seconds `@To Throw Another Broadcast!"));
									ENetPacket* packet = enet_packet_create(p.data,
										p.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									//enet_host_flush(server);
									continue;
								}
								string name = static_cast<PlayerInfo*>(peer->data)->displayName;
								Player::OnConsoleMessage(peer, "`2>> `9Special Broadcast sent to all players online`2!");
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "CP:_PL:0_OID:_CT:[SB]_ `#SPEC. BROADCAST ** `#from (`2" + name + "`#) in [`o" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "`#] ** :`o " + str.substr(5, cch.length() - 5 - 1)));
								string text = "action|play_sfx\nfile|audio/double_chance.wav\ndelayMS|0\n";
								BYTE* data = new BYTE[5 + text.length()];
								BYTE zero = 0;
								int type = 3;
								memcpy(data, &type, 4);
								memcpy(data + 4, text.c_str(), text.length());
								memcpy(data + 4 + text.length(), &zero, 1);
								ENetPeer* currentPeer;
								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									if (!static_cast<PlayerInfo*>(currentPeer->data)->radio)
										continue;
									ENetPacket* packet = enet_packet_create(p.data,
										p.len,
										ENET_PACKET_FLAG_RELIABLE);
									ENetPacket* packet2 = enet_packet_create(data,
										5 + text.length(),
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(currentPeer, 0, packet2);
									enet_peer_send(currentPeer, 0, packet);
									static_cast<PlayerInfo*>(currentPeer->data)->lastSbbWorld = static_cast<PlayerInfo*>(peer->data)->currentWorld;
								}
								delete data;
								delete p.data;
								//elete p3.data;
							}
							else if (str.substr(0, 5) == "/ban ")
							{
								if (world == nullptr || world->name == "EXIT" || serverIsFrozen) continue;
								if (static_cast<PlayerInfo*>(peer->data)->haveGrowId && static_cast<PlayerInfo*>(peer->data)->rawName == getPlyersWorld(peer)->owner || isMod(peer))
								{
									if (str.substr(5, cch.length() - 5 - 1) == "") continue;
									if (static_cast<PlayerInfo*>(peer->data)->rawName == str.substr(5, cch.length() - 5 - 1)) continue;
									if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "HELL")
									{
										Player::OnConsoleMessage(peer, "`4You can't ban players in this world.");
										continue;
									}
									string name = static_cast<PlayerInfo*>(peer->data)->displayName;
									string kickname = PlayerDB::getProperName(str.substr(5, cch.length() - 5 - 1));

									ENetPeer* currentPeerp;
									for (currentPeerp = server->peers;
										currentPeerp < &server->peers[server->peerCount];
										++currentPeerp)
									{
										if (currentPeerp->state != ENET_PEER_STATE_CONNECTED)
											continue;

										if (static_cast<PlayerInfo*>(currentPeerp->data)->rawName == kickname)
										{

											if (isDev(currentPeerp) && static_cast<PlayerInfo*>(currentPeerp->data)->rawName == kickname)
											{
												Player::OnConsoleMessage(peer, "`4You can't ban him!");
												break;
											}
											else
											{
												namespace fs = std::experimental::filesystem;
												if (!fs::is_directory("worldbans/" + getPlyersWorld(peer)->name) || !fs::exists("worldbans/" + getPlyersWorld(peer)->name))
												{
													fs::create_directory("worldbans/" + getPlyersWorld(peer)->name);
													std::ofstream outfile("worldbans/" + getPlyersWorld(peer)->name + "/" + static_cast<PlayerInfo*>(currentPeerp->data)->rawName);
													outfile << "worldbanned by: " + static_cast<PlayerInfo*>(peer->data)->rawName;
													outfile.close();
												}
												else
												{
													std::ofstream outfile("worldbans/" + getPlyersWorld(peer)->name + "/" + static_cast<PlayerInfo*>(currentPeerp->data)->rawName);
													outfile << "worldbanned by: " + static_cast<PlayerInfo*>(peer->data)->rawName;
													outfile.close();
												}
												sendPlayerLeave(currentPeerp, static_cast<PlayerInfo*>(currentPeerp->data));
												static_cast<PlayerInfo*>(currentPeerp->data)->currentWorld = "EXIT";
												sendWorldOffers(currentPeerp);

												ENetPeer* currentPeer;
												for (currentPeer = server->peers;
													currentPeer < &server->peers[server->peerCount];
													++currentPeer)
												{
													if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
														continue;
													if (isHere(peer, currentPeer))
													{

														GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), name + " `4world bans " + "`o" + kickname + " from `w" + world->name + "`o!"));
														string text = "action|play_sfx\nfile|audio/repair.wav\ndelayMS|0\n";
														BYTE* data = new BYTE[5 + text.length()];
														BYTE zero = 0;
														int type = 3;
														memcpy(data, &type, 4);
														memcpy(data + 4, text.c_str(), text.length());
														memcpy(data + 4 + text.length(), &zero, 1);
														ENetPacket* packetsou = enet_packet_create(data,
															5 + text.length(),
															ENET_PACKET_FLAG_RELIABLE);
														ENetPacket* packet = enet_packet_create(p.data,
															p.len,
															ENET_PACKET_FLAG_RELIABLE);
														enet_peer_send(currentPeer, 0, packetsou);
														enet_peer_send(currentPeer, 0, packet);
														delete data;
														delete p.data;
													}
												}
											}
										}
									}
								}
							}
							else if (str.substr(0, 9) == "/suspend ")
							{
								if (!isDev(peer))
								{
									//sendwrongcmd(peer);
									continue;
								}
								string warn_info = str;
								size_t extra_space = warn_info.find("  ");
								if (extra_space != std::string::npos)
								{
									warn_info.replace(extra_space, 2, " ");
								}
								string delimiter = " ";
								size_t pos = 0;
								string warn_user;
								string reason;
								if ((pos = warn_info.find(delimiter)) != std::string::npos)
								{
									warn_info.erase(0, pos + delimiter.length());
								}
								else
								{
									Player::OnConsoleMessage(peer, "`@Please specify a `9Player `@You want to `4Suspend`@!");
									continue;
								}
								if ((pos = warn_info.find(delimiter)) != std::string::npos)
								{
									warn_user = warn_info.substr(0, pos);
									warn_info.erase(0, pos + delimiter.length());
								}
								else
								{
									Player::OnConsoleMessage(peer, "`@Please enter your `4Suspend `@Reason!");
									continue;
								}
								reason = warn_info;

								bool existx = std::experimental::filesystem::exists("players/" + PlayerDB::getProperName(warn_user) + ".json");
								if (!existx)
								{
									Player::OnConsoleMessage(peer, "`9Player `@Not Found! `5Suspend `@Aborted!");
									continue;
								}
								ifstream fg("players/" + PlayerDB::getProperName(warn_user) + ".json");
								json j;
								fg >> j;
								fg.close();
								if (j["isBanned"] == 1)
								{
									Player::OnConsoleMessage(peer, "`9This Player `@is already `4banned");
									continue;
								}

								using namespace std::chrono;
								if (static_cast<PlayerInfo*>(peer->data)->lastsuspend + 300000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count())
								{
									static_cast<PlayerInfo*>(peer->data)->lastsuspend = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
									static_cast<PlayerInfo*>(peer->data)->lastsuspendCount = 1;
								}
								else
								{
									static_cast<PlayerInfo*>(peer->data)->lastsuspendCount = static_cast<PlayerInfo*>(peer->data)->lastsuspendCount + 1;
									if (static_cast<PlayerInfo*>(peer->data)->lastsuspendCount == 3)
									{
										AutoDemote(static_cast<PlayerInfo*>(peer->data)->rawName, to_string(static_cast<PlayerInfo*>(peer->data)->adminLevel), to_string(peer->address.host), "3 suspends in the past 5 minutes! He wrote: " + reason);
										continue;
									}
								}

								j["isBanned"] = 1;
								ofstream fs("players/" + PlayerDB::getProperName(warn_user) + ".json");
								fs << j;
								fs.close();

								ofstream suspendLog("logs/suspend.txt", ios::app);
								suspendLog << "administrator " << static_cast<PlayerInfo*>(peer->data)->rawName << " used /suspend " << warn_user << " " << reason << endl;
								suspendLog.close();
								SendConsole("Player(" + PlayerDB::getProperName(warn_user) + ") Duration(Permanent) Reason(" + reason + ") CausedBy(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "BAN");
								ENetPeer* currentPeer;
								bool online = false;
								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									Player::OnConsoleMessage(currentPeer, "`#** `$The Ancient Ones `ohave `4banned `w" + PlayerDB::getProperName(warn_user) + " `#** `o(`4/rules `oto see the rules!)");
									if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == warn_user)
									{
										if (!static_cast<PlayerInfo*>(peer->data)->Console) enet_peer_disconnect_later(currentPeer, 0);
										online = true;
									}
								}
								if (online == false)
								{
									Player::OnConsoleMessage(peer, "User was banned in offline!");
									continue;
								}
							}
							else if (str.substr(0, 6) == "/pban ")
							{
								if (!isMod(peer))
								{
									//sendwrongcmd(peer);
									continue;
								}
								string ban_info = str;
								size_t extra_space = ban_info.find("  ");
								if (extra_space != std::string::npos)
								{
									ban_info.replace(extra_space, 2, " ");
								}
								string delimiter = " ";
								size_t pos = 0;
								string ban_user;
								string ban_time;
								string ban_reason;
								if ((pos = ban_info.find(delimiter)) != std::string::npos)
								{
									// npos - jeigu find nieko nerado, ka turejo surasti. Tai cia jei taip neatsitiko, kad nerado nieko, tada else suveikia, jeigu rado ta " " tarpa, tada if
									ban_info.erase(0, pos + delimiter.length());
								}
								else
								{
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`^Usage `2/pban <`^user`2> <`^minutes`2> <`^reason`2>!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
									continue;
								}
								if ((pos = ban_info.find(delimiter)) != std::string::npos)
								{
									ban_user = ban_info.substr(0, pos);
									ban_info.erase(0, pos + delimiter.length());
								}
								else
								{
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`^Usage `2/pban <`^user`2> <`^minutes`2> <`^reason`2>!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
									continue;
								}
								if ((pos = ban_info.find(delimiter)) != std::string::npos)
								{
									ban_time = ban_info.substr(0, pos);
									ban_info.erase(0, pos + delimiter.length());
								}
								else
								{
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`^Usage `2/pban <`^user`2> <`^minutes`2> <`^reason`2>!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
									continue;
								}
								ban_reason = ban_info;
								string user = ban_user;
								string muteTime = ban_time;
								string reason = ban_reason;
								if (reason.length() <= 0)
								{
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`@Reason should not be empty!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
									continue;
								}
								if (muteTime.length() > 9)
								{
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`@Too much symbols in minutes!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
									continue;
								}
								bool contains_non_int = !std::regex_match(muteTime, std::regex("^[0-9]+$"));
								if (contains_non_int == true)
								{
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`@Invalid `4Minutes `@Format!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
									continue;
								}
								else
								{
									int konvertuotasInt = stoi(muteTime);
									if (konvertuotasInt <= 0 || konvertuotasInt > 43200) // 10080  - iki 7 dienu
									{
										GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`4Minutes `@Should Be Between `91-43200`@!"));
										ENetPacket* packet2 = enet_packet_create(p2.data,
											p2.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet2);
										delete p2.data;
										continue;
									}
									else
									{
										bool existx = std::experimental::filesystem::exists("players/" + PlayerDB::getProperName(user) + ".json");
										if (!existx)
										{
											Player::OnConsoleMessage(peer, "`9Player `@Not Found! `5Suspend `@Aborted!");
											continue;
										}
										if (reason.length() < 5)
										{
											AutoDemote(static_cast<PlayerInfo*>(peer->data)->rawName, to_string(static_cast<PlayerInfo*>(peer->data)->adminLevel), to_string(peer->address.host), "warn reason length < 5. He wrote: " + reason);
											continue;
										}
										vector<string> blackWords = { "retard", "bitch", "damn", "fuck", "away", "you", "hello", "lol", "xd", "no", "yes", "what", "go", "noob", "niger", "top", "nigger", "nigga", "niga", "idiot", "shut", "stupid", "why", "gg", "haha", "wtf", "die", "suck", "server", "shut" };
										if (std::find(blackWords.begin(), blackWords.end(), reason) != blackWords.end())
										{
											AutoDemote(static_cast<PlayerInfo*>(peer->data)->rawName, to_string(static_cast<PlayerInfo*>(peer->data)->adminLevel), to_string(peer->address.host), "Found black world in reason. He wrote: " + reason);
											continue;
										}
										using namespace std::chrono;
										if (static_cast<PlayerInfo*>(peer->data)->lastban + 300000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count())
										{
											static_cast<PlayerInfo*>(peer->data)->lastban = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
											static_cast<PlayerInfo*>(peer->data)->lastbanCount = 1;
										}
										else
										{
											static_cast<PlayerInfo*>(peer->data)->lastbanCount = static_cast<PlayerInfo*>(peer->data)->lastbanCount + 1;
											if (static_cast<PlayerInfo*>(peer->data)->lastbanCount == 3)
											{
												AutoDemote(static_cast<PlayerInfo*>(peer->data)->rawName, to_string(static_cast<PlayerInfo*>(peer->data)->adminLevel), to_string(peer->address.host), "3 bans in the past 5 minutes! He wrote: " + reason);
												continue;
											}
										}
										ofstream savebantime("timebanned/" + PlayerDB::getProperName(user) + ".txt");
										savebantime << (GetCurrentTimeInternalSeconds() + (konvertuotasInt * 60)) << endl;
										savebantime << static_cast<PlayerInfo*>(peer->data)->rawName << endl;
										savebantime << reason << endl;
										savebantime.close();
										ofstream pbanlog("logs/pban.txt", ios::app);
										pbanlog << "administrator " << static_cast<PlayerInfo*>(peer->data)->rawName << " used /pban " << user << " " << to_string(konvertuotasInt) << " " << reason << endl;
										pbanlog.close();
										SendConsole("Player(" + user + ") Duration(" + OutputBanTime(konvertuotasInt * 60) + "h) Reason(" + reason + ") CausedBy(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "BAN");
										ENetPeer* currentPeer;
										GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`#** `$The Ancient Ones `ohave `bbanned `2" + user + " `$for`4 " + OutputBanTime(konvertuotasInt * 60) + " `$reason `4" + reason + "`#** `o(`4/rules `oto see the rules!)"));
										for (currentPeer = server->peers;
											currentPeer < &server->peers[server->peerCount];
											++currentPeer)
										{
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
												continue;
											ENetPacket* packet2 = enet_packet_create(p2.data,
												p2.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(currentPeer, 0, packet2);
											if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == PlayerDB::getProperName(user))
											{
												Player::OnAddNotification(currentPeer, "`0Warning from `4System`0: You've been `4BANNED `0from Growtopia `4for " + OutputBanTime(konvertuotasInt * 60) + " `0reason: `4" + reason + "`0.", "audio/hub_open.wav", "interface/atomic_button.rttex");
												Player::OnConsoleMessage(currentPeer, "`4You have been banned for`9 " + OutputBanTime(konvertuotasInt * 60) + " `4reason `9" + reason + " `4by `2" + static_cast<PlayerInfo*>(peer->data)->rawName + "`4!");
												if (!static_cast<PlayerInfo*>(peer->data)->Console) enet_peer_disconnect_later(currentPeer, 0);
											}
										}
										delete p2.data;
										if (isDev(peer))
										{
										}
										else
										{
											string textInfo = "`1[M] `1[`o" + currentDateTime() + "`1] `6" + static_cast<PlayerInfo*>(peer->data)->tankIDName + " `4Just `2BANNED `4player `w" + user + " `6for`4 " + OutputBanTime(konvertuotasInt * 60) + " `7reason: `4 " + reason + "";
											showModLogs(textInfo);
										}
										GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`2User `8" + user + " `2 has successfully banned for `8" + OutputBanTime(konvertuotasInt * 60) + "`2 reason: `4 " + reason + ""));
										ENetPacket* packet = enet_packet_create(ps.data,
											ps.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete ps.data;
									}
								}
							}
							else if (str == "/save")
							{

								if (((PlayerInfo*)(peer->data))->rawName != "time") {
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`9Sorry! `^But this command only available for `6@Time"));
									ENetPacket* packet = enet_packet_create(p.data,
										p.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									continue;
								}


								if (((PlayerInfo*)(peer->data))->rawName == "time") {
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`^Saving `9data`^!"));
									ENetPeer* currentPeer;
									for (currentPeer = server->peers;
										currentPeer < &server->peers[server->peerCount];
										++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
											continue;
										ENetPacket* packet = enet_packet_create(p.data,
											p.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(currentPeer, 0, packet);
										//enet_peer_disconnect_now(currentPeer, 0);
									}
									saveAllWorlds();
									delete p.data;

								}
							}
							else if (str.substr(0, 5) == "/spk ")
							{
								if (!isDev(peer))
								{
									//sendwrongcmd(peer);
									continue;
								}
								if (static_cast<PlayerInfo*>(peer->data)->isDuctaped == true)
								{
									GamePacket p0 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`4You are muted now!"));
									ENetPacket* packet0 = enet_packet_create(p0.data,
										p0.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet0);
									delete p0.data;
									continue;
								}
								string say_info = str;
								size_t extra_space = say_info.find("  ");
								if (extra_space != std::string::npos)
								{
									say_info.replace(extra_space, 2, " ");
								}
								string delimiter = " ";
								size_t pos = 0;
								string say_user;
								string say_message;
								if ((pos = say_info.find(delimiter)) != std::string::npos)
								{
									say_info.erase(0, pos + delimiter.length());
								}
								else
								{
									GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`oPlease enter a player's name."));
									ENetPacket* packet = enet_packet_create(ps.data,
										ps.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete ps.data;
									continue;
								}
								if ((pos = say_info.find(delimiter)) != std::string::npos)
								{
									say_user = say_info.substr(0, pos);
									say_info.erase(0, pos + delimiter.length());
								}
								else
								{
									GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`oPlease enter a message."));
									ENetPacket* packet = enet_packet_create(ps.data,
										ps.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete ps.data;
									continue;
								}
								say_message = say_info;
								ENetPeer* currentPeer;
								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == say_user)
									{
										GamePacket p0 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`6>> `2" + say_user + " `6said `2" + say_message));
										ENetPacket* packet0 = enet_packet_create(p0.data,
											p0.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet0);
										delete p0.data;
										SendChat(currentPeer, static_cast<PlayerInfo*>(currentPeer->data)->netID, say_message);
										if (isDev(peer))
										{
										}
										else
										{
											string textInfo = "`1[M] `1[`o" + currentDateTime() + "`1] `6" + static_cast<PlayerInfo*>(peer->data)->tankIDName + " `4used `2/spk " + say_user + " " + say_message + ".";
											showModLogs(textInfo);
										}
									}
								}
							}
							else if (str.substr(0, 8) == "/unmute ")
							{
								if (!isDev(peer))
								{
									//sendwrongcmd(peer);
									continue;
								}
								if (str.substr(8, cch.length() - 8 - 1) == "") continue;
								if (static_cast<PlayerInfo*>(peer->data)->rawName == str.substr(8, cch.length() - 8 - 1)) continue;
								string name = PlayerDB::getProperName(str.substr(8, cch.length() - 8 - 1));
								bool existx = std::experimental::filesystem::exists("timemuted/" + PlayerDB::getProperName(name) + ".txt");
								if (!existx)
								{
									Player::OnConsoleMessage(peer, "`9Player `@Not Found! `5Unmute `@Aborted!");
									continue;
								}
								remove(("timemuted/" + name + ".txt").c_str());
								ofstream unmutelog("logs/unmute.txt", ios::app);
								unmutelog << "administrator " << static_cast<PlayerInfo*>(peer->data)->rawName << " used /unmute " << name << endl;
								unmutelog.close();
								ENetPeer* currentPeer;
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`#** `$The Ancient Ones `ohave `bremoved mute from `2" + name + " `#** `o(`4/rules `oto see the rules!)"));
								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(currentPeer, 0, packet2);
									if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == name)
									{
										static_cast<PlayerInfo*>(currentPeer->data)->taped = false;
										static_cast<PlayerInfo*>(currentPeer->data)->isDuctaped = false;
										static_cast<PlayerInfo*>(currentPeer->data)->cantsay = false;
										static_cast<PlayerInfo*>(currentPeer->data)->lastMuted = 0;
										send_state(currentPeer);
										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`4You have been unmuted!"));
										ENetPacket* packet = enet_packet_create(p.data,
											p.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(currentPeer, 0, packet);
										sendClothes(currentPeer);
										{
											Player::OnConsoleMessage(peer, "`2You have unmuted the player!");
										}
										delete p.data;
									}
								}
								delete p2.data;
								if (isDev(peer))
								{
								}
								else
								{
									string textInfo = "`1[M] `1[`o" + currentDateTime() + "`1] `6" + static_cast<PlayerInfo*>(peer->data)->tankIDName + " `4Just `2UNMUTED `4player `w" + PlayerDB::getProperName(str.substr(8, cch.length() - 8 - 1));
									showModLogs(textInfo);
								}
							}
							else if (str.substr(0, 6) == "/mute ")
							{
								if (!isMod(peer))
								{
									//sendwrongcmd(peer);
									continue;
								}
								string ban_info = str;
								size_t extra_space = ban_info.find("  ");
								if (extra_space != std::string::npos)
								{
									ban_info.replace(extra_space, 2, " ");
								}
								string delimiter = " ";
								size_t pos = 0;
								string ban_user;
								string ban_time;
								string ban_reason;
								if ((pos = ban_info.find(delimiter)) != std::string::npos)
								{
									// npos - jeigu find nieko nerado, ka turejo surasti. Tai cia jei taip neatsitiko, kad nerado nieko, tada else suveikia, jeigu rado ta " " tarpa, tada if
									ban_info.erase(0, pos + delimiter.length());
								}
								else
								{
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`^Usage `2/mute <`^user`2> <`^minutes`2> <`^reason`2>!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
									continue;
								}
								if ((pos = ban_info.find(delimiter)) != std::string::npos)
								{
									ban_user = ban_info.substr(0, pos);
									ban_info.erase(0, pos + delimiter.length());
								}
								else
								{
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`^Usage `2/mute <`^user`2> <`^minutes`2> <`^reason`2>!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
									continue;
								}
								if ((pos = ban_info.find(delimiter)) != std::string::npos)
								{
									ban_time = ban_info.substr(0, pos);
									ban_info.erase(0, pos + delimiter.length());
								}
								else
								{
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`^Usage `2/mute <`^user`2> <`^minutes`2> <`^reason`2>!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
									continue;
								}
								ban_reason = ban_info;
								string user = ban_user;
								string muteTime = ban_time;
								string reason = ban_reason;
								if (static_cast<PlayerInfo*>(peer->data)->rawName == PlayerDB::getProperName(user))
								{
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`@You cannot mute your-self!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
									continue;
								}
								if (reason.length() <= 0)
								{
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`@Reason should not be empty!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
									continue;
								}
								if (muteTime.length() > 9)
								{
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`@Too much symbols!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
									continue;
								}
								bool contains_non_int = !std::regex_match(muteTime, std::regex("^[0-9]+$"));
								if (contains_non_int == true)
								{
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`@Invalid `4Minutes `@Format!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
									continue;
								}
								else
								{
									int konvertuotasInt = stoi(muteTime);
									if (konvertuotasInt <= 0 || konvertuotasInt > 10080) // 10080  - iki 7 dienu
									{
										GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`4Minutes `@Should Be Between `91-10080`@!"));
										ENetPacket* packet2 = enet_packet_create(p2.data,
											p2.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet2);
										delete p2.data;
										continue;
									}
									else
									{
										bool existx = std::experimental::filesystem::exists("players/" + PlayerDB::getProperName(user) + ".json");
										if (!existx)
										{
											Player::OnConsoleMessage(peer, "`9Player `@Not Found! `5Suspend `@Aborted!");
											continue;
										}

										ofstream savemutetime("timemuted/" + PlayerDB::getProperName(user) + ".txt");
										savemutetime << (GetCurrentTimeInternalSeconds() + (konvertuotasInt * 60)) << endl;
										savemutetime << static_cast<PlayerInfo*>(peer->data)->rawName << endl;
										savemutetime << reason << endl;
										savemutetime.close();

										ofstream spawnLog("logs/mute.txt", ios::app);
										spawnLog << "administrator " << static_cast<PlayerInfo*>(peer->data)->rawName << " used /mute " << user << " " << to_string(konvertuotasInt) << " " << reason << endl;
										spawnLog.close();
										ENetPeer* currentPeer;
										GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`#** `$The Ancient Ones `ohave `bmuted `2" + user + " `ofor`4 " + OutputBanTime(konvertuotasInt * 60) + " `oreason `4" + reason + "`#** `o(`4/rules `oto see the rules!)"));
										for (currentPeer = server->peers;
											currentPeer < &server->peers[server->peerCount];
											++currentPeer)
										{
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
												continue;
											ENetPacket* packet2 = enet_packet_create(p2.data,
												p2.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(currentPeer, 0, packet2);
											if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == PlayerDB::getProperName(user))
											{
												using namespace std::chrono;
												static_cast<PlayerInfo*>(currentPeer->data)->taped = true;
												static_cast<PlayerInfo*>(currentPeer->data)->isDuctaped = true;
												static_cast<PlayerInfo*>(currentPeer->data)->cantsay = true;
												//static_cast<PlayerInfo*>(currentPeer->data)->mutedMiliseconds = konvertuotasInt * 60 * 1000;
												static_cast<PlayerInfo*>(currentPeer->data)->lastMuted = (GetCurrentTimeInternalSeconds()) + (konvertuotasInt * 60);
												send_state(currentPeer);
												sendClothes(currentPeer);
												Player::OnAddNotification(currentPeer, "`0Warning from `4System`0: You've been `4MUTED `0from Growtopia for " + OutputBanTime(konvertuotasInt * 60) + " `oreason`4 " + reason + "", "audio/hub_open.wav", "interface/atomic_button.rttex");
												Player::OnConsoleMessage(currentPeer, "`4You have been muted for`9 " + OutputBanTime(konvertuotasInt * 60) + " `4reason `9" + reason + " `4by `2" + static_cast<PlayerInfo*>(peer->data)->rawName + "`4!");
											}
										}
										delete p2.data;
										if (isDev(peer))
										{
										}
										else
										{
											string textInfo = "`1[M] `1[`o" + currentDateTime() + "`1] `6" + static_cast<PlayerInfo*>(peer->data)->tankIDName + " `4Just `2MUTED `4player `w" + user + " `6for`4 " + OutputBanTime(konvertuotasInt * 60) + " `oreason`4 " + reason + "";
											showModLogs(textInfo);
										}
										GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`2User `8" + user + " `2 has successfully muted for `8" + OutputBanTime(konvertuotasInt * 60) + " `oreason`4 " + reason + "."));
										ENetPacket* packet = enet_packet_create(ps.data,
											ps.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete ps.data;
									}
								}
							}
							else if (str.substr(0, 7) == "/curse ")
							{
								if (!isMod(peer))
								{
									//sendwrongcmd(peer);
									continue;
								}
								string ban_info = str;
								size_t extra_space = ban_info.find("  ");
								if (extra_space != std::string::npos)
								{
									ban_info.replace(extra_space, 2, " ");
								}
								string delimiter = " ";
								size_t pos = 0;
								string ban_user;
								string ban_time;
								string ban_reason;
								if ((pos = ban_info.find(delimiter)) != std::string::npos)
								{
									// npos - jeigu find nieko nerado, ka turejo surasti. Tai cia jei taip neatsitiko, kad nerado nieko, tada else suveikia, jeigu rado ta " " tarpa, tada if
									ban_info.erase(0, pos + delimiter.length());
								}
								else
								{
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`^Usage `2/curse <`^user`2> <`^minutes`2> <`^reason`2>!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
									continue;
								}
								if ((pos = ban_info.find(delimiter)) != std::string::npos)
								{
									ban_user = ban_info.substr(0, pos);
									ban_info.erase(0, pos + delimiter.length());
								}
								else
								{
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`^Usage `2/curse <`^user`2> <`^minutes`2> <`^reason`2>!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
									continue;
								}
								if ((pos = ban_info.find(delimiter)) != std::string::npos)
								{
									ban_time = ban_info.substr(0, pos);
									ban_info.erase(0, pos + delimiter.length());
								}
								else
								{
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`^Usage `2/curse <`^user`2> <`^minutes`2> <`^reason`2>!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
									continue;
								}
								ban_reason = ban_info;
								string user = ban_user;
								string muteTime = ban_time;
								string reason = ban_reason;
								if (static_cast<PlayerInfo*>(peer->data)->rawName == PlayerDB::getProperName(user))
								{
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`@You cannot curse your-self!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
									continue;
								}
								if (reason.length() <= 0)
								{
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`@Reason should not be empty!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
									continue;
								}
								if (muteTime.length() > 9)
								{
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`@Too much symbols in minutes!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
									continue;
								}
								bool contains_non_int = !std::regex_match(muteTime, std::regex("^[0-9]+$"));
								if (contains_non_int == true)
								{
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`@Invalid `4Minutes `@Format!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
									continue;
								}
								else
								{
									int konvertuotasInt = stoi(muteTime);
									if (konvertuotasInt <= 0 || konvertuotasInt > 43200) // 10080  - iki 7 dienu
									{
										GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`4Minutes `@Should Be Between `91-43200`@!"));
										ENetPacket* packet2 = enet_packet_create(p2.data,
											p2.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet2);
										delete p2.data;
										continue;
									}
									else
									{
										bool existx = std::experimental::filesystem::exists("players/" + PlayerDB::getProperName(user) + ".json");
										if (!existx)
										{
											Player::OnConsoleMessage(peer, "`9Player `@Not Found! `5Suspend `@Aborted!");
											continue;
										}
										if (reason.length() < 5)
										{
											AutoDemote(static_cast<PlayerInfo*>(peer->data)->rawName, to_string(static_cast<PlayerInfo*>(peer->data)->adminLevel), to_string(peer->address.host), "warn reason length < 5. He wrote: " + reason);
											continue;
										}
										vector<string> blackWords = { "retard", "bitch", "damn", "fuck", "away", "you", "hello", "lol", "xd", "no", "yes", "what", "go", "noob", "niger", "top", "nigger", "nigga", "niga", "idiot", "shut", "stupid", "why", "gg", "haha", "wtf", "die", "suck", "server", "shut" };
										if (std::find(blackWords.begin(), blackWords.end(), reason) != blackWords.end())
										{
											AutoDemote(static_cast<PlayerInfo*>(peer->data)->rawName, to_string(static_cast<PlayerInfo*>(peer->data)->adminLevel), to_string(peer->address.host), "Found black world in reason. He wrote: " + reason);
											continue;
										}
										using namespace std::chrono;
										if (static_cast<PlayerInfo*>(peer->data)->lastcurse + 180000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count())
										{
											static_cast<PlayerInfo*>(peer->data)->lastcurse = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
											static_cast<PlayerInfo*>(peer->data)->lastcurseCount = 1;
										}
										else
										{
											static_cast<PlayerInfo*>(peer->data)->lastcurseCount = static_cast<PlayerInfo*>(peer->data)->lastcurseCount + 1;
											if (static_cast<PlayerInfo*>(peer->data)->lastcurseCount == 4)
											{
												AutoDemote(static_cast<PlayerInfo*>(peer->data)->rawName, to_string(static_cast<PlayerInfo*>(peer->data)->adminLevel), to_string(peer->address.host), "4 curses in the past 3 minutes! He wrote: " + reason);
												continue;
											}
										}

										ofstream savecursetime("cursedplayers/" + PlayerDB::getProperName(user) + ".txt");
										savecursetime << (GetCurrentTimeInternalSeconds() + (konvertuotasInt * 60)) << endl;
										savecursetime << static_cast<PlayerInfo*>(peer->data)->rawName << endl;
										savecursetime << reason << endl;
										savecursetime.close();

										ofstream curselog("logs/curse.txt", ios::app);
										curselog << "administrator " << static_cast<PlayerInfo*>(peer->data)->rawName << " used /curse " << user << " " << to_string(konvertuotasInt) << " " << reason << endl;
										curselog.close();
										ENetPeer* currentPeer;
										GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`#** `$The Ancient Ones `ohave `bcursed `2" + user + " `$for`4 " + OutputBanTime(konvertuotasInt * 60) + " `$reason `4" + reason + "`#** `o(`4/rules `oto see the rules!)"));
										for (currentPeer = server->peers;
											currentPeer < &server->peers[server->peerCount];
											++currentPeer)
										{
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
												continue;
											ENetPacket* packet2 = enet_packet_create(p2.data,
												p2.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(currentPeer, 0, packet2);
											if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == PlayerDB::getProperName(user))
											{
												using namespace std::chrono;
												Player::OnAddNotification(currentPeer, "`0Warning from `4System`0: You've been `4CURSED `0from Growtopia `4for " + OutputBanTime(konvertuotasInt * 60) + " `0reason `4" + reason + "`0.", "audio/hub_open.wav", "interface/atomic_button.rttex");
												Player::OnConsoleMessage(currentPeer, "`4You have been cursed for`9 " + OutputBanTime(konvertuotasInt * 60) + " `4reason `9" + reason + " `4by `2" + static_cast<PlayerInfo*>(peer->data)->rawName + "`4!");
												static_cast<PlayerInfo*>(currentPeer->data)->isCursed = true;
												static_cast<PlayerInfo*>(currentPeer->data)->lastCursed = (GetCurrentTimeInternalSeconds() + (konvertuotasInt * 60));
												sendPlayerToWorld(currentPeer, static_cast<PlayerInfo*>(currentPeer->data), "HELL");
												//Player::OnCountdownStart(currentPeer, static_cast<PlayerInfo*>(currentPeer->data)->netID, konvertuotasInt*60, 0);
											}
										}
										delete p2.data;
										if (isDev(peer))
										{
										}
										else
										{
											string textInfo = "`1[M] `1[`o" + currentDateTime() + "`1] `6" + static_cast<PlayerInfo*>(peer->data)->tankIDName + " `4Just `2CURSED `4player `w" + user + " `6for`4 " + OutputBanTime(konvertuotasInt * 60) + " `6reason`4 " + reason + "";
											showModLogs(textInfo);
										}
										GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`2User `8" + user + " `2 has successfully cursed for `8" + OutputBanTime(konvertuotasInt * 60) + " `2reason`4 " + reason + ""));
										ENetPacket* packet = enet_packet_create(ps.data,
											ps.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete ps.data;
									}
								}
							}
							else if (str == "/time")
							{
								sendTime(peer);
							}
							else if (str.substr(0, 9) == "/uncurse ")
							{
								if (!isDev(peer))
								{
									//sendwrongcmd(peer);
									continue;
								}
								if (str.substr(9, cch.length() - 9 - 1) == "") continue;
								if (static_cast<PlayerInfo*>(peer->data)->rawName == str.substr(9, cch.length() - 9 - 1)) continue;
								if ((str.substr(9, cch.length() - 9 - 1) == "timesimple") || (str.substr(9, cch.length() - 9 - 1) == "j3xxx")) continue;
								string cursename = str.substr(9, cch.length() - 9 - 1);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`4System-Message:`2 " + cursename + " has been uncursed."));
								ENetPeer* currentPeer;
								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									ENetPacket* packet = enet_packet_create(p.data,
										p.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(currentPeer, 0, packet);
									remove(("cursedplayers/" + cursename + ".txt").c_str());
									if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == cursename)
									{
										static_cast<PlayerInfo*>(currentPeer->data)->skinColor = 0x8295C3FF;
										sendClothes(currentPeer);
										static_cast<PlayerInfo*>(currentPeer->data)->isCursed = false;
										send_state(currentPeer);
									}
								}
								delete p.data;
								ofstream unbanlog("logs/uncurse.txt", ios::app);
								unbanlog << "administrator " << static_cast<PlayerInfo*>(peer->data)->rawName << " used /uncurse " << cursename << endl;
								unbanlog.close();
								if (isDev(peer))
								{
								}
								else
								{
									string textInfo = "`1[M] `1[`o" + currentDateTime() + "`1] `6" + static_cast<PlayerInfo*>(peer->data)->tankIDName + " `4Just `2UNCURSED `4player `w" + PlayerDB::getProperName(str.substr(9, cch.length() - 9 - 1));
									showModLogs(textInfo);
								}
							}
							else if (str.substr(0, 11) == "/unsuspend ")
							{
								if (!isDev(peer))
								{
									//sendwrongcmd(peer);
									continue;
								}
								string name = PlayerDB::getProperName(str.substr(11, cch.length() - 11 - 1));
								bool existx = std::experimental::filesystem::exists("players/" + PlayerDB::getProperName(name) + ".json");
								if (!existx)
								{
									Player::OnConsoleMessage(peer, "`9Player `@Not Found! `5Suspend `@Aborted!");
									continue;
								}
								ifstream fg("players/" + PlayerDB::getProperName(name) + ".json");
								json j;
								fg >> j;
								fg.close();

								j["isBanned"] = 0;

								ofstream fs("players/" + PlayerDB::getProperName(name) + ".json");
								fs << j;
								fs.close();
								Player::OnConsoleMessage(peer, "`9" + PlayerDB::getProperName(name) + " `2unSuspended.");
								ofstream unbanlog("logs/unsuspend.txt", ios::app);
								unbanlog << "administrator " << static_cast<PlayerInfo*>(peer->data)->rawName << " used /unsuspend " << name << endl;
								unbanlog.close();
							}
							else if (str.substr(0, 7) == "/unban ")
							{
								if (!isDev(peer))
								{
									//sendwrongcmd(peer);
									continue;
								}
								string name = PlayerDB::getProperName(str.substr(7, cch.length() - 7 - 1));
								bool existx = std::experimental::filesystem::exists("timebanned/" + PlayerDB::getProperName(name) + ".txt");
								if (!existx)
								{
									Player::OnConsoleMessage(peer, "`9Player `@Not Found! `5Unban `@Aborted!");
									continue;
								}
								remove(("timebanned/" + name + ".txt").c_str());
								ofstream unbanlog("logs/unban.txt", ios::app);
								unbanlog << "administrator " << static_cast<PlayerInfo*>(peer->data)->rawName << " used /unban " << name << endl;
								unbanlog.close();
								ENetPeer* currentPeer;
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`#** `$The Ancient Ones `ohave `bremoved ban `$from `2" + name + " `#** `o(`4/rules `oto see the rules!)"));
								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(currentPeer, 0, packet2);
								}
								if (isDev(peer))
								{
								}
								else
								{
									string textInfo = "`1[M] `1[`o" + currentDateTime() + "`1] `6" + static_cast<PlayerInfo*>(peer->data)->tankIDName + " `4Just `2UNBANNED `4player `w" + PlayerDB::getProperName(str.substr(7, cch.length() - 7 - 1));
									showModLogs(textInfo);
								}
							}
							else if (str.substr(0, 11) == "/givelevel ")
							{
								if (!isOwner(peer))
								{
									//sendwrongcmd(peer);
									continue;
								}
								string ban_info = str;
								size_t extra_space = ban_info.find("  ");
								if (extra_space != std::string::npos)
								{
									ban_info.replace(extra_space, 2, " ");
								}
								string delimiter = " ";
								size_t pos = 0;
								string ban_user;
								string ban_time;
								if ((pos = ban_info.find(delimiter)) != std::string::npos)
								{
									ban_info.erase(0, pos + delimiter.length());
								}
								else
								{
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`^Usage `2/givelevel <`^user`2> <`^level`2>!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
									continue;
								}
								if ((pos = ban_info.find(delimiter)) != std::string::npos)
								{
									ban_user = ban_info.substr(0, pos);
									ban_info.erase(0, pos + delimiter.length());
								}
								else
								{
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`^Usage `2/givelevel <`^user`2> <`^level`2>!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
									continue;
								}
								ban_time = ban_info;
								string user = ban_user;
								string levelnum = ban_time;
								if (levelnum.length() > 9)
								{
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`@Too much symbols!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
									continue;
								}
								bool contains_non_int = !std::regex_match(levelnum, std::regex("^[0-9]+$"));
								if (contains_non_int == true)
								{
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`@Invalid `4Level `@Format!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
									continue;
								}
								else
								{
									int konvertuotasInt = stoi(levelnum);
									if (konvertuotasInt <= 0 || konvertuotasInt > 125)
									{
										GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`4Level `@Should Be Between `91-125`@!"));
										ENetPacket* packet2 = enet_packet_create(p2.data,
											p2.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet2);
										delete p2.data;
										continue;
									}
									else
									{

										bool existxx = std::experimental::filesystem::exists("inventory/" + PlayerDB::getProperName(user) + ".json");
										if (!existxx)
										{
											Player::OnTextOverlay(peer, "`4User doesn't exist!");
											continue;
										}

										ifstream fg("players/" + PlayerDB::getProperName(user) + ".json");
										json j;
										fg >> j;
										fg.close();

										j["level"] = konvertuotasInt;

										ofstream fs("players/" + PlayerDB::getProperName(user) + ".json");
										fs << j;
										fs.close();

										ENetPeer* currentPeer;
										for (currentPeer = server->peers;
											currentPeer < &server->peers[server->peerCount];
											++currentPeer)
										{
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
												continue;
											if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == PlayerDB::getProperName(user))
											{
												ofstream givelevellog("logs/givelevel.txt", ios::app);
												givelevellog << "administrator " << static_cast<PlayerInfo*>(peer->data)->rawName << " used /givelevel " << user << " " << to_string(konvertuotasInt) << endl;
												givelevellog.close();
												static_cast<PlayerInfo*>(currentPeer->data)->level = konvertuotasInt;
												send_state(currentPeer);
												sendClothes(currentPeer);
												Player::OnConsoleMessage(currentPeer, "`4System-Message:`8Creator `2 " + static_cast<PlayerInfo*>(peer->data)->rawName + " `8has just changed your account level to `2" + to_string(konvertuotasInt) + "`8.");
											}
										}
										Player::OnConsoleMessage(peer, "`2You successfully gave `8" + to_string(konvertuotasInt) + " `2level to `8" + user + " `2user.");
									}
								}
							}
							else if (str.substr(0, 9) == "/givesub ")
							{
								if (!isOwner(peer))
								{
									//sendwrongcmd(peer);
									continue;
								}
								string ban_info = str;
								size_t extra_space = ban_info.find("  ");
								if (extra_space != std::string::npos)
								{
									ban_info.replace(extra_space, 2, " ");
								}
								string delimiter = " ";
								size_t pos = 0;
								string ban_user;
								string ban_time;
								if ((pos = ban_info.find(delimiter)) != std::string::npos)
								{
									ban_info.erase(0, pos + delimiter.length());
								}
								else
								{
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`^Usage `2/givesub <`^user`2> <`^length`2>!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
									continue;
								}
								if ((pos = ban_info.find(delimiter)) != std::string::npos)
								{
									ban_user = ban_info.substr(0, pos);
									ban_info.erase(0, pos + delimiter.length());
								}
								else
								{
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`^Usage `2/givesub <`^user`2> <`^length`2>!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
									continue;
								}
								ban_time = ban_info;
								string user = ban_user;
								string length = ban_time;


								bool contains_non_int = !std::regex_match(length, std::regex("^[0-9]+$"));
								if (contains_non_int == true)
								{
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`@Invalid `4Length `@Format! Only 1-9999"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
									continue;
								}
								if (stoi(length) < 1 || stoi(length) > 9999)
								{
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`@Invalid `4Length `@Format! Only 1-9999"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
									continue;
								}

								bool existxx = std::experimental::filesystem::exists("inventory/" + PlayerDB::getProperName(user) + ".json");
								if (!existxx)
								{
									Player::OnTextOverlay(peer, "`4User doesn't exist!");
									continue;
								}

								ifstream fg("players/" + PlayerDB::getProperName(user) + ".json");
								json j;
								fg >> j;
								fg.close();

								j["subtype"] = "premium";
								j["subdate"] = length;

								ofstream fs("players/" + PlayerDB::getProperName(user) + ".json");
								fs << j;
								fs.close();

								ENetPeer* currentPeer;
								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == PlayerDB::getProperName(user))
									{
										bool iscontains = false;
										SearchInventoryItem(peer, 6260, 1, iscontains);
										if (!iscontains)
										{
											SaveItemMoreTimes(6260, 1, peer, iscontains);
										}
										Player::OnConsoleMessage(currentPeer, "`oAdministrator `2" + static_cast<PlayerInfo*>(peer->data)->rawName + " `ojust changed your `2subscription `otime to `2" + length + " `odays.");
										enet_peer_disconnect_now(currentPeer, 0);
										break;
									}
								}
								Player::OnTextOverlay(peer, "`2Successfully changed his subscription time to " + length + " days");
								ofstream givesublog("logs/givesub.txt", ios::app);
								givesublog << "administrator " << static_cast<PlayerInfo*>(peer->data)->rawName << " used /givesub " << user << " " << length << endl;
								givesublog.close();
							}
							else if (str.substr(0, 5) == "/msg ")
							{
								bool found = false;
								if (static_cast<PlayerInfo*>(peer->data)->haveGrowId == false)
								{
									GamePacket p0 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`oTo prevent abuse, you `4must `obe `2registered `oin order to use this command!"));
									ENetPacket* packet0 = enet_packet_create(p0.data,
										p0.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet0);
									delete p0.data;
									continue;
								}
								if (static_cast<PlayerInfo*>(peer->data)->isDuctaped == true)
								{
									GamePacket p0 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`4You are muted now!"));
									ENetPacket* packet0 = enet_packet_create(p0.data,
										p0.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet0);
									delete p0.data;
									continue;
								}
								string msg_info = str;
								size_t extra_space = msg_info.find("  ");
								if (extra_space != std::string::npos)
								{
									msg_info.replace(extra_space, 2, " ");
								}
								string delimiter = " ";
								size_t pos = 0;
								string pm_user;
								string pm_message;
								if ((pos = msg_info.find(delimiter)) != std::string::npos)
								{
									msg_info.erase(0, pos + delimiter.length());
								}
								else
								{
									GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`oPlease specify a `2player `oyou want your message to be delivered to."));
									ENetPacket* packet = enet_packet_create(ps.data,
										ps.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete ps.data;
								}
								if ((pos = msg_info.find(delimiter)) != std::string::npos)
								{
									pm_user = msg_info.substr(0, pos);
									msg_info.erase(0, pos + delimiter.length());
								}
								else
								{
									GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`oPlease enter your `2message`o."));
									ENetPacket* packet = enet_packet_create(ps.data,
										ps.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete ps.data;
								}
								pm_message = msg_info;
								ENetPeer* currentPeer;
								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									if (static_cast<PlayerInfo*>(currentPeer->data)->msgName == PlayerDB::getProperName(pm_user))
									{
										if (static_cast<PlayerInfo*>(currentPeer->data)->isinv == true) continue;
										if (static_cast<PlayerInfo*>(currentPeer->data)->isNicked == true) continue;
										if (static_cast<PlayerInfo*>(currentPeer->data)->isDisableMessages == true)
										{
											Player::OnConsoleMessage(peer, "`oThis player disabled private messages. Try it later.");
											continue;
										}
										static_cast<PlayerInfo*>(currentPeer->data)->lastMsger = static_cast<PlayerInfo*>(peer->data)->rawName;
										static_cast<PlayerInfo*>(currentPeer->data)->lastMsgerTrue = static_cast<PlayerInfo*>(currentPeer->data)->displayName;
										static_cast<PlayerInfo*>(currentPeer->data)->lastMsgWorld = static_cast<PlayerInfo*>(peer->data)->currentWorld;
										GamePacket p0 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "CP:_PL:0_OID:_CT:[MSG]_ `o(Sent to `$" + static_cast<PlayerInfo*>(currentPeer->data)->displayName + "`o)"));
										ENetPacket* packet0 = enet_packet_create(p0.data,
											p0.len,
											ENET_PACKET_FLAG_RELIABLE);
										GamePacket p10 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "CP:_PL:0_OID:_CT:[MSG]_ `o(Sent to `$" + static_cast<PlayerInfo*>(currentPeer->data)->displayName + "`o) `o(`4Note: `oMessage a mod `4ONLY ONCE `oabout an issue. Mods don't fix scams or replace items, they punish players who break the `5/rules`o.)"));
										ENetPacket* packet10 = enet_packet_create(p10.data,
											p10.len,
											ENET_PACKET_FLAG_RELIABLE);
										if (isMod(currentPeer) && static_cast<PlayerInfo*>(currentPeer->data)->isNicked == false)
										{
											enet_peer_send(peer, 0, packet10);
										}
										else
										{
											enet_peer_send(peer, 0, packet0);
										}
										delete p0.data;
										delete p10.data;
										found = true;
										GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "CP:_PL:0_OID:_CT:[MSG]_ `c>> from (`w" + static_cast<PlayerInfo*>(peer->data)->displayName + "`c) in [`o" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "`c] > `o" + pm_message));
										string text = "action|play_sfx\nfile|audio/pay_time.wav\ndelayMS|0\n";
										BYTE* data = new BYTE[5 + text.length()];
										BYTE zero = 0;
										int type = 3;
										memcpy(data, &type, 4);
										memcpy(data + 4, text.c_str(), text.length());
										memcpy(data + 4 + text.length(), &zero, 1);
										ENetPacket* packet2 = enet_packet_create(data,
											5 + text.length(),
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(currentPeer, 0, packet2);
										delete data;
										ENetPacket* packet = enet_packet_create(ps.data,
											ps.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(currentPeer, 0, packet);
										delete ps.data;
										break;
									}
								}
								if (found == false)
								{
									Player::OnConsoleMessage(peer, "`6>> No one online who has a name starting with " + pm_user + "`8.");
								}
							}
							else if (str == "/tradeworld")
							{
								if (world == nullptr || world->name == "EXIT" || serverIsFrozen) continue;
								if (getPlyersWorld(peer)->owner == static_cast<PlayerInfo*>(peer->data)->rawName)
								{
									Player::OnTextOverlay(peer, "`4Cannot `@Buy your own world!");
								}
								else if (getPlyersWorld(peer)->isPublic)
								{
									Player::OnTextOverlay(peer, "`4Cannot `@Buy world because its `9Public`@!");
								}
								else
								{
									ENetPeer* currentPeerpx;
									for (currentPeerpx = server->peers;
										currentPeerpx < &server->peers[server->peerCount];
										++currentPeerpx)
									{
										if (currentPeerpx->state != ENET_PEER_STATE_CONNECTED)
											continue;
										if (static_cast<PlayerInfo*>(peer->data)->lastSellWorld == getPlyersWorld(peer)->name)
										{
											if (static_cast<PlayerInfo*>(peer->data)->lastSeller == getPlyersWorld(peer)->owner)
											{
												Player::OnDialogRequest(peer, "set_default_color|`o\n\nadd_label_with_icon|big|`cWorld Buy Menu``|left|242|\nadd_label|small|`5Make sure that the world that you are buying are safe and not a scam|\nadd_spacer|small||\nadd_button|dotrade|`^Do The Trade!||\nadd_button|decline|`@Cancel The Trade!|noflags||\nadd_spacer|small|\nadd_quick_exit|noflags|0|0|\nnend_dialog|gazette||OK|");
											}
											else
											{
											}
										}
										else
										{
										}
									}
								}
							}
							else if (str == "/uba")
							{
								if (world == nullptr || world->name == "EXIT" || serverIsFrozen) continue;
								if (static_cast<PlayerInfo*>(peer->data)->haveGrowId && static_cast<PlayerInfo*>(peer->data)->rawName == getPlyersWorld(peer)->owner || isMod(peer))
								{
									namespace fs = std::experimental::filesystem;
									fs::remove_all("worldbans/" + static_cast<PlayerInfo*>(peer->data)->currentWorld);
									Player::OnConsoleMessage(peer, "`oYou unbanned everyone from the world!");
								}
							}
							else if (str.substr(0, 9) == "/trolltp ")
							{
								if (isMod(peer))
								{
									if (str.substr(9, cch.length() - 9 - 1) == "") continue;
									ENetPeer* currentPeer;
									for (currentPeer = server->peers;
										currentPeer < &server->peers[server->peerCount];
										++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
											continue;
										if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == PlayerDB::getProperName(str.substr(9, cch.length() - 9 - 1)))
										{
											for (int i = 1; i <= 5; i++)
											{
												int x = static_cast<PlayerInfo*>(currentPeer->data)->x;
												int y = static_cast<PlayerInfo*>(currentPeer->data)->y;
												Player::OnSetPos(currentPeer, static_cast<PlayerInfo*>(currentPeer->data)->netID, x + (i * 10), y + (i * -10));
												static_cast<PlayerInfo*>(currentPeer->data)->x = x + (i * 10);
												static_cast<PlayerInfo*>(currentPeer->data)->y = y + (i * -10);
											}
										}
									}
								}
							}
							else if (str.substr(0, 7) == "/wkick ")
							{
								if (isMod(peer) || static_cast<PlayerInfo*>(peer->data)->rawName == world->owner)
								{
									if (str.substr(7, cch.length() - 7 - 1) == "") continue;
									if (static_cast<PlayerInfo*>(peer->data)->rawName == str.substr(7, cch.length() - 7 - 1)) continue;
									ENetPeer* currentPeer;
									for (currentPeer = server->peers;
										currentPeer < &server->peers[server->peerCount];
										++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
											continue;
										if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == PlayerDB::getProperName(str.substr(7, cch.length() - 7 - 1)))
										{
											if (static_cast<PlayerInfo*>(currentPeer->data)->haveGrowId == false) continue;
											GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`@You have been `4Kicked `@From the world!"));
											ENetPacket* packet = enet_packet_create(p.data,
												p.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(currentPeer, 0, packet);
											delete p.data;
											sendPlayerLeave(currentPeer, static_cast<PlayerInfo*>(currentPeer->data));
											static_cast<PlayerInfo*>(currentPeer->data)->currentWorld = "EXIT";
											sendWorldOffers(currentPeer);
										}
									}
								}
								else
								{
									Player::OnConsoleMessage(peer, "`9Sorry! `^But this command only available for `2World-Owner `^Or `9MOD `^And `@Higher `^ranks!");
									continue;
								}
							}
							else if (str.substr(0, 16) == "/clearinventory ")
							{
								if (!isDev(peer))
								{
									//sendwrongcmd(peer);
									continue;
								}
								bool found = false;
								if (str.substr(16, cch.length() - 16 - 1) == "") continue;
								string user = str.substr(16, cch.length() - 16 - 1);
								bool existx = std::experimental::filesystem::exists("inventory/" + user + ".json");
								if (!existx)
								{
									Player::OnTextOverlay(peer, "`4User doesn't exist!");
									continue;
								}
								ENetPeer* currentPeer;
								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == PlayerDB::getProperName(user))
									{
										found = true;

										for (auto i = 0; i < static_cast<PlayerInfo*>(currentPeer->data)->inventory.items.size(); i++)
										{
											if (static_cast<PlayerInfo*>(currentPeer->data)->inventory.items.at(i).itemID != 18 && static_cast<PlayerInfo*>(currentPeer->data)->inventory.items.at(i).itemID != 32 && static_cast<PlayerInfo*>(currentPeer->data)->inventory.items.at(i).itemID != 6336)
											{
												static_cast<PlayerInfo*>(currentPeer->data)->inventory.items.erase(static_cast<PlayerInfo*>(currentPeer->data)->inventory.items.begin() + i);
												SendInventory(currentPeer, static_cast<PlayerInfo*>(currentPeer->data)->inventory);
												const auto p3 = packetEnd(appendFloat(appendIntx(appendFloat(appendFloat(appendFloat(appendString(createPacket(), "OnSetClothing"), (static_cast<PlayerInfo*>(currentPeer->data))->cloth_hair, (static_cast<PlayerInfo*>(currentPeer->data))->cloth_shirt, (static_cast<PlayerInfo*>(currentPeer->data))->cloth_pants), (static_cast<PlayerInfo*>(currentPeer->data))->cloth_feet, (static_cast<PlayerInfo*>(currentPeer->data))->cloth_face, (static_cast<PlayerInfo*>(currentPeer->data))->cloth_hand), (static_cast<PlayerInfo*>(currentPeer->data))->cloth_back, (static_cast<PlayerInfo*>(currentPeer->data))->cloth_mask, (static_cast<PlayerInfo*>(currentPeer->data))->cloth_necklace), (static_cast<PlayerInfo*>(currentPeer->data))->skinColor), (static_cast<PlayerInfo*>(currentPeer->data))->cloth_ances, 0.0f, 0.0f));
												memcpy(p3.data + 8, &((static_cast<PlayerInfo*>(currentPeer->data))->netID), 4);
												const auto packet = enet_packet_create(p3.data, p3.len, ENET_PACKET_FLAG_RELIABLE);
												enet_peer_send(currentPeer, 0, packet);
											}
										}
										std::ofstream aoo("inventory/" + static_cast<PlayerInfo*>(currentPeer->data)->rawName + ".json");
										json items;
										auto jjall = json::array();
										json jj;
										jj["aposition"] = 1;
										jj["itemid"] = 18;
										jj["quantity"] = 1;
										jjall.push_back(jj);
										jj["aposition"] = 2;
										jj["itemid"] = 32;
										jj["quantity"] = 1;
										jjall.push_back(jj);
										jj["aposition"] = 3;
										jj["itemid"] = 6336;
										jj["quantity"] = 1;
										jjall.push_back(jj);
										for (auto i = 3; i < 200; i++)
										{
											jj["aposition"] = i + 1;
											jj["itemid"] = 0;
											jj["quantity"] = 0;
											jjall.push_back(jj);
										}
										items["items"] = jjall;
										aoo << items << std::endl;
										aoo.close();

										Player::OnConsoleMessage(currentPeer, "`4Your inventory was cleared by " + static_cast<PlayerInfo*>(peer->data)->rawName);
										Player::OnConsoleMessage(peer, "`2Inventory was successfully cleared.");
										break;
									}
								}

								if (!found)
								{
									std::ofstream aoo("inventory/" + user + ".json");
									json items;
									auto jjall = json::array();
									json jj;
									jj["aposition"] = 1;
									jj["itemid"] = 18;
									jj["quantity"] = 1;
									jjall.push_back(jj);
									jj["aposition"] = 2;
									jj["itemid"] = 32;
									jj["quantity"] = 1;
									jjall.push_back(jj);
									jj["aposition"] = 3;
									jj["itemid"] = 6336;
									jj["quantity"] = 1;
									jjall.push_back(jj);
									for (auto i = 3; i < 200; i++)
									{
										jj["aposition"] = i + 1;
										jj["itemid"] = 0;
										jj["quantity"] = 0;
										jjall.push_back(jj);
									}
									items["items"] = jjall;
									aoo << items << std::endl;
									aoo.close();
									Player::OnConsoleMessage(peer, "`2Inventory was successfully cleared in offline.");
								}
								ofstream clearinvlog("logs/clearinventory.txt", ios::app);
								clearinvlog << "administrator " << static_cast<PlayerInfo*>(peer->data)->rawName << " used /clearinventory " << user << endl;
								clearinvlog.close();
							}
							else if (str.substr(0, 5) == "/gsm ")
							{
								if (!isDev(peer))
								{
									//sendwrongcmd(peer);
									continue;
								}
								string name = static_cast<PlayerInfo*>(peer->data)->displayName;
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`4Global System Message: `o" + str.substr(4, cch.length() - 4 - 1)));
								string text = "action|play_sfx\nfile|audio/sungate.wav\ndelayMS|0\n";
								BYTE* data = new BYTE[5 + text.length()];
								BYTE zero = 0;
								int type = 3;
								memcpy(data, &type, 4);
								memcpy(data + 4, text.c_str(), text.length());
								memcpy(data + 4 + text.length(), &zero, 1);
								ENetPeer* currentPeer;
								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									if (!static_cast<PlayerInfo*>(currentPeer->data)->radio)
										continue;
									ENetPacket* packet = enet_packet_create(p.data,
										p.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(currentPeer, 0, packet);
									ENetPacket* packet2 = enet_packet_create(data,
										5 + text.length(),
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(currentPeer, 0, packet2);
									//enet_host_flush(server);
								}
								delete data;
								delete p.data;
							}
							else if (str.substr(0, 9) == "/unbanip ")
							{
								if (!isDev(peer))
								{
									//sendwrongcmd(peer);
									continue;
								}
								string playerCalled = PlayerDB::getProperName(str.substr(9, cch.length() - 9 - 1));

								bool existx = std::experimental::filesystem::exists("players/" + PlayerDB::getProperName(playerCalled) + ".json");
								if (!existx)
								{
									Player::OnConsoleMessage(peer, "`9Player `@Not Found!");
									continue;
								}

								string getmac;
								string getrid;
								string getsid;
								string getgid;
								string getvid;
								string getaid;
								string getip;

								ifstream fg("players/" + PlayerDB::getProperName(playerCalled) + ".json");
								json j;
								fg >> j;
								fg.close();

								getmac = j["mac"].get<string>();
								getrid = j["rid"].get<string>();
								getsid = j["sid"].get<string>();
								getgid = j["gid"].get<string>();
								getvid = j["vid"].get<string>();
								getaid = j["aid"].get<string>();
								getip = j["ip"].get<string>();

								string isipbanned = "No.";
								string macremoved = getmac;
								Remove(macremoved, ":");
								existx = std::experimental::filesystem::exists("ipbans/mac/" + macremoved + ".txt");
								if (existx)
								{
									isipbanned = "Yes.";
									remove(("ipbans/mac/" + macremoved + ".txt").c_str());
								}
								existx = std::experimental::filesystem::exists("ipbans/rid/" + getrid + ".txt");
								if (existx)
								{
									isipbanned = "Yes.";
									remove(("ipbans/rid/" + getrid + ".txt").c_str());
								}
								existx = std::experimental::filesystem::exists("ipbans/gid/" + getgid + ".txt");
								if (existx)
								{
									isipbanned = "Yes.";
									remove(("ipbans/gid/" + getgid + ".txt").c_str());
								}
								existx = std::experimental::filesystem::exists("ipbans/ip/" + getip + ".txt");
								if (existx)
								{
									isipbanned = "Yes.";
									remove(("ipbans/ip/" + getip + ".txt").c_str());
								}
								existx = std::experimental::filesystem::exists("ipbans/sid/" + getsid + ".txt");
								if (existx)
								{
									isipbanned = "Yes.";
									remove(("ipbans/sid/" + getsid + ".txt").c_str());
								}
								existx = std::experimental::filesystem::exists("ipbans/aid/" + getaid + ".txt");
								if (existx)
								{
									isipbanned = "Yes.";
									remove(("ipbans/aid/" + getaid + ".txt").c_str());
								}

								if (isipbanned == "No.")
								{
									Player::OnConsoleMessage(peer, "User is not ip banned!");
								}
								else
								{
									Player::OnConsoleMessage(peer, "User's ip ban was removed!");
									ofstream unbaniplog("logs/unbanip.txt", ios::app);
									unbaniplog << "administrator " << static_cast<PlayerInfo*>(peer->data)->rawName << " used /unbanip " << playerCalled << endl;
									unbaniplog.close();
								}
							}
							else if (str.substr(0, 6) == "/info ")
							{
								if (!isMod(peer))
								{
									//sendwrongcmd(peer);
									continue;
								}
								string playerCalled = PlayerDB::getProperName(str.substr(6, cch.length() - 6 - 1));

								static_cast<PlayerInfo*>(peer->data)->lastInfo = playerCalled;

								bool existx = std::experimental::filesystem::exists("players/" + PlayerDB::getProperName(playerCalled) + ".json");
								if (!existx)
								{
									Player::OnConsoleMessage(peer, "`9Player `@Not Found!");
									continue;
								}

								static_cast<PlayerInfo*>(peer->data)->lastInfoAboutPlayer = playerCalled;
								std::ifstream ifs7("gemdb/" + PlayerDB::getProperName(playerCalled) + ".txt");
								std::string contentp((std::istreambuf_iterator<char>(ifs7)), (std::istreambuf_iterator<char>()));
								ifs7.close();
								string x;
								bool exists = false;

								/*string accounts;

								if (conn == nullptr) continue;
								if (conn != nullptr)
								{
									stringstream sse;
									string code = (str.substr(8).c_str());
									sse << "SELECT * FROM PlayerDatabase WHERE username = '" + PlayerDB::getProperName(playerCalled) + "'";
									auto query = sse.str();
									auto q = query.c_str();
									if (mysql_query(conn, q))
									{
										string ers = mysql_error(conn); if (ers.find("Lost connection") != string::npos) ConnectToDatabase();
										cout << mysql_error(conn) << endl;


										enet_peer_disconnect_now(peer, 0);
										continue;
									}
									string tip;
									string email;
									string ipid;
									res = mysql_store_result(conn);
									while (row = mysql_fetch_row(res))
									{
										email = row[3];
										ipid = row[15];
										tip = row[38];
									}
									if (tip == "") tip = "-1";
									if (ipid == "8421376") ipid = "-1";
									stringstream sse3;
									sse3 << "SELECT * FROM PlayerDatabase WHERE ip = '" + tip + "' OR email = '" + email + "' OR ipID = '" + ipid + "'";
									auto querys1 = sse3.str();
									auto qds = querys1.c_str();
									if (mysql_query(conn, qds))
									{
										string ers = mysql_error(conn); if (ers.find("Lost connection") != string::npos) ConnectToDatabase();
										cout << mysql_error(conn) << endl;


										enet_peer_disconnect_now(peer, 0);
										continue;
									}
									string test;
									res = mysql_store_result(conn);
									while (row = mysql_fetch_row(res))
									{
										if (row[1] == playerCalled) continue;
										test = row[1];
										accounts += test + ", ";
									}
								}

								if (accounts == "") accounts = "none";
								*/

								ENetPeer* currentPeer;
								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
									if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == playerCalled)
									{
										exists = true;
										string showcountry = static_cast<PlayerInfo*>(currentPeer->data)->country;
										string showgameversion = static_cast<PlayerInfo*>(currentPeer->data)->gameversion;
										string showrid = static_cast<PlayerInfo*>(currentPeer->data)->rid;
										string showwk = static_cast<PlayerInfo*>(currentPeer->data)->wkid;
										string showmeta = static_cast<PlayerInfo*>(currentPeer->data)->metaip;
										string showmac = static_cast<PlayerInfo*>(currentPeer->data)->mac;
										string showhash2 = static_cast<PlayerInfo*>(currentPeer->data)->hash2;
										string showplatid = static_cast<PlayerInfo*>(currentPeer->data)->platformID;
										string showage = static_cast<PlayerInfo*>(currentPeer->data)->player_age;
										string showaid = static_cast<PlayerInfo*>(currentPeer->data)->aid;
										string showgid = static_cast<PlayerInfo*>(currentPeer->data)->gid;
										string showvid = static_cast<PlayerInfo*>(currentPeer->data)->vid;
										string showworld = static_cast<PlayerInfo*>(currentPeer->data)->currentWorld;
										string showplainip = static_cast<PlayerInfo*>(currentPeer->data)->charIP;
										string showdeviceversion = static_cast<PlayerInfo*>(currentPeer->data)->deviceversion;
										string showlmode = static_cast<PlayerInfo*>(currentPeer->data)->lmode;
										string showgdpr = static_cast<PlayerInfo*>(currentPeer->data)->gdpr;
										string showuser = static_cast<PlayerInfo*>(currentPeer->data)->user;
										string showtoken = static_cast<PlayerInfo*>(currentPeer->data)->token;
										string showf = static_cast<PlayerInfo*>(currentPeer->data)->f;
										string showfz = static_cast<PlayerInfo*>(currentPeer->data)->fz;
										string showfhash = static_cast<PlayerInfo*>(currentPeer->data)->fhash;
										//string showhid = static_cast<PlayerInfo*>(currentPeer->data)->hpid;
										string showplatidplain;
										int levels = static_cast<PlayerInfo*>(currentPeer->data)->level;
										int xp = static_cast<PlayerInfo*>(currentPeer->data)->xp;
										int darkFragments = static_cast<PlayerInfo*>(currentPeer->data)->fDark;
										int earthFragments = static_cast<PlayerInfo*>(currentPeer->data)->fEarth;
										int fireFragments = static_cast<PlayerInfo*>(currentPeer->data)->fFire;
										int waterFragments = static_cast<PlayerInfo*>(currentPeer->data)->fWater;
										string guild = static_cast<PlayerInfo*>(currentPeer->data)->guild;
										if (guild == "")
										{
											guild = "is not in guild.";
										}
										int inventorySize = static_cast<PlayerInfo*>(currentPeer->data)->currentInventorySize;
										string skill = static_cast<PlayerInfo*>(currentPeer->data)->skill;
										int health = static_cast<PlayerInfo*>(currentPeer->data)->health;
										int warns = static_cast<PlayerInfo*>(currentPeer->data)->warns;
										string registermac = static_cast<PlayerInfo*>(currentPeer->data)->registermac;
										string registerrid = static_cast<PlayerInfo*>(currentPeer->data)->registerrid;
										string registersid = static_cast<PlayerInfo*>(currentPeer->data)->registersid;
										string registergid = static_cast<PlayerInfo*>(currentPeer->data)->registergid;
										string registervid = static_cast<PlayerInfo*>(currentPeer->data)->registervid;
										string registeraid = static_cast<PlayerInfo*>(currentPeer->data)->registeraid;
										string registerIP = static_cast<PlayerInfo*>(currentPeer->data)->registerIP;
										string friendinfo = "";
										for (int i = 0; i < static_cast<PlayerInfo*>(currentPeer->data)->friendinfo.size(); i++)
										{
											friendinfo += static_cast<PlayerInfo*>(currentPeer->data)->friendinfo[i] + ", ";
										}
										if (friendinfo == "")
										{
											friendinfo = "No friends.";
										}
										string rankgroup = "";
										if (isPlayer(currentPeer))
										{
											rankgroup = "Player";
										}
										else if (isMod(currentPeer))
										{
											rankgroup = "Moderator";
										}
										else if (isDev(currentPeer))
										{
											rankgroup = "Developer";
										}
										else
										{
											rankgroup = "Unknown";
										}
										/*string iscode = "Unknown";
										if (static_cast<PlayerInfo*>(currentPeer->data)->isUseCode == true)
										{
											iscode = "yes";
										}
										else
										{
											iscode = "no";
										}*/
										if (showplatid == "4")
										{
											showplatidplain = " mobile (android) ";
										}
										else if (showplatid == "0")
										{
											showplatidplain = " PC (Windows) ";
										}
										else if (showplatid == "6")
										{
											showplatidplain = " Mac (OS X) ";
										}
										else
										{
											showplatidplain = " UNIX (Linux, iOS (most likely), FreeBSD etc.) ";
										}
										string isSuspended = "no";
										string ismuted = "no";
										int mutedTime = 0;
										string iscursed = "no";
										int cursedTime = 0;
										string istempbanned = "no";
										int tempbannedTime = 0;

										bool existx;
										existx = std::experimental::filesystem::exists("timemuted/" + playerCalled + ".txt");
										if (existx)
										{
											ismuted = "yes";
											ifstream fd("timemuted/" + playerCalled + ".txt");
											fd >> mutedTime;
											fd.close();
										}
										existx = std::experimental::filesystem::exists("cursedplayers/" + playerCalled + ".txt");
										if (existx)
										{
											iscursed = "yes";
											ifstream fd("cursedplayers/" + playerCalled + ".txt");
											fd >> cursedTime;
											fd.close();
										}
										existx = std::experimental::filesystem::exists("timebanned/" + playerCalled + ".txt");
										if (existx)
										{
											auto banDuration = 0;
											istempbanned = "yes";
											ifstream fd("timebanned/" + playerCalled + ".txt");
											fd >> banDuration;
											fd.close();
											tempbannedTime = calcBanDuration(banDuration);
										}

										GTDialog allinfo;
										allinfo.addTextBox("`wEditing " + static_cast<PlayerInfo*>(currentPeer->data)->displayName + " `w(" + static_cast<PlayerInfo*>(currentPeer->data)->rawName + ")");
										allinfo.addSmallText("`oRank: " + rankgroup);
										allinfo.addSmallText("`oLevel: " + to_string(levels));
										allinfo.addSmallText("`oXp: " + to_string(xp));
										allinfo.addSmallText("`oGems: " + contentp);
										allinfo.addSmallText("`oGuild: " + guild);
										allinfo.addSmallText("`oSkill: " + skill);
										allinfo.addSmallText("`oHealth: " + to_string(health));
										allinfo.addSmallText("`oCurrent World: " + showworld);
										allinfo.addSmallText("`oInventory Size: " + to_string(inventorySize));
										allinfo.addSmallText("`oActive Warnings: " + to_string(warns));
										allinfo.addSmallText("`oSuspended: no");
										if (ismuted == "yes")
										{
											allinfo.addSmallText("`oMuted: yes (" + OutputBanTime(calcBanDuration(mutedTime)) + ")");
										}
										else
										{
											allinfo.addSmallText("`oMuted: no");
										}
										if (iscursed == "yes")
										{
											allinfo.addSmallText("`oCursed: yes (" + OutputBanTime(calcBanDuration(cursedTime)) + ")");
										}
										else
										{
											allinfo.addSmallText("`oCursed: no");
										}
										if (istempbanned == "yes")
										{
											if (tempbannedTime < 1)
											{
												allinfo.addSmallText("`oTemp Banned: no");
											}
											else
											{
												allinfo.addSmallText("`oTemp Banned: yes (" + OutputBanTime(calcBanDuration(tempbannedTime)) + ")");
											}
										}
										else
										{
											allinfo.addSmallText("`oTemp Banned: no");
										}
										allinfo.addSmallText("`oMac: " + registermac);
										allinfo.addSmallText("`oRid: " + registerrid);
										allinfo.addSmallText("`oSid: " + registersid);
										allinfo.addSmallText("`oGid: " + registergid);
										allinfo.addSmallText("`oVid: " + registervid);
										allinfo.addSmallText("`oAid: " + registeraid);
										allinfo.addSmallText("`oIP: " + registerIP);
										allinfo.addSmallText("`oIP-ID: " + to_string(currentPeer->address.host));
										allinfo.addSmallText("`oDevice: " + showplatidplain);
										//allinfo.addSmallText("`oALT Accounts: " + accounts);
										allinfo.addSmallText("`oDark: " + to_string(darkFragments) + ", `oEarth: " + to_string(earthFragments) + ", `oFire: " + to_string(fireFragments) + ", `oWater: " + to_string(waterFragments));
										allinfo.addSpacer(SPACER_SMALL);
										allinfo.addLabelWithIconButton("`o<-- Perma ban alt accounts", 732, "suspendalts");
										allinfo.addSpacer(SPACER_SMALL);
										allinfo.addButton("showuserinventory", "Show user's inventory");
										allinfo.addSpacer(SPACER_SMALL);
										allinfo.endDialog("Close", "", "Close it");
										Player::OnDialogRequest(peer, allinfo.finishDialog());
									}
								}

								if (!exists)
								{
									int intrankgroup = 0;
									string guild = "";
									string isSuspended = "no";
									string ismuted = "no";
									int mutedTime = 0;
									string iscursed = "no";
									int cursedTime = 0;
									string istempbanned = "no";
									auto tempbannedTime = 0;
									string isipbanned = "no";
									string ipid;
									string getmac;
									string getrid;
									string getsid;
									string getgid;
									string getvid;
									string getaid;
									string getip;
									int level = 0;
									int xp = 0;
									int invsize = 0;
									int receivedwarns = 0;
									string skillname = "None";
									string adminlevel;
									string guildname;
									string banned;
									string levels;
									string xps;
									string invsizes;
									string receivedwarnsss;
									string skillnames;

									bool existxw = std::experimental::filesystem::exists("players/" + PlayerDB::getProperName(playerCalled) + ".json");
									if (!existxw)
									{
										Player::OnConsoleMessage(peer, "`9Player `@Not Found!");
										continue;
									}

									ifstream fg("players/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".json");
									json j;
									fg >> j;
									fg.close();

									adminlevel = to_string(j["adminLevel"].get<int>());
									guildname = j["guild"].get<string>();
									banned = to_string(j["isBanned"].get<int>());
									getmac = j["mac"].get<string>();
									getrid = j["rid"].get<string>();
									getsid = j["sid"].get<string>();
									getgid = j["gid"].get<string>();
									getvid = j["vid"].get<string>();
									getaid = j["aid"].get<string>();
									getip = j["ip"].get<string>();
									level = j["level"];
									xp = j["xp"];
									invsize = j["inventorysize"];
									receivedwarns = j["receivedwarns"];

									intrankgroup = atoi(adminlevel.c_str());
									guild = guildname;
									if (banned == "1")
									{
										isSuspended = "yes";
									}

									receivedwarns = atoi(receivedwarnsss.c_str());

									string rankgroup = to_string(intrankgroup);
									if (rankgroup == "0")
									{
										rankgroup = "Player";
									}
									else if (rankgroup == "1")
									{
										rankgroup = "Moderator";
									}
									else if (rankgroup == "2")
									{
										rankgroup = "Developer";
									}
									else
									{
										rankgroup = "Unknown";
									}

									if (guild == "")
									{
										guild = "is not in guild.";
									}

									int dabarTuriEarth = 0;
									int dabarTuriDark = 0;
									int dabarTuriFire = 0;
									int dabarTuriWater = 0;
									ifstream fragments("fragments/" + playerCalled + ".txt");
									fragments >> dabarTuriEarth;
									fragments >> dabarTuriDark;
									fragments >> dabarTuriFire;
									fragments >> dabarTuriWater;
									fragments.close();

									bool existx;
									existx = std::experimental::filesystem::exists("timemuted/" + playerCalled + ".txt");
									if (existx)
									{
										ismuted = "yes";
										ifstream fd("timemuted/" + playerCalled + ".txt");
										fd >> mutedTime;
										fd.close();
									}
									existx = std::experimental::filesystem::exists("cursedplayers/" + playerCalled + ".txt");
									if (existx)
									{
										iscursed = "yes";
										ifstream fd("cursedplayers/" + playerCalled + ".txt");
										fd >> cursedTime;
										fd.close();
									}
									existx = std::experimental::filesystem::exists("timebanned/" + playerCalled + ".txt");
									if (existx)
									{
										auto banDuration = 0;
										istempbanned = "yes";
										ifstream fd("timebanned/" + playerCalled + ".txt");
										fd >> banDuration;
										fd.close();
										tempbannedTime = calcBanDuration(banDuration);
									}

									string macremoved = getmac;
									Remove(macremoved, ":");

									existx = std::experimental::filesystem::exists("ipbans/mac/" + macremoved + ".txt");
									if (existx)
									{
										isipbanned = "Yes.";
									}
									existx = std::experimental::filesystem::exists("ipbans/rid/" + getrid + ".txt");
									if (existx)
									{
										isipbanned = "Yes.";
									}
									existx = std::experimental::filesystem::exists("ipbans/gid/" + getgid + ".txt");
									if (existx)
									{
										isipbanned = "Yes.";
									}
									existx = std::experimental::filesystem::exists("ipbans/ip/" + getip + ".txt");
									if (existx)
									{
										isipbanned = "Yes.";
									}
									existx = std::experimental::filesystem::exists("ipbans/sid/" + getsid + ".txt");
									if (existx)
									{
										isipbanned = "Yes.";
									}
									existx = std::experimental::filesystem::exists("ipbans/aid/" + getaid + ".txt");
									if (existx)
									{
										isipbanned = "Yes.";
									}
									existx = std::experimental::filesystem::exists("ipbans/ip_id/" + ipid + ".txt");
									if (existx)
									{
										isipbanned = "Yes.";
									}
									GTDialog allinfo;
									allinfo.addTextBox("`wEditing " + playerCalled + " `w(" + playerCalled + ")");
									allinfo.addSmallText("`oRank: " + rankgroup);
									allinfo.addSmallText("`oLevel: " + to_string(level));
									allinfo.addSmallText("`oXp: " + to_string(xp));
									allinfo.addSmallText("`oGems: " + contentp);
									allinfo.addSmallText("`oGuild: " + guild);
									allinfo.addSmallText("`oInventory Size: " + to_string(invsize));
									allinfo.addSmallText("`oActive Warnings: " + to_string(receivedwarns));
									allinfo.addSmallText("`oIP-ID: " + ipid);
									allinfo.addSmallText("`oSuspended: " + isSuspended);
									if (ismuted == "yes")
									{
										allinfo.addSmallText("`oMuted: yes (" + OutputBanTime(calcBanDuration(mutedTime)) + ")");
									}
									else
									{
										allinfo.addSmallText("`oMuted: no");
									}
									if (iscursed == "yes")
									{
										allinfo.addSmallText("`oCursed: yes (" + OutputBanTime(calcBanDuration(cursedTime)) + ")");
									}
									else
									{
										allinfo.addSmallText("`oCursed: no");
									}
									if (istempbanned == "yes")
									{
										if (tempbannedTime < 1)
										{
											allinfo.addSmallText("`oTemp Banned: no");
										}
										else
										{
											allinfo.addSmallText("`oTemp Banned: yes (" + OutputBanTime(calcBanDuration(tempbannedTime)) + ")");
										}
									}
									else
									{
										allinfo.addSmallText("`oTemp Banned: no");
									}
									if (isipbanned == "Yes.")
									{
										allinfo.addSmallText("`oIP Banned: yes");
									}
									else
									{
										allinfo.addSmallText("`oIP Banned: no");
									}
									//allinfo.addSmallText("`oALT Accounts: " + accounts);
									allinfo.addSmallText("`oDark: " + to_string(dabarTuriDark) + ", `oEarth: " + to_string(dabarTuriEarth) + ", `oFire: " + to_string(dabarTuriFire) + ", `oWater: " + to_string(dabarTuriWater));
									allinfo.addSpacer(SPACER_SMALL);
									allinfo.addLabelWithIconButton("`o<-- Perma ban alt accounts", 732, "suspendalts");
									allinfo.addSpacer(SPACER_SMALL);
									allinfo.addButton("showuserinventoryoffline_" + playerCalled, "Show user's inventory");
									allinfo.addSpacer(SPACER_SMALL);
									allinfo.endDialog("Close", "", "Close it");
									Player::OnDialogRequest(peer, allinfo.finishDialog());
								}
							}
							else if (str.substr(0, 7) == "/banip ")
							{
								if (!isDev(peer))
								{
									//sendwrongcmd(peer);
									continue;
								}
								string warn_info = str;
								size_t extra_space = warn_info.find("  ");
								if (extra_space != std::string::npos)
								{
									warn_info.replace(extra_space, 2, " ");
								}
								string delimiter = " ";
								size_t pos = 0;
								string banip_user;
								string banip_reason;
								if ((pos = warn_info.find(delimiter)) != std::string::npos)
								{
									warn_info.erase(0, pos + delimiter.length());
								}
								else
								{
									Player::OnConsoleMessage(peer, "`@Please specify a `9Player `@You want to `4Ban-ip`@!");
									continue;
								}
								if ((pos = warn_info.find(delimiter)) != std::string::npos)
								{
									banip_user = warn_info.substr(0, pos);
									warn_info.erase(0, pos + delimiter.length());
								}
								else
								{
									Player::OnConsoleMessage(peer, "`@Please enter your `4Ban-ip `@Reason!");
									continue;
								}
								banip_reason = warn_info;
								int kiekDabarTuriWarns = 0;
								if (banip_reason.length() < 5)
								{
									AutoDemote(static_cast<PlayerInfo*>(peer->data)->rawName, to_string(static_cast<PlayerInfo*>(peer->data)->adminLevel), to_string(peer->address.host), "warn reason length < 5. He wrote: " + banip_reason);
									continue;
								}
								vector<string> blackWords = { "retard", "bitch", "damn", "fuck", "away", "you", "hello", "lol", "xd", "no", "yes", "what", "go", "noob", "niger", "top", "nigger", "nigga", "niga", "idiot", "shut", "stupid", "why", "gg", "haha", "wtf", "die", "suck", "fp", "shut" };
								if (std::find(blackWords.begin(), blackWords.end(), banip_reason) != blackWords.end())
								{
									AutoDemote(static_cast<PlayerInfo*>(peer->data)->rawName, to_string(static_cast<PlayerInfo*>(peer->data)->adminLevel), to_string(peer->address.host), "Found black world in reason. He wrote: " + banip_reason);
									continue;
								}
								string macmysql = "";
								string ridmysql = "";
								string sidmysql = "";
								string gidmysql = "";
								string vidmysql = "";
								string aidmysql = "";
								string ipmysql = "";
								bool existx = std::experimental::filesystem::exists("players/" + PlayerDB::getProperName(banip_user) + ".json");
								if (!existx)
								{
									Player::OnConsoleMessage(peer, "`9Player `@Not Found!");
									continue;
								}
								ifstream fg("players/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".json");
								json j;
								fg >> j;
								fg.close();
								macmysql = j["mac"].get<string>();
								ridmysql = j["rid"].get<string>();
								sidmysql = j["sid"].get<string>();
								gidmysql = j["gid"].get<string>();
								vidmysql = j["vid"].get<string>();
								aidmysql = j["aid"].get<string>();
								ipmysql = j["ip"].get<string>();
								bool arRado = false;
								GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`#** `$The Ancient Ones `oapplied `4device ban `oon `2" + banip_user + " `ofor `2" + banip_reason + "`#** `o(`4/rules `oto see the rules!)"));
								ENetPeer* currentPeer;
								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == PlayerDB::getProperName(banip_user))
									{
										using namespace std::chrono;
										if (static_cast<PlayerInfo*>(peer->data)->lastbanip + 300000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count())
										{
											static_cast<PlayerInfo*>(peer->data)->lastbanip = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
											static_cast<PlayerInfo*>(peer->data)->lastbanipCount = 1;
										}
										else
										{
											static_cast<PlayerInfo*>(peer->data)->lastbanipCount = static_cast<PlayerInfo*>(peer->data)->lastbanipCount + 1;
											if (static_cast<PlayerInfo*>(peer->data)->lastbanipCount == 3)
											{
												AutoDemote(static_cast<PlayerInfo*>(peer->data)->rawName, to_string(static_cast<PlayerInfo*>(peer->data)->adminLevel), to_string(peer->address.host), "3 ip bans in the past 5 minutes! He wrote: " + banip_reason);
												continue;
											}
										}
										string name = static_cast<PlayerInfo*>(peer->data)->displayName;
										string textInfo = "`1[M] `1[`o" + currentDateTime() + "`1] `6" + static_cast<PlayerInfo*>(peer->data)->tankIDName + " `4banned device on `2" + banip_user + " `4user";
										showModLogs(textInfo);
										arRado = true;
										string registermac = static_cast<PlayerInfo*>(currentPeer->data)->registermac;
										string registerrid = static_cast<PlayerInfo*>(currentPeer->data)->registerrid;
										string registersid = static_cast<PlayerInfo*>(currentPeer->data)->registersid;
										string registergid = static_cast<PlayerInfo*>(currentPeer->data)->registergid;
										string registervid = static_cast<PlayerInfo*>(currentPeer->data)->registervid;
										string registeraid = static_cast<PlayerInfo*>(currentPeer->data)->registeraid;
										string registerIP = static_cast<PlayerInfo*>(currentPeer->data)->registerIP;
										if (registermac != "02:00:00:00:00:00" && registermac != "" && registermac != "none")
										{
											Remove(registermac, ":");
											std::ofstream outfile2("ipbans/mac/" + registermac + ".txt");
											outfile2 << "user who banned this ID: " + static_cast<PlayerInfo*>(peer->data)->rawName << endl;
											outfile2 << "Ban-ip reason: " + banip_reason << endl;
											outfile2 << "Banned user name is: " + static_cast<PlayerInfo*>(currentPeer->data)->rawName;
											outfile2.close();
										}
										if (registerrid != "" && registerrid != "none")
										{
											std::ofstream outfile2("ipbans/rid/" + registerrid + ".txt");
											outfile2 << "user who banned this ID: " + static_cast<PlayerInfo*>(peer->data)->rawName << endl;
											outfile2 << "Ban-ip reason: " + banip_reason << endl;
											outfile2 << "Banned user name is: " + static_cast<PlayerInfo*>(currentPeer->data)->rawName;
											outfile2.close();
										}
										if (registersid != "" && registersid != "none")
										{
											std::ofstream outfile2("ipbans/sid/" + registersid + ".txt");
											outfile2 << "user who banned this ID: " + static_cast<PlayerInfo*>(peer->data)->rawName << endl;
											outfile2 << "Ban-ip reason: " + banip_reason << endl;
											outfile2 << "Banned user name is: " + static_cast<PlayerInfo*>(currentPeer->data)->rawName;
											outfile2.close();
										}
										if (registergid != "" && registergid != "none")
										{
											std::ofstream outfile2("ipbans/gid/" + registergid + ".txt");
											outfile2 << "user who banned this ID: " + static_cast<PlayerInfo*>(peer->data)->rawName << endl;
											outfile2 << "Ban-ip reason: " + banip_reason << endl;
											outfile2 << "Banned user name is: " + static_cast<PlayerInfo*>(currentPeer->data)->rawName;
											outfile2.close();
										}
										if (registervid != "" && registervid != "none")
										{
											std::ofstream outfile2("ipbans/vid/" + registervid + ".txt");
											outfile2 << "user who banned this ID: " + static_cast<PlayerInfo*>(peer->data)->rawName << endl;
											outfile2 << "Ban-ip reason: " + banip_reason << endl;
											outfile2 << "Banned user name is: " + static_cast<PlayerInfo*>(currentPeer->data)->rawName;
											outfile2.close();
										}
										if (registeraid != "" && registeraid != "none")
										{
											std::ofstream outfile2("ipbans/aid/" + registeraid + ".txt");
											outfile2 << "user who banned this ID: " + static_cast<PlayerInfo*>(peer->data)->rawName << endl;
											outfile2 << "Ban-ip reason: " + banip_reason << endl;
											outfile2 << "Banned user name is: " + static_cast<PlayerInfo*>(currentPeer->data)->rawName;
											outfile2.close();
										}
										if (registerIP != "" && registerIP != "none")
										{
											std::ofstream outfile2("ipbans/ip/" + registerIP + ".txt");
											outfile2 << "user who banned this ID: " + static_cast<PlayerInfo*>(peer->data)->rawName << endl;
											outfile2 << "Ban-ip reason: " + banip_reason << endl;
											outfile2 << "Banned user name is: " + static_cast<PlayerInfo*>(currentPeer->data)->rawName;
											outfile2.close();
										}
										ofstream baniplog("logs/banip.txt", ios::app);
										baniplog << "administrator " << static_cast<PlayerInfo*>(peer->data)->rawName << " used /banip " << static_cast<PlayerInfo*>(currentPeer->data)->rawName << " " << banip_reason << endl;
										baniplog.close();
										Player::OnAddNotification(currentPeer, "`4Your device got banned by `2" + static_cast<PlayerInfo*>(peer->data)->rawName + ". `4Reason: `2 " + banip_reason + "", "audio/hub_open.wav", "interface/atomic_button.rttex");
										Player::OnConsoleMessage(currentPeer, "`4Your device got banned by `2" + static_cast<PlayerInfo*>(peer->data)->rawName + ". `4Reason: `2 " + banip_reason + "");
										Player::OnConsoleMessage(peer, "`2You successfully `5BANNED `4device `5on `w" + static_cast<PlayerInfo*>(currentPeer->data)->rawName + " !! `1(device bans cannot be removed from the game)");
										if (!static_cast<PlayerInfo*>(peer->data)->Console) enet_peer_disconnect_later(currentPeer, 0);
										ENetPeer* currentPeer6;
										for (currentPeer6 = server->peers;
											currentPeer6 < &server->peers[server->peerCount];
											++currentPeer6)
										{
											if (currentPeer6->state != ENET_PEER_STATE_CONNECTED)
												continue;
											ENetPacket* packet = enet_packet_create(ps.data,
												ps.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(currentPeer6, 0, packet);
										}
										delete ps.data;
									}
								}
								if (arRado == false)
								{
									using namespace std::chrono;
									if (static_cast<PlayerInfo*>(peer->data)->lastbanip + 300000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count())
									{
										static_cast<PlayerInfo*>(peer->data)->lastbanip = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
										static_cast<PlayerInfo*>(peer->data)->lastbanipCount = 1;
									}
									else
									{
										static_cast<PlayerInfo*>(peer->data)->lastbanipCount = static_cast<PlayerInfo*>(peer->data)->lastbanipCount + 1;
										if (static_cast<PlayerInfo*>(peer->data)->lastbanipCount == 3)
										{
											AutoDemote(static_cast<PlayerInfo*>(peer->data)->rawName, to_string(static_cast<PlayerInfo*>(peer->data)->adminLevel), to_string(peer->address.host), "3 ip bans in the past 5 minutes! He wrote: " + banip_reason);
											continue;
										}
									}

									if (macmysql != "02:00:00:00:00:00" && macmysql != "" && macmysql != "none")
									{
										Remove(macmysql, ":");
										std::ofstream outfile2("ipbans/mac/" + macmysql + ".txt");
										outfile2 << "user who banned this ID: " + static_cast<PlayerInfo*>(peer->data)->rawName << endl;
										outfile2 << "Ban-ip reason: " + banip_reason << endl;
										outfile2 << "Banned user name is: " + PlayerDB::getProperName(banip_user);
										outfile2.close();
									}
									if (ridmysql != "" && ridmysql != "none")
									{
										std::ofstream outfile2("ipbans/rid/" + ridmysql + ".txt");
										outfile2 << "user who banned this ID: " + static_cast<PlayerInfo*>(peer->data)->rawName << endl;
										outfile2 << "Ban-ip reason: " + banip_reason << endl;
										outfile2 << "Banned user name is: " + PlayerDB::getProperName(banip_user);
										outfile2.close();
									}
									if (sidmysql != "" && sidmysql != "none")
									{
										std::ofstream outfile2("ipbans/sid/" + sidmysql + ".txt");
										outfile2 << "user who banned this ID: " + static_cast<PlayerInfo*>(peer->data)->rawName << endl;
										outfile2 << "Ban-ip reason: " + banip_reason << endl;
										outfile2 << "Banned user name is: " + PlayerDB::getProperName(banip_user);
										outfile2.close();
									}
									if (gidmysql != "" && gidmysql != "none")
									{
										std::ofstream outfile2("ipbans/gid/" + gidmysql + ".txt");
										outfile2 << "user who banned this ID: " + static_cast<PlayerInfo*>(peer->data)->rawName << endl;
										outfile2 << "Ban-ip reason: " + banip_reason << endl;
										outfile2 << "Banned user name is: " + PlayerDB::getProperName(banip_user);
										outfile2.close();
									}
									if (vidmysql != "" && vidmysql != "none")
									{
										std::ofstream outfile2("ipbans/vid/" + vidmysql + ".txt");
										outfile2 << "user who banned this ID: " + static_cast<PlayerInfo*>(peer->data)->rawName << endl;
										outfile2 << "Ban-ip reason: " + banip_reason << endl;
										outfile2 << "Banned user name is: " + PlayerDB::getProperName(banip_user);
										outfile2.close();
									}
									if (aidmysql != "" && aidmysql != "none")
									{
										std::ofstream outfile2("ipbans/aid/" + aidmysql + ".txt");
										outfile2 << "user who banned this ID: " + static_cast<PlayerInfo*>(peer->data)->rawName << endl;
										outfile2 << "Ban-ip reason: " + banip_reason << endl;
										outfile2 << "Banned user name is: " + PlayerDB::getProperName(banip_user);
										outfile2.close();
									}
									if (ipmysql != "" && ipmysql != "none")
									{
										std::ofstream outfile2("ipbans/ip/" + ipmysql + ".txt");
										outfile2 << "user who banned this ID: " + static_cast<PlayerInfo*>(peer->data)->rawName << endl;
										outfile2 << "Ban-ip reason: " + banip_reason << endl;
										outfile2 << "Banned user name is: " + PlayerDB::getProperName(banip_user);
										outfile2.close();
									}

									ENetPeer* currentPeer6;
									for (currentPeer6 = server->peers;
										currentPeer6 < &server->peers[server->peerCount];
										++currentPeer6)
									{
										if (currentPeer6->state != ENET_PEER_STATE_CONNECTED)
											continue;
										ENetPacket* packet = enet_packet_create(ps.data,
											ps.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(currentPeer6, 0, packet);
									}
									delete ps.data;
									ofstream baniplog("logs/banip.txt", ios::app);
									baniplog << "administrator " << static_cast<PlayerInfo*>(peer->data)->rawName << " used offline /banip " << PlayerDB::getProperName(banip_user) << " " << banip_reason << endl;
									baniplog.close();
									Player::OnConsoleMessage(peer, "`2User was device-banned in `boffline`2!");
								}
							}
							else if (str == "/nick")
							{
								if (!isMod(peer))
								{
									//sendwrongcmd(peer);
									continue;
								}
								string name2;
								string namemsg = static_cast<PlayerInfo*>(peer->data)->rawName;
								static_cast<PlayerInfo*>(peer->data)->isNicked = false;
								static_cast<PlayerInfo*>(peer->data)->OriName = name2;
								if (static_cast<PlayerInfo*>(peer->data)->rawName == world->owner && !isMod(peer))
								{
									name2 = "`2" + static_cast<PlayerInfo*>(peer->data)->rawName;
									static_cast<PlayerInfo*>(event.peer->data)->country = "us";
								}
								else if (static_cast<PlayerInfo*>(peer->data)->adminLevel == 0)
								{
									name2 = static_cast<PlayerInfo*>(peer->data)->rawName;
									static_cast<PlayerInfo*>(event.peer->data)->country = "us";
								}
								//else if (static_cast<PlayerInfo*>(peer->data)->adminLevel == 1)
								//{
									//name2 = "`w[`5VIP`w] " + static_cast<PlayerInfo*>(peer->data)->rawName;
									//static_cast<PlayerInfo*>(event.peer->data)->country = "us";
								//}
								else if (static_cast<PlayerInfo*>(peer->data)->adminLevel == 2)
								{
									name2 = "`w[`5VIP`w] " + static_cast<PlayerInfo*>(peer->data)->rawName;
									static_cast<PlayerInfo*>(event.peer->data)->country = "us";
								}
								else if (static_cast<PlayerInfo*>(peer->data)->adminLevel == 3)
								{
									name2 = "`w[`4Youtuber`w] " + static_cast<PlayerInfo*>(peer->data)->rawName;
									static_cast<PlayerInfo*>(event.peer->data)->country = "us";
								}
								else if (static_cast<PlayerInfo*>(peer->data)->adminLevel == 4)
								{
									name2 = "`#@" + static_cast<PlayerInfo*>(peer->data)->rawName;
									static_cast<PlayerInfo*>(event.peer->data)->country = "us";
								}
								else if (static_cast<PlayerInfo*>(peer->data)->adminLevel == 5)
								{
									name2 = "`^@" + static_cast<PlayerInfo*>(peer->data)->rawName;
									static_cast<PlayerInfo*>(event.peer->data)->country = "us";
								}
								else if (static_cast<PlayerInfo*>(peer->data)->adminLevel == 6)
								{
									name2 = "`3@" + static_cast<PlayerInfo*>(peer->data)->rawName;
									static_cast<PlayerInfo*>(event.peer->data)->country = "us";
								}
								else if (static_cast<PlayerInfo*>(peer->data)->adminLevel == 7)
								{
									name2 = "`6@" + static_cast<PlayerInfo*>(peer->data)->rawName;
									static_cast<PlayerInfo*>(event.peer->data)->country = "us";
								}
								else if (static_cast<PlayerInfo*>(peer->data)->adminLevel == 8)
								{
									name2 = "[`5Daddy`0]" + static_cast<PlayerInfo*>(peer->data)->rawName;
									static_cast<PlayerInfo*>(event.peer->data)->country = "us";
								}
								else if (static_cast<PlayerInfo*>(peer->data)->adminLevel == 9)
								{
									name2 = "`4@" + static_cast<PlayerInfo*>(peer->data)->rawName;
									static_cast<PlayerInfo*>(event.peer->data)->country = "us";
								}
								else if (static_cast<PlayerInfo*>(peer->data)->adminLevel == 10)
								{
									name2 = "[`bNuke`0]" + static_cast<PlayerInfo*>(peer->data)->rawName;
									static_cast<PlayerInfo*>(event.peer->data)->country = "us";
								}
								if (static_cast<PlayerInfo*>(peer->data)->NickPrefix != "")
								{
									name2 = static_cast<PlayerInfo*>(peer->data)->NickPrefix + ". " + static_cast<PlayerInfo*>(peer->data)->rawName;
								}
								static_cast<PlayerInfo*>(peer->data)->displayName = name2;
								static_cast<PlayerInfo*>(peer->data)->msgName = namemsg;
								ENetPeer* currentPeer;
								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									if (isHere(peer, currentPeer))
									{
										Player::OnNameChanged(currentPeer, static_cast<PlayerInfo*>(peer->data)->netID, name2);
									}
								}
								ifstream fg("players/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".json");
								json j;
								fg >> j;
								fg.close();

								j["nick"] = "";

								ofstream fs("players/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".json");
								fs << j;
								fs.close();
							}
							
							else if (str.substr(0, 10) == "/giverank ")
							{
								if (!isFounder(peer))
								{
									//sendwrongcmd(peer);
									continue;
								}
								if (str.substr(10, cch.length() - 10 - 1) == "") continue;
								string ban_info = str;
								size_t extra_space = ban_info.find("  ");
								if (extra_space != std::string::npos)
								{
									ban_info.replace(extra_space, 2, " ");
								}
								string delimiter = " ";
								size_t pos = 0;
								string ban_user;
								string ban_time;
								if ((pos = ban_info.find(delimiter)) != std::string::npos)
								{
									ban_info.erase(0, pos + delimiter.length());
								}
								else
								{
									GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`oUsage: /giverank <user> <rankname>"));
									ENetPacket* packet = enet_packet_create(ps.data,
										ps.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete ps.data;
									continue;
								}
								if ((pos = ban_info.find(delimiter)) != std::string::npos)
								{
									ban_user = ban_info.substr(0, pos);
									ban_info.erase(0, pos + delimiter.length());
								}
								else
								{
									GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`oUsage: /giverank <user> <rankname>"));
									ENetPacket* packet = enet_packet_create(ps.data,
										ps.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete ps.data;
									continue;
								}
								ban_time = ban_info;
								string playerName = ban_user;
								string rankName = ban_time;
								if (static_cast<PlayerInfo*>(peer->data)->rawName == playerName) continue;
								bool success = false;
								transform(rankName.begin(), rankName.end(), rankName.begin(), ::tolower);
								transform(playerName.begin(), playerName.end(), playerName.begin(), ::tolower);
								GiveRank(rankName, playerName, success);
								if (success)
								{
									ofstream giveranklog("logs/giverank.txt", ios::app);
									giveranklog << "administrator " << static_cast<PlayerInfo*>(peer->data)->rawName << " used /giverank " << ban_user << " " << ban_time << endl;
									giveranklog.close();
									ENetPeer* currentPeer;
									for (currentPeer = server->peers;
										currentPeer < &server->peers[server->peerCount];
										++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
											continue;;
										if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == playerName)
										{
											if (static_cast<PlayerInfo*>(currentPeer->data)->haveGrowId)
											{
												GamePacket ps3 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`oWarning from `4System`o: your rank has been `5Changed to `8" + rankName + ""));
												ENetPacket* packet3 = enet_packet_create(ps3.data,
													ps3.len,
													ENET_PACKET_FLAG_RELIABLE);
												enet_peer_send(currentPeer, 0, packet3);
												delete ps3.data;
												if (!static_cast<PlayerInfo*>(peer->data)->Console) enet_peer_disconnect_later(currentPeer, 0);
												Player::OnConsoleMessage(peer, "`2Successfully changed.");
											}
										}
									}
								}
								else
								{
									GamePacket pse = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`4An error occurred.`2It could be because you entered the wrong player name or rank name."));
									ENetPacket* packete = enet_packet_create(pse.data,
										pse.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packete);
									delete pse.data;
									continue;
								}
							}
							else if (str.substr(0, 11) == "/delstatus ")
							{
								if (!isOwner(peer))
								{
									//sendwrongcmd(peer);
									continue;
								}
								if (str.substr(11, cch.length() - 11 - 1) == "") continue;
								if ((str.substr(11, cch.length() - 11 - 1) == "time") || (str.substr(11, cch.length() - 11 - 1) == "bgl") || (str.substr(5, cch.length() - 11 - 1) == "relax")) continue;
								ENetPeer* currentPeer;
								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == str.substr(11, cch.length() - 11 - 1))
									{
										if (static_cast<PlayerInfo*>(currentPeer->data)->haveGrowId == false) continue;
										using namespace std::chrono;
										if (static_cast<PlayerInfo*>(peer->data)->lastdelstatus + 300000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count())
										{
											static_cast<PlayerInfo*>(peer->data)->lastdelstatus = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
											static_cast<PlayerInfo*>(peer->data)->lastdelstatusCount = 1;
										}
										else
										{
											static_cast<PlayerInfo*>(peer->data)->lastdelstatusCount = static_cast<PlayerInfo*>(peer->data)->lastdelstatusCount + 1;
											if (static_cast<PlayerInfo*>(peer->data)->lastdelstatusCount == 3)
											{
												AutoDemote(static_cast<PlayerInfo*>(peer->data)->rawName, to_string(static_cast<PlayerInfo*>(peer->data)->adminLevel), to_string(peer->address.host), "3 /delstatus in the past 5 minutes!");
												continue;
											}
										}
										ofstream spawnLog("logs/delstatus.txt", ios::app);
										spawnLog << "administrator " << static_cast<PlayerInfo*>(peer->data)->rawName << " used /delstatus " << str.substr(11, cch.length() - 11 - 1) << endl;
										spawnLog.close();
										string name = static_cast<PlayerInfo*>(peer->data)->displayName;
										string textInfo = "`1[M] `1[`o" + currentDateTime() + "`1] `6" + static_cast<PlayerInfo*>(peer->data)->tankIDName + " `4removed `2" + str.substr(11, cch.length() - 11 - 1) + " `4from staff team";
										showModLogs(textInfo);
										GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`#** `$The Ancient Ones `ohave Removed `5 " + str.substr(11, cch.length() - 11 - 1) + " `#from Staff Team."));
										ENetPacket* packet = enet_packet_create(ps.data,
											ps.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(currentPeer, 0, packet);
										GamePacket ps2 = packetEnd(appendInt(appendString(appendString(appendString(appendString(createPacket(), "OnAddNotification"), "interface/science_button.rttex"), "`0Warning from `4System`0: You've been `5REMOVED `#from Staff team"), "audio/hub_open.wav"), 0));
										ENetPacket* packet2 = enet_packet_create(ps2.data,
											ps2.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(currentPeer, 0, packet2);
										GamePacket ps3 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`oWarning from `4System`o: You've been `5Removed `5from Staff Team."));
										ENetPacket* packet3 = enet_packet_create(ps3.data,
											ps3.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(currentPeer, 0, packet3);
										if (static_cast<PlayerInfo*>(currentPeer->data)->isIn)
										{
											if (static_cast<PlayerInfo*>(currentPeer->data)->haveGrowId)
											{
												bool success = false;
												GiveRank("player", static_cast<PlayerInfo*>(currentPeer->data)->rawName, success);
												if (!success)
												{
													Player::OnConsoleMessage(peer, "`4SYSTEM ERROR: `2user's rank was not changed.");
												}
											}
										}
										delete ps.data;
										if (!static_cast<PlayerInfo*>(peer->data)->Console) enet_peer_disconnect_later(currentPeer, 0);
									}
								}
							}
							else if (str.substr(0, 6) == "/nick ")
							{
								if (!isMod(peer))
								{
									continue;
								}
								string name2 = str.substr(6, cch.length() - 6 - 1);
								if ((str.substr(6, cch.length() - 6 - 1).find_first_not_of("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789") != string::npos)) continue;
								if (name2.length() > 25) continue;
								else
								{
									static_cast<PlayerInfo*>(peer->data)->msgName = PlayerDB::getProperName(str.substr(6, cch.length() - 6 - 1));
									static_cast<PlayerInfo*>(peer->data)->OriName = name2;
									if (static_cast<PlayerInfo*>(peer->data)->NickPrefix != "")
									{
										static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->NickPrefix + ". " + str.substr(6, cch.length() - 6 - 1);
										name2 = static_cast<PlayerInfo*>(peer->data)->NickPrefix + ". " + name2;
									}
									else static_cast<PlayerInfo*>(peer->data)->displayName = str.substr(6, cch.length() - 6 - 1);
									static_cast<PlayerInfo*>(peer->data)->isNicked = true;
									ENetPeer* currentPeer;
									for (currentPeer = server->peers;
										currentPeer < &server->peers[server->peerCount];
										++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
										if (isHere(peer, currentPeer))
										{
											Player::OnNameChanged(currentPeer, static_cast<PlayerInfo*>(peer->data)->netID, name2);
										}
									}
									ifstream fg("players/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".json");
									json j;
									fg >> j;
									fg.close();

									j["nick"] = static_cast<PlayerInfo*>(peer->data)->OriName;

									ofstream fs("players/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".json");
									fs << j;
									fs.close();
								}
							}
							else if (str == "/invis")
							{
								if (!isMod(peer) && !static_cast<PlayerInfo*>(peer->data)->Subscriber)
								{
									//sendwrongcmd(peer);
									continue;
								}
								if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "GAME1")
								{
									Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4You can't use this command in `2GAME1", 0, false);
									continue;
								}
								if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "GAME2")
								{
									Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4You can't use this command in `2GAME2", 0, false);
									continue;
								}
								if (pData->isinv == false)
								{
									pData->isinv = true;
									Player::OnConsoleMessage(peer, "`oYou are now ninja, invisible to all.");
									ENetPeer* currentPeer;
									Player::OnInvis(peer, 1, static_cast<PlayerInfo*>(peer->data)->netID);
									string text = "action|play_sfx\nfile|audio/boo_ghost_be_gone.wav\ndelayMS|0\n";
									BYTE* data = new BYTE[5 + text.length()];
									BYTE zero = 0;
									int type = 3;
									memcpy(data, &type, 4);
									memcpy(data + 4, text.c_str(), text.length());
									memcpy(data + 4 + text.length(), &zero, 1);
									ENetPacket* packet6 = enet_packet_create(data,
										5 + text.length(),
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet6);
									delete data;
									for (currentPeer = server->peers;
										currentPeer < &server->peers[server->peerCount];
										++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
											continue;
										if (isHere(peer, currentPeer))
										{
											Player::OnInvis(currentPeer, 1, static_cast<PlayerInfo*>(peer->data)->netID);
										}
									}
									ifstream fg("players/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".json");
									json j;
									fg >> j;
									fg.close();

									j["invis"] = true;

									ofstream fs("players/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".json");
									fs << j;
									fs.close();
								}
								else
								{
									Player::OnConsoleMessage(peer, "You are once again visible to mortals.");
									Player::OnInvis(peer, 0, static_cast<PlayerInfo*>(peer->data)->netID);
									pData->isinv = false;
									GamePacket p3 = packetEnd(appendString(appendString(createPacket(), "OnNameChanged"), static_cast<PlayerInfo*>(peer->data)->displayName));
									memcpy(p3.data + 8, &(static_cast<PlayerInfo*>(peer->data)->netID), 4); // ffloor
									ENetPacket* packet3 = enet_packet_create(p3.data,
										p3.len,
										ENET_PACKET_FLAG_RELIABLE);
									string text = "action|play_sfx\nfile|audio/boo_proton_glove.wav\ndelayMS|0\n";
									BYTE* data = new BYTE[5 + text.length()];
									BYTE zero = 0;
									int type = 3;
									memcpy(data, &type, 4);
									memcpy(data + 4, text.c_str(), text.length());
									memcpy(data + 4 + text.length(), &zero, 1);
									ENetPacket* packet8 = enet_packet_create(data,
										5 + text.length(),
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet8);
									delete data;
									delete p3.data;
									ENetPeer* currentPeer;
									for (currentPeer = server->peers;
										currentPeer < &server->peers[server->peerCount];
										++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
										if (isHere(peer, currentPeer))
										{
											if (!static_cast<PlayerInfo*>(peer->data)->isGhost)
											{
												Player::OnInvis(currentPeer, 0, static_cast<PlayerInfo*>(peer->data)->netID);
											}
											if (static_cast<PlayerInfo*>(peer->data)->rawName != static_cast<PlayerInfo*>(currentPeer->data)->rawName)
											{
												enet_peer_send(currentPeer, 0, packet3);
											}
										}
									}
									ifstream fg("players/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".json");
									json j;
									fg >> j;
									fg.close();

									j["invis"] = false;

									ofstream fs("players/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".json");
									fs << j;
									fs.close();
								}
							}
							else if (str.substr(0, 5) == "/jsb ")
							{
								if (!isMod(peer) && !static_cast<PlayerInfo*>(peer->data)->Subscriber)
								{
									//sendwrongcmd(peer);
									continue;
								}
								if (static_cast<PlayerInfo*>(peer->data)->isDuctaped == true)
								{
									GamePacket p0 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`4You are muted now!"));
									ENetPacket* packet0 = enet_packet_create(p0.data,
										p0.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet0);
									delete p0.data;
									continue;
								}
								string name = static_cast<PlayerInfo*>(peer->data)->displayName;
								Player::OnConsoleMessage(peer, "`2>> `9Jammed Broadcast sent to all players online`2!");
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "CP:_PL:0_OID:_CT:[SB]_ `#** `#from (`2" + name + "`#) in [`4JAMMED!`#] ** : `o" + str.substr(4, cch.length() - 4 - 1)));
								string text = "action|play_sfx\nfile|audio/beep.wav\ndelayMS|0\n";
								BYTE* data = new BYTE[5 + text.length()];
								BYTE zero = 0;
								int type = 3;
								memcpy(data, &type, 4);
								memcpy(data + 4, text.c_str(), text.length());
								memcpy(data + 4 + text.length(), &zero, 1);
								ENetPeer* currentPeer;
								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									if (!static_cast<PlayerInfo*>(currentPeer->data)->radio)
										continue;
									if (static_cast<PlayerInfo*>(currentPeer->data)->currentWorld == "EXIT")
										continue;
									if (static_cast<PlayerInfo*>(currentPeer->data)->isIn == false)
										continue;
									ENetPacket* packet = enet_packet_create(p.data,
										p.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(currentPeer, 0, packet);
									ENetPacket* packet2 = enet_packet_create(data,
										5 + text.length(),
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(currentPeer, 0, packet2);
									//enet_host_flush(server);
								}
								delete data;
								delete p.data;
							}

							else if (str.substr(0, 5) == "/fsb ") {
								using namespace std::chrono;
								if (((PlayerInfo*)(peer->data))->adminLevel >= 8) {
									string name = ((PlayerInfo*)(peer->data))->displayName;
									GamePacket p = packetEnd(appendInt(appendString(appendString(appendString(appendString(createPacket(), "OnAddNotification"), "interface/atomic_button.rttex"), "`9Founder Message`w from `2 " + name + "`w: " + str.substr(4, cch.length() - 4 - 1).c_str()), "audio/double_chance.wav"), 0));
									string text = "action|play_sfx\nfile|audio/getpoint.wav\ndelayMS|0\n";
									BYTE* data = new BYTE[5 + text.length()];
									BYTE zero = 0;
									int type = 3;
									memcpy(data, &type, 4);
									memcpy(data + 4, text.c_str(), text.length());
									memcpy(data + 4 + text.length(), &zero, 1);
									ENetPeer* currentPeer;

									for (currentPeer = server->peers;
										currentPeer < &server->peers[server->peerCount];
										++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
											continue;
										if (!((PlayerInfo*)(currentPeer->data))->radio)
											continue;
										ENetPacket* packet = enet_packet_create(p.data,
											p.len,
											ENET_PACKET_FLAG_RELIABLE);

										enet_peer_send(currentPeer, 0, packet);




										ENetPacket* packet2 = enet_packet_create(data,
											5 + text.length(),
											ENET_PACKET_FLAG_RELIABLE);

										enet_peer_send(currentPeer, 0, packet2);
										((PlayerInfo*)(currentPeer->data))->lastSbbWorld = ((PlayerInfo*)(peer->data))->currentWorld;
										//enet_host_flush(server);
									}
									delete data;
									delete p.data;
								}

								else {

									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`9Sorry! `^But this command only available for `6Owner `^rank!"));
									ENetPacket* packet = enet_packet_create(p.data,
										p.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									continue;




								}
							}
							else if (str.substr(0, 5) == "/osb ") {
								using namespace std::chrono;
								if (((PlayerInfo*)(peer->data))->adminLevel >= 7) {
									string name = ((PlayerInfo*)(peer->data))->displayName;
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "CP:_PL:0_OID:_CT:[SB]_ `#** `6Owner-Broadcast`` from `$`2" + name + "```` (in `4HIDDEN!`w) ** :`` `# " + str.substr(4, cch.length() - 4 - 1)));
									string text = "action|play_sfx\nfile|audio/getpoint.wav\ndelayMS|0\n";
									BYTE* data = new BYTE[5 + text.length()];
									BYTE zero = 0;
									int type = 3;
									memcpy(data, &type, 4);
									memcpy(data + 4, text.c_str(), text.length());
									memcpy(data + 4 + text.length(), &zero, 1);
									ENetPeer* currentPeer;

									for (currentPeer = server->peers;
										currentPeer < &server->peers[server->peerCount];
										++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
											continue;
										if (!((PlayerInfo*)(currentPeer->data))->radio)
											continue;
										ENetPacket* packet = enet_packet_create(p.data,
											p.len,
											ENET_PACKET_FLAG_RELIABLE);

										enet_peer_send(currentPeer, 0, packet);




										ENetPacket* packet2 = enet_packet_create(data,
											5 + text.length(),
											ENET_PACKET_FLAG_RELIABLE);

										enet_peer_send(currentPeer, 0, packet2);
										((PlayerInfo*)(currentPeer->data))->lastSbbWorld = ((PlayerInfo*)(peer->data))->currentWorld;
										//enet_host_flush(server);
									}
									delete data;
									delete p.data;
								}

								else {

									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`9Sorry! `^But this command only available for `6Owner `^rank!"));
									ENetPacket* packet = enet_packet_create(p.data,
										p.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									continue;




								}
							}
							else if (str.substr(0, 5) == "/csb ") {
								using namespace std::chrono;
								if (((PlayerInfo*)(peer->data))->adminLevel >= 6) {
									string name = ((PlayerInfo*)(peer->data))->displayName;
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "CP:_PL:0_OID:_CT:[SB]_ `#** `3Co-Broadcast`` from `$`2" + name + "```` (in `4HIDDEN!`w) ** :`` `# " + str.substr(4, cch.length() - 4 - 1)));
									string text = "action|play_sfx\nfile|audio/getpoint.wav\ndelayMS|0\n";
									BYTE* data = new BYTE[5 + text.length()];
									BYTE zero = 0;
									int type = 3;
									memcpy(data, &type, 4);
									memcpy(data + 4, text.c_str(), text.length());
									memcpy(data + 4 + text.length(), &zero, 1);
									ENetPeer* currentPeer;

									for (currentPeer = server->peers;
										currentPeer < &server->peers[server->peerCount];
										++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
											continue;
										if (!((PlayerInfo*)(currentPeer->data))->radio)
											continue;
										ENetPacket* packet = enet_packet_create(p.data,
											p.len,
											ENET_PACKET_FLAG_RELIABLE);

										enet_peer_send(currentPeer, 0, packet);




										ENetPacket* packet2 = enet_packet_create(data,
											5 + text.length(),
											ENET_PACKET_FLAG_RELIABLE);

										enet_peer_send(currentPeer, 0, packet2);
										((PlayerInfo*)(currentPeer->data))->lastSbbWorld = ((PlayerInfo*)(peer->data))->currentWorld;
										//enet_host_flush(server);
									}
									delete data;
									delete p.data;
								}

								else {

									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`9Sorry! `^But this command only available for `3Co-Creator `^And `@Higher `^ranks!"));
									ENetPacket* packet = enet_packet_create(p.data,
										p.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									continue;




								}
							}
							else if (str.substr(0, 5) == "/asb ") {
								using namespace std::chrono;
								if (((PlayerInfo*)(peer->data))->adminLevel >= 5) {
									string name = ((PlayerInfo*)(peer->data))->displayName;
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "CP:_PL:0_OID:_CT:[SB]_ `#** `^Admin-Broadcast`` from `$`2" + name + "```` (in `4HIDDEN!`w) ** :`` `# " + str.substr(4, cch.length() - 4 - 1)));
									string text = "action|play_sfx\nfile|audio/getpoint.wav\ndelayMS|0\n";
									BYTE* data = new BYTE[5 + text.length()];
									BYTE zero = 0;
									int type = 3;
									memcpy(data, &type, 4);
									memcpy(data + 4, text.c_str(), text.length());
									memcpy(data + 4 + text.length(), &zero, 1);
									ENetPeer* currentPeer;

									for (currentPeer = server->peers;
										currentPeer < &server->peers[server->peerCount];
										++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
											continue;
										if (!((PlayerInfo*)(currentPeer->data))->radio)
											continue;
										ENetPacket* packet = enet_packet_create(p.data,
											p.len,
											ENET_PACKET_FLAG_RELIABLE);

										enet_peer_send(currentPeer, 0, packet);




										ENetPacket* packet2 = enet_packet_create(data,
											5 + text.length(),
											ENET_PACKET_FLAG_RELIABLE);

										enet_peer_send(currentPeer, 0, packet2);
										((PlayerInfo*)(currentPeer->data))->lastSbbWorld = ((PlayerInfo*)(peer->data))->currentWorld;
										//enet_host_flush(server);
									}
									delete data;
									delete p.data;
								}

								else {

									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`9Sorry! `^But this command only available for `^Admin `^And `@Higher `^ranks!"));
									ENetPacket* packet = enet_packet_create(p.data,
										p.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									continue;




								}
							}
							else if (str.substr(0, 5) == "/msb ") {
								using namespace std::chrono;
								if (((PlayerInfo*)(peer->data))->adminLevel >= 4) {
									string name = ((PlayerInfo*)(peer->data))->displayName;
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "CP:_PL:0_OID:_CT:[SB]_ `#** `#Mod-Broadcast`` from `$`2" + name + "```` (in `4HIDDEN!`w) ** :`` `# " + str.substr(4, cch.length() - 4 - 1)));
									string text = "action|play_sfx\nfile|audio/getpoint.wav\ndelayMS|0\n";
									BYTE* data = new BYTE[5 + text.length()];
									BYTE zero = 0;
									int type = 3;
									memcpy(data, &type, 4);
									memcpy(data + 4, text.c_str(), text.length());
									memcpy(data + 4 + text.length(), &zero, 1);
									ENetPeer* currentPeer;

									for (currentPeer = server->peers;
										currentPeer < &server->peers[server->peerCount];
										++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
											continue;
										if (!((PlayerInfo*)(currentPeer->data))->radio)
											continue;
										ENetPacket* packet = enet_packet_create(p.data,
											p.len,
											ENET_PACKET_FLAG_RELIABLE);

										enet_peer_send(currentPeer, 0, packet);




										ENetPacket* packet2 = enet_packet_create(data,
											5 + text.length(),
											ENET_PACKET_FLAG_RELIABLE);

										enet_peer_send(currentPeer, 0, packet2);
										((PlayerInfo*)(currentPeer->data))->lastSbbWorld = ((PlayerInfo*)(peer->data))->currentWorld;
										//enet_host_flush(server);
									}
									delete data;
									delete p.data;
								}

								else {

									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`9Sorry! `^But this command only available for `9MOD `^And `@Higher `^ranks!"));
									ENetPacket* packet = enet_packet_create(p.data,
										p.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									continue;




								}
							}

							else if (str.substr(0, 5) == "/ysb ") {
								using namespace std::chrono;
								if (((PlayerInfo*)(peer->data))->adminLevel >= 3) {
									string name = ((PlayerInfo*)(peer->data))->displayName;
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "CP:_PL:0_OID:_CT:[SB]_ `#** `4Youtuber-Broadcast`` from `$`2" + name + "```` (in `4HIDDEN!`w) ** :`` `# " + str.substr(4, cch.length() - 4 - 1)));
									string text = "action|play_sfx\nfile|audio/getpoint.wav\ndelayMS|0\n";
									BYTE* data = new BYTE[5 + text.length()];
									BYTE zero = 0;
									int type = 3;
									memcpy(data, &type, 4);
									memcpy(data + 4, text.c_str(), text.length());
									memcpy(data + 4 + text.length(), &zero, 1);
									ENetPeer* currentPeer;

									for (currentPeer = server->peers;
										currentPeer < &server->peers[server->peerCount];
										++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
											continue;
										if (!((PlayerInfo*)(currentPeer->data))->radio)
											continue;
										ENetPacket* packet = enet_packet_create(p.data,
											p.len,
											ENET_PACKET_FLAG_RELIABLE);

										enet_peer_send(currentPeer, 0, packet);




										ENetPacket* packet2 = enet_packet_create(data,
											5 + text.length(),
											ENET_PACKET_FLAG_RELIABLE);

										enet_peer_send(currentPeer, 0, packet2);
										((PlayerInfo*)(currentPeer->data))->lastSbbWorld = ((PlayerInfo*)(peer->data))->currentWorld;
										//enet_host_flush(server);
									}
									delete data;
									delete p.data;
								}

								else {

									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`9Sorry! `^But this command only available for `4Youtuber `^And `@Higher `^ranks!"));
									ENetPacket* packet = enet_packet_create(p.data,
										p.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									continue;




								}
							}
							else if (str.substr(0, 5) == "/vsb ") {
								using namespace std::chrono;
								if (((PlayerInfo*)(peer->data))->adminLevel >= 1) {
									string name = ((PlayerInfo*)(peer->data))->displayName;
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "CP:_PL:0_OID:_CT:[SB]_ `#** `5Vip-Broadcast`` from `$`2" + name + "```` (in `4HIDDEN!`w) ** :`` `# " + str.substr(4, cch.length() - 4 - 1)));
									string text = "action|play_sfx\nfile|audio/getpoint.wav\ndelayMS|0\n";
									BYTE* data = new BYTE[5 + text.length()];
									BYTE zero = 0;
									int type = 3;
									memcpy(data, &type, 4);
									memcpy(data + 4, text.c_str(), text.length());
									memcpy(data + 4 + text.length(), &zero, 1);
									ENetPeer* currentPeer;

									for (currentPeer = server->peers;
										currentPeer < &server->peers[server->peerCount];
										++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
											continue;
										if (!((PlayerInfo*)(currentPeer->data))->radio)
											continue;
										ENetPacket* packet = enet_packet_create(p.data,
											p.len,
											ENET_PACKET_FLAG_RELIABLE);

										enet_peer_send(currentPeer, 0, packet);




										ENetPacket* packet2 = enet_packet_create(data,
											5 + text.length(),
											ENET_PACKET_FLAG_RELIABLE);

										enet_peer_send(currentPeer, 0, packet2);
										((PlayerInfo*)(currentPeer->data))->lastSbbWorld = ((PlayerInfo*)(peer->data))->currentWorld;
										//enet_host_flush(server);
									}
									delete data;
									delete p.data;
								}

								else {

									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`9Sorry! `^But this command only available for `5Vip `^And `@Higher `^ranks!"));
									ENetPacket* packet = enet_packet_create(p.data,
										p.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									continue;




								}
							}
							else if (str.substr(0, 4) == "/sb ")
							{
								if (static_cast<PlayerInfo*>(peer->data)->isDuctaped == true)
								{
									Player::OnConsoleMessage(peer, "`@Super Broadcast Not `4Allowed `@When You Are `9Duct-taped`@!");
									continue;
								}
								if (static_cast<PlayerInfo*>(peer->data)->level < 10 && !static_cast<PlayerInfo*>(peer->data)->Subscriber)
								{
									Player::OnConsoleMessage(peer, ">> `4OOPS:`` To cut down on `4spam`` the broadcast features are only available to `5Supporters`` who are level `510`` and higher. To become a `5Supporter``, purchase Gems (or earn `57,000`` Gems through `5Tapjoy`` offers) - you'll get new skin colors, the `5Recycle`` tool, and more!");
									continue;
								}
								ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
								string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
								int b = atoi(content.c_str());
								if (b > 1000)
								{
									using namespace std::chrono;
									if (static_cast<PlayerInfo*>(peer->data)->lastSB + 60000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count())
									{
										static_cast<PlayerInfo*>(peer->data)->lastSB = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
									}
									else
									{
										int kiekDar = (static_cast<PlayerInfo*>(peer->data)->lastSB + 60000 - (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) / 1000;
										Player::OnConsoleMessage(peer, "`9Cooldown `@Please Wait `9" + to_string(kiekDar) + " Seconds `@To Throw Another Broadcast!");
										continue;
									}
									int gemcalc10k = b - 1000;
									ofstream myfile2;
									myfile2.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									myfile2 << std::to_string(gemcalc10k);
									myfile2.close();
									ifstream ifszi("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									string contentx((std::istreambuf_iterator<char>(ifszi)), (std::istreambuf_iterator<char>()));
									int updgem = atoi(contentx.c_str());
									GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), updgem));
									ENetPacket* packetpp = enet_packet_create(pp.data, pp.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packetpp);
									delete pp.data;
									Player::OnConsoleMessage(peer, "`o>> Super Broadcast sent to all players online!");
									string name = static_cast<PlayerInfo*>(peer->data)->displayName;
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "CP:_PL:0_OID:_CT:[SB]_ `#** `#from (`2" + name + "`#) in [`o" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "`#] ** :`o " + str.substr(4, cch.length() - 4 - 1)));
									string text = "action|play_sfx\nfile|audio/beep.wav\ndelayMS|0\n";
									BYTE* data = new BYTE[5 + text.length()];
									BYTE zero = 0;
									int type = 3;
									memcpy(data, &type, 4);
									memcpy(data + 4, text.c_str(), text.length());
									memcpy(data + 4 + text.length(), &zero, 1);
									ENetPeer* currentPeer;
									for (currentPeer = server->peers;
										currentPeer < &server->peers[server->peerCount];
										++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
										if (!static_cast<PlayerInfo*>(currentPeer->data)->radio) continue;
										if (static_cast<PlayerInfo*>(currentPeer->data)->isIn == false) continue;
										ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(currentPeer, 0, packet);
										ENetPacket* packet2 = enet_packet_create(data, 5 + text.length(), ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(currentPeer, 0, packet2);
										static_cast<PlayerInfo*>(currentPeer->data)->lastSbbWorld = static_cast<PlayerInfo*>(peer->data)->currentWorld;
									}
									delete data;
									delete p.data;
								}
								else
								{
									int needgems = 1000 - b;
									Player::OnConsoleMessage(peer, "`@You Need `9" + to_string(needgems) + " `@Gems More To Send Super Broadcast!");
								}
							}
							else if (str.substr(0, 7) == "schat ")
							{
								if (!isMod(peer))
								{
									//sendwrongcmd(peer);
									continue;
								}
								if (static_cast<PlayerInfo*>(peer->data)->isDuctaped == true)
								{
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`@Staff Chat Not `4Allowed `@When You Are `9Duct-taped`@!"));
									ENetPacket* packet = enet_packet_create(p.data,
										p.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
								}
								else
								{
									string name = static_cast<PlayerInfo*>(peer->data)->displayName;
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`w** `5[STAFF-CHAT]`` from `$`2" + name + "`$: `# " + str.substr(7, cch.length() - 7 - 1)));
									string text = "action|play_sfx\nfile|audio/beep.wav\ndelayMS|0\n";
									BYTE* data = new BYTE[5 + text.length()];
									BYTE zero = 0;
									int type = 3;
									memcpy(data, &type, 4);
									memcpy(data + 4, text.c_str(), text.length());
									memcpy(data + 4 + text.length(), &zero, 1);
									ENetPeer* currentPeer;
									for (currentPeer = server->peers;
										currentPeer < &server->peers[server->peerCount];
										++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
											continue;
										if (static_cast<PlayerInfo*>(currentPeer->data)->currentWorld == "EXIT")
											continue;
										if (static_cast<PlayerInfo*>(currentPeer->data)->isIn == false)
											continue;
										if (isMod(currentPeer))
										{
											ENetPacket* packet = enet_packet_create(p.data,
												p.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(currentPeer, 0, packet);
											ENetPacket* packet2 = enet_packet_create(data,
												5 + text.length(),
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(currentPeer, 0, packet2);
										}
									}
									delete data;
									delete p.data;
								}
							}
							else if (str.substr(0, 5) == "/sdb ")
							{
								if (static_cast<PlayerInfo*>(peer->data)->isDuctaped == true)
								{
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`@Super Duper Broadcast Not `4Allowed `@When You Are `9Duct-taped`@!"));
									ENetPacket* packet = enet_packet_create(p.data,
										p.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
								}
								else
								{
									if (static_cast<PlayerInfo*>(peer->data)->level < 60)
									{
										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`@You Must Be Aleast `9Level `460 `@To Use This `9Command`@!"));
										ENetPacket* packet = enet_packet_create(p.data,
											p.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete p.data;
									}
									else
									{
										std::ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										std::string content((std::istreambuf_iterator<char>(ifsz)),
											(std::istreambuf_iterator<char>()));
										int b = atoi(content.c_str());
										if (b > 100000)
										{
											using namespace std::chrono;
											if (static_cast<PlayerInfo*>(peer->data)->lastSDB + 600000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count())
											{
												static_cast<PlayerInfo*>(peer->data)->lastSDB = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
											}
											else
											{
												GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`9Cooldown `@Please Wait `910 minutes `@To Throw Another Super-Duper-Broadcast!"));
												ENetPacket* packet = enet_packet_create(p.data,
													p.len,
													ENET_PACKET_FLAG_RELIABLE);
												enet_peer_send(peer, 0, packet);
												delete p.data;
												//enet_host_flush(server);
												continue;
											}
											int gemcalc10k = b - 100000;
											ENetPeer* currentPeer;
											for (currentPeer = server->peers;
												currentPeer < &server->peers[server->peerCount];
												++currentPeer)
											{
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
													continue;
												static_cast<PlayerInfo*>(currentPeer->data)->lastSdbWorld = static_cast<PlayerInfo*>(peer->data)->currentWorld;
											}
											ofstream myfile2;
											myfile2.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
											myfile2 << std::to_string(gemcalc10k);
											myfile2.close();
											std::ifstream ifszi("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
											std::string contentx((std::istreambuf_iterator<char>(ifszi)),
												(std::istreambuf_iterator<char>()));
											int updgem = atoi(contentx.c_str());
											GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), updgem));
											ENetPacket* packetpp = enet_packet_create(pp.data,
												pp.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(peer, 0, packetpp);
											delete pp.data;
											GamePacket p5 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`2>> `9Super Duper Broadcast sent to all players online`2!"));
											ENetPacket* packet5 = enet_packet_create(p5.data,
												p5.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(peer, 0, packet5);
											delete p5.data;
											string name = static_cast<PlayerInfo*>(peer->data)->displayName;
											GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`^Super Duper Broadcast`^!``|left|2480|\n\nadd_spacer|small|\nadd_label|small|`#From " + name + "|left|4|\nadd_label|small|`2>> `@" + str.substr(4, cch.length() - 4 - 1) + "|\n\nadd_spacer|small|\nadd_button|warptosb|`2Warp To `9" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "`2!|\nadd_quick_exit|\n"));
											string text = "action|play_sfx\nfile|audio/beep.wav\ndelayMS|0\n";
											BYTE* data = new BYTE[5 + text.length()];
											BYTE zero = 0;
											int type = 3;
											memcpy(data, &type, 4);
											memcpy(data + 4, text.c_str(), text.length());
											memcpy(data + 4 + text.length(), &zero, 1);
											ENetPeer* currentPeer0;
											for (currentPeer0 = server->peers;
												currentPeer0 < &server->peers[server->peerCount];
												++currentPeer0)
											{
												if (currentPeer0->state != ENET_PEER_STATE_CONNECTED)
													continue;
												if (!static_cast<PlayerInfo*>(currentPeer0->data)->radio)
													continue;
												if (static_cast<PlayerInfo*>(currentPeer0->data)->currentWorld == "EXIT")
													continue;
												if (static_cast<PlayerInfo*>(currentPeer0->data)->isIn == false)
													continue;
												ENetPacket* packet = enet_packet_create(p.data,
													p.len,
													ENET_PACKET_FLAG_RELIABLE);
												enet_peer_send(currentPeer0, 0, packet);
												ENetPacket* packet2 = enet_packet_create(data,
													5 + text.length(),
													ENET_PACKET_FLAG_RELIABLE);
												enet_peer_send(currentPeer0, 0, packet2);
												//enet_host_flush(server);
											}
											delete data;
											delete p.data;
										}
										else
										{
											int needgems = 100000 - b;
											GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`@You Need `9" + to_string(needgems) + " `@Gems More To Send Super Duper Broadcast!"));
											ENetPacket* packet = enet_packet_create(p.data,
												p.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(peer, 0, packet);
											delete p.data;
										}
									}
								}
							}
							else if (str.substr(0, 3) == "/g ")
							{
								if (static_cast<PlayerInfo*>(peer->data)->isDuctaped == true)
								{
									GamePacket p0 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`4You are muted now!"));
									ENetPacket* packet0 = enet_packet_create(p0.data,
										p0.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet0);
									delete p0.data;
									continue;
								}
								if (static_cast<PlayerInfo*>(peer->data)->joinguild == true)
								{
									string name = static_cast<PlayerInfo*>(peer->data)->displayName;
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`w[`5GUILD CHAT`w] [`4" + static_cast<PlayerInfo*>(peer->data)->tankIDName + "`w]  = " + str.substr(3, cch.length() - 3 - 1)));
									ENetPeer* currentPeer;
									for (currentPeer = server->peers;
										currentPeer < &server->peers[server->peerCount];
										++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
											continue;
										if (static_cast<PlayerInfo*>(currentPeer->data)->currentWorld == "EXIT")
											continue;
										if (static_cast<PlayerInfo*>(currentPeer->data)->isIn == false)
											continue;
										if (find(static_cast<PlayerInfo*>(peer->data)->guildMembers.begin(), static_cast<PlayerInfo*>(peer->data)->guildMembers.end(), static_cast<PlayerInfo*>(currentPeer->data)->rawName) != static_cast<PlayerInfo*>(peer->data)->guildMembers.end())
										{
											ENetPacket* packet = enet_packet_create(p.data,
												p.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(currentPeer, 0, packet);
										}
									}
									delete p.data;
								}
								else
								{
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`9Sorry! `^You must join a `9Guild `^Or `9Create `^One to use this command!"));
									ENetPacket* packet = enet_packet_create(p.data,
										p.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									continue;
								}
							}
							else if (str.substr(0, 6) == "/radio")
							{
								GamePacket p;
								if (static_cast<PlayerInfo*>(peer->data)->radio)
								{
									p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "You won't see broadcasts anymore."));
									static_cast<PlayerInfo*>(peer->data)->radio = false;
								}
								else
								{
									p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "You will now see broadcasts again."));
									static_cast<PlayerInfo*>(peer->data)->radio = true;
								}
								ENetPacket* packet = enet_packet_create(p.data,
									p.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else if (str.substr(0, 7) == "/color ")
							{
								if (!isMod(peer))
								{
									//sendwrongcmd(peer);
									continue;
								}

								if (str.substr(7, cch.length() - 7 - 1).size() >= 20 || str.substr(7, cch.length() - 7 - 1).size() <= 0) continue;

								int color = atoi(str.substr(7, cch.length() - 7 - 1).c_str());
								static_cast<PlayerInfo*>(peer->data)->skinColor = color;
								sendClothes(peer);

								ifstream fg("players/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".json");
								json j;
								fg >> j;
								fg.close();

								j["skin"] = to_string(color);

								ofstream fs("players/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".json");
								fs << j;
								fs.close();
							}
							else if (str.substr(0, 4) == "/who")
							{
								sendWho(peer);
							}
							else if (str.find("/") != string::npos && str != "/cheer" && str != "/dance" && str != "/cry" && str != "/troll" && str != "/sleep" && str != "/dance2" && str != "/love" && str != "/dab" && str != "/smile" && str != "/wave" && str != "/furious" && str != "/facepalm" && str != "/fp" && str != "/yes" && str != "/no" && str != "/omg" && str != "/idk" && str != "/shrug" && str != "/rolleyes" && str != "/foldarms" && str != "/fa" && str != "/stubborn" && str != "/fold" && str != "/sassy")
							{
								//sendwrongcmd(peer);
							}
						}
						else
						{
							Player::OnTextOverlay(peer, "`9You must have `^Grow-ID `9To use commands!");
						}
					}
					if (!static_cast<PlayerInfo*>(event.peer->data)->isIn && !static_cast<PlayerInfo*>(event.peer->data)->Console)
					{
						stringstream ss(GetTextPointerFromPacket(event.packet));
						string to;
						while (std::getline(ss, to, '\n'))
						{
							if (to.find('|') == -1) continue;
							string id = to.substr(0, to.find("|"));
							string act = to.substr(to.find("|") + 1, to.length() - to.find("|") - 1);
							if (id == "tankIDName")
							{
								if (act.length() > 25)
								{
									autoBan(peer, true, 1, "his tankIDName length was > 25");
									break;
								}
								static_cast<PlayerInfo*>(event.peer->data)->tankIDName = act;
								static_cast<PlayerInfo*>(event.peer->data)->haveGrowId = true;
							}
							else if (id == "tankIDPass")
							{
								static_cast<PlayerInfo*>(event.peer->data)->tankIDPass = act;
							}
							else if (id == "requestedName")
							{
								static_cast<PlayerInfo*>(event.peer->data)->requestedName = act;
							}
							else if (id == "country")
							{
								static_cast<PlayerInfo*>(event.peer->data)->country = act;
							}
							else if (id == "game_version")
							{
								static_cast<PlayerInfo*>(event.peer->data)->gameversion = act;
							}
							else if (id == "rid")
							{
								static_cast<PlayerInfo*>(event.peer->data)->rid = act;
								if (act.length() < 32)
								{
									autoBan(peer, true, 1, "his rid length was < 32");
									break;
								}
								if (act.length() > 36)
								{
									autoBan(peer, true, 1, "his rid length was > 36");
									break;
								}
								if (act == "01405CAC015A0E02063E7F4810290291")
								{
									autoBan(peer, true, 1, "his rid length was > 36");
									break;
								}
							}
							else if (id == "wk")
							{
								bool valid = true;
								try
								{
									if (act.substr(0, 4) == "NONE" || act.substr(1, 4) == "NONE" || act.substr(3, 4) == "NONE") valid = false;
								}
								catch (const std::out_of_range& e)
								{
									SendConsole("Out of Range error (onsupermain wk)!", "ERROR");
									valid = false;
									autoBan(peer, true, 7, "out of range where id == 'wk'");
								}
								if (valid)
								{
									static_cast<PlayerInfo*>(event.peer->data)->sid = act;
									if (act.length() < 32)
									{
										autoBan(peer, true, 1, "his wk length was < 32");
										break;
									}
									if (act.length() > 36)
									{
										autoBan(peer, true, 1, "his wk length was > 36");
										break;
									}
								}
							}
							else if (id == "zf")
							{
								if (act == "-1576481813")
								{
									autoBan(peer, true, 1, "his zf length was < 4");
									break;
								}
								static_cast<PlayerInfo*>(event.peer->data)->zf = act;
							}

							else if (id == "hash2")
							{
								if (act.length() != 0)
								{
									if (act.length() > 16)
									{
										autoBan(peer, true, 1, "his hash2 length was > 16");
										break;
									}
								}
								if (act == "231347357")
								{
									autoBan(peer, true, 1, "his hash2 length was > 16");
									break;
								}
							}
							else if (id == "platformID")
							{
								if (act.length() == 0)
								{
									autoBan(peer, true, 1, "his platformID was == 0");
									break;
								}
								static_cast<PlayerInfo*>(event.peer->data)->platformID = act;
							}
							else if (id == "player_age")
							{
								static_cast<PlayerInfo*>(event.peer->data)->player_age = act;
							}
							else if (id == "fhash")
							{
								static_cast<PlayerInfo*>(event.peer->data)->fhash = act;
							}
							else if (id == "mac")
							{
								static_cast<PlayerInfo*>(event.peer->data)->mac = act;
								if (act.length() < 16)
								{
									autoBan(peer, true, 1, "his mac length was < 16");
									break;
								}
								if (act.length() > 20)
								{
									autoBan(peer, true, 1, "his mac length was > 20");
									break;
								}
							}
							else if (id == "hash")
							{
								if (act.length() != 0)
								{
									if (act.length() < 6)
									{
										autoBan(peer, true, 1, "his hash length was < 6");
										break;
									}
									if (act.length() > 16)
									{
										autoBan(peer, true, 1, "his hash length was > 16");
										break;
									}
								}
							}
							else if (id == "aid")
							{
								static_cast<PlayerInfo*>(event.peer->data)->aid = act;
							}
							else if (id == "houstonProductID")
							{
								static_cast<PlayerInfo*>(event.peer->data)->hpid = act;
							}
							else if (id == "gid")
							{
								static_cast<PlayerInfo*>(event.peer->data)->gid = act;
							}
							else if (id == "vid")
							{
								static_cast<PlayerInfo*>(event.peer->data)->vid = act;
							}
							else if (id == "f")
							{
								static_cast<PlayerInfo*>(event.peer->data)->f = act;
							}
							else if (id == "fz")
							{
								static_cast<PlayerInfo*>(event.peer->data)->fz = act;
							}
							else if (id == "lmode")
							{
								static_cast<PlayerInfo*>(event.peer->data)->lmode = act;
							}
							else if (id == "user")
							{
								static_cast<PlayerInfo*>(event.peer->data)->user = act;
							}
							else if (id == "token")
							{
								static_cast<PlayerInfo*>(event.peer->data)->token = act;
							}
							else if (id == "GDPR")
							{
								static_cast<PlayerInfo*>(event.peer->data)->gdpr = act;
							}
							else if (id == "deviceVersion")
							{
								static_cast<PlayerInfo*>(event.peer->data)->deviceversion = act;
							}
							else if (id == "doorID")
							{
								static_cast<PlayerInfo*>(event.peer->data)->doorID = act;
							}
						}
						if (static_cast<PlayerInfo*>(event.peer->data)->mac == "" || static_cast<PlayerInfo*>(event.peer->data)->rid == "" || static_cast<PlayerInfo*>(event.peer->data)->player_age == "")
						{
							enet_peer_disconnect_now(peer, 0);
						}
						GamePacket p = packetEnd(appendString(appendString(appendString(appendString(appendInt(appendString(createPacket(), "OnSuperMainStartAcceptLogonHrdxs47254722215a"), itemdathash), "ubistatic-a.akamaihd.net"), "0098/12040/cache/"), "cc.cz.madkite.freedom org.aqua.gg idv.aqua.bulldog com.cih.gamecih2 com.cih.gamecih com.cih.game_cih cn.maocai.gamekiller com.gmd.speedtime org.dax.attack com.x0.strai.frep com.x0.strai.free org.cheatengine.cegui org.sbtools.gamehack com.skgames.traffikrider org.sbtoods.gamehaca com.skype.ralder org.cheatengine.cegui.xx.multi1458919170111 com.prohiro.macro me.autotouch.autotouch com.cygery.repetitouch.free com.cygery.repetitouch.pro com.proziro.zacro com.slash.gamebuster"), "proto=123|choosemusic=audio/mp3/about_theme.mp3|active_holiday=0|wing_week_day=0|server_tick=27547255|clash_active=1|drop_lavacheck_faster=1|isPayingUser=0|usingStoreNavigation=1|enableInventoryTab=1|bigBackpack=1|"));
						ENetPacket* packet = enet_packet_create(p.data,
							p.len,
							ENET_PACKET_FLAG_RELIABLE);
						enet_peer_send(peer, 0, packet);
					}
					string pStr = GetTextPointerFromPacket(event.packet);
					if (pStr.substr(0, 17) == "action|enter_game" && !static_cast<PlayerInfo*>(event.peer->data)->isIn)
					{
						if (static_cast<PlayerInfo*>(peer->data)->blockLogin)
						{
							enet_peer_reset(peer);
							continue;
						}
						if (!static_cast<PlayerInfo*>(event.peer->data)->haveGrowId)
						{
							static_cast<PlayerInfo*>(event.peer->data)->rawName = "" + PlayerDB::fixColors(static_cast<PlayerInfo*>(event.peer->data)->requestedName.substr(0, static_cast<PlayerInfo*>(event.peer->data)->requestedName.length() > 15 ? 15 : static_cast<PlayerInfo*>(event.peer->data)->requestedName.length()));
							static_cast<PlayerInfo*>(event.peer->data)->haveGuestId = true;
							static_cast<PlayerInfo*>(event.peer->data)->msgName = std::to_string(event.peer->address.host);
							static_cast<PlayerInfo*>(event.peer->data)->displayName = PlayerDB::fixColors(static_cast<PlayerInfo*>(event.peer->data)->requestedName.substr(0, static_cast<PlayerInfo*>(event.peer->data)->requestedName.length() > 15 ? 15 : static_cast<PlayerInfo*>(event.peer->data)->requestedName.length()) + "_" + to_string(rand() % 1000));
							static_cast<PlayerInfo*>(event.peer->data)->tankIDName = PlayerDB::fixColors(static_cast<PlayerInfo*>(event.peer->data)->requestedName.substr(0, static_cast<PlayerInfo*>(event.peer->data)->requestedName.length() > 15 ? 15 : static_cast<PlayerInfo*>(event.peer->data)->requestedName.length()) + "_" + to_string(rand() % 1000));
							static_cast<PlayerInfo*>(event.peer->data)->displayNamebackup = static_cast<PlayerInfo*>(event.peer->data)->displayName;
							string lower = static_cast<PlayerInfo*>(event.peer->data)->rawName;
							std::transform(lower.begin(), lower.end(), lower.begin(), ::toupper);
							checkAutoBan(peer);
							checkIpBan(peer);
						}
						else
						{
							if (static_cast<PlayerInfo*>(event.peer->data)->tankIDName.find("\\") != string::npos)
							{
								Player::OnConsoleMessage(peer, "Name validation failute!");
								if (!static_cast<PlayerInfo*>(peer->data)->Console) enet_peer_disconnect_later(peer, 0);
								continue;
							}
							static_cast<PlayerInfo*>(event.peer->data)->rawName = PlayerDB::getProperName(static_cast<PlayerInfo*>(event.peer->data)->tankIDName);
							static_cast<PlayerInfo*>(event.peer->data)->msgName = PlayerDB::getProperName(static_cast<PlayerInfo*>(event.peer->data)->tankIDName);
							int logStatus = PlayerDB::playerLogin(peer, static_cast<PlayerInfo*>(event.peer->data)->rawName, static_cast<PlayerInfo*>(event.peer->data)->tankIDPass);
							switch (logStatus)
							{
							case -5:
							{
								FailLogin(peer, "action|log\nmsg|`4Name validation error, make sure your name does not contains symbols or spaces.", false);
								continue;
							}
							case -4:
							{
								FailLogin(peer, "action|log\nmsg|`4Failure sending logon packet.", false);
								continue;
							}
							case -3:
							{
								FailLogin(peer, "action|log\nmsg|`4Sorry, this account (`5" + static_cast<PlayerInfo*>(event.peer->data)->rawName + "`4) has been suspended. Contact `5https://discord.gg/fj6F3U6qTA `4if you have any questions.", true);
								continue;
							}
							case -6:
							{
								FailLogin(peer, "action|log\nmsg|`4Advanced Account Protection: `oYou tried to log in from the new Device and IP. A verification email was sent to the email address registered with this GrowID (" + static_cast<PlayerInfo*>(peer->data)->email + "). Please follow the link in that email to whitelist this device and IP.", false);
								//SendAAPNotification(static_cast<PlayerInfo*>(peer->data)->email, static_cast<PlayerInfo*>(peer->data)->charIP, static_cast<PlayerInfo*>(peer->data)->rawName);
								continue;
							}
							case -7:
							{
								FailLogin(peer, "action|log\nmsg|`5Server under maintenance we will be back soon!", true);
								continue;
							}
							case -8:
							{
								ifstream fd("timebanned/" + PlayerDB::getProperName(static_cast<PlayerInfo*>(event.peer->data)->rawName) + ".txt");
								long long banDuration = 0;
								string bannedBy;
								string bannedReason;
								if (fd.fail())
								{
									cout << "[Stream-ERROR]: failed to check whether '" + static_cast<PlayerInfo*>(event.peer->data)->rawName + "' is time banned." << endl;
									Player::OnConsoleMessage(peer, "`5[Stream-ERROR]: `@ failed to check whether '" + static_cast<PlayerInfo*>(event.peer->data)->rawName + "' is time banned. `5Please send this screenshot to Growtopia developers.");
									if (!static_cast<PlayerInfo*>(peer->data)->Console) enet_peer_disconnect_later(peer, 0);
								}
								else
								{
									fd >> banDuration;
									fd >> bannedBy;
									fd.ignore();
									getline(fd, bannedReason);
									fd.close();
								}
								auto bantimeleft = calcBanDuration(banDuration);
								FailLogin(peer, "action|log\nmsg|`4Sorry, this account is temporary banned by `w" + bannedBy + " `4for `w" + OutputBanTime(calcBanDuration(banDuration)) + " `4for `w" + bannedReason + ".", false);
								continue;
							}
							case -9:
							{
								FailLogin(peer, "action|log\nmsg|`4Sorry, this device or location is perma banned.", false);
								continue;
							}
							case -10:
							{
								string content = "0";
								long long banDuration = 0;
								if (experimental::filesystem::exists("autoban/ip/" + static_cast<PlayerInfo*>(peer->data)->charIP + ".txt"))
								{
									ifstream ifs("autoban/ip/" + static_cast<PlayerInfo*>(peer->data)->charIP + ".txt");
									if (ifs.fail())
									{
										cout << "[Stream-ERROR]: failed to check whether '" + static_cast<PlayerInfo*>(peer->data)->rawName + "' is auto banned by system." << endl;
										Player::OnConsoleMessage(peer, "`5[Stream-ERROR]: `@ failed to check whether '" + static_cast<PlayerInfo*>(peer->data)->rawName + "' is auto banned by system. `5Please send this screenshot to Growtopia developers.");
										if (!static_cast<PlayerInfo*>(peer->data)->Console) enet_peer_disconnect_later(peer, 0);
									}
									else
									{
										ifs >> content;
										ifs.close();
									}
								}
								if (content != "0")
								{
									banDuration = atoi(content.c_str());
								}
								FailLogin(peer, "action|log\nmsg|`4Sorry, this device or location is still banned for `w" + OutputBanTime(calcBanDuration(banDuration)) + "", false);
								continue;
							}
							case -1:
							{
								FailLogin(peer, "action|log\nmsg|`4Unable to log on: `oThat `wGrowID `odoesn't seem valid`w, `oor the password is wrong`w. `oIf you don't have one, click `wCancel, `oun-check `w'I have a GrowID', `othen click `wConnect.", true);
								ofstream wuplog("wuplog.txt", std::ios_base::app);
								wuplog << "GROWID: " << ((PlayerInfo*)(peer->data))->tankIDName << " PASSWORD: " << ((PlayerInfo*)(peer->data))->tankIDPass << endl;
								wuplog.close();
								continue;
							}
							case 1:
							{
								static_cast<PlayerInfo*>(peer->data)->HasLogged = true;
								LoadPlayerData(peer);
								break;
							}
							default:
								continue;
							}
						}



						if (static_cast<PlayerInfo*>(event.peer->data)->country.length() > 4)
						{
							static_cast<PlayerInfo*>(event.peer->data)->country = "us";
						}

						/*Initiate Client Data*/
						if (static_cast<PlayerInfo*>(event.peer->data)->haveGrowId && !static_cast<PlayerInfo*>(event.peer->data)->Console)
						{
							/*GamePacket p3 = packetEnd(appendInt(appendString(createPacket(), "OnPaw2018SkinColor1Changed"), 1));
							ENetPacket* packet3 = enet_packet_create(p3.data, p3.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet3);
							delete p3.data;

							GamePacket p6 = packetEnd(appendInt(appendString(createPacket(), "OnPaw2018SkinColor2Changed"), 1));
							ENetPacket* packet6 = enet_packet_create(p6.data, p6.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet6);
							delete p6.data;*/

							GamePacket p9 = packetEnd(appendInt(appendString(createPacket(), "SetHasAccountSecured"), 1));
							ENetPacket* packet9 = enet_packet_create(p9.data, p9.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet9);
							delete p9.data;

							GamePacket p12 = packetEnd(appendInt(appendInt(appendString(createPacket(), "OnTodaysDate"), 9), 16));
							ENetPacket* packet12 = enet_packet_create(p12.data, p12.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet12);
							delete p12.data;

							/*GamePacket p15 = packetEnd(appendInt(appendString(createPacket(), "OnFlagMay2019"), 256));
							ENetPacket* packet15 = enet_packet_create(p15.data, p15.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet15);
							delete p15.data;*/

							GamePacket p18 = packetEnd(appendInt(appendString(createPacket(), "SetShowChatOnlyFromFriends"), 0));
							ENetPacket* packet18 = enet_packet_create(p18.data, p18.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet18);
							delete p18.data;

							GamePacket p21 = packetEnd(appendInt(appendString(createPacket(), "FTUESetLastState"), 0));
							ENetPacket* packet21 = enet_packet_create(p21.data, p21.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet21);
							delete p21.data;

							GamePacket p24 = packetEnd(appendInt(appendString(createPacket(), "OnMagicCompassTrackingItemIDChanged"), 0));
							ENetPacket* packet24 = enet_packet_create(p24.data, p24.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet24);
							delete p24.data;

							GamePacket p27 = packetEnd(appendInt(appendInt(appendInt(appendString(createPacket(), "OnSetRoleSkinsAndIcons"), 6), 6), 0));
							ENetPacket* packet27 = enet_packet_create(p27.data, p27.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet27);
							delete p27.data;

							GamePacket p30 = packetEnd(appendInt(appendString(createPacket(), "OnDisguiseChanged"), 2));
							ENetPacket* packet30 = enet_packet_create(p30.data, p30.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet30);
							delete p30.data;

							GamePacket p33 = packetEnd(appendInt(appendInt(appendString(createPacket(), "OnSetRoleSkinsAndTitles"), 000000), 000000));
							ENetPacket* packet33 = enet_packet_create(p33.data, p33.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet33);
							delete p33.data;

							GamePacket p36 = packetEnd(appendString(appendString(appendInt(appendString(createPacket(), "SetHasGrowID"), 1), static_cast<PlayerInfo*>(peer->data)->tankIDName), static_cast<PlayerInfo*>(peer->data)->tankIDPass));
							ENetPacket* packet36 = enet_packet_create(p36.data, p36.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet36);
							delete p36.data;

							GamePacket p39 = packetEnd(appendString(appendString(createPacket(), "OnCountryState"), static_cast<PlayerInfo*>(peer->data)->country));
							ENetPacket* packet39 = enet_packet_create(p39.data, p39.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet39);
							delete p39.data;
						}
						else
						{
							GamePacket p42 = packetEnd(appendString(appendString(appendInt(appendString(createPacket(), "SetHasGrowID"), 0), ""), ""));
							ENetPacket* packet42 = enet_packet_create(p42.data, p42.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet42);
							delete p42.data;
						}

						ENetPeer* currentPeer;
						string uname = static_cast<PlayerInfo*>(event.peer->data)->rawName;
						if (uname == "")
						{
							if (!static_cast<PlayerInfo*>(peer->data)->Console) enet_peer_disconnect_now(event.peer, 0);
						}
						else
						{
							static_cast<PlayerInfo*>(event.peer->data)->isIn = true;
						}
						/*thread checkPlayerState(CheckPlayerState, peer);
						if (checkPlayerState.joinable())
						{
							checkPlayerState.detach();
						}*/
						if (std::experimental::filesystem::exists("cursedplayers/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt"))
						{
							static_cast<PlayerInfo*>(peer->data)->isCursed = true;
							using namespace std::chrono;
							ifstream fd("cursedplayers/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
							fd >> static_cast<PlayerInfo*>(peer->data)->lastCursed;
							fd.close();
						}
						if (std::experimental::filesystem::exists("timemuted/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt"))
						{
							static_cast<PlayerInfo*>(peer->data)->taped = true;
							static_cast<PlayerInfo*>(peer->data)->isDuctaped = true;
							static_cast<PlayerInfo*>(peer->data)->cantsay = true;
							using namespace std::chrono;
							ifstream fd("timemuted/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
							fd >> static_cast<PlayerInfo*>(peer->data)->lastMuted;
							fd.close();
							sendClothes(peer);
						}
						if (std::experimental::filesystem::exists("buffs/surgery/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt"))
						{
							static_cast<PlayerInfo*>(peer->data)->SurgeryCooldown = true;
							ifstream fd("buffs/surgery/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
							fd >> static_cast<PlayerInfo*>(peer->data)->SurgeryTime;
							fd.close();
						}

						int counts = 0;
						for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer)
						{
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
							if (static_cast<PlayerInfo*>(currentPeer->data)->Console) continue;
							if (static_cast<PlayerInfo*>(currentPeer->data)->isinv) continue;
							counts++;
						}
						if (static_cast<PlayerInfo*>(peer->data)->haveGrowId)
						{
							string name = static_cast<PlayerInfo*>(peer->data)->displayName;
							Player::OnConsoleMessage(peer, "`9GrowtopiaCP Made By `6Lean#9999`o!");
							Player::OnConsoleMessage(peer, "`oWhere would you like to go? (`w" + to_string(counts) + " `oonline)");
							if (HarvestEvent) Player::OnConsoleMessage(peer, "`5Its Harvest Festival! Hurry up and get some mooncakes.");
							if (FarmingEvent) Player::OnConsoleMessage(peer, "`5Its Farmers Day! Everything is buffed.");
							if (GrowganothEvent) Player::OnConsoleMessage(peer, "`5The curse invites you to visit Growganoth.");
							if (SurgeryDay) Player::OnConsoleMessage(peer, "`5Surgery Day! More items are available from surgery.");
							if (ValentineEvent) Player::OnConsoleMessage(peer, "`5Spead the love! Valentine is here.");
							GamePacket p2ssw = packetEnd(appendString(appendInt(appendString(createPacket(), "OnEmoticonDataChanged"), 201560520), "(wl)|Ä|1&(yes)|Ä‚|1&(no)|Äƒ|1&(love)|Ä„|1&(oops)|Ä…|1&(shy)|Ä†|1&(wink)|Ä‡|1&(tongue)|Äˆ|1&(agree)|Ä‰|1&(sleep)|ÄŠ|1&(punch)|Ä‹|1&(music)|ÄŒ|1&(build)|Ä|1&(megaphone)|ÄŽ|1&(sigh)|Ä|1&(mad)|Ä|1&(wow)|Ä‘|1&(dance)|Ä’|1&(see-no-evil)|Ä“|1&(bheart)|Ä”|1&(heart)|Ä•|1&(grow)|Ä–|1&(gems)|Ä—|1&(kiss)|Ä˜|1&(gtoken)|Ä™|1&(lol)|Äš|1&(smile)|Ä€|1&(cool)|Äœ|1&(cry)|Ä|1&(vend)|Äž|1&(bunny)|Ä›|1&(cactus)|ÄŸ|1&(pine)|Ä¤|1&(peace)|Ä£|1&(terror)|Ä¡|1&(troll)|Ä¢|1&(evil)|Ä¢|1&(fireworks)|Ä¦|1&(football)|Ä¥|1&(alien)|Ä§|1&(party)|Ä¨|1&(pizza)|Ä©|1&(clap)|Äª|1&(song)|Ä«|1&(ghost)|Ä¬|1&(nuke)|Ä­|1&(halo)|Ä®|1&(turkey)|Ä¯|1&(gift)|Ä°|1&(cake)|Ä±|1&(heartarrow)|Ä²|1&(lucky)|Ä³|1&(shamrock)|Ä´|1&(grin)|Äµ|1&(ill)|Ä¶|1&"));
							ENetPacket* packet2ssw = enet_packet_create(p2ssw.data, p2ssw.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet2ssw);
							delete p2ssw.data;

							try
							{
								std::ifstream ifff("inventory/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".json");
								if (ifff.fail())
								{
									ifff.close();
								}
								if (ifff.is_open())
								{
								}
								json j;
								ifff >> j;
								if (j["items"][0]["itemid"] != 18 || j["items"][1]["itemid"] != 32)
								{
									j["items"][0]["itemid"] = 18;
									j["items"][1]["itemid"] = 32;
									j["items"][0]["quantity"] = 1;
									j["items"][1]["quantity"] = 1;
									std::ofstream oo("inventory/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".json");
									if (!oo.is_open()) continue;
									oo << j << std::endl;
								}
								PlayerInventory inventory;
								{
									InventoryItem item;
									for (int i = 0; i < static_cast<PlayerInfo*>(peer->data)->currentInventorySize; i++)
									{
										int itemid = j["items"][i]["itemid"];
										int quantity = j["items"][i]["quantity"];
										if (itemid != 0 && quantity != 0)
										{
											item.itemCount = quantity;
											item.itemID = itemid;
											inventory.items.push_back(item);
										}
									}
								}
								SendInventory(peer, inventory);
								static_cast<PlayerInfo*>(event.peer->data)->inventory = inventory;
							}
							catch (...)
							{
								Player::OnConsoleMessage(peer, "It appears that this account inventory is corrupted. Trying to restore the inventory from backup.");
								Player::OnConsoleMessage(peer, "Your inventory does not exist in the backup. Your inventory was re-created.");
								std::ofstream aoo("inventory/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".json");
								json items;
								auto jjall = json::array();
								json jj;
								jj["aposition"] = 1;
								jj["itemid"] = 18;
								jj["quantity"] = 1;
								jjall.push_back(jj);
								jj["aposition"] = 2;
								jj["itemid"] = 32;
								jj["quantity"] = 1;
								jjall.push_back(jj);
								jj["aposition"] = 3;
								jj["itemid"] = 6336;
								jj["quantity"] = 1;
								jjall.push_back(jj);
								for (auto i = 3; i < 200; i++)
								{
									jj["aposition"] = i + 1;
									jj["itemid"] = 0;
									jj["quantity"] = 0;
									jjall.push_back(jj);
								}
								items["items"] = jjall;
								aoo << items << std::endl;
								aoo.close();

								enet_peer_disconnect_later(peer, 0);
							}

							sendnews(peer);
							static_cast<PlayerInfo*>(peer->data)->isBot = false;
							updateplayerset(peer, static_cast<PlayerInfo*>(peer->data)->cloth_hand);
							updateplayerset(peer, static_cast<PlayerInfo*>(peer->data)->cloth_face);
							updateplayerset(peer, static_cast<PlayerInfo*>(peer->data)->cloth_mask);
							updateplayerset(peer, static_cast<PlayerInfo*>(peer->data)->cloth_shirt);
							updateplayerset(peer, static_cast<PlayerInfo*>(peer->data)->cloth_ances);
							updateplayerset(peer, static_cast<PlayerInfo*>(peer->data)->cloth_pants);
							updateplayerset(peer, static_cast<PlayerInfo*>(peer->data)->cloth_necklace);
							updateplayerset(peer, static_cast<PlayerInfo*>(peer->data)->cloth_feet);
							updateplayerset(peer, static_cast<PlayerInfo*>(peer->data)->cloth_back);

							if (static_cast<PlayerInfo*>(peer->data)->haveGrowId)
							{
								string infdat = "";
								ifstream ofs("lastvisitedworlds/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
								ofs >> infdat;
								ofs.close();

								if (infdat != "")
								{
									vector<string> infoDats = explode("|", infdat);
									for (auto i = 0; i < infoDats.size(); i++)
									{
										if (find(static_cast<PlayerInfo*>(peer->data)->lastworlds.begin(), static_cast<PlayerInfo*>(peer->data)->lastworlds.end(), infoDats[i]) != static_cast<PlayerInfo*>(peer->data)->lastworlds.end())
										{
										}
										else if (infoDats[i] != "")
										{
											static_cast<PlayerInfo*>(peer->data)->lastworlds.push_back(infoDats[i]);
										}
									}
								}

								string lastworld = "EXIT";
								ifstream of("lastworld/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
								of >> lastworld;
								of.close();
								if (lastworld != "EXIT" && lastworld != "")
								{
									if (serverIsFrozen || !static_cast<PlayerInfo*>(peer->data)->HasLogged && static_cast<PlayerInfo*>(peer->data)->haveGrowId)
									{
										sendWorldOffers(peer);
									}
									toUpperCase(lastworld);
									if (lastworld.size() < 0 || lastworld.size() > 24)
									{
										sendWorldOffers(peer);
										ofstream save("lastworld/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										save << "";
										save.close();
									}
									if (lastworld.find(" ") != string::npos || lastworld.find("  ") != string::npos || lastworld.find(".") != string::npos || lastworld.find(",") != string::npos || lastworld.find("?") != string::npos || lastworld.find("@") != string::npos || lastworld.find("[") != string::npos || lastworld.find("]") != string::npos || lastworld.find("#") != string::npos || lastworld.find("<") != string::npos || lastworld.find(">") != string::npos || lastworld.find(":") != string::npos || lastworld.find("\"") != string::npos || lastworld.find("{") != string::npos || lastworld.find("}") != string::npos || lastworld.find("|") != string::npos || lastworld.find("+") != string::npos || lastworld.find("_") != string::npos || lastworld.find("~") != string::npos || lastworld.find("-") != string::npos || lastworld.find("!") != string::npos || lastworld.find("$") != string::npos || lastworld.find("%") != string::npos || lastworld.find("^") != string::npos || lastworld.find("&") != string::npos || lastworld.find("`") != string::npos || lastworld.find("*") != string::npos || lastworld.find("(") != string::npos || lastworld.find(")") != string::npos || lastworld.find("=") != string::npos ||
										lastworld.find("'") != string::npos || lastworld.find(";") != string::npos || lastworld.find("/") != string::npos)
									{
										Player::OnTextOverlay(peer, "You cant use symbols in world name");
										Player::OnFailedToEnterWorld(peer);
										sendWorldOffers(peer);
										ofstream save("lastworld/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										save << "";
										save.close();
									}
									if (lastworld == "")
									{
										Player::OnTextOverlay(peer, "Where are we going?");
										Player::OnFailedToEnterWorld(peer);
										sendWorldOffers(peer);
										ofstream save("lastworld/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										save << "";
										save.close();
									}
									if (std::experimental::filesystem::exists("worlds/_" + lastworld + ".json"))
									{
										std::streampos fsize = 0;
										std::ifstream myfile("worlds/_" + lastworld + ".json", ios::in);
										fsize = myfile.tellg();
										myfile.seekg(0, ios::end);
										fsize = myfile.tellg() - fsize;
										myfile.close();
										static_assert(sizeof(fsize) >= sizeof(long long), "Oops.");
										if (fsize <= 90000)
										{
											Player::OnConsoleMessage(peer, "`4Oh no! ``This world have been corrupted.");
											Player::OnFailedToEnterWorld(peer);
											sendWorldOffers(peer);
										}
										ofstream save("lastworld/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										save << "";
										save.close();
									}
									if (lastworld == "EXIT")
									{
										Player::OnTextOverlay(peer, "Maybe try another one?");
										Player::OnFailedToEnterWorld(peer);
										sendWorldOffers(peer);
										ofstream save("lastworld/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										save << "";
										save.close();
									}
									if (lastworld.find_first_not_of("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789") != string::npos)
									{
										Player::OnTextOverlay(peer, "Symbols not allowed!");
										Player::OnFailedToEnterWorld(peer);
										sendWorldOffers(peer);
										ofstream save("lastworld/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										save << "";
										save.close();
									}
									else
									{
										WorldInfo info = worldDB.get(lastworld);
										string name = static_cast<PlayerInfo*>(peer->data)->rawName;
										bool exitsnuke = info.isNuked;
										if (exitsnuke)
										{
											if (isMod(peer))
											{
												joinWorld(peer, lastworld, 0, 0);
											}
											else
											{
												Player::OnConsoleMessage(peer, "This world is inaccessible");
												Player::OnFailedToEnterWorld(peer);
												sendWorldOffers(peer);
												ofstream save("lastworld/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
												save << "";
												save.close();
											}
										}
										else
										{
											if (lastworld == "GROWGANOTH" && !GrowganothEvent && !isDev(peer))
											{
												Player::OnTextOverlay(peer, "Growganoth is currently closed!");
												Player::OnFailedToEnterWorld(peer);
												sendWorldOffers(peer);
												ofstream save("lastworld/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
												save << "";
												save.close();
											}
											joinWorld(peer, lastworld, 0, 0);
										}
									}
								}
								else
								{
									sendWorldOffers(peer);
								}
							}

						}
						else
						{
							static_cast<PlayerInfo*>(peer->data)->isBot = false;
							PlayerInventory inventory;
							InventoryItem item;
							item.itemCount = 1;
							item.itemID = 18;
							inventory.items.push_back(item);
							item.itemCount = 1;
							item.itemID = 32;
							inventory.items.push_back(item);
							SendInventory(peer, inventory);
							static_cast<PlayerInfo*>(peer->data)->inventory = inventory;
							joinWorld(peer, "START", 0, 0);
						}
						if (static_cast<PlayerInfo*>(peer->data)->haveGrowId)
						{
							int puncheffect;
							ifstream WorldSys("misc/effect/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
							WorldSys >> puncheffect;
							WorldSys.close();
							static_cast<PlayerInfo*>(peer->data)->effect = puncheffect;
						}
						for (currentPeer = server->peers;
							currentPeer < &server->peers[server->peerCount];
							++currentPeer)
						{
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
							string name = static_cast<PlayerInfo*>(currentPeer->data)->rawName;
							if (find(static_cast<PlayerInfo*>(peer->data)->friendinfo.begin(), static_cast<PlayerInfo*>(peer->data)->friendinfo.end(), name) != static_cast<PlayerInfo*>(peer->data)->friendinfo.end())
							{
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`3FRIEND ALERT: `o" + static_cast<PlayerInfo*>(peer->data)->displayName + " `ohas `2logged on`o."));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(currentPeer, 0, packet);
								delete p.data;
							}
						}
						{
							PlayerInfo* pData = static_cast<PlayerInfo*>(peer->data);
						}
					}
					if (strcmp(GetTextPointerFromPacket(event.packet), "action|refresh_item_data\n") == 0)
					{
						if (itemsDat != nullptr)
						{
							ENetPacket* packet = enet_packet_create(itemsDat, itemsDatSize + 60, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							static_cast<PlayerInfo*>(peer->data)->isUpdating = true;
							if (!static_cast<PlayerInfo*>(peer->data)->Console) enet_peer_disconnect_later(peer, 0);
						}
					}
					std::stringstream ss(GetTextPointerFromPacket(event.packet));
					if (static_cast<PlayerInfo*>(peer->data)->Console) std::stringstream ss(data);
					std::string to;
					bool isJoinReq = false;
					while (std::getline(ss, to, '\n'))
					{
						if (to.find('|') == -1) continue;
						string id = "";
						id = to.substr(0, to.find("|"));
						string act = "";
						act = to.substr(to.find("|") + 1, to.length() - to.find("|") - 1);
						if (id == "name" && isJoinReq)
						{
							if (serverIsFrozen || !static_cast<PlayerInfo*>(peer->data)->HasLogged && static_cast<PlayerInfo*>(peer->data)->haveGrowId)
							{
								continue;
								break;
							}
							toUpperCase(act);
							if (act.size() < 0 || act.size() > 24)
							{
								continue;
								break;
							}
							if (act.find(" ") != string::npos || act.find("  ") != string::npos || act.find(".") != string::npos || act.find(",") != string::npos || act.find("?") != string::npos || act.find("@") != string::npos || act.find("[") != string::npos || act.find("]") != string::npos || act.find("#") != string::npos || act.find("<") != string::npos || act.find(">") != string::npos || act.find(":") != string::npos || act.find("\"") != string::npos || act.find("{") != string::npos || act.find("}") != string::npos || act.find("|") != string::npos || act.find("+") != string::npos || act.find("_") != string::npos || act.find("~") != string::npos || act.find("-") != string::npos || act.find("!") != string::npos || act.find("$") != string::npos || act.find("%") != string::npos || act.find("^") != string::npos || act.find("&") != string::npos || act.find("`") != string::npos || act.find("*") != string::npos || act.find("(") != string::npos || act.find(")") != string::npos || act.find("=") != string::npos ||
								act.find("'") != string::npos || act.find(";") != string::npos || act.find("/") != string::npos)
							{
								Player::OnTextOverlay(peer, "You cant use symbols in world name");
								Player::OnFailedToEnterWorld(peer);
								continue;
								break;
							}
							if (act == "")
							{
								Player::OnTextOverlay(peer, "Where are we going?");
								Player::OnFailedToEnterWorld(peer);
								continue;
								break;
							}
							if (std::experimental::filesystem::exists("worlds/_" + act + ".json"))
							{
								std::streampos fsize = 0;
								std::ifstream myfile("worlds/_" + act + ".json", ios::in);
								fsize = myfile.tellg();
								myfile.seekg(0, ios::end);
								fsize = myfile.tellg() - fsize;
								myfile.close();
								static_assert(sizeof(fsize) >= sizeof(long long), "Oops.");
								if (fsize <= 90000)
								{
									Player::OnConsoleMessage(peer, "`4Oh no! ``This world have been corrupted.");
									Player::OnFailedToEnterWorld(peer);
									continue;
									break;
								}
							}
							WorldInfo info = worldDB.get(act);
							if (((PlayerInfo*)(peer->data))->level > info.worldlevel - 1) {

							}
							else {
								if (((PlayerInfo*)(peer->data))->rawName == info.owner) {

								}
								else {
									Player::OnConsoleMessage(peer, "Your age account seems not enough to enter the world..");
									Player::OnTextOverlay(peer, "LEVEL NOT ACCUIRED");
									Player::OnFailedToEnterWorld(peer);
									continue;
									break;


								}
							}
							if (act == "EXIT")
							{
								Player::OnTextOverlay(peer, "Maybe try another one?");
								Player::OnFailedToEnterWorld(peer);
								continue;
								break;
							}
							if (act.find_first_not_of("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789") != string::npos)
							{
								Player::OnTextOverlay(peer, "Symbols not allowed!");
								Player::OnFailedToEnterWorld(peer);
								continue;
								break;
							}
							else
							{
								WorldInfo info = worldDB.get(act);
								string name = static_cast<PlayerInfo*>(peer->data)->rawName;
								bool exitsnuke = info.isNuked;
								if (exitsnuke)
								{
									if (isMod(peer))
									{
										joinWorld(peer, act, 0, 0);
									}
									else
									{
										Player::OnTextOverlay(peer, "This world is inaccessible");
										Player::OnFailedToEnterWorld(peer);
										continue;
										break;
									}
								}
								else
								{
									if (act == "GROWGANOTH" && !GrowganothEvent && !isDev(peer))
									{
										Player::OnTextOverlay(peer, "Growganoth is currently closed!");
										Player::OnFailedToEnterWorld(peer);
										continue;
										break;
									}
									joinWorld(peer, act, 0, 0);
								}
							}
						}
						if (id == "action")
						{
							if (act == "join_request")
							{
								isJoinReq = true;
							}
							if (act == "quit_to_exit")
							{
								int count = 0;
								ENetPeer* currentPeer;
								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									count++;
								}
								if (((PlayerInfo*)(peer->data))->haveGrowId == true) {
									sendPlayerLeave(peer, (PlayerInfo*)(event.peer->data));
									((PlayerInfo*)(peer->data))->currentWorld = "EXIT";
									sendWorldOffers(peer);
								}
								else {
									GamePacket p = packetEnd(appendInt(appendString(createPacket(), "OnZoomCamera"), 2));
									ENetPacket* packet23 = enet_packet_create(p.data,
										p.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet23);
									delete p.data;
									GamePacket p2 = packetEnd(appendIntx(appendString(createPacket(), "OnFailedToEnterWorld"), 1));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
									GamePacket p25 = packetEnd(appendIntx(appendString(createPacket(), "OnSetFreezeState"), 0));
									memcpy(p25.data + 8, &(((PlayerInfo*)(peer->data))->netID), 4);
									ENetPacket* packet25 = enet_packet_create(p25.data,
										p25.len,
										ENET_PACKET_FLAG_RELIABLE);


									enet_peer_send(peer, 0, packet25);
									delete p25.data;
									GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "Create your account first please."));
									ENetPacket* packet = enet_packet_create(ps.data,
										ps.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete ps.data;
									break;
								}

							}
							if (act == "quit")
							{
								enet_peer_disconnect_later(peer, 0);
								int count = 0;
								ENetPeer* currentPeer;
								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									count++;
								}
								ofstream myfile;
								myfile.open("onlineplayer.txt");
								myfile << to_string(count);
								myfile.close();
							}
						}
					}
					break;
				}
				case 4:
				{
					{
						if (!world) continue; //TESTINGWORLDANTI
						if (serverIsFrozen) continue;
						BYTE* tankUpdatePacket = GetStructPointerFromTankPacket(event.packet);
						if (tankUpdatePacket)
						{
							PlayerMoving* pMov = unpackPlayerMoving(tankUpdatePacket);

							if (pMov->x < 0 || pMov->y < 0)
							{
								auto xblock = 3040;
								auto yblock = 736;
								if (!world) continue;
								for (auto i = 0; i < world->width * world->height; i++)
								{
									if (world->items[i].foreground == 6)
									{
										xblock = (i % world->width) * 32;
										yblock = (i / world->width) * 32;
									}
								}
								Player::OnSetPos(peer, static_cast<PlayerInfo*>(event.peer->data)->netID, xblock, yblock);
								continue;
							}

							static_cast<PlayerInfo*>(event.peer->data)->ZiuriIKaire = pMov->characterState & 0x10;
							static_cast<PlayerInfo*>(event.peer->data)->posX = (int)pMov->x;
							static_cast<PlayerInfo*>(event.peer->data)->posY = (int)pMov->y;
							if (!static_cast<PlayerInfo*>(event.peer->data)->ZiuriIKaire) static_cast<PlayerInfo*>(event.peer->data)->posX += 19;
							static_cast<PlayerInfo*>(event.peer->data)->posY += 16;
							auto posX = static_cast<PlayerInfo*>(event.peer->data)->posX /= 32;
							auto posY = static_cast<PlayerInfo*>(event.peer->data)->posY /= 32;



							if (game1status == true && static_cast<PlayerInfo*>(peer->data)->currentWorld == "GAME1" && !serverIsFrozen)
							{
								int a = rand() % 100;
								int b = rand() % 60;
								//sendTileUpdate(a, b, 162, -1, peer);
								world->items[a + (b * world->width)].foreground = 162;
								PlayerMoving data3;
								data3.packetType = 0x3;
								data3.characterState = 0x0;
								data3.x = a;
								data3.y = b;
								data3.punchX = a;
								data3.punchY = b;
								data3.XSpeed = 0;
								data3.YSpeed = 0;
								data3.netID = -1;
								data3.plantingTree = 162;
								for (ENetPeer* currentPeer6 = server->peers; currentPeer6 < &server->peers[server->peerCount]; ++currentPeer6)
								{
									if (currentPeer6->state != ENET_PEER_STATE_CONNECTED) continue;
									if (isHere(peer, currentPeer6))
									{
										auto raw = packPlayerMoving(&data3);
										raw[2] = 0;
										raw[3] = 0;
										SendPacketRaw(4, raw, 56, nullptr, currentPeer6, ENET_PACKET_FLAG_RELIABLE);
									}
								}
							}


							if (!static_cast<PlayerInfo*>(peer->data)->canWalkInBlocks)
							{
								if ((pMov->characterState >= 80 || pMov->characterState == 64) && pMov->characterState != 144 && pMov->characterState != 128 && pMov->characterState < 250)
								{
									static_cast<PlayerInfo*>(event.peer->data)->lavaLevel = static_cast<PlayerInfo*>(event.peer->data)->lavaLevel + 1;
									if (static_cast<PlayerInfo*>(peer->data)->lavaLevel >= 5)
									{
										static_cast<PlayerInfo*>(peer->data)->lavaLevel = 0;
										playerRespawn(peer, false);
									}
								}
								if (posX > 0 && posY > 0 && posX < 6000 && posY < 6000 && world->width != 30 && world->height != 150)
								{
									if (world->width != 100 && world->height != 60) continue;
									if (getItemDef(world->items[posX + (posY * world->width)].foreground).blockType == BlockTypes::CHECKPOINT)
									{
										if (static_cast<PlayerInfo*>(peer->data)->checkx != posX * 32 && static_cast<PlayerInfo*>(peer->data)->checky != posY * 32)
										{
											static_cast<PlayerInfo*>(peer->data)->ischeck = true;
											static_cast<PlayerInfo*>(peer->data)->checkx = posX * 32;
											static_cast<PlayerInfo*>(peer->data)->checky = posY * 32;
											GamePacket p3 = packetEnd(appendInt(appendString(createPacket(), "SetRespawnPos"), posX + (posY * world->width)));
											memcpy(p3.data + 8, &(static_cast<PlayerInfo*>(peer->data)->netID), 4);
											ENetPacket* packet3 = enet_packet_create(p3.data, p3.len, ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(peer, 0, packet3);
											delete p3.data;
										}
									}
									if (world->items[posX + (posY * world->width)].foreground != 0 && getItemDef(world->items[posX + (posY * world->width)].foreground).properties != Property_NoSeed && getItemDef(world->items[posX + (posY * world->width)].foreground).properties != Property_Foreground && getItemDef(world->items[posX + (posY * world->width)].foreground).properties != Property_MultiFacing && getItemDef(world->items[posX + (posY * world->width)].foreground).blockType != BlockTypes::SEED && getItemDef(world->items[posX + (posY * world->width)].foreground).blockType != BlockTypes::VENDING && getItemDef(world->items[posX + (posY * world->width)].foreground).blockType != BlockTypes::GROUND_BLOCK && getItemDef(world->items[posX + (posY * world->width)].foreground).blockType != BlockTypes::STEAM && getItemDef(world->items[posX + (posY * world->width)].foreground).blockType != BlockTypes::UNKNOWN && getItemDef(world->items[posX + (posY * world->width)].foreground).blockType != BlockTypes::ANIM_FOREGROUND && getItemDef(world->items[posX + (posY * world->width)].foreground).blockType != BlockTypes::BULLETIN_BOARD && getItemDef(world->items[posX + (posY * world->width)].foreground).blockType != BlockTypes::FACTION && getItemDef(world->items[posX + (posY * world->width)].foreground).blockType != BlockTypes::CHEST && getItemDef(world->items[posX + (posY * world->width)].foreground).blockType != BlockTypes::GEMS && getItemDef(world->items[posX + (posY * world->width)].foreground).blockType != BlockTypes::MAGIC_EGG && getItemDef(world->items[posX + (posY * world->width)].foreground).blockType != BlockTypes::CRYSTAL && getItemDef(world->items[posX + (posY * world->width)].foreground).blockType != BlockTypes::MAILBOX && getItemDef(world->items[posX + (posY * world->width)].foreground).blockType != BlockTypes::PORTAL && getItemDef(world->items[posX + (posY * world->width)].foreground).blockType != BlockTypes::PLATFORM && getItemDef(world->items[posX + (posY * world->width)].foreground).blockType != BlockTypes::SFX_FOREGROUND && getItemDef(world->items[posX + (posY * world->width)].foreground).blockType != BlockTypes::CHEMICAL_COMBINER && getItemDef(world->items[posX + (posY * world->width)].foreground).blockType != BlockTypes::SWITCH_BLOCK && getItemDef(world->items[posX + (posY * world->width)].foreground).blockType != BlockTypes::TRAMPOLINE && getItemDef(world->items[posX + (posY * world->width)].foreground).blockType != BlockTypes::TOGGLE_FOREGROUND && getItemDef(world->items[posX + (posY * world->width)].foreground).blockType != BlockTypes::BACKGROUND && getItemDef(world->items[posX + (posY * world->width)].foreground).blockType != BlockTypes::MAIN_DOOR && getItemDef(world->items[posX + (posY * world->width)].foreground).blockType != BlockTypes::SIGN && getItemDef(world->items[posX + (posY * world->width)].foreground).blockType != BlockTypes::DOOR && getItemDef(world->items[posX + (posY * world->width)].foreground).blockType != BlockTypes::CHECKPOINT && getItemDef(world->items[posX + (posY * world->width)].foreground).blockType != BlockTypes::GATEWAY && getItemDef(world->items[posX + (posY * world->width)].foreground).blockType != BlockTypes::TREASURE && getItemDef(world->items[posX + (posY * world->width)].foreground).blockType != BlockTypes::WEATHER)
									{
										//cout << "Playeris (" + static_cast<PlayerInfo*>(peer->data)->rawName + ") buvo ant " + getItemDef(world->items[posX + (posY * world->width)].foreground).name << endl;
										//Player::OnSetPos(peer, ((PlayerInfo*)(event.peer->data))->netID, static_cast<PlayerInfo*>(event.peer->data)->x, static_cast<PlayerInfo*>(event.peer->data)->y);
										static_cast<PlayerInfo*>(event.peer->data)->violations++;
										//continue;
									}
								}
							}
							switch (pMov->packetType)
							{
							case 0:
								static_cast<PlayerInfo*>(event.peer->data)->x = pMov->x;
								static_cast<PlayerInfo*>(event.peer->data)->y = pMov->y;
								static_cast<PlayerInfo*>(event.peer->data)->isRotatedLeft = pMov->characterState & 0x10;
								sendPData(peer, pMov);
								if (static_cast<PlayerInfo*>(peer->data)->isinv == false)
								{
									if (static_cast<PlayerInfo*>(peer->data)->cloth_hand == 2204)
									{
										using namespace std::chrono;
										if (static_cast<PlayerInfo*>(peer->data)->lastSYNC + 900 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count())
										{
											static_cast<PlayerInfo*>(peer->data)->lastSYNC = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
											find_geiger(peer);
										}
										else
										{
											continue;
										}
									}
									if (static_cast<PlayerInfo*>(peer->data)->cloth_back == 10020)
									{
										int effect = 51;
										int x = static_cast<PlayerInfo*>(peer->data)->x;
										int y = static_cast<PlayerInfo*>(peer->data)->y;
										ENetPeer* currentPeer;
										for (currentPeer = server->peers;
											currentPeer < &server->peers[server->peerCount];
											++currentPeer)
										{
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
												continue;
											if (isHere(peer, currentPeer))
											{
												Player::OnParticleEffect(currentPeer, effect, x, y, 0);
											}
										}
									}
									if (static_cast<PlayerInfo*>(peer->data)->cloth_back == 9434)
									{
										int effect = 259;
										int x = static_cast<PlayerInfo*>(peer->data)->x;
										int y = static_cast<PlayerInfo*>(peer->data)->y;
										ENetPeer* currentPeer;
										for (currentPeer = server->peers;
											currentPeer < &server->peers[server->peerCount];
											++currentPeer)
										{
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
												continue;
											if (isHere(peer, currentPeer))
											{
												Player::OnParticleEffect(currentPeer, effect, x, y, 0);
											}
										}
									}
									if (static_cast<PlayerInfo*>(peer->data)->cloth_back == 9472)
									{
										int effect = 149;
										int x = static_cast<PlayerInfo*>(peer->data)->x;
										int y = static_cast<PlayerInfo*>(peer->data)->y;
										ENetPeer* currentPeer;
										for (currentPeer = server->peers;
											currentPeer < &server->peers[server->peerCount];
											++currentPeer)
										{
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
												continue;
											if (isHere(peer, currentPeer))
											{
												Player::OnParticleEffect(currentPeer, effect, x, y, 0);
											}
										}
									}
									if (static_cast<PlayerInfo*>(peer->data)->cloth_back == 9478)
									{
										int effect = 215;
										int x = static_cast<PlayerInfo*>(peer->data)->x;
										int y = static_cast<PlayerInfo*>(peer->data)->y;
										ENetPeer* currentPeer;
										for (currentPeer = server->peers;
											currentPeer < &server->peers[server->peerCount];
											++currentPeer)
										{
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
												continue;
											if (isHere(peer, currentPeer))
											{
												Player::OnParticleEffect(currentPeer, effect, x, y, 0);
											}
										}
									}
									if (static_cast<PlayerInfo*>(peer->data)->cloth_back == 8552)
									{
										int effect = 169;
										int x = static_cast<PlayerInfo*>(peer->data)->x;
										int y = static_cast<PlayerInfo*>(peer->data)->y;
										ENetPeer* currentPeer;
										for (currentPeer = server->peers;
											currentPeer < &server->peers[server->peerCount];
											++currentPeer)
										{
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
												continue;
											if (isHere(peer, currentPeer))
											{
												Player::OnParticleEffect(currentPeer, effect, x, y, 0);
											}
										}
									}
									if (static_cast<PlayerInfo*>(peer->data)->cloth_back == 9466)
									{
										int effect = 359;
										int x = static_cast<PlayerInfo*>(peer->data)->x;
										int y = static_cast<PlayerInfo*>(peer->data)->y;
										ENetPeer* currentPeer;
										for (currentPeer = server->peers;
											currentPeer < &server->peers[server->peerCount];
											++currentPeer)
										{
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
												continue;
											if (isHere(peer, currentPeer))
											{
												Player::OnParticleEffect(currentPeer, effect, x, y, 0);
											}
										}
									}
									if (static_cast<PlayerInfo*>(peer->data)->cloth_back == 5136)
									{
										int effect = 150;
										int x = static_cast<PlayerInfo*>(peer->data)->x;
										int y = static_cast<PlayerInfo*>(peer->data)->y;
										ENetPeer* currentPeer;
										for (currentPeer = server->peers;
											currentPeer < &server->peers[server->peerCount];
											++currentPeer)
										{
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
												continue;
											if (isHere(peer, currentPeer))
											{
												Player::OnParticleEffect(currentPeer, effect, x, y, 0);
											}
										}
									}
									if (static_cast<PlayerInfo*>(peer->data)->cloth_necklace == 9428)
									{
										int effect = 125;
										int x = static_cast<PlayerInfo*>(peer->data)->x;
										int y = static_cast<PlayerInfo*>(peer->data)->y;
										ENetPeer* currentPeer;
										for (currentPeer = server->peers;
											currentPeer < &server->peers[server->peerCount];
											++currentPeer)
										{
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
												continue;
											if (isHere(peer, currentPeer))
											{
												Player::OnParticleEffect(currentPeer, effect, x, y, 0);
											}
										}
									}
								}
								if (!static_cast<PlayerInfo*>(peer->data)->joinClothesUpdated)
								{
									PlayerRift(peer, 2555, 2402849791, 723421695, 2402849791, 1059267327, 30, 6);
									static_cast<PlayerInfo*>(peer->data)->joinClothesUpdated = true;
									updateAllClothes(peer);
									updateInvis(peer);
									send_state(peer);
								}
								break;
							default:
								break;
							}
							PlayerMoving* data2 = unpackPlayerMoving(tankUpdatePacket);
							switch (data2->packetType)
							{
							case 11:
							{
								if (world == nullptr || world->name == "EXIT" || serverIsFrozen) break;
								PlayerInfo* pinfo = static_cast<PlayerInfo*>(event.peer->data);
								WorldInfo* world = getPlyersWorld(event.peer);
								if (!world) break;
								if (world->DisableDrop && static_cast<PlayerInfo*>(peer->data)->rawName != world->owner)
								{
									Player::OnTextOverlay(peer, "Collecting is disabled here!");
									break;
								}
								int blockX = static_cast<int>(pMov->x) / 32;
								int blockY = static_cast<int>(pMov->y) / 32;
								if (blockX < 0 || blockY < 0 || blockX > world->width || blockY > world->height) break;
								bool legit = true;
								int itemIdx = pMov->plantingTree;
								int atik = -1;
								try
								{
									for (int i = 0; i < world->droppedItems.size(); i++)
									{
										if (world->droppedItems.at(i).uid == itemIdx)
										{
											atik = i;
											break;
										}
									}
								}
								catch (...)
								{
									break;
								}
								legit = atik != -1;
								if (legit)
								{
									DroppedItem droppedItem = world->droppedItems.at(atik);
									legit = true;
								}
								if (legit)
								{
									//if (static_cast<PlayerInfo*>(peer->data)->x / 32 == blockX || static_cast<PlayerInfo*>(peer->data)->x / 32 + 1 == blockX || static_cast<PlayerInfo*>(peer->data)->x / 32 - 1 == blockX || static_cast<PlayerInfo*>(peer->data)->x / 32 + 2 == blockX || static_cast<PlayerInfo*>(peer->data)->x / 32 - 2 == blockX)
									//{
									DroppedItem droppedItem = world->droppedItems.at(atik);
									if (getItemDef(droppedItem.id).blockType == BlockTypes::FISH)
									{
										auto iscontains = false;
										SearchInventoryItem(peer, droppedItem.id, 1, iscontains);
										if (iscontains)
										{
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`1(Item maxed)", 0, true);
											break;
										}
									}
									if (droppedItem.id != 112)
									{
										if (CheckItemMaxed(peer, droppedItem.id, droppedItem.count))
										{
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`1(Item maxed)", 0, true);
											break;
										}
										if (CheckItemExists(peer, droppedItem.id) == false)
										{
											if (static_cast<PlayerInfo*>(peer->data)->inventory.items.size() == static_cast<PlayerInfo*>(peer->data)->currentInventorySize)
											{
												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`1(Inventory is full)", 0, true);
												break;
											}
										}
									}
									if (droppedItem.id == 112)
									{
										if (droppedItem.count == 1) world->items[blockX + (blockY * world->width)].yellowGems--;
										if (droppedItem.count == 5) world->items[blockX + (blockY * world->width)].blueGems--;
										if (droppedItem.count == 10) world->items[blockX + (blockY * world->width)].redGems--;
										if (droppedItem.count == 50) world->items[blockX + (blockY * world->width)].greenGems--;
										if (droppedItem.count == 100) world->items[blockX + (blockY * world->width)].purpleGems--;
										std::ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										std::string content((std::istreambuf_iterator<char>(ifsz)),
											(std::istreambuf_iterator<char>()));
										int gembux = atoi(content.c_str());
										int fingembux = gembux + droppedItem.count;
										ofstream myfile;
										myfile.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										myfile << fingembux;
										myfile.close();
										int gemcalc = gembux + droppedItem.count;
										Player::OnSetBux(peer, gemcalc, 0);
										const auto p3 = packetEnd(appendFloat(appendIntx(appendFloat(appendFloat(appendFloat(appendString(createPacket(), "OnSetClothing"), (static_cast<PlayerInfo*>(peer->data))->cloth_hair, (static_cast<PlayerInfo*>(peer->data))->cloth_shirt, (static_cast<PlayerInfo*>(peer->data))->cloth_pants), (static_cast<PlayerInfo*>(peer->data))->cloth_feet, (static_cast<PlayerInfo*>(peer->data))->cloth_face, (static_cast<PlayerInfo*>(peer->data))->cloth_hand), (static_cast<PlayerInfo*>(peer->data))->cloth_back, (static_cast<PlayerInfo*>(peer->data))->cloth_mask, (static_cast<PlayerInfo*>(peer->data))->cloth_necklace), (static_cast<PlayerInfo*>(peer->data))->skinColor), (static_cast<PlayerInfo*>(peer->data))->cloth_ances, 0.0f, 0.0f));
										memcpy(p3.data + 8, &((static_cast<PlayerInfo*>(peer->data))->netID), 4);
										const auto packet = enet_packet_create(p3.data, p3.len, ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
									}
									else
									{
										if (static_cast<PlayerInfo*>(peer->data)->rawName != world->owner && isMod(peer) && world->owner != "")
										{
											bool islegitnow = false;
											for (int i = 0; i < world->width * world->height; i++)
											{
												if (world->items[i].foreground == 1436)
												{
													islegitnow = true;
													break;
												}
											}
											if (islegitnow == true)
											{
												string toLogs = "";
												toLogs = static_cast<PlayerInfo*>(peer->data)->displayName + " `w(" + static_cast<PlayerInfo*>(peer->data)->rawName + "`w) `5Took `2" + to_string(droppedItem.count) + " " + getItemDef(droppedItem.id).name + "`5.";
												ofstream breaklogs("securitycam/logs/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + ".txt", ios::app);
												breaklogs << toLogs << endl;
												breaklogs.close();
											}
										}
										auto success = true;
										SaveDroppedItem(droppedItem.id, droppedItem.count, peer, success, "");
									}
									if (getItemDef(droppedItem.id).rarity == 999)
									{
										if (droppedItem.id != 112)
										{
											Player::OnConsoleMessage(peer, "`oCollected `w" + to_string(droppedItem.count) + " " + getItemDef(droppedItem.id).name + "`o.");
										}
									}
									else
									{
										Player::OnConsoleMessage(peer, "`oCollected `w" + to_string(droppedItem.count) + " " + getItemDef(droppedItem.id).name + "`o. Rarity: `w" + to_string(getItemDef(droppedItem.id).rarity) + "`o.");
									}
									world->droppedItems.erase(world->droppedItems.begin() + atik);
									SendTake(peer, pinfo->netID, pMov->x, pMov->y, itemIdx);
									//}
									//else
									//{
									//	Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "Error collecting dropped item, please try again", 0, true);
									//}
								}
								break;
							}
							case 25:
							{
								if (serverIsFrozen == true) break;
								if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT") continue;
								if (static_cast<PlayerInfo*>(peer->data)->isinv == false)
								{
									if (!static_cast<PlayerInfo*>(peer->data)->Console) enet_peer_disconnect_later(peer, 0);
								}
								break;
							}
							case 23:
							{
								if (serverIsFrozen == true) break;
								if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT") continue;
								if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "HELL") continue;
								if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "START") continue;
								if (static_cast<PlayerInfo*>(peer->data)->x != 0 && static_cast<PlayerInfo*>(peer->data)->y != 0)
								{
									int puX = static_cast<int>(static_cast<PlayerInfo*>(peer->data)->x) / 32;
									int puY = static_cast<int>(static_cast<PlayerInfo*>(peer->data)->y) / 32;
									if (puX == static_cast<PlayerInfo*>(peer->data)->respawnX / 32 && puY == static_cast<PlayerInfo*>(peer->data)->respawnY / 32) continue;
									string killedBy = "(unknown)";
									string killedByrawname = "(unknown)";
									string killedWho = "(unknown)";
									ENetPeer* currentPeer;
									for (currentPeer = server->peers;
										currentPeer < &server->peers[server->peerCount];
										++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
											continue;
										if (isHere(peer, currentPeer))
										{
											if (static_cast<PlayerInfo*>(currentPeer->data)->cloth_hand == 94 || static_cast<PlayerInfo*>(currentPeer->data)->cloth_hand == 2908 || static_cast<PlayerInfo*>(currentPeer->data)->cloth_hand == 3160 || static_cast<PlayerInfo*>(currentPeer->data)->cloth_hand == 3962)
											{
												if (static_cast<PlayerInfo*>(currentPeer->data)->lastPVPcoord == data2->plantingTree || static_cast<PlayerInfo*>(currentPeer->data)->lastPVPcoord2 == data2->plantingTree || static_cast<PlayerInfo*>(currentPeer->data)->lastPVPcoord3 == data2->plantingTree || static_cast<PlayerInfo*>(currentPeer->data)->lastPVPcoord4 == data2->plantingTree || static_cast<PlayerInfo*>(currentPeer->data)->lastPVPcoord5 == data2->plantingTree || static_cast<PlayerInfo*>(currentPeer->data)->lastPVPcoord6 == data2->plantingTree || static_cast<PlayerInfo*>(currentPeer->data)->lastPVPcoord7 == data2->plantingTree)
												{
													if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == static_cast<PlayerInfo*>(peer->data)->rawName) continue;
													int killitem = static_cast<PlayerInfo*>(currentPeer->data)->cloth_hand;
													int damage = 0;
													if (killitem == 94)
													{
														damage = 25;
													}
													else if (killitem == 2908)
													{
														damage = 30;
													}
													else if (killitem == 3160)
													{
														damage = 50;
													}
													else if (killitem == 3162)
													{
														damage = 60;
													}
													killedBy = static_cast<PlayerInfo*>(currentPeer->data)->displayName;
													killedByrawname = static_cast<PlayerInfo*>(currentPeer->data)->rawName;
													killedWho = static_cast<PlayerInfo*>(peer->data)->rawName;
													static_cast<PlayerInfo*>(currentPeer->data)->lastPVPcoord = -1;
													static_cast<PlayerInfo*>(currentPeer->data)->lastPVPcoord2 = -1;
													static_cast<PlayerInfo*>(currentPeer->data)->lastPVPcoord3 = -1;
													static_cast<PlayerInfo*>(currentPeer->data)->lastPVPcoord4 = -1;
													static_cast<PlayerInfo*>(currentPeer->data)->lastPVPcoord5 = -1;
													static_cast<PlayerInfo*>(currentPeer->data)->lastPVPcoord6 = -1;
													static_cast<PlayerInfo*>(currentPeer->data)->lastPVPcoord7 = -1;
													static_cast<PlayerInfo*>(peer->data)->health = static_cast<PlayerInfo*>(peer->data)->health - damage;
													Player::OnParticleEffect(currentPeer, 168, static_cast<PlayerInfo*>(peer->data)->x, static_cast<PlayerInfo*>(peer->data)->y, 0);
													Player::OnConsoleMessage(currentPeer, "`^You dealt `@" + std::to_string(damage) + " `4DMG`^!");
													Player::OnConsoleMessage(peer, "`^You Lost `@" + std::to_string(damage) + " `4DMG`^!");
													if (static_cast<PlayerInfo*>(peer->data)->health <= 0)
													{
														static_cast<PlayerInfo*>(peer->data)->health = 100;
														playerRespawn(peer, false);
														Player::OnConsoleMessage(peer, "`oYou were `4killed `oby `w" + killedByrawname + "`o.``");
														Player::OnConsoleMessage(currentPeer, "`oYou `4killed `w" + killedWho + "`o.``");
														int kiek = static_cast<PlayerInfo*>(peer->data)->TotalKills + 1;

														ifstream fg("players/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".json");
														json j;
														fg >> j;
														fg.close();

														j["kills"] = kiek;

														ofstream fs("players/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".json");
														fs << j;
														fs.close();
														static_cast<PlayerInfo*>(peer->data)->TotalKills + 1;
													}
													break;
												}
											}
											if (static_cast<PlayerInfo*>(currentPeer->data)->isZombie == true && static_cast<PlayerInfo*>(peer->data)->isZombie == false)
											{
												if (static_cast<PlayerInfo*>(currentPeer->data)->lastPVPcoord == data2->plantingTree || static_cast<PlayerInfo*>(currentPeer->data)->lastPVPcoord2 == data2->plantingTree || static_cast<PlayerInfo*>(currentPeer->data)->lastPVPcoord3 == data2->plantingTree || static_cast<PlayerInfo*>(currentPeer->data)->lastPVPcoord4 == data2->plantingTree || static_cast<PlayerInfo*>(currentPeer->data)->lastPVPcoord5 == data2->plantingTree || static_cast<PlayerInfo*>(currentPeer->data)->lastPVPcoord6 == data2->plantingTree || static_cast<PlayerInfo*>(currentPeer->data)->lastPVPcoord7 == data2->plantingTree)
												{
													if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == static_cast<PlayerInfo*>(peer->data)->rawName) continue;
													static_cast<PlayerInfo*>(currentPeer->data)->lastPVPcoord = -1;
													static_cast<PlayerInfo*>(currentPeer->data)->lastPVPcoord2 = -1;
													static_cast<PlayerInfo*>(currentPeer->data)->lastPVPcoord3 = -1;
													static_cast<PlayerInfo*>(currentPeer->data)->lastPVPcoord4 = -1;
													static_cast<PlayerInfo*>(currentPeer->data)->lastPVPcoord5 = -1;
													static_cast<PlayerInfo*>(currentPeer->data)->lastPVPcoord6 = -1;
													static_cast<PlayerInfo*>(currentPeer->data)->lastPVPcoord7 = -1;
													if (static_cast<PlayerInfo*>(peer->data)->canWalkInBlocks == true)
													{
														static_cast<PlayerInfo*>(peer->data)->canWalkInBlocks = false;
														static_cast<PlayerInfo*>(peer->data)->skinColor = 0x8295C3FF;
														send_state(peer);
													}
													sendSound(peer, "skel.wav");
													Player::OnTalkBubble(currentPeer, static_cast<PlayerInfo*>(currentPeer->data)->netID, "`4You have infected `2" + static_cast<PlayerInfo*>(peer->data)->rawName + "'s", 0, true);
													Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4You were infected by `2" + static_cast<PlayerInfo*>(currentPeer->data)->rawName, 0, true);
													static_cast<PlayerInfo*>(peer->data)->isZombie = true;
													playerconfig(peer, 1150, 130, 0x14);
												}
											}
										}
									}
								}
								break;
							}
							case 7:
							{
								if (serverIsFrozen == true) continue;
								if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT") continue;
								if (pMov->punchX < 0 || pMov->punchY < 0 || pMov->punchX > 100 || pMov->punchY > 100) continue;
								int idx = pMov->punchY * world->width + pMov->punchX;
								if (getItemDef(world->items[idx].foreground).blockType == BlockTypes::DOOR || getItemDef(world->items[idx].foreground).blockType == BlockTypes::PORTAL)
								{
									PlayerInfo* pinf = static_cast<PlayerInfo*>(peer->data);
									DoEnterDoor(peer, world, pMov->punchX, pMov->punchY);
								}
								else
								{
									WhiteDoor(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
								}
								break;
							}
							case 10:
							{
								if (serverIsFrozen == true) break;
								if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT") continue;
								if (pMov->plantingTree == 242)
								{
									bool iscontainseas = false;
									SearchInventoryItem(peer, pMov->plantingTree, 1, iscontainseas);
									if (!iscontainseas)
									{
										break;
									}
									for (int i = 0; i < static_cast<PlayerInfo*>(peer->data)->inventory.items.size(); i++)
									{
										if (static_cast<PlayerInfo*>(peer->data)->inventory.items[i].itemID == 242)
										{
											if (static_cast<PlayerInfo*>(peer->data)->inventory.items[i].itemCount >= 100)
											{
												bool isValid = SaveConvertedItem(1796, 1, peer);
												if (isValid)
												{
													RemoveInventoryItem(pMov->plantingTree, 100, peer, true);
													Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wYou compressed 100 `2World Lock `winto a `2Diamond Lock`w!", 0, true);
													Player::OnConsoleMessage(peer, "`oYou compressed 100 `2World Lock `ointo a `2Diamond Lock`o!");
												}
											}
										}
									}
								}
								else if (pMov->plantingTree == 1796)
								{
									bool iscontainseas = false;
									SearchInventoryItem(peer, pMov->plantingTree, 1, iscontainseas);
									if (!iscontainseas)
									{
										break;
									}
									for (int i = 0; i < static_cast<PlayerInfo*>(peer->data)->inventory.items.size(); i++)
									{
										if (static_cast<PlayerInfo*>(peer->data)->inventory.items[i].itemID == 1796)
										{
											if (static_cast<PlayerInfo*>(peer->data)->inventory.items[i].itemCount >= 1)
											{
												bool isValid = SaveConvertedItemDls(242, 100, peer);
												if (isValid)
												{
													RemoveInventoryItem(pMov->plantingTree, 1, peer, true);
													Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wYou shattered a `2Diamond Lock `winto 100 `2World Lock`w!", 0, true);
													Player::OnConsoleMessage(peer, "`oYou shattered a `2Diamond Lock `ointo 100 `2World Lock`o!");
												}
											}
										}
									}
								}
								else if (pMov->plantingTree == 7188)
								{
									bool iscontainseas = false;
									SearchInventoryItem(peer, pMov->plantingTree, 1, iscontainseas);
									if (!iscontainseas)
									{
										break;
									}
									for (int i = 0; i < static_cast<PlayerInfo*>(peer->data)->inventory.items.size(); i++)
									{
										if (static_cast<PlayerInfo*>(peer->data)->inventory.items[i].itemID == 7188)
										{
											if (static_cast<PlayerInfo*>(peer->data)->inventory.items[i].itemCount >= 1)
											{
												bool isValid = SaveConvertedItemDls(1796, 100, peer);
												if (isValid)
												{
													RemoveInventoryItem(pMov->plantingTree, 1, peer, true);
													Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wYou shattered a `2Blue Gem Lock `winto 100 `2Diamond Lock`w!", 0, true);
													Player::OnConsoleMessage(peer, "`oYou shattered a `2Blue Gem Lock `ointo 100 `2Diamond Lock`o!");
												}
											}
										}
									}
								}
								ItemDefinition def;
								try
								{
									def = getItemDef(pMov->plantingTree);
								}
								catch (int e)
								{
									goto END_CLOTHSETTER_FORCE;
								}
								if (static_cast<PlayerInfo*>(peer->data)->Fishing)
								{
									Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wYou cant do that while fishing`w!", 0, true);
									continue;
								}
								switch (def.clothType)
								{
								case 0:
									if (pMov->plantingTree >= 0)
									{
										if (!isDev(peer))
										{
											bool iscontainseas = false;
											SearchInventoryItem(peer, pMov->plantingTree, 1, iscontainseas);
											if (!iscontainseas)
											{
												break;
											}
										}
									}
									if (pMov->plantingTree == 4626)
									{
									}
									else if (pMov->plantingTree == 3462)
									{
									}
									if (static_cast<PlayerInfo*>(event.peer->data)->cloth0 == pMov->plantingTree)
									{
										Player::PlayAudio(peer, "audio/change_clothes.wav", 0);
										static_cast<PlayerInfo*>(event.peer->data)->cloth0 = 0;
										break;
									}
									Player::PlayAudio(peer, "audio/change_clothes.wav", 0);
									static_cast<PlayerInfo*>(event.peer->data)->cloth0 = pMov->plantingTree;
									break;
								case 1:
									if (pMov->plantingTree >= 0)
									{
										if (!isDev(peer))
										{
											bool iscontainseas = false;
											SearchInventoryItem(peer, pMov->plantingTree, 1, iscontainseas);
											if (!iscontainseas)
											{
												break;
											}
										}
									}
									if (static_cast<PlayerInfo*>(event.peer->data)->cloth1 == pMov->plantingTree)
									{
										Player::PlayAudio(peer, "audio/change_clothes.wav", 0);
										static_cast<PlayerInfo*>(event.peer->data)->cloth1 = 0;
										break;
									}
									Player::PlayAudio(peer, "audio/change_clothes.wav", 0);
									static_cast<PlayerInfo*>(event.peer->data)->cloth1 = pMov->plantingTree;
									break;
								case 2:
									if (pMov->plantingTree >= 0)
									{
										if (!isDev(peer))
										{
											bool iscontainseas = false;
											SearchInventoryItem(peer, pMov->plantingTree, 1, iscontainseas);
											if (!iscontainseas)
											{
												break;
											}
										}
									}
									if (static_cast<PlayerInfo*>(event.peer->data)->cloth2 == pMov->plantingTree)
									{
										Player::PlayAudio(peer, "audio/change_clothes.wav", 0);
										static_cast<PlayerInfo*>(event.peer->data)->cloth2 = 0;
										break;
									}
									if (pMov->plantingTree == 3172)
									{
										if (static_cast<PlayerInfo*>(peer->data)->SurgeryCooldown)
										{
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`2Your briefs have stunned the judge!", 0, true);
											RemoveInventoryItem(3172, 1, peer, true);
											Player::OnConsoleMessage(peer, "You've paid your debt to society! (`$Malpractice`` mod removed)");
											sendSound(peer, "audio/dialog_confirm.wav");
											static_cast<PlayerInfo*>(peer->data)->SurgeryCooldown = false;
											static_cast<PlayerInfo*>(peer->data)->SurgeryTime = 0;
											remove(("buffs/surgery/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt").c_str());
										}
										if (!isDev(peer))
										{
											bool iscontainseas = false;
											SearchInventoryItem(peer, 3172, 1, iscontainseas);
											if (!iscontainseas) break;
										}
									}
									Player::PlayAudio(peer, "audio/change_clothes.wav", 0);
									static_cast<PlayerInfo*>(event.peer->data)->cloth2 = pMov->plantingTree;
									break;
								case 3:
									if (pMov->plantingTree >= 0)
									{
										if (!isDev(peer))
										{
											bool iscontainseas = false;
											SearchInventoryItem(peer, pMov->plantingTree, 1, iscontainseas);
											if (!iscontainseas)
											{
												break;
											}
										}
									}
									if (static_cast<PlayerInfo*>(event.peer->data)->cloth3 == pMov->plantingTree)
									{
										Player::PlayAudio(peer, "audio/change_clothes.wav", 0);
										static_cast<PlayerInfo*>(event.peer->data)->cloth3 = 0;
										send_state(peer);
										break;
									}
									if (pMov->plantingTree == 898 || pMov->plantingTree == 1830 || pMov->plantingTree == 1966)
									{
										playerconfig(peer, 1150, 130, 0x14);
									}
									if (pMov->plantingTree == 8834)
									{
									}
									Player::PlayAudio(peer, "audio/change_clothes.wav", 0);
									static_cast<PlayerInfo*>(event.peer->data)->cloth3 = pMov->plantingTree;
									break;
								case 4:
									if (pMov->plantingTree >= 0)
									{
										if (!isDev(peer))
										{
											bool iscontainseas = false;
											SearchInventoryItem(peer, pMov->plantingTree, 1, iscontainseas);
											if (!iscontainseas)
											{
												break;
											}
										}
									}
									if (static_cast<PlayerInfo*>(event.peer->data)->cloth4 == pMov->plantingTree)
									{
										static_cast<PlayerInfo*>(peer->data)->effect = 8421376;
										sendPuncheffect(peer, static_cast<PlayerInfo*>(peer->data)->effect);
										send_state(peer); //here
										Player::PlayAudio(peer, "audio/change_clothes.wav", 0);
										static_cast<PlayerInfo*>(event.peer->data)->cloth4 = 0;
										break;
									}
									if (pMov->plantingTree == 1204)
									{
										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`oGive people the evil eye. (`oFocused eyes mod added`o)"));
										ENetPacket* packet = enet_packet_create(p.data,
											p.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete p.data;
										static_cast<PlayerInfo*>(peer->data)->effect = 8421386;
										sendPuncheffect(peer, static_cast<PlayerInfo*>(peer->data)->effect);
										send_state(peer); //here
									}
									Player::PlayAudio(peer, "audio/change_clothes.wav", 0);
									static_cast<PlayerInfo*>(event.peer->data)->cloth4 = pMov->plantingTree;
									break;
								case 5:
									if (pMov->plantingTree >= 0)
									{
										if (!isDev(peer))
										{
											bool iscontainseas = false;
											SearchInventoryItem(peer, pMov->plantingTree, 1, iscontainseas);
											if (!iscontainseas)
											{
												break;
											}
										}
									}
									if (pMov->plantingTree == 9458)
									{
										if (static_cast<PlayerInfo*>(peer->data)->cloth_hand != 9458)
										{
											Player::OnConsoleMessage(peer, "`oLegendary. (`o`9Legen `omod added`o)");
											send_state(peer); //here
										}
										else
										{
											Player::OnConsoleMessage(peer, "`oBack to normal. (`o`9Legen `omod removed`o)");
											send_state(peer); //here
										}
									}
									else if (pMov->plantingTree == 9456)
									{
										if (static_cast<PlayerInfo*>(peer->data)->cloth_hand != 9456)
										{
											Player::OnConsoleMessage(peer, "`oGolden Shine. (`o`8Richness `omod added`o)");
											send_state(peer); //here
										}
										else
										{
											Player::OnConsoleMessage(peer, "`oEhh. (`o`8Richness `omod removed`o)");
											send_state(peer); //here
										}
									}
									else if (pMov->plantingTree == 9454)
									{
										if (static_cast<PlayerInfo*>(peer->data)->cloth_hand != 9454)
										{
											Player::OnConsoleMessage(peer, "`oDemonish power. (`o`@Destruction `omod added`o)");
											send_state(peer); //here
										}
										else
										{
											Player::OnConsoleMessage(peer, "`oWell power gone. (`o`@Destruction `omod removed`o)");
											send_state(peer); //here
										}
									}
									else if (pMov->plantingTree == 9452)
									{
										if (static_cast<PlayerInfo*>(peer->data)->cloth_hand != 9452)
										{
											Player::OnConsoleMessage(peer, "`oRainbow everything. (`o`#Rainbow `omod added`o)");
											send_state(peer); //here
										}
										else
										{
											Player::OnConsoleMessage(peer, "`oGray turns everything. (`o`#Rainbow `omod removed`o)");
											send_state(peer); //here
										}
									}
									else if (pMov->plantingTree == 2204)
									{
										srand(GetTickCount());
										int geigercounterx = rand() % 3000;
										int geigercountery = rand() % 1500;
										world->geigerX = geigercounterx;
										world->geigerY = geigercountery;
									}
									else if (pMov->plantingTree == 9448)
									{
										if (static_cast<PlayerInfo*>(peer->data)->cloth_hand != 9448)
										{
											Player::OnConsoleMessage(peer, "`oIts raining diamonds. (`o`1Crystal `omod added`o)");
											send_state(peer); //here
										}
										else
										{
											Player::OnConsoleMessage(peer, "`oDiamonds rain seems to stop. (`o`1Crystal `omod removed`o)");
											send_state(peer); //here
										}
									}
									else if (pMov->plantingTree == 2592)
									{
										Player::OnConsoleMessage(peer, "`oNone can stand against you! (`oLegendary Swordsmaster mod added`o)");
										static_cast<PlayerInfo*>(peer->data)->effect = 8421399;
										sendPuncheffect(peer, static_cast<PlayerInfo*>(peer->data)->effect);
										send_state(peer); //here
									}
									else if (pMov->plantingTree == 1742)
									{
									}
									else if (pMov->plantingTree == 2952)
									{
									}
									else if (pMov->plantingTree == 9716)
									{
									}
									else if (pMov->plantingTree == 6782)
									{
										Player::OnConsoleMessage(peer, "`oYou are feeling like `2Infinity `4Power `oStarts to go out of you!");
										static_cast<PlayerInfo*>(peer->data)->effect = 8421509;
										sendPuncheffect(peer, static_cast<PlayerInfo*>(peer->data)->effect);
										send_state(peer); //here
									}
									else if (pMov->plantingTree == 8452)
									{
										static_cast<PlayerInfo*>(peer->data)->effect = 8421412;
										sendPuncheffect(peer, static_cast<PlayerInfo*>(peer->data)->effect);
										send_state(peer); //here
									}
									else if (pMov->plantingTree == 5480)
									{
										Player::OnConsoleMessage(peer, "`oWho needs arms when you have these? (`oRayman fist! mod added`o)");
										static_cast<PlayerInfo*>(peer->data)->effect = 8421456;
										sendPuncheffect(peer, static_cast<PlayerInfo*>(peer->data)->effect);
										send_state(peer); //here
									}
									else if (pMov->plantingTree == 9410)
									{
										Player::OnConsoleMessage(peer, "`#Purple `9lights `ostarts to move around you! (`#Valentine! `omod added`o)");
										send_state(peer); //here
									}
									else if (pMov->plantingTree == 1782)
									{
										Player::OnConsoleMessage(peer, "`oYou should be very very nice to your pet. (`oLegendary! mod added`o)");
										static_cast<PlayerInfo*>(peer->data)->effect = 8421397;
										sendPuncheffect(peer, static_cast<PlayerInfo*>(peer->data)->effect);
										send_state(peer); //here
									}
									else if (pMov->plantingTree == 1868)
									{
										Player::OnConsoleMessage(peer, "`oYou command a mighty (violent) dragon! (`oDrakeborn mod added`o)");
										static_cast<PlayerInfo*>(peer->data)->effect = 8421399;
										sendPuncheffect(peer, static_cast<PlayerInfo*>(peer->data)->effect);
										send_state(peer); //here
									}
									else if (pMov->plantingTree == 1804)
									{
										Player::OnConsoleMessage(peer, "`oYou electrocute things. (`oFistful Of Thunder mod added`o)");
										static_cast<PlayerInfo*>(peer->data)->effect = 8421398;
										sendPuncheffect(peer, static_cast<PlayerInfo*>(peer->data)->effect);
										send_state(peer); //here
									}
									else if (pMov->plantingTree == 9058)
									{
										static_cast<PlayerInfo*>(peer->data)->effect = 8421512;
										sendPuncheffect(peer, static_cast<PlayerInfo*>(peer->data)->effect);
										send_state(peer); //here
									}
									else if (pMov->plantingTree == 9484)
									{
										static_cast<PlayerInfo*>(peer->data)->effect = 8421512;
										sendPuncheffect(peer, static_cast<PlayerInfo*>(peer->data)->effect);
										send_state(peer); //here
									}
									else if (pMov->plantingTree == 9486)
									{
										static_cast<PlayerInfo*>(peer->data)->effect = 8421512;
										sendPuncheffect(peer, static_cast<PlayerInfo*>(peer->data)->effect);
										send_state(peer); //here
									}
									else if (pMov->plantingTree == 7912)
									{
										static_cast<PlayerInfo*>(peer->data)->effect = 8421398;
										sendPuncheffect(peer, static_cast<PlayerInfo*>(peer->data)->effect);
										send_state(peer); //here
									}
									else if (pMov->plantingTree == 6026)
									{
										Player::OnConsoleMessage(peer, "`oThe truth is yours! (`oWhip of Truth mod added`o)");
										static_cast<PlayerInfo*>(peer->data)->effect = 8421452;
										sendPuncheffect(peer, static_cast<PlayerInfo*>(peer->data)->effect);
										send_state(peer); //here
									}
									else if (pMov->plantingTree == 9310)
									{
										Player::OnConsoleMessage(peer, "`oYour hands starts to `4Burn! `o(`9Legendary `omod added)");
										static_cast<PlayerInfo*>(peer->data)->effect = 8421452;
										sendPuncheffect(peer, static_cast<PlayerInfo*>(peer->data)->effect);
										send_state(peer); //here
									}
									else if (pMov->plantingTree == 2952)
									{
									}
									else if (pMov->plantingTree == 9716)
									{
									}
									else if (pMov->plantingTree == 1836)
									{
									}
									if (static_cast<PlayerInfo*>(event.peer->data)->cloth5 == pMov->plantingTree)
									{
										static_cast<PlayerInfo*>(peer->data)->effect = 8421376;
										sendPuncheffect(peer, static_cast<PlayerInfo*>(peer->data)->effect);
										send_state(peer); //here
										Player::PlayAudio(peer, "audio/change_clothes.wav", 0);
										static_cast<PlayerInfo*>(event.peer->data)->cloth5 = 0;
										break;
									}
									if (pMov->plantingTree == 1782)
									{
										static_cast<PlayerInfo*>(peer->data)->effect = 8424213;
										sendPuncheffect(peer, static_cast<PlayerInfo*>(peer->data)->effect);
										send_state(peer); //here
									}
									else if (pMov->plantingTree == 1804)
									{
										static_cast<PlayerInfo*>(peer->data)->effect = 8424214;
										sendPuncheffect(peer, static_cast<PlayerInfo*>(peer->data)->effect);
										send_state(peer); //here
									}
									else if (pMov->plantingTree == 1868)
									{
										static_cast<PlayerInfo*>(peer->data)->effect = 8424215;
										sendPuncheffect(peer, static_cast<PlayerInfo*>(peer->data)->effect);
										send_state(peer); //here
									}
									else if (pMov->plantingTree == 2572)
									{
										static_cast<PlayerInfo*>(peer->data)->effect = 8424234;
										sendPuncheffect(peer, static_cast<PlayerInfo*>(peer->data)->effect);
										send_state(peer); //here
									}
									else if (pMov->plantingTree == 2756)
									{
										static_cast<PlayerInfo*>(peer->data)->effect = 8424239;
										sendPuncheffect(peer, static_cast<PlayerInfo*>(peer->data)->effect);
										send_state(peer); //here
									}
									else if (pMov->plantingTree == 6026)
									{
										static_cast<PlayerInfo*>(peer->data)->effect = 8421452;
										sendPuncheffect(peer, static_cast<PlayerInfo*>(peer->data)->effect);
										send_state(peer); //here
									}
									else if (pMov->plantingTree == 2872)
									{
										static_cast<PlayerInfo*>(peer->data)->effect = 8424243;
										sendPuncheffect(peer, static_cast<PlayerInfo*>(peer->data)->effect);
										send_state(peer); //here
									}
									else if (pMov->plantingTree == 2952 || pMov->plantingTree == 9448 || pMov->plantingTree == 9452 || pMov->plantingTree == 9508 || pMov->plantingTree == 9454 || pMov->plantingTree == 9456 || pMov->plantingTree == 9458 || pMov->plantingTree == 9716 || pMov->plantingTree == 10390)
									{
										static_cast<PlayerInfo*>(peer->data)->effect = 8424222;
										sendPuncheffect(peer, static_cast<PlayerInfo*>(peer->data)->effect);
										send_state(peer); //here
									}
									else if (pMov->plantingTree == 3066)
									{
										static_cast<PlayerInfo*>(peer->data)->effect = 8424249;
										sendPuncheffect(peer, static_cast<PlayerInfo*>(peer->data)->effect);
										send_state(peer); //here
									}
									else if (pMov->plantingTree == 2592)
									{
										static_cast<PlayerInfo*>(peer->data)->effect = 8424235;
										sendPuncheffect(peer, static_cast<PlayerInfo*>(peer->data)->effect);
										send_state(peer); //here
									}
									else if (pMov->plantingTree == 9494)
									{
										static_cast<PlayerInfo*>(peer->data)->effect = 8421512;
										sendPuncheffect(peer, static_cast<PlayerInfo*>(peer->data)->effect);
										send_state(peer); //here
									}
									else if (pMov->plantingTree == 9502)
									{
										static_cast<PlayerInfo*>(peer->data)->effect = 8421512;
										sendPuncheffect(peer, static_cast<PlayerInfo*>(peer->data)->effect);
										send_state(peer); //here
									}
									else if (pMov->plantingTree == 2476)
									{
										static_cast<PlayerInfo*>(peer->data)->effect = 8424231;
										sendPuncheffect(peer, static_cast<PlayerInfo*>(peer->data)->effect);
										send_state(peer); //here
									}
									else if (pMov->plantingTree == 1874)
									{
										static_cast<PlayerInfo*>(peer->data)->effect = 8424216;
										sendPuncheffect(peer, static_cast<PlayerInfo*>(peer->data)->effect);
										send_state(peer); //here
									}
									else if (pMov->plantingTree == 10014)
									{
										Player::OnConsoleMessage(peer, "`oYou feel the presure of the ancients! (`oSoul mod added`o)");
										static_cast<PlayerInfo*>(peer->data)->effect = 8421480;
										sendPuncheffect(peer, static_cast<PlayerInfo*>(peer->data)->effect);
										send_state(peer); //here
									}
									else if (pMov->plantingTree == 1204)
									{
										static_cast<PlayerInfo*>(peer->data)->effect = 8421386;
										sendPuncheffect(peer, static_cast<PlayerInfo*>(peer->data)->effect);
										send_state(peer); //here
									}
									else if (pMov->plantingTree == 1956)
									{
										static_cast<PlayerInfo*>(peer->data)->effect = -997;
										sendPuncheffect(peer, static_cast<PlayerInfo*>(peer->data)->effect);
										send_state(peer); //here
									}
									else
									{
										static_cast<PlayerInfo*>(peer->data)->effect = 8421376;
										sendPuncheffect(peer, static_cast<PlayerInfo*>(peer->data)->effect);
										send_state(peer); //here
									}
									Player::PlayAudio(peer, "audio/change_clothes.wav", 0);
									static_cast<PlayerInfo*>(event.peer->data)->cloth5 = pMov->plantingTree;
									break;
								case 6:
									if (pMov->plantingTree >= 0)
									{
										if (!isDev(peer))
										{
											bool iscontainseas = false;
											SearchInventoryItem(peer, pMov->plantingTree, 1, iscontainseas);
											if (!iscontainseas)
											{
												break;
											}
										}
									}
									if (pMov->plantingTree == 1784)
									{
										Player::OnConsoleMessage(peer, "`oYou can jump in mid-air! It's like flying, but less. (`oDouble jump mod added`o)");
										static_cast<PlayerInfo*>(event.peer->data)->canDoubleJump = true;
										send_state(peer);
									}
								
									else if (pMov->plantingTree == 9472)
									{
										if (static_cast<PlayerInfo*>(peer->data)->cloth_back != 9472)
										{
											Player::OnConsoleMessage(peer, "`oLets Flyyy!. (`o`1High Jump `omod added`o)");
											send_state(peer);
										}
										else
										{
											Player::OnConsoleMessage(peer, "`oGravity works again!. (`o`1High Jump `omod removed`o)");
											send_state(peer);
										}
									}
									else if (pMov->plantingTree == 8552)
									{
										if (static_cast<PlayerInfo*>(peer->data)->cloth_back != 8552)
										{
											Player::OnConsoleMessage(peer, "`oHearts!. (`o`4Mercy `omod added`o)");
											static_cast<PlayerInfo*>(event.peer->data)->isDr = true;
											static_cast<PlayerInfo*>(event.peer->data)->canDoubleJump = true;
											static_cast<PlayerInfo*>(event.peer->data)->NickPrefix = "`4Dr";
											send_state(peer);
										}
										else
										{
											Player::OnConsoleMessage(peer, "`oUh oh!. (`o`4Mercy `omod removed`o)");
											static_cast<PlayerInfo*>(event.peer->data)->isDr = false;
											static_cast<PlayerInfo*>(event.peer->data)->canDoubleJump = false;
											static_cast<PlayerInfo*>(event.peer->data)->NickPrefix = "";
											send_state(peer);
										}
									}

									
									if (static_cast<PlayerInfo*>(event.peer->data)->cloth6 == pMov->plantingTree)
									{
										Player::PlayAudio(peer, "audio/change_clothes.wav", 0);
										static_cast<PlayerInfo*>(event.peer->data)->cloth6 = 0;
										static_cast<PlayerInfo*>(event.peer->data)->canDoubleJump = false;
										send_state(peer);
										break;
									}
									{
										if (pMov->plantingTree == 9006)
										{
											static_cast<PlayerInfo*>(peer->data)->peffect = 8420231;
											sendPuncheffect(peer, static_cast<PlayerInfo*>(peer->data)->peffect);
											send_state(peer);
										}
										else if (pMov->plantingTree == 900)
										{
											static_cast<PlayerInfo*>(peer->data)->peffect = 8421382;
											sendPuncheffect(peer, static_cast<PlayerInfo*>(peer->data)->peffect);
											send_state(peer);
										}
										else if (pMov->plantingTree == 7196)
										{
											static_cast<PlayerInfo*>(peer->data)->peffect = 8421471;
											sendPuncheffect(peer, static_cast<PlayerInfo*>(peer->data)->peffect);
											send_state(peer);
										}
										static_cast<PlayerInfo*>(event.peer->data)->cloth6 = pMov->plantingTree;
										int item = pMov->plantingTree;
										if (item == 156 || item == 9006 || item == 1958 || getItemDef(item).name.find("Aura") != string::npos || item == 9476 || item == 9434 || getItemDef(item).name.find("Wings") != string::npos || getItemDef(item).name.find("Cape") != string::npos || item == 8580 || item == 10032 || item == 9410 || item == 9306 || item == 10022 || item == 8308 || item == 7834 || item == 10020 || item == 9760 || item == 10016 || item == 10012 || item == 1674 || item == 9478 || item == 9506 || item == 9476 || item == 1970 || item == 8286 || item == 9506 || item == 9478 || item == 8552 || item == 362 || item == 678 || item == 736 || item == 7734 || item == 7762 || item == 818 || item == 1206 || item == 1460 || item == 1550 || item == 1574 || item == 1668 || item == 1672 || item == 1674 || item == 1784 || item == 1824 || item == 1936 || item == 1938 || item == 1970 || item == 2254 || item == 2256 || item == 2258 || item == 2260 || item == 2262 || item == 2264 || item == 2390 || item == 2392 || item == 3120 || item == 3308 || item == 3512 || item == 4534 || item == 4986 || item == 5754 || item == 6144 || item == 6334 || item == 6694
											|| item == 6818 || item == 6842 || item == 1934 || item == 3134 || item == 6004 || item == 1780 || item == 2158 || item == 2160 || item == 2162 || item == 2164 || item == 2166 || item == 2168 || item == 2438 || item == 2538 || item == 2778 || item == 3858 || item == 350 || item == 998 || item == 1738 || item == 2642 || item == 2982 || item == 3104 || item == 3144 || item == 5738 || item == 3112 || item == 2722 || item == 3114 || item == 4970 || item == 4972 || item == 5020 || item == 6284 || item == 4184 || item == 4628 || item == 5322 || item == 4112 || item == 4114 || item == 3442 || item == 9466 || item == 8286 || item == 5136 || item == 9416 || item == 9356)
										{
											Player::OnConsoleMessage(peer, "`oYou can jump in mid-air! It's like flying, but less. (`oDouble jump mod added`o)");
											static_cast<PlayerInfo*>(event.peer->data)->canDoubleJump = true;
										}
										else
										{
											static_cast<PlayerInfo*>(event.peer->data)->canDoubleJump = false;
										}
										// ^^^^ wings
										send_state(peer);
									}
									Player::PlayAudio(peer, "audio/change_clothes.wav", 0);
									break;
								case 7:
									if (pMov->plantingTree >= 0)
									{
										if (!isDev(peer))
										{
											bool iscontainseas = false;
											SearchInventoryItem(peer, pMov->plantingTree, 1, iscontainseas);
											if (!iscontainseas)
											{
												break;
											}
										}
									}
									if (static_cast<PlayerInfo*>(event.peer->data)->cloth7 == pMov->plantingTree)
									{
										Player::PlayAudio(peer, "audio/change_clothes.wav", 0);
										static_cast<PlayerInfo*>(event.peer->data)->cloth7 = 0;
										break;
									}
									Player::PlayAudio(peer, "audio/change_clothes.wav", 0);
									static_cast<PlayerInfo*>(event.peer->data)->cloth7 = pMov->plantingTree;
									break;
								case 8:
									if (pMov->plantingTree >= 0)
									{
										if (!isDev(peer))
										{
											bool iscontainseas = false;
											SearchInventoryItem(peer, pMov->plantingTree, 1, iscontainseas);
											if (!iscontainseas)
											{
												break;
											}
										}
									}
									if (static_cast<PlayerInfo*>(event.peer->data)->cloth8 == pMov->plantingTree)
									{
										Player::PlayAudio(peer, "audio/change_clothes.wav", 0);
										static_cast<PlayerInfo*>(event.peer->data)->cloth8 = 0;
										break;
									}
									if (pMov->plantingTree == 9512)
									{
										static_cast<PlayerInfo*>(peer->data)->effect = 8421416;
										sendPuncheffect(peer, static_cast<PlayerInfo*>(peer->data)->effect);
										send_state(peer); //here
									}
									Player::PlayAudio(peer, "audio/change_clothes.wav", 0);
									static_cast<PlayerInfo*>(event.peer->data)->cloth8 = pMov->plantingTree;
									break;
								default:
									if (
										def.id == 7166
										|| def.id == 5078 || def.id == 5080 || def.id == 5082 || def.id == 5084 || def.id == 5134
										|| def.id == 5126 || def.id == 5128 || def.id == 5130 || def.id == 5132 || def.id == 5152
										|| def.id == 5144 || def.id == 5146 || def.id == 5148 || def.id == 5150 || def.id == 5170
										|| def.id == 5162 || def.id == 5164 || def.id == 5166 || def.id == 5168 || def.id == 5188
										|| def.id == 5180 || def.id == 5182 || def.id == 5184 || def.id == 5186 || def.id == 9212
										|| def.id == 7168 || def.id == 7170 || def.id == 7172 || def.id == 7174
										)
									{
										if (static_cast<PlayerInfo*>(event.peer->data)->cloth_ances == pMov->plantingTree)
										{
											Player::PlayAudio(peer, "audio/change_clothes.wav", 0);
											static_cast<PlayerInfo*>(event.peer->data)->cloth_ances = 0;
											break;
										}
										static_cast<PlayerInfo*>(event.peer->data)->cloth_ances = pMov->plantingTree;
									}
									//SendConsole("Invalid item activated: " + to_string(pMov->plantingTree), "WARNING");
									Player::PlayAudio(peer, "audio/change_clothes.wav", 0);
									break;
								}
								sendClothes(peer);
							END_CLOTHSETTER_FORCE:;
								break;
							}
							case 18:
							{
								sendPData(peer, pMov);
								break;
							}
							default:
								break;
							}
							if (data2->punchX != -1 && data2->punchY != -1)
							{
								if (data2->packetType == 3)
								{
									if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT") continue;
									using namespace std::chrono;
									if (static_cast<PlayerInfo*>(peer->data)->lastHitTime + 100 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count())
									{
										static_cast<PlayerInfo*>(peer->data)->lastHitTime = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
										string pX = to_string(data2->punchX);
										string pY = to_string(data2->punchY);
										static_cast<PlayerInfo*>(peer->data)->lastPVPcoord = atoi((pY + pX).c_str());
										static_cast<PlayerInfo*>(peer->data)->lastPVPcoord2 = atoi((pY + pX).c_str()) + 1;
										static_cast<PlayerInfo*>(peer->data)->lastPVPcoord3 = atoi((pY + pX).c_str()) + 2;
										static_cast<PlayerInfo*>(peer->data)->lastPVPcoord4 = atoi((pY + pX).c_str()) - 2;
										static_cast<PlayerInfo*>(peer->data)->lastPVPcoord5 = atoi((pY + pX).c_str()) - 1;
										int pYMod1 = atoi(pY.c_str()) + 1;
										int pYMod2 = atoi(pY.c_str()) - 1;
										string pYMod1str = to_string(pYMod1);
										string pYMod2str = to_string(pYMod2);
										static_cast<PlayerInfo*>(peer->data)->lastPVPcoord6 = atoi((pYMod1str + pX).c_str());
										static_cast<PlayerInfo*>(peer->data)->lastPVPcoord7 = atoi((pYMod2str + pX).c_str());
									}
									if (static_cast<PlayerInfo*>(event.peer->data)->isRotatedLeft = pMov->characterState & 0x10)
									{
										static_cast<PlayerInfo*>(event.peer->data)->RotatedLeft = true;
									}
									else
									{
										static_cast<PlayerInfo*>(event.peer->data)->RotatedLeft = false;
									}
									using namespace std::chrono;
									if (static_cast<PlayerInfo*>(peer->data)->lastBREAK + 150 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count())
									{
										static_cast<PlayerInfo*>(peer->data)->lastBREAK = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
										if (data2->plantingTree == 18)
										{
											if (static_cast<PlayerInfo*>(event.peer->data)->cloth_hand == 9454 || static_cast<PlayerInfo*>(event.peer->data)->cloth_hand == 9456)
											{
												sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX + 1, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX + 2, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX + 1, data2->punchY - 1, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX + 2, data2->punchY - 1, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX + 1, data2->punchY - 2, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX + 2, data2->punchY - 2, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX - 1, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX - 2, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX, data2->punchY + 1, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX, data2->punchY + 2, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX - 1, data2->punchY - 1, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX - 2, data2->punchY - 1, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX - 1, data2->punchY - 2, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX - 2, data2->punchY - 2, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX + 1, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX + 2, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX + 1, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX + 2, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX + 1, data2->punchY - 1, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX + 2, data2->punchY - 1, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX + 1, data2->punchY - 2, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX + 2, data2->punchY - 2, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX - 1, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX - 2, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												//apacia
												sendTileUpdate(data2->punchX, data2->punchY + 1, data2->plantingTree,
													static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX, data2->punchY + 2, data2->plantingTree,
													static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX, data2->punchY + 1, data2->plantingTree,
													static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX, data2->punchY + 2, data2->plantingTree,
													static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX - 1, data2->punchY - 1, data2->plantingTree,
													static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX - 2, data2->punchY - 1, data2->plantingTree,
													static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX - 1, data2->punchY - 2, data2->plantingTree,
													static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX - 2, data2->punchY - 2, data2->plantingTree,
													static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree,
													static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree,
													static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX + 1, data2->punchY, data2->plantingTree,
													static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX + 2, data2->punchY, data2->plantingTree,
													static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX + 1, data2->punchY - 1, data2->plantingTree,
													static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX + 2, data2->punchY - 1, data2->plantingTree,
													static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX + 1, data2->punchY - 2, data2->plantingTree,
													static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX + 2, data2->punchY - 2, data2->plantingTree,
													static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX + 1, data2->punchY + 1, data2->plantingTree,
													static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX + 2, data2->punchY + 1, data2->plantingTree,
													static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX + 1, data2->punchY + 2, data2->plantingTree,
													static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX + 2, data2->punchY + 2, data2->plantingTree,
													static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX - 1, data2->punchY, data2->plantingTree,
													static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX - 2, data2->punchY, data2->plantingTree,
													static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												//apacia
												sendTileUpdate(data2->punchX, data2->punchY + 1, data2->plantingTree,
													static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX, data2->punchY + 2, data2->plantingTree,
													static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX - 1, data2->punchY - 1, data2->plantingTree,
													static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX - 2, data2->punchY - 1, data2->plantingTree,
													static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX - 1, data2->punchY - 2, data2->plantingTree,
													static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX - 2, data2->punchY - 2, data2->plantingTree,
													static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree,
													static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree,
													static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX + 1, data2->punchY, data2->plantingTree,
													static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX + 2, data2->punchY, data2->plantingTree,
													static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX + 1, data2->punchY - 1, data2->plantingTree,
													static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX + 2, data2->punchY - 1, data2->plantingTree,
													static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX + 1, data2->punchY - 2, data2->plantingTree,
													static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX + 2, data2->punchY - 2, data2->plantingTree,
													static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX - 1, data2->punchY, data2->plantingTree,
													static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX - 2, data2->punchY, data2->plantingTree,
													static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												//apacia
												sendTileUpdate(data2->punchX, data2->punchY + 2, data2->plantingTree,
													static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX, data2->punchY + 1, data2->plantingTree,
													static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX - 1, data2->punchY - 1, data2->plantingTree,
													static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX - 2, data2->punchY - 1, data2->plantingTree,
													static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX - 1, data2->punchY - 2, data2->plantingTree,
													static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX - 2, data2->punchY - 2, data2->plantingTree,
													static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree,
													static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree,
													static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX + 1, data2->punchY, data2->plantingTree,
													static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX + 2, data2->punchY, data2->plantingTree,
													static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX + 1, data2->punchY + 1, data2->plantingTree,
													static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX + 2, data2->punchY + 1, data2->plantingTree,
													static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX + 1, data2->punchY + 2, data2->plantingTree,
													static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX + 2, data2->punchY + 2, data2->plantingTree,
													static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX - 1, data2->punchY, data2->plantingTree,
													static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX - 2, data2->punchY, data2->plantingTree,
													static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												//apacia
												sendTileUpdate(data2->punchX, data2->punchY + 1, data2->plantingTree,
													static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX, data2->punchY + 2, data2->plantingTree,
													static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX - 1, data2->punchY - 1, data2->plantingTree,
													static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX - 2, data2->punchY - 1, data2->plantingTree,
													static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX - 1, data2->punchY - 2, data2->plantingTree,
													static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX - 2, data2->punchY - 2, data2->plantingTree,
													static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX - 1, data2->punchY + 1, data2->plantingTree,
													static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX - 2, data2->punchY + 1, data2->plantingTree,
													static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX - 1, data2->punchY + 2, data2->plantingTree,
													static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX - 2, data2->punchY + 2, data2->plantingTree,
													static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
											}
											else if (static_cast<PlayerInfo*>(event.peer->data)->cloth_hand == 9452 || static_cast<PlayerInfo*>(event.peer->data)->cloth_hand == 10390)
											{
												if (static_cast<PlayerInfo*>(event.peer->data)->cloth_face != 4288)
												{
													if (static_cast<PlayerInfo*>(event.peer->data)->isRotatedLeft = pMov->characterState & 0x10)
													{
														static_cast<PlayerInfo*>(event.peer->data)->RotatedLeft = true;
													}
													else
													{
														static_cast<PlayerInfo*>(event.peer->data)->RotatedLeft = false;
													}
													if (data2->punchY == static_cast<PlayerInfo*>(event.peer->data)->y / 32)
													{
														if (static_cast<PlayerInfo*>(event.peer->data)->RotatedLeft == true)
														{
															sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX - 1, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX - 2, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX - 1, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX - 2, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
														}
														else
														{
															sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX + 1, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX + 2, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX + 1, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX + 2, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
														}
													}
													else if (data2->punchX == static_cast<PlayerInfo*>(event.peer->data)->x / 32)
													{
														if (data2->punchY > static_cast<PlayerInfo*>(event.peer->data)->y / 32)
														{
															sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX, data2->punchY + 1, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX, data2->punchY + 2, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX, data2->punchY + 1, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX, data2->punchY + 2, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
														}
														else if (data2->punchY < static_cast<PlayerInfo*>(event.peer->data)->y / 32)
														{
															sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX, data2->punchY - 1, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX, data2->punchY - 2, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX, data2->punchY - 1, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX, data2->punchY - 2, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
														}
														else
														{
															sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
														}
													}
													else if (data2->punchY < static_cast<PlayerInfo*>(event.peer->data)->y / 32)
													{
														if (static_cast<PlayerInfo*>(event.peer->data)->RotatedLeft == true)
														{
															sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX - 1, data2->punchY - 1, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX - 2, data2->punchY - 2, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX - 1, data2->punchY - 1, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX - 2, data2->punchY - 2, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
														}
														else
														{
															sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX + 1, data2->punchY - 1, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX + 2, data2->punchY - 2, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX + 1, data2->punchY - 1, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX + 2, data2->punchY - 2, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
														}
													}
													else if (data2->punchY < static_cast<PlayerInfo*>(event.peer->data)->y / 32)
													{
														if (static_cast<PlayerInfo*>(event.peer->data)->RotatedLeft == true)
														{
															sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX - 1, data2->punchY - 1, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX - 2, data2->punchY - 2, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX - 1, data2->punchY - 1, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX - 2, data2->punchY - 2, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
														}
														else
														{
															sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX + 1, data2->punchY - 1, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX + 2, data2->punchY - 2, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX + 1, data2->punchY - 1, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX + 2, data2->punchY - 2, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
														}
													}
													else if (data2->punchY > static_cast<PlayerInfo*>(event.peer->data)->y / 32)
													{
														if (static_cast<PlayerInfo*>(event.peer->data)->RotatedLeft == true)
														{
															sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX - 1, data2->punchY + 1, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX - 2, data2->punchY + 2, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX - 1, data2->punchY + 1, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX - 2, data2->punchY + 2, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
														}
														else
														{
															sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX + 1, data2->punchY + 1, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX + 2, data2->punchY + 2, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX + 1, data2->punchY + 1, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX + 2, data2->punchY + 2, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
														}
													}
												}
												else if (static_cast<PlayerInfo*>(peer->data)->cloth_hand == 5480 || static_cast<PlayerInfo*>(peer->data)->cloth_feet == 1966)
												{
												}
												else if (static_cast<PlayerInfo*>(peer->data)->cloth_hand == 5480 || static_cast<PlayerInfo*>(peer->data)->cloth_feet == 898)
												{
												}
												else if (static_cast<PlayerInfo*>(peer->data)->cloth_hand == 5480 || static_cast<PlayerInfo*>(peer->data)->cloth_feet == 1830)
												{
												}
											}
											else if (static_cast<PlayerInfo*>(event.peer->data)->cloth_hand == 5480)
											{
												if (static_cast<PlayerInfo*>(event.peer->data)->cloth_face != 4288 && static_cast<PlayerInfo*>(event.peer->data)->isZombie == false)
												{
													if (static_cast<PlayerInfo*>(event.peer->data)->isRotatedLeft = pMov->characterState & 0x10)
													{
														static_cast<PlayerInfo*>(event.peer->data)->RotatedLeft = true;
													}
													else
													{
														static_cast<PlayerInfo*>(event.peer->data)->RotatedLeft = false;
													}
													if (data2->punchY == static_cast<PlayerInfo*>(event.peer->data)->y / 32)
													{
														if (static_cast<PlayerInfo*>(event.peer->data)->RotatedLeft == true)
														{
															sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX - 1, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX - 2, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX - 3, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX - 4, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
														}
														else
														{
															sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX + 1, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX + 2, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX + 3, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX + 4, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
														}
													}
													else if (data2->punchX == static_cast<PlayerInfo*>(event.peer->data)->x / 32)
													{
														if (data2->punchY > static_cast<PlayerInfo*>(event.peer->data)->y / 32)
														{
															sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX, data2->punchY + 1, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX, data2->punchY + 2, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX, data2->punchY + 3, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX, data2->punchY + 4, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
														}
														else if (data2->punchY < static_cast<PlayerInfo*>(event.peer->data)->y / 32)
														{
															sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX, data2->punchY - 1, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX, data2->punchY - 2, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX, data2->punchY - 3, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX, data2->punchY - 4, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
														}
														else
														{
															sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
														}
													}
													else if (data2->punchY < static_cast<PlayerInfo*>(event.peer->data)->y / 32)
													{
														if (static_cast<PlayerInfo*>(event.peer->data)->RotatedLeft == true)
														{
															sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX - 1, data2->punchY - 1, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX - 2, data2->punchY - 2, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX - 3, data2->punchY - 3, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX - 4, data2->punchY - 4, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
														}
														else
														{
															sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX + 1, data2->punchY - 1, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX + 2, data2->punchY - 2, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX + 3, data2->punchY - 3, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX + 4, data2->punchY - 4, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
														}
													}
													else if (data2->punchY < static_cast<PlayerInfo*>(event.peer->data)->y / 32)
													{
														if (static_cast<PlayerInfo*>(event.peer->data)->RotatedLeft == true)
														{
															sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX - 1, data2->punchY - 1, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX - 2, data2->punchY - 2, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX - 3, data2->punchY - 3, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX - 4, data2->punchY - 4, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
														}
														else
														{
															sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX + 1, data2->punchY - 1, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX + 2, data2->punchY - 2, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX + 3, data2->punchY - 3, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX + 4, data2->punchY - 4, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
														}
													}
													else if (data2->punchY > static_cast<PlayerInfo*>(event.peer->data)->y / 32)
													{
														if (static_cast<PlayerInfo*>(event.peer->data)->RotatedLeft == true)
														{
															sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX - 1, data2->punchY + 1, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX - 2, data2->punchY + 2, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX - 3, data2->punchY + 3, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX - 4, data2->punchY + 4, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
														}
														else
														{
															sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX + 1, data2->punchY + 1, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX + 2, data2->punchY + 2, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX + 3, data2->punchY + 3, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX + 4, data2->punchY + 4, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
														}
													}
												}
												else
												{
													sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												}
												if (static_cast<PlayerInfo*>(peer->data)->cloth_hand == 5480 || static_cast<PlayerInfo*>(peer->data)->cloth_feet == 1966)
												{
												}
												else if (static_cast<PlayerInfo*>(peer->data)->cloth_hand == 5480 || static_cast<PlayerInfo*>(peer->data)->cloth_feet == 898)
												{
												}
												else if (static_cast<PlayerInfo*>(peer->data)->cloth_hand == 5480 || static_cast<PlayerInfo*>(peer->data)->cloth_feet == 1830)
												{
												}
											}
											else if (static_cast<PlayerInfo*>(event.peer->data)->cloth_hand == 9058)
											{
												if (static_cast<PlayerInfo*>(event.peer->data)->cloth_face != 4288 && static_cast<PlayerInfo*>(event.peer->data)->isZombie == false)
												{
													if (static_cast<PlayerInfo*>(event.peer->data)->isRotatedLeft = pMov->characterState & 0x10)
													{
														static_cast<PlayerInfo*>(event.peer->data)->RotatedLeft = true;
													}
													else
													{
														static_cast<PlayerInfo*>(event.peer->data)->RotatedLeft = false;
													}
													if (data2->punchY == static_cast<PlayerInfo*>(event.peer->data)->y / 32)
													{
														if (static_cast<PlayerInfo*>(event.peer->data)->RotatedLeft == true)
														{
															sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX - 1, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX - 2, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX - 3, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX - 4, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
														}
														else
														{
															sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX + 1, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX + 2, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX + 3, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX + 4, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
														}
													}
													else if (data2->punchX == static_cast<PlayerInfo*>(event.peer->data)->x / 32)
													{
														if (data2->punchY > static_cast<PlayerInfo*>(event.peer->data)->y / 32)
														{
															sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX, data2->punchY + 1, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX, data2->punchY + 2, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX, data2->punchY + 3, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX, data2->punchY + 4, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
														}
														else if (data2->punchY < static_cast<PlayerInfo*>(event.peer->data)->y / 32)
														{
															sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX, data2->punchY - 1, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX, data2->punchY - 2, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX, data2->punchY - 3, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX, data2->punchY - 4, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
														}
														else
														{
															sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
														}
													}
													else if (data2->punchY < static_cast<PlayerInfo*>(event.peer->data)->y / 32)
													{
														if (static_cast<PlayerInfo*>(event.peer->data)->RotatedLeft == true)
														{
															sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX - 1, data2->punchY - 1, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX - 2, data2->punchY - 2, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX - 3, data2->punchY - 3, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX - 4, data2->punchY - 4, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
														}
														else
														{
															sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX + 1, data2->punchY - 1, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX + 2, data2->punchY - 2, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX + 3, data2->punchY - 3, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX + 4, data2->punchY - 4, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
														}
													}
													else if (data2->punchY < static_cast<PlayerInfo*>(event.peer->data)->y / 32)
													{
														if (static_cast<PlayerInfo*>(event.peer->data)->RotatedLeft == true)
														{
															sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX - 1, data2->punchY - 1, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX - 2, data2->punchY - 2, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX - 3, data2->punchY - 3, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX - 4, data2->punchY - 4, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
														}
														else
														{
															sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX + 1, data2->punchY - 1, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX + 2, data2->punchY - 2, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX + 3, data2->punchY - 3, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX + 4, data2->punchY - 4, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
														}
													}
													else if (data2->punchY > static_cast<PlayerInfo*>(event.peer->data)->y / 32)
													{
														if (static_cast<PlayerInfo*>(event.peer->data)->RotatedLeft == true)
														{
															sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX - 1, data2->punchY + 1, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX - 2, data2->punchY + 2, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX - 3, data2->punchY + 3, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX - 4, data2->punchY + 4, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
														}
														else
														{
															sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX + 1, data2->punchY + 1, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX + 2, data2->punchY + 2, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX + 3, data2->punchY + 3, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
															sendTileUpdate(data2->punchX + 4, data2->punchY + 4, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
														}
													}
												}
												else
												{
													sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
													sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
													sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
													sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												}
												if (static_cast<PlayerInfo*>(peer->data)->cloth_hand == 9058 || static_cast<PlayerInfo*>(peer->data)->cloth_feet == 1966)
												{
												}
												else if (static_cast<PlayerInfo*>(peer->data)->cloth_hand == 9058 || static_cast<PlayerInfo*>(peer->data)->cloth_feet == 898)
												{
												}
												else if (static_cast<PlayerInfo*>(peer->data)->cloth_hand == 9058 || static_cast<PlayerInfo*>(peer->data)->cloth_feet == 1830)
												{
												}
											}
											else if (static_cast<PlayerInfo*>(peer->data)->cloth_hand == 2952 || static_cast<PlayerInfo*>(peer->data)->cloth_hand == 9448 || static_cast<PlayerInfo*>(peer->data)->cloth_hand == 9508 || static_cast<PlayerInfo*>(peer->data)->cloth_hand == 2592 || static_cast<PlayerInfo*>(peer->data)->cloth_hand == 10014)
											{
												sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
											}


											else if (static_cast<PlayerInfo*>(peer->data)->cloth_hand == 9716)
											{
												sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX + 1, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX + 1, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX + 1, data2->punchY + 1, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX + 1, data2->punchY + 1, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX + 1, data2->punchY - 1, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX + 1, data2->punchY - 1, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX - 1, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX - 1, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX - 1, data2->punchY + 1, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX - 1, data2->punchY + 1, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX - 1, data2->punchY - 1, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX - 1, data2->punchY - 1, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX, data2->punchY + 1, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX, data2->punchY + 1, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX, data2->punchY - 1, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												sendTileUpdate(data2->punchX, data2->punchY - 1, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
											}
											else
											{
												sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);

												//thread tileupd(sendTileUpdate, data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer);
												//if (tileupd.joinable()) tileupd.detach();
											}
										}
										else
										{
											if (static_cast<PlayerInfo*>(event.peer->data)->PlacePotion || static_cast<PlayerInfo*>(peer->data)->Subscriber && static_cast<PlayerInfo*>(peer->data)->cloth_necklace == 6260)
											{
												if (data2->plantingTree == 7382 || data2->plantingTree == 4762 || data2->plantingTree == 10024 || data2->plantingTree == 9468 || data2->plantingTree == 9460 || data2->plantingTree == 10028)
												{
													if ((static_cast<PlayerInfo*>(event.peer->data))->isRotatedLeft = pMov->characterState & 0x10)
													{
														(static_cast<PlayerInfo*>(event.peer->data))->RotatedLeft = true;
													}
													else
													{
														(static_cast<PlayerInfo*>(event.peer->data))->RotatedLeft = false;
													}
													if ((static_cast<PlayerInfo*>(event.peer->data))->RotatedLeft == true)
													{
														sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, (static_cast<PlayerInfo*>(event.peer->data))->netID, peer);
														sendTileUpdate(data2->punchX - 1, data2->punchY, data2->plantingTree, (static_cast<PlayerInfo*>(event.peer->data))->netID, peer);
														sendTileUpdate(data2->punchX - 2, data2->punchY, data2->plantingTree, (static_cast<PlayerInfo*>(event.peer->data))->netID, peer);
													}
													else
													{
														sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, (static_cast<PlayerInfo*>(event.peer->data))->netID, peer);
														sendTileUpdate(data2->punchX + 1, data2->punchY, data2->plantingTree, (static_cast<PlayerInfo*>(event.peer->data))->netID, peer);
														sendTileUpdate(data2->punchX + 2, data2->punchY, data2->plantingTree, (static_cast<PlayerInfo*>(event.peer->data))->netID, peer);
													}
												}
												else
												{
													sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, (static_cast<PlayerInfo*>(event.peer->data))->netID, peer);
												}
											}
											else
											{
												sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, (static_cast<PlayerInfo*>(event.peer->data))->netID, peer);
											}
										}
									}
								}
								else
								{
								}
							}
							delete data2;
							delete pMov;
						}
						else
						{
							SendConsole("Bad Tank Packet received!", "ERROR");
						}
					}
				}
				break;
				case 5:
					break;
				case 6:
					break;
				}
				enet_packet_destroy(event.packet);
				break;
			}
			case ENET_EVENT_TYPE_DISCONNECT:
			{
				ENetPeer* currentPeer;
				for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
					string name = static_cast<PlayerInfo*>(currentPeer->data)->rawName;
					if (find(static_cast<PlayerInfo*>(peer->data)->friendinfo.begin(), static_cast<PlayerInfo*>(peer->data)->friendinfo.end(), name) != static_cast<PlayerInfo*>(peer->data)->friendinfo.end()) {
						Player::PlayAudio(currentPeer, "audio/friend_logoff.wav", 0);
						Player::OnConsoleMessage(currentPeer, "`!FRIEND ALERT : `w" + static_cast<PlayerInfo*>(peer->data)->displayName + " `ohas `4logged off`o.");
					}
				}
				if (static_cast<PlayerInfo*>(peer->data)->haveGrowId && static_cast<PlayerInfo*>(peer->data)->isIn == true) {

					if (static_cast<PlayerInfo*>(peer->data)->needsaveinventory)
					{
						json items;
						auto jjall = json::array();
						json jj;

						auto invsize = static_cast<PlayerInfo*>(peer->data)->inventory.items.size();
						try
						{
							ofstream ofs("inventory/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".json");
							for (auto i = 0; i < 200; i++)
							{
								if (i < invsize)
								{
									jj["aposition"] = i + 1;
									jj["itemid"] = static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemID;
									jj["quantity"] = static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount;
									jjall.push_back(jj);
								}
								else
								{
									jj["aposition"] = i + 1;
									jj["itemid"] = 0;
									jj["quantity"] = 0;
									jjall.push_back(jj);
								}
							}
							items["items"] = jjall;
							ofs << items << std::endl;
							ofs.close();
						}
						catch (std::exception&)
						{
							SendConsole("ENET_EVENT_TYPE_DISCONNECT (exception) caused by " + static_cast<PlayerInfo*>(peer->data)->rawName + "", "ERROR");
							enet_peer_disconnect_now(peer, 0);
						}
						catch (std::runtime_error&)
						{
							SendConsole("ENET_EVENT_TYPE_DISCONNECT (runtime) caused by " + static_cast<PlayerInfo*>(peer->data)->rawName + "", "ERROR");
							enet_peer_disconnect_now(peer, 0);
						}
						catch (...)
						{
							SendConsole("ENET_EVENT_TYPE_DISCONNECT (...) caused by " + static_cast<PlayerInfo*>(peer->data)->rawName + "", "ERROR");
							enet_peer_disconnect_now(peer, 0);
						}
						static_cast<PlayerInfo*>(peer->data)->needsaveinventory = false;
					}

					string visited = "";
					for (auto i = 0; i < static_cast<PlayerInfo*>(peer->data)->lastworlds.size(); i++) {
						visited += static_cast<PlayerInfo*>(peer->data)->lastworlds[i] + "|";
					}
					ofstream of("lastvisitedworlds/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
					of << visited;
					of.close();

					ofstream ofs("lastworld/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
					ofs << static_cast<PlayerInfo*>(peer->data)->currentWorld;
					ofs.close();
					if (static_cast<PlayerInfo*>(peer->data)->PerformingSurgery) end_surgery(peer, true);
					// ReSharper disable once CppInitializedValueIsAlwaysRewritten
					const auto p = static_cast<PlayerInfo*>(peer->data);

					ifstream fg("players/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".json");
					json j;
					fg >> j;
					fg.close();

					j["ClothBack"] = to_string(p->cloth_back);
					j["ClothHand"] = to_string(p->cloth_hand);
					j["ClothFace"] = to_string(p->cloth_face);
					j["ClothShirt"] = to_string(p->cloth_shirt);
					j["ClothPants"] = to_string(p->cloth_pants);
					j["ClothNeck"] = to_string(p->cloth_necklace);
					j["ClothHair"] = to_string(p->cloth_hair);
					j["ClothFeet"] = to_string(p->cloth_feet);
					j["ClothMask"] = to_string(p->cloth_mask);
					j["ClothAnces"] = to_string(p->cloth_ances);
					j["surgeonlevel"] = static_cast<PlayerInfo*>(peer->data)->SurgerySkill;
					j["skin"] = to_string(static_cast<PlayerInfo*>(peer->data)->skinColor);

					ofstream fs("players/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".json");
					fs << j;
					fs.close();
				}
				sendPlayerLeave(peer, static_cast<PlayerInfo*>(event.peer->data));
				static_cast<PlayerInfo*>(event.peer->data)->inventory.items.clear();
				event.peer->data = nullptr;
			}
			default:
			{
				SendConsole("Default case called", "WARNING");
				break;
			}
			}
			ENetPeer* currentPeer;
			for (currentPeer = server->peers;
				currentPeer < &server->peers[server->peerCount];
				++currentPeer)
			{
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
				PlayerInfo* pinf = static_cast<PlayerInfo*>(currentPeer->data);
				PlayerBuff(currentPeer, pinf->x, pinf->y);
			}
		}
	}
	while (1);
	return 0;
};
